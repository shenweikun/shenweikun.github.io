<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C和C++中static的区别</title>
    <url>/2021/10/10/2021-10-10The-difference-between-C-and-C-static/</url>
    <content><![CDATA[<p>在C/C++中static有三种用法：<br>1.用來修饰局部变量，形成静态局部函数<br>2.用來修饰全局变量/函数<br>3.用來修饰静态数据成员和成员函数<br>前两种是C/C++共有的，第三种是C++独有的。</p>
<span id="more"></span>
<hr>
<h3 id="修饰局部变量"><a href="#修饰局部变量" class="headerlink" title="修饰局部变量"></a>修饰局部变量</h3><p>在介绍静态局部变量之前，先认识一下关键字auto。</p>
<h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>auto关键字在C/C++中只有一个作用，就是修饰局部变量(不能用于修饰全局变量)。<br>被auto修饰的局部变量又称之为自动局部变量。<br>平时我们定义的局部变量，若没有用static或者register修饰，默认就是auto类型的，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//等价于 auto int i = 0;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d \n&quot;</span>,i);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自动局部变量的特点：<br>1.自动局部变量分配在栈上（由于栈内存是脏的，说明在栈上分配的变量，若没有初始化，其值就是随机的）。<br>2.自动局部变量的生命周期和作用域仅限于定义它的函数，函数运行结束，其生命周期也结束。</p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>static修饰的局部变量称之为静态局部变量，静态局部变量和自动局部变量（auto）本质区别是变量开辟的空间在内存的位置不同。<br>静态局部变量的特点：<br>1.静态局部变量分配在data段或者bss段上。（在程序执行之前BSS段会自动清0，所以未初始化的静态局部变量的值为0）<br>2.静态局部变量的作用域与自动局部变量（auto）相同，都仅限于定义它的函数。<br>3.静态局部变量的生命周期与全局变量相同，在程序整个运行期间都不释放。<br>4.静态局部变量在所处模块在初次运行时进行初始化工作, 且只操作一次，之后操作它都保存着上一次的值，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;val = %d&quot;</span>,val);</span><br><span class="line"></span><br><span class="line">    val++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>(); <span class="comment">//第一次调用输出“val = 0”</span></span><br><span class="line">    <span class="built_in">test</span>(); <span class="comment">//第二次调用输出“val = 1”</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修饰全局变量-函数"><a href="#修饰全局变量-函数" class="headerlink" title="修饰全局变量/函数"></a>修饰全局变量/函数</h3><p>当我们使用static来修饰全局变量或函数时，全局变量和函数的作用范围就被限定为本文件了，其他文件在链接时无法使用这些变量和函数，这就是内链接。<br>使用static修饰之后，可以有效的避免函数和全局变量的命名冲突问题。例如：<br>a.c文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val1 = <span class="number">1</span>；</span><br><span class="line"><span class="keyword">static</span> val2 = <span class="number">2</span>；</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> test1（）</span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> test2（）</span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>b.c文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> val1;  <span class="comment">//正确，可以使用a.c文件中的val1</span></span><br><span class="line"><span class="keyword">extern</span> val2;  <span class="comment">//错误,不可以使用a.c文件中的val2，因为被static修饰了</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> test1（）； <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> test2（）； <span class="comment">//错误</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;val1 = %d \n&quot;</span>,val1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修饰静态数据成员和成员函数"><a href="#修饰静态数据成员和成员函数" class="headerlink" title="修饰静态数据成员和成员函数"></a>修饰静态数据成员和成员函数</h3><p>静态数据成员和静态成员函数是C++特有的，被static修饰的类成员或成员函数，称为静态数据成员或静态成员函数，C++引入这一概念的目的是为了在类的范围内实现内存共享。</p>
<h4 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h4><p>静态数据成员实际上是类域中的全局变量。主要特点如下：</p>
<ul>
<li>静态数据成员的定义。举例如下：<br>xxx.h文件<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">base</span>&#123;</span>     </span><br><span class="line">     <span class="keyword">private</span>:     </span><br><span class="line">     <span class="keyword">static</span>   <span class="keyword">const</span>   <span class="keyword">int</span>   _i;<span class="comment">//声明，标准c++支持有序类型在类体中初始化,但vc6不支持。     </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
xxx.c文件<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>   <span class="keyword">int</span>   base::_i=<span class="number">10</span>;<span class="comment">//定义(初始化)时不受private和protected访问限制.</span></span><br></pre></td></tr></table></figure></li>
<li>静态数据成员被 类 的所有对象所共享，包括该类派生类的对象。即派生类对象与基类对象共享基类的静态数据成员。举例如下：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">base</span>&#123;</span>     </span><br><span class="line">            <span class="keyword">public</span>   :     </span><br><span class="line">            <span class="keyword">static</span>   <span class="keyword">int</span>   _num;<span class="comment">//声明     </span></span><br><span class="line">&#125;;     </span><br><span class="line"><span class="keyword">int</span>   base::_num=<span class="number">0</span>;<span class="comment">//静态数据成员的真正定义     </span></span><br><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">derived</span>:</span><span class="keyword">public</span>   base&#123;     </span><br><span class="line">&#125;;     </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">   base   a;     </span><br><span class="line">   derived   b;     </span><br><span class="line">   a._num++;     </span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;base   class   static   data   number   _num   is&quot;</span>&lt;&lt;a._num&lt;&lt;endl;     </span><br><span class="line">   b._num++;     </span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;derived   class   static   data   number   _num   is&quot;</span>&lt;&lt;b._num&lt;&lt;endl;     </span><br><span class="line">&#125;     </span><br><span class="line"><span class="comment">//   结果为1,2;可见派生类与基类共用一个静态数据成员。</span></span><br></pre></td></tr></table></figure></li>
<li>静态数据成员可以成为成员函数的可选参数，而普通数据成员则不可以。举例如下：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">base</span>&#123;</span>     </span><br><span class="line"><span class="keyword">public</span>   :     </span><br><span class="line">       <span class="keyword">static</span>   <span class="keyword">int</span>   _staticVar;     </span><br><span class="line">       <span class="keyword">int</span>   _var;     </span><br><span class="line">       <span class="function"><span class="keyword">void</span>   <span class="title">foo1</span><span class="params">(<span class="keyword">int</span>   i=_staticVar)</span></span>;<span class="comment">//正确,_staticVar为静态数据成员     </span></span><br><span class="line">       <span class="function"><span class="keyword">void</span>   <span class="title">foo2</span><span class="params">(<span class="keyword">int</span>   i=_var)</span></span>;<span class="comment">//错误,_var为普通数据成员     </span></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure></li>
<li>静态数据成员的类型可以是所属类的类型，而普通数据成员则不可以。普通数据成员的只能声明为所属类类型的指针或引用。举例如下：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">base</span>&#123;</span>     </span><br><span class="line"><span class="keyword">public</span>   :     </span><br><span class="line">        <span class="keyword">static</span>   base   _object1;<span class="comment">//正确，静态数据成员     </span></span><br><span class="line">        base   _object2;<span class="comment">//错误     </span></span><br><span class="line">        base   *pObject;<span class="comment">//正确，指针     </span></span><br><span class="line">        base   &amp;mObject;<span class="comment">//正确，引用     </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>这个特性，我不知道是属于标准c++中的特性，还是vc6自己的特性。 静态数据成员的值在const成员函数中可以被合法的改变。举例如下：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">base</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">        <span class="built_in">base</span>()&#123;_i=<span class="number">0</span>;_val=<span class="number">0</span>;&#125;     </span><br><span class="line">          <span class="keyword">mutable</span>   <span class="keyword">int</span>   _i;     </span><br><span class="line">          <span class="keyword">static</span>   <span class="keyword">int</span>   _staticVal;       </span><br><span class="line">          <span class="keyword">int</span>   _val;     </span><br><span class="line">          <span class="function"><span class="keyword">void</span>   <span class="title">test</span><span class="params">()</span>   <span class="keyword">const</span></span>&#123;<span class="comment">//const   成员函数     </span></span><br><span class="line"></span><br><span class="line">                _i++;<span class="comment">//正确，mutable数据成员     </span></span><br><span class="line">                _staticVal++;<span class="comment">//正确，static数据成员     </span></span><br><span class="line">                _val++;<span class="comment">//错误     </span></span><br><span class="line"></span><br><span class="line">        &#125;     </span><br><span class="line">&#125;;     </span><br><span class="line"><span class="keyword">int</span>   base::_staticVal=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4>静态成员函数没有什么太多好讲的。</li>
</ul>
<p>1.静态成员函数的地址可用普通函数指针储存，而普通成员函数地址需要用类成员函数指针来储存。举例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">base</span>&#123;</span>     </span><br><span class="line">              <span class="function"><span class="keyword">static</span>   <span class="keyword">int</span>   <span class="title">func1</span><span class="params">()</span></span>;     </span><br><span class="line">              <span class="function"><span class="keyword">int</span>   <span class="title">func2</span><span class="params">()</span></span>;     </span><br><span class="line">&#125;;     </span><br><span class="line"></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span>   (*pf1)()=&amp;base::func1;<span class="comment">//普通的函数指针     </span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span>   (base::*pf2)()=&amp;base::func2;<span class="comment">//成员函数指针</span></span><br></pre></td></tr></table></figure>
<p>2.静态成员函数不可以调用类的非静态成员。因为静态成员函数不含this指针。<br>3.静态成员函数不可以同时声明为 virtual、const、volatile函数。举例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">base</span>&#123;</span>     </span><br><span class="line">             <span class="function"><span class="keyword">virtual</span>   <span class="keyword">static</span>   <span class="keyword">void</span>   <span class="title">func1</span><span class="params">()</span></span>;<span class="comment">//错误     </span></span><br><span class="line">             <span class="function"><span class="keyword">static</span>   <span class="keyword">void</span>   <span class="title">func2</span><span class="params">()</span>   <span class="keyword">const</span></span>;<span class="comment">//错误     </span></span><br><span class="line">             <span class="function"><span class="keyword">static</span>   <span class="keyword">void</span>   <span class="title">func3</span><span class="params">()</span>   <span class="keyword">volatile</span></span>;<span class="comment">//错误     </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后要说的一点是，静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。</p>
<p><a href="https://blog.csdn.net/xiajun07061225/article/details/6955226">关于静态数据成员和成员函数的说明，引用于此处</a> </p>
]]></content>
      <categories>
        <category>4. C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Camera CTS 介绍</title>
    <url>/2021/10/17/2021-10-17-CTS-Introduction/</url>
    <content><![CDATA[<p>CTS测试全称为系列兼容测试（Compatibility Test Suite）,CTS是谷歌为了测试是否符合Google定义的兼容性规范，从而基于Android的应用程序能在基于同一个API版本的设备上面运行。<br>通过CTS测试的设备可以获得谷歌的商标，并且享受Android Market的权限。</p>
<span id="more"></span>  
<h4 id="Camera-CTS简介"><a href="#Camera-CTS简介" class="headerlink" title="Camera CTS简介"></a>Camera CTS简介</h4><p>相机CTS测试分为5部分：CTS、GSI、VTS、CTS-verifier，其中CTS-Verifier包含ITS。<br>CTS、GSI、VTS是自动化测试，执行测试命令就行，CTS-Verifier是手动测试，其中ITS对测试环境和操作要求较高。GSI、VTS测试要刷谷谷歌image，其他不需要。</p>
<h4 id="CTS测试环境搭建"><a href="#CTS测试环境搭建" class="headerlink" title="CTS测试环境搭建"></a>CTS测试环境搭建</h4><p>Windows CTS测试环境配置（细节参考百度）<br>1.安装adb并配置环境变量<br>2.安装JDK并配置环境变量<br>3.下载CTS工具包<br>4.将CTS Windows脚本放在tools目录下，执行cts-tradefed脚本</p>
<h4 id="CTS测试命令"><a href="#CTS测试命令" class="headerlink" title="CTS测试命令"></a>CTS测试命令</h4><h5 id="CTS测试"><a href="#CTS测试" class="headerlink" title="CTS测试"></a>CTS测试</h5><p>手机设置不锁屏，息屏时间最大值；<br>部分手机厂商的手机系统会有权限限制，需要在开发者选项中关闭权限控制，例如：开发者选项勾选“禁止权限监控”（OPPO），“启用MIUI优化”（小米）。<br>运行android-cts/tools目录下的cts-tradefed脚本，输入命令测试：<br>全局camera cts测试:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">run cts -m CtsCameraTestCases</span><br></pre></td></tr></table></figure>
<p>测试camera cts中某一个模块:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">run cts -m CtsCameraTestCases -t android.hardware.camera2.cts.CaptureRequestTest</span><br></pre></td></tr></table></figure>
<p>测试camera cts中的某一具体项:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">run cts -m CtsCameraTestCases -t android.hardware.camera2.cts.CaptureRequestTest#testAeModeAndLock</span><br></pre></td></tr></table></figure>
<p>debug时可加上-a选项，缩短测试时间，如-a arm64-v8a，则其他如armeabi-v7a就不会测试。<br>-s 手机序列，多设备运行使用，指定设备ID</p>
<h5 id="GSI-VTS测试"><a href="#GSI-VTS测试" class="headerlink" title="GSI/VTS测试"></a>GSI/VTS测试</h5><p>GSI/VTS测试要刷Google system image，image可以去官网下载。<br>Android原生Q刷google image方法：<br>手机已解锁</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br><span class="line">fastboot flash boot boot-debug.img</span><br><span class="line">fastboot reboot fastboot</span><br><span class="line">fastboot flash system system.img</span><br><span class="line">fashboot reboot bootloader</span><br><span class="line">fastboot -w</span><br><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure>
<p>重启后，进入相机允许权限提示框，运行VTS包android-vts/tools/vts-tradefed脚本，进行测试:<br>全局 VTS 测试：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">./vts-tradefed</span><br><span class="line">run vts</span><br></pre></td></tr></table></figure>
<p>测试Camera GSI/VTS中某一个模块:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">./vts-tradefed</span><br><span class="line">run vts -m VtsHalCameraProviderV2_4Target -s 手机序列号 <span class="comment">//测试Camera ProviderV2_4的VTS</span></span><br><span class="line">run cts-on-gsi -m CtsCameraTestCases -s 手机序列 <span class="comment">//测试Camera GSI</span></span><br></pre></td></tr></table></figure>
<p>测试Camera GSI/VTS中的某一具体项:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">./vts-tradefed</span><br><span class="line">run vts -m VtsHalAudioV2_0Target -t RecommendedOutputStreamConfigSupport</span><br></pre></td></tr></table></figure>
<h5 id="CTS-verifier及ITS测试："><a href="#CTS-verifier及ITS测试：" class="headerlink" title="CTS verifier及ITS测试："></a>CTS verifier及ITS测试：</h5><p>将cts Verifier包中CtsVerifier.apk安装到手机上，打开CtsVerifier可看到camera有关测试项。<br>ITS测试参考：<br>官方文档介绍：android/cts/apps/CameraITS/CameraITS.pdf<br>ubuntu ITS测试命令：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 通过adb install -r CtsVerifier.apk 安装CtsVerifier.apk</span><br><span class="line"><span class="number">2.</span> cd android-cts-verifier/CameraITS目录</span><br><span class="line"><span class="number">3.</span> source build/envsetup.sh</span><br></pre></td></tr></table></figure>
<p>全局测试：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">python tools/run_all_tests.py</span><br></pre></td></tr></table></figure>
<p>全测后置camera 0全场景测试：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">python tools/run_all_tests.py camera=<span class="number">0</span> scenes=scene0 device=设备ID</span><br></pre></td></tr></table></figure>
<p>单独模块测试：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">python tests/scene1/test_raw_exposure.py camera=<span class="number">0</span> scenes=scene1 device=设备ID</span><br><span class="line"><span class="comment">//或者在CameraITS/scene1目录只保留目标项，再执行：</span></span><br><span class="line">python tools/run_all_tests.py camera=<span class="number">0</span> scenes=<span class="number">1</span> device=设备ID</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>3. Camera基础概念</category>
      </categories>
      <tags>
        <tag>CTS</tag>
        <tag>测试</tag>
        <tag>Camera基础概念</tag>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+github搭建个人博客</title>
    <url>/2018/02/07/2018-02-07-hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>最近年关将至，手头上的工作也落实得七七八八，总而言之就是很闲的意思。于是乎，开始搭建一个属于自己的个人博客。搭建个人博客的想法并不是突发奇想，而是一直都存在，不过苦于没有时间和精力，便一直搁置着。趁着这段空闲的时间，就来实现一下自己的小梦想啦。</p>
<span id="more"></span>  
<p>本文主要用于记录搭建本博客的过程，以便日后查阅，也给需要的同学留点小参考。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基于系统：Ubuntu16.04</span><br></pre></td></tr></table></figure>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>虽然从事IT行业，但是从来没有接触过web相关的知识，所以希望寻找一种相对简单的方式来搭建自己的博客。搜索了网络上大量的资料，最终选择了这组组合hexo+github,原因如下：<br>1.搭建部署简单，完全不用担心写代码，稍微有点计算机基础的同学都能完成<br>2.基于Markdown编写文章，简洁快速，不需考虑文章排版<br>3.有许多优秀的主题模板可供选择<br>4.免费！不需要服务器，不需要后台（让我们为互联网的免费学习开源精神干杯！）<br>等等   </p>
<p>大概可以分为以下几个步骤：<br>1.搭建环境准备<br>2.安装配置Hexo<br>3.配置主题<br>4.申请github账号，并将Hexo与github pages联系起来<br>5.如何发布文章？</p>
<hr>
<h3 id="环境搭建准备"><a href="#环境搭建准备" class="headerlink" title="环境搭建准备"></a>环境搭建准备</h3><p>大概分为以下三步：  </p>
<ul>
<li>git安装与配置 </li>
<li>Node.js安装  </li>
</ul>
<h4 id="git安装与配置"><a href="#git安装与配置" class="headerlink" title="git安装与配置"></a>git安装与配置</h4><p>GitHub 肯定是要 Git 的。  </p>
<ul>
<li>git从源中安装 （推荐）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update 获得最近的软件包的列表； </span><br><span class="line">sudo apt-get install git</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure></li>
<li>安装完成后，需要进行git基本配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config –global user.name “这里写你的名字” </span><br><span class="line">git config –global user.email “这里写你的邮箱地址”</span><br></pre></td></tr></table></figure></li>
<li>配置完成后，需要创建验证用的公钥，因为git是通过ssh的方式访问资源库的，所以需要在本地创建验证用的文件。<br>执行命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -C &#x27;写上你的邮箱地址&#x27; -t rsa</span><br></pre></td></tr></table></figure>
完成后，会在用户目录~/.ssh/下建立相应的密钥文件<em>id_rsa.pub</em>。这个公钥非常重要，在后面配置github的时候会用到。</li>
</ul>
<h4 id="Node-js安装"><a href="#Node-js安装" class="headerlink" title="Node.js安装"></a>Node.js安装</h4><p>Hexo 是 Node.js 写的，所以需要先安装好 Node.js  </p>
<ul>
<li>Node.js源码安装  （推荐）  </li>
</ul>
<p>1.在 Github 上获取 Node.js 源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo git clone https://github.com/nodejs/node.git</span><br></pre></td></tr></table></figure>
<p> 2.修改目录权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod -R 755 node</span><br></pre></td></tr></table></figure>
<p> 3.使用 ./configure 创建编译文件，按照：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd node</span><br><span class="line">sudo chmod +x configure</span><br><span class="line">sudo ./configure</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p> 4.查看Node版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node --version</span><br></pre></td></tr></table></figure>
<ul>
<li>apt-get命令安装 （不推荐，命令看起来简单，但安装过程经常发生问题）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="安装配置Hexo"><a href="#安装配置Hexo" class="headerlink" title="安装配置Hexo"></a>安装配置Hexo</h3><p>安装好Node.js之后npm管理工具了，可以使用npm命令来安装Hexo</p>
<ul>
<li>使用 npm 来便捷安装 Hexo：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">或者：</span><br><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure></li>
<li>创建本地Hello World<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init myblog</span><br><span class="line">cd myblog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li>
<li>myblog下文件如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_config.yml 是 Hexo 的配置。</span><br><span class="line">node_modules： 是每个 Node.js 项目的依赖代码库，不用管。</span><br><span class="line">package.json： 是每个 Node.js 项目的依赖库说明，不用管。</span><br><span class="line">scaffolds： 模板文件夹，高端话题。非高级用户不用管。</span><br><span class="line">source： 文件夹就是我们放原始 Markdown 写的文章的地方。每次发布上传文章时都要先将这里的原始 Markdown 格式文件编译成 HTML 文件。source 文件夹下默认带了 _post 文件夹，且后者里边有篇默认的 Markdown 文章，即 hello-world.md 文件。</span><br><span class="line">themes： 文件夹里放的是主题，主题就是大家博客的页面布局、样式等。上边安装时带了一个默认主题 landscape，自己可以往这里放自定义主题。</span><br></pre></td></tr></table></figure></li>
<li>本地运行 myblog 站点，在 myblog 路径下运行命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></li>
<li>输出如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></li>
<li>去浏览器访问 <a href="http://localhost:4000/">http://localhost:4000/</a> 看到默认主题 landscape 风格的博客了。博客里默认自带了一篇 Hello World 文章。  此时，我们看到的页面均是本地web，如果你想让别人也看到你的博客，请网下看。</li>
</ul>
<hr>
<h3 id="申请github账号，并将Hexo与github-pages联系起来"><a href="#申请github账号，并将Hexo与github-pages联系起来" class="headerlink" title="申请github账号，并将Hexo与github pages联系起来"></a>申请github账号，并将Hexo与github pages联系起来</h3><ul>
<li>github账户的注册和配置  </li>
</ul>
<p>1.Github注册（如果已经拥有账号，请跳过此步~）<br>打开<a href="https://github.com/">https://github.com/</a> ，在下图的框中，分别输入自己的用户名，邮箱，密码。<br><img src="%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2_sign_up_for_GitHub.jpg"><br>然后前往注册的邮箱，点开github给你发送的邮件，进行认证。<br>2.创建代码库<br>到主页点击new repository：<br><img src="%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2_new_repository.png"><br>在Repository name中输入你要创建的名字，注意<strong>要使用你自己的名字+.github.io</strong>,例如我的名字为：shenweikun,则Repository name中输入：<br><img src="%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2_create_repository.png"><br>然后，github会自动为你创建github pages，以后就可以使用yourname.gitgub.io在浏览器中访问你的博客了。<br>3.为了将你本地git仓库与github关联，还需要配置SSH<br>将前面<strong>git安装与配置</strong>步骤生成的<strong>id_rsa.pub</strong>复制到github上。具体步骤如下：<br> a. cat ~/.ssh/id_rsa.pub<br> b.复制id_rsa.pub中的内容<br> c.黏贴到SSH key中，然后点击 add SSH key<br>   <img src="%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2_SSH.png"></p>
<ul>
<li>hexo配置和部署  </li>
</ul>
<p>1.配置Deployment<br>在hexo（myblog）目录下的_config.yml文件中，找到Deployment，然后按照如下修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//记得要将名字替换成你建立git仓库时的yourname</span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:shenweikun/shenweikun.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p> 2.执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g  //生成HTML</span><br><span class="line">hexo d  //部署到博客</span><br></pre></td></tr></table></figure>
<p> 3.打开你的博客yourname.github.io,就可以看到你的博客主页了：</p>
<p><img src="%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2_%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A1%B5.png"></p>
<hr>
<h3 id="如何发布文章？"><a href="#如何发布文章？" class="headerlink" title="如何发布文章？"></a>如何发布文章？</h3><ul>
<li>本地生成markdown文件<br>进入到我们的hexo根目录，执行命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &#x27;my-new-blog&#x27;</span><br></pre></td></tr></table></figure>
hexo会帮我们在_posts下生成相关md文件：<br>source/_posts/my-new-blog.md</li>
</ul>
<ul>
<li>编辑markdown文件<br>我们只需要打开my-new-blog.md编辑博客内容了。<br>你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。一般完整格式如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: postName #文章页面上的显示名称，一般是中文</span><br><span class="line">date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改</span><br><span class="line">categories: 默认分类 #分类</span><br><span class="line">tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格</span><br><span class="line">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span><br><span class="line">后面写正文</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>部署到github pages博客上<br>执行：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g  //生成HTML</span><br><span class="line">hexo d  //部署到博客</span><br></pre></td></tr></table></figure>
然后打开你的博客就能看到你的文章了 </li>
</ul>
<hr>
<p>写得比较简单，很多细节都没有提到，要回家过年了，暂时先这样吧，后面有时间再做完善了。<br>例如：<br><a href="https://shenweikun.github.io/2018/03/13/How-to-modify-hexo-config/">怎么把hexo的相关信息修改为自己？</a><br><a href="https://shenweikun.github.io/2018/03/14/How-to-change-theme/">怎么更换主题？</a><br><a href="https://shenweikun.github.io/2018/03/14/How-to-backup-blog/">怎么备份博客？</a><br><a href="https://shenweikun.github.io/2018/03/14/How-to-edit-MarkDown-visually/">怎么可视化编辑markdown?</a></p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
  </entry>
  <entry>
    <title>Camera概念篇-标准光源</title>
    <url>/2021/10/25/2021-10-24-Camera-concept-illuminant/</url>
    <content><![CDATA[<p>标准光源（Standard Light Sources）是指模拟各种环境光线下的人造光源，让生产工厂或实验室非现场也能获得与这些特定环境下的光源基本一致的照明效果。标准光源通常安装在标准光源箱内，主要用于检测物品的颜色偏差，自动白平衡等校准需要用到各类标准光源。</p>
<span id="more"></span>
<h4 id="光源色温"><a href="#光源色温" class="headerlink" title="光源色温"></a>光源色温</h4><p>光源有高、中、低三种色温，具体有D50,D65,D35,D75,A,F,TL84,TL83,965,CWF,U30 HOR（Horizon）,UV等。</p>
<p>1.低色温（2700K－3500K）：含有较多的红光、橙光。犹如早晨八时左右的太阳光，给人以温暖、温磬的美感。<br>2.中色温（3500K－5000K）：所含的红光、蓝光等光色较均衡，犹如上午八时以后，十时以前的太阳光。给人以温和、舒适的美感。<br>3.高色温（5000K－7000K）：含有较多的蓝光，象上午十时以后，下午二时以前的太阳光。给人以明亮、清晰的美感。<br>注：光源以K（开尔文）为单位，（K数为高越偏蓝调）色温（Color Temperature），单位：开尔文[Kelvin]定义：当光源所发出的颜色与“黑体”在某一温度下辐射的颜色相同时，“黑体”的温度就称为该光源的色温。“黑体”的温度越高，光谱中蓝色的成份则越多，而红色的成份则越少。色温是衡量一种光源“有多么热”或者“有多么冷”的指标，也是表示一种光源“白得程度”、“黄得程度”或者“蓝得程度”的指标。</p>
<h4 id="色温场景"><a href="#色温场景" class="headerlink" title="色温场景"></a>色温场景</h4><p>1.暖色光：暖色光的色温在3300K以下，暖色光与白炽灯相近，红光成分较多，能给人温暖、健康、舒适的感觉。适用于家庭、住宅、宿舍、宾馆等场所或温度较低的地方。<br>2.冷白色光：又叫中性色，它的色温在3300K~5300K之间，中性色由于光线柔和，使人有愉快、舒适、安详的感觉。适用于商店、医院、办公室、饭店、餐厅、候车室等场所。<br>3.冷色光：又叫日光色，它的色温在5300K以上，光源接近自然光，有明亮的感觉，使人精力集中。适用于办公室、会议室、教室、绘图室、设计室、图书馆的阅览室、展览橱窗等场所。</p>
<h4 id="低色温光源"><a href="#低色温光源" class="headerlink" title="低色温光源"></a>低色温光源</h4><p>H：色温2300K，模拟水平日光（Horizon）；<br>F：色温2700K，模拟家庭酒店暖色灯光、比色参考光源，夕阳光、黃光源、落日黃，多为英式灯箱使用；<br>A：色温2856K，美式厨窗射灯，功率60W，多为美式灯箱使用；<br>WF：色温2500-3000K，暖荧光灯（Warm Fluorescent），通用室内荧光灯；<br>Inca灯：色温2856K，模拟美式展示厅射灯，特殊钨丝灯；<br>U30：色温3000K，模拟美国暖白商店光源(Warm White Fluorescent)，功率20W；<br>TL83：色温3000K，欧洲标准暖白商店光源 (Warm White )，功率18W；<br>T：色温2600-3200K，钨丝灯（Tungsten）（40W 2600K，100W 2850K）；<br>U35：色温3500K，模拟指定的商店灯光光源；</p>
<h4 id="中色温光源"><a href="#中色温光源" class="headerlink" title="中色温光源"></a>中色温光源</h4><p>CWF：色温4150K，模拟美国冷白商店光源（Cold White Fluorescent），功率20W；<br>TL84：色温4000K（3750K），模拟欧洲、日本、中国商店灯光；<br>F：同TL84光源，荧光灯（Fluorescent）；</p>
<h4 id="高色温光源"><a href="#高色温光源" class="headerlink" title="高色温光源"></a>高色温光源</h4><p>D为Daylight，日光，色温5200K;<br>S：色温7000K，阴影，Shade;<br>D50：色温5000K，模拟太阳光；<br>D65：色温6500K，国际标准人工日光(Artificial Daylight)，模拟蓝天日光；<br>D75：色温7500K，模拟北方平均太阳光，同S；<br>DF：同D65，Daylight Fluorescent;<br>DNP：色温5100K，透射式灯箱；</p>
<h4 id="其它光源"><a href="#其它光源" class="headerlink" title="其它光源"></a>其它光源</h4><p>UV：波长365nm，紫外灯光源(Ultra-Violet)，功率20W</p>
]]></content>
      <categories>
        <category>3. Camera基础概念</category>
      </categories>
      <tags>
        <tag>Camera基础概念</tag>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Camera概念篇-Sensor介绍</title>
    <url>/2021/10/24/2021-10-24-Camera-concept-sensorIntroduction/</url>
    <content><![CDATA[<p>本部分主要介绍MTK平台支持的Image Sensor类型，硬件接口以及常见基本概念。</p>
<span id="more"></span>
<h4 id="1-Image-Sensor类型"><a href="#1-Image-Sensor类型" class="headerlink" title="1. Image Sensor类型"></a>1. Image Sensor类型</h4><h5 id="a-YUV-Sensor"><a href="#a-YUV-Sensor" class="headerlink" title="a) YUV Sensor"></a>a) YUV Sensor</h5><p>YUV Sensor输出的Data格式为YUV，图像的效果处理使用Sensor内部的ISP，BB端接收YUV格式的data后只进行格式的转换，效果方面不进行处理，由于Sensor内部的ISP处理能力有限，且YUV Sensor的数据量比较大（YUV422的格式1个pixel2个byte），一般Size都比较小，常见的YUV sensor都是5M以下。</p>
<h5 id="b-Raw-Sensor"><a href="#b-Raw-Sensor" class="headerlink" title="b) Raw Sensor"></a>b) Raw Sensor</h5><p>Raw Sensor输出的Data格式为Raw，图像的效果处理使用BB端的ISP，BB端接收Raw data后进行一系列的图像处理（OB，Shading，AWB，Gamma，EE，ANR等），效果方面由BB端控制，需要针对不同的模组进行效果调试，Raw sensor是目前的主流，数据量比YUV Sensor小（RAW10 格式的sensor 1个pixel 10个bit）使用平台ISP处理，能支持较大的size。</p>
<h4 id="2-硬件接口"><a href="#2-硬件接口" class="headerlink" title="2. 硬件接口"></a>2. 硬件接口</h4><p>简单说来，Camera的接口分为并行和串行两种方式，而目前MTK平台主要支持的串行方式为mipi接口，Parallel接口和mipi接口的介绍可以参考下图:<br><img src="HW-interface1.png"><br><img src="HW-interface2.png"></p>
<h4 id="3-常见基本概念"><a href="#3-常见基本概念" class="headerlink" title="3. 常见基本概念"></a>3. 常见基本概念</h4><h5 id="a-三路电压"><a href="#a-三路电压" class="headerlink" title="a) 三路电压"></a>a) 三路电压</h5><p>camera包含的三路电压为模拟电压（VCAMA），数字电压（VCAMD），IO口电压（VCAMIO）。</p>
<h5 id="b-I2C信号"><a href="#b-I2C信号" class="headerlink" title="b) I2C信号"></a>b) I2C信号</h5><p>平台端与Sensor端通过I2C来通信（读写寄存器），包括SCL（I2C Clock） SDA（I2C Data）信号。</p>
<h5 id="c-mipi几条lane"><a href="#c-mipi几条lane" class="headerlink" title="c) mipi几条lane"></a>c) mipi几条lane</h5><p>mipi data是成对的差分信号，MIPI_RDN和MIPI_RDP，有几对这样的pin脚，则说明是几条lane，同一颗sensor由于register setting不同，输出的信号有可能是2 lane或者4lane等。</p>
<h5 id="d-parallel高低八位"><a href="#d-parallel高低八位" class="headerlink" title="d) parallel高低八位"></a>d) parallel高低八位</h5><p>Parallel接口一般Data有10根pin，分别叫做Data0<del>Data9，Parallel sensor输出的data信号是8根pin时，这八根pin接到的是Data0</del>Data7还是Data2~Data9，需要配置正确，叫做接到高八位或者低八位，接错了可能产生如下现象:<br><img src="parallel.png"></p>
<h5 id="e-Data-Format"><a href="#e-Data-Format" class="headerlink" title="e) Data Format"></a>e) Data Format</h5><p>Sensor输出的数据格式，对于YUV Sensor来说，Data Fomat一般有YUYV，YVYU，UYVY等，配置不对可能会导致颜色和亮度错掉，例如下图:<br><img src="dataFormat.png"></p>
<h5 id="f-MCLK"><a href="#f-MCLK" class="headerlink" title="f) MCLK"></a>f) MCLK</h5><p>Soc提供给Sensor的外部clock。</p>
<h5 id="g-PCLK"><a href="#g-PCLK" class="headerlink" title="g) PCLK"></a>g) PCLK</h5><p>Parallel接口的Sensor输出的clock，该clock变化一次，data更新一次。</p>
<h5 id="h-mipi-信号"><a href="#h-mipi-信号" class="headerlink" title="h) mipi 信号"></a>h) mipi 信号</h5><p>mipi信号包括mipi clock和mipi data，该信号是高速信号，用来传输mipi数据包。</p>
]]></content>
      <categories>
        <category>3. Camera基础概念</category>
      </categories>
      <tags>
        <tag>Camera基础概念</tag>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
      </tags>
  </entry>
  <entry>
    <title>BufferQueue详解</title>
    <url>/2021/10/24/2021-10-24-BufferQueue/</url>
    <content><![CDATA[<p>BufferQueue是Android 中所有图形处理操作的核心，是图像buffer流转重要中转站。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相关源码：frameworks/native/libs/gui/</span><br><span class="line">在线阅读：http://aospxref.com/android-11.0.0_r21/xref/frameworks/native/libs/gui/</span><br></pre></td></tr></table></figure>
<h4 id="BufferQueue-简介"><a href="#BufferQueue-简介" class="headerlink" title="BufferQueue 简介"></a>BufferQueue 简介</h4><p>几乎所有在Android系统中移动图形数据缓冲区的内容都依赖于BufferQueue，比如显示、编码等。<br>BufferQueue是典型的生产者、消费者模型，通信过程如下所示：<br><img src="bufferqueue%E9%80%9A%E4%BF%A1%E7%AE%80%E5%9B%BE.png"><br>运行流程简单如下：<br>1.Dequeue buffer：图形生产者先向BufferQueue申请GraphicBuffer<br>2.queue buffer：填充完GraphicBuffer后，将GraphicBuffer移交给BufferQueue<br>3.BufferQueue会通知图形消费者有新的图形数据可以使用<br>4.acquire buffer：图形消费者就可以从BufferQueue取出GraphicBuffer<br>5.release buffer：使用完之后放回到BufferQueue以便循环使用。<br>一般图形生产者和消费者是在不同进程中，BufferQueue采用了binder和共享内存机制，因此可以高效地在进程间传递图形数据。</p>
<h4 id="BufferQueue与Camera的关系"><a href="#BufferQueue与Camera的关系" class="headerlink" title="BufferQueue与Camera的关系"></a>BufferQueue与Camera的关系</h4><p>在实际Camera开发过程中，经常会与surface，ImageReader，ImageWriter等打交道。当Camera APP向Framework发送一个request，请求一帧图像数据时，就是通过surface/ImageReader来接收图像数据的，这期间buffer的流转就是通过BufferQueue来实现的。实际上Surface，ImageReader，ImageWriter是对BufferQueue的生产者消费者的封装，其核心实现还是BufferQueue。<br>而BufferQueue是一个生产者消费者模型又是GraphicBuffer管理者，它和显示系统以及Camera流媒体紧密关系着。所以要了解Camera数据如何流转的，绕不开BufferQueue，要了解BufferQueue 就要先了解生产者消费者模型。<br>下面就从生产者消费者模型开始，深入浅出的讲解一下BufferQueue。</p>
<h4 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h4><h5 id="1-生产者消费者模型基本原理"><a href="#1-生产者消费者模型基本原理" class="headerlink" title="1.生产者消费者模型基本原理"></a>1.生产者消费者模型基本原理</h5><p>在生产者消费者模型中，存在生产者和消费者两种角色，它们通过内存缓冲区进行通信，生产者生产消费者需要的数据，消费者获取生产者生产的数据进行消费。<br>如果没有生产者消费者模型，那么生产者和消费者是直接调用关系，生产速度的和消费速度相互拖累，必须在消费完成之后才能进行下一次生产，如下图：<br><img src="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%851.png"><br>有了生产者和消费者模型之后，生产者生产的数据存到缓冲队列，消费者从队列中取数据去消费，互不影响，互不拖累，耦合性低。如下图:<br><img src="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%852.png"></p>
<h5 id="2-生产者消费者模型的组成"><a href="#2-生产者消费者模型的组成" class="headerlink" title="2.生产者消费者模型的组成"></a>2.生产者消费者模型的组成</h5><p>总结起来生产者消费者模型由一个场所，和两个角色组成：<br>. 一个场所：数据缓冲区，实现内存共享和轮转。<br>. 两个角色： 生产者(生产线程)生产数据，消费者(消费线程)消费数据。也可以是进程间使用。<br>生产者和消费着之间又需要遵循三种关系和四个基本的原则：<br>. 三个关系：生产者和生产者互斥关系，消费者和消费者互斥关系，生产者和消费者互斥同步关系。<br>. 四个原则：生产者生产的时候消费者不能消费，消费者消费的时候生产者不能生产，缓冲区空时消费者不能消费，缓冲区满时生产者不能生产。</p>
<p>以上就可以很清晰，简单明了的解释了生产者消费者模型。那么BufferQueue是什么，怎么应用生产者-消费者模型思想的，下面详细说明。</p>
<h4 id="BufferQueue基本原理"><a href="#BufferQueue基本原理" class="headerlink" title="BufferQueue基本原理"></a>BufferQueue基本原理</h4><h5 id="1-BufferQueue的生产消费框架"><a href="#1-BufferQueue的生产消费框架" class="headerlink" title="1.BufferQueue的生产消费框架"></a>1.BufferQueue的生产消费框架</h5><p>BufferQueue的核心逻辑是生产者消费者逻辑，在BufferQueue这个生产者消费者框架中， BufferQueuecore可以理解为数据缓冲区的管理者，代码逻辑在BufferQueue.cpp和BufferQueuecore.cpp中。<br>它的原始消费者是BufferQueueConsumer，它的原始生产者是BufferQueueProducer。</p>
<p>那么BufferQueue.cpp 和BufferQueuecore.cpp是什么样的关系呢，可以理解为BufferQueue是创建者，BufferQueuecore是由BufferQueue调用createBufferQueue创建的。</p>
<p>总的来讲 BufferQueue.cpp 主要定义了createBufferQueue接口和ProxyConsumerListener的onFrameAvailable等通知接口。<br>使用的时候，封装的消费者调用createBufferQueue创建BufferQueuecore，然后根据创建好的BufferQueuecore，去创建原始生产者消费者BufferQueueConsumer和BufferQueueProducer。</p>
<p>而消费者BufferQueueConsumer在调用connect的时候把ConsumerListener相关的回调接口注册进BufferQueue供ProxyConsumerListener回调使用。</p>
<p>生产者BufferQueueProducer也有一个connect接口，生产者的connect接口会注册IProducerListener到BufferQueuecore中，在消费者使用完GraphicBuffer释放的时候通过这个Listener通知生产者。</p>
<p>同时这个IProducerListener会注册Binder死亡通知函数，在死亡的时候回调BufferQueueProducer的binderDied，取消连接。</p>
<p>至此由BufferQueue BufferQueuecore，BufferQueueConsumer， BufferQueueProducer，组成的核心的生产者消费者模型就建立起来了。</p>
<p>这里说的是封装的消费者去创建BufferQueuecore有两点需要解释一下:<br>一个是消费者的封装关系，这个后面会详细说明。<br>另外一个就是为什么是消费者创建BufferQueuecore，而不是生产者去创建呢。<br>其实也是可以放到生产者中创建的，但是主要由于两点原因，正常会放在消费者中去创建：<br>1.出于消费者准备好消费了在去生产的思想考虑。<br>2.以消费者端作为核心端去管理，在消费者端创建方便统一管理。</p>
<h5 id="2-BufferQueueCore概述"><a href="#2-BufferQueueCore概述" class="headerlink" title="2.BufferQueueCore概述"></a>2.BufferQueueCore概述</h5><p>从BufferQueue的生产消费框架建立过程看，BufferQueueCore是核心缓冲区管理者，是由BufferQueue创建的，那么BufferQueueCore具体管理哪些事呢。<br>代码上看主要包含了下面这些关键参数。<br>可以大概划分一下：<br>1.slots相关，用于关联数据核心GraphicBuffer。(包括mSlots mQueue mFreeSlots mfreeBuffers mUnusedSlots,mActiveBuffers )，<br>2.listener相关，用于通知和回调(包括mConsumerListener mLinkedToDeath mConnectedProducerListener)，<br>3.Buffercount相关，用于定BufferQuue中的Buffer数量。(包括mMaxBufferCount mMaxAcquiredBufferCount mMaxDequeuedBufferCount)，<br>4.一些设置项(包括 mConsumerName mDefaultWidth mDefaultHeight mDefaultBufferFormat mDefaultBufferDataSpace)<br>设置相关主要是name 宽高信息，format信息，dataspace信息等,下面会分章节重点讲一下Slots BufferCount和 Listener。</p>
<h5 id="3-BufferSlot和BufferItem详解"><a href="#3-BufferSlot和BufferItem详解" class="headerlink" title="3.BufferSlot和BufferItem详解"></a>3.BufferSlot和BufferItem详解</h5><p>BufferQueueCore中管理着数据缓冲区，而数据的核心GraphicBuffer关联在BufferSlot中。<br>从源码中分析BufferSlot 和 GraphicBuffer的关联关系：<br>BufferQueueCore.h定义了:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/libs/gui/include/gui/BufferQueueCore.h</span></span><br><span class="line">BufferQueueDefs::SlotsType mSlots;</span><br></pre></td></tr></table></figure>
<p>SlotsType的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/libs/gui/include/gui/BufferQueueDefs.h</span></span><br><span class="line">  <span class="keyword">namespace</span> android &#123;</span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">BufferQueueCore</span>;</span></span><br><span class="line">  </span><br><span class="line">      <span class="keyword">namespace</span> BufferQueueDefs &#123;</span><br><span class="line">          <span class="keyword">typedef</span> BufferSlot SlotsType[NUM_BUFFER_SLOTS];</span><br><span class="line">      &#125; <span class="comment">// namespace BufferQueueDefs</span></span><br><span class="line">  &#125; <span class="comment">// namespace android</span></span><br></pre></td></tr></table></figure>
<p>由此可以看出mSlots实际上是一个BufferSlot的数组。<br>BufferSolt中定义了一个GraphicBuffer的強指针用于关联mGraphicBuffer。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/libs/gui/include/gui/BufferSlot.h</span></span><br><span class="line">truct BufferSlot &#123;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; mGraphicBuffer;</span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样BufferSlot 和 GraphicBuffer 就关联上了。</p>
<p>BufferQueue框架中，消费者和生产者对缓冲区数据操作的单元核心就是一个BufferSlot，也就是说所有取GraphicBuffer，放GraphicBuffer的操作都是针对BufferSlot来完成的。</p>
<p>具体的BufferSlot是怎么取和放的呢。可以看到BufferQueueCore 中还定义了 Fifo mQueue;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/libs/gui/include/gui/BufferQueueCore.h</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">typedef</span> Vector&lt;BufferItem&gt; Fifo;</span><br><span class="line">      </span><br><span class="line">     <span class="comment">// mQueue is a FIFO of queued buffers used in synchronous mode.</span></span><br><span class="line">      Fifo mQueue;</span><br></pre></td></tr></table></figure>
<p>字面上看，定义了一个先进先出的对列，那么这个队列里存放的是什么呢。<br>可以看到这样的定义typedef Vector Fifo; 也就是说Fifo是的向量集，里面存的是BufferItem。而 BufferItem中又定义了mslots的索引值:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/libs/hostgraphics/gui/BufferItem.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferItem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> mSlot;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以和BufferSlot关联上了。</p>
<p>总结一下可以简单理解成生产者从mQueue上获取BufferItem从而找到了对应的BufferSlot，并对它完成一系列的操作之后，放回到mQueue中供消费者使用，消费者也是从mQueue上获取BufferItem从而找到对应的BufferSlot来消费，消费完成之后放回mQueue。不过需要注意实际上不是真正的把BufferSlot取出放回mQueue，而是mSlots索引值的传递过程。</p>
<p>BufferQueueCore 中定义的mSlots是BufferSlot数组，默认数组长度为NUM_BUFFER_SLOTS =64</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/frameworks/native/libs/ui/include/ui/BufferQueueDefs.h</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> NUM_BUFFER_SLOTS = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>
<p>但是实际使用的时候64个Slots不一定全用，这里就引入了一个mUnusedSlots，mUnusedSlots只的是不被使用的BufferSlot集合，那么可用的BufferSlot 就是NUM_BUFFER_SLOTS - num(mUnusedSlots) 这么多个。</p>
<p>在这些可用的BufferSlot中，又会根据BufferSlot当前的状态即BufferState做区分。分为FREE状态下的BufferSlot和非FREE状态下的BufferSlot，非FREE状态下的BufferSlot集合在mActiveBuffers中。<br>FREE状态下的BufferSlot又会根据有没有和GraphicBuffer关联做区分。没有GraphicBuffer与之相关联的BufferSlot集合在mFreeSlots中，有GraphicBuffer与之关联的BufferSlot 集合在mFreeBuffers中。</p>
<p>在BufferQueueProducer和BufferQueueConsumer的生产消费的过程中，mslots中的BufferSlot会动态的在 mFreeSlots mFreeBuffers mActiveBuffers mUnusedSlots之间进行流转。</p>
<p>需要注意的是mSlots 是个数据结构数组，但是mFreeSlots mFreeBuffers mActiveBuffers mUnusedSlots 都不是结构数组，都是mSlots的 index值的集合(也就是mSlots的下标的集合)。</p>
<p>刚刚提到的BufferSlot会根据当前的状态即BufferState做区分为FREE状态的slot和非Free状态的slot。这个BufferState 就是BufferSlot流转过程中的状态。主要包含FREE DEQUEUED QUEUED ACQUIRED 四种状态。</p>
<p>FREE：FREE状态下的BufferSlot指的是可以被生产者dequeue或attach出来使用的BufferSlot，以及消费者消费完毕release或者detach的BufferSlot。<br>DEQUEUED：DEQUEUED状态的BufferSlot 是已经被生产者dequeue或attach出来供生产使用的BufferSlot。<br>QUEUED：QUEUED状态的BufferSlot 是生产者生产完成放回队列供消费者使用的BufferSlot。<br>ACQUIRED ：消费者从 BufferQueue获取准备消费的BufferSlot。</p>
<p>BufferState 用isFree isDequeued isQueued isAcquired 接口来判断状态，用attachProducer，detachProducer，dequeue，queue，cancel，freeQueued，acquire，release等接口来完成状态转换。</p>
<p>可以用下图形象的描述一下mFreeSlots mFreeBuffers mActiveBuffers mUnusedSlots 之间的关系。其中 TotalSlots 最大支持NUM_BUFFER_SLOTS = 64个，调用getMaxBufferCountLocked 获取的是可用的BufferSlot数量后面会详细介绍。<br><img src="All-Slots.png"></p>
<h5 id="4-BufferCount详解"><a href="#4-BufferCount详解" class="headerlink" title="4.BufferCount详解"></a>4.BufferCount详解</h5><p>BufferSlot中介绍中讲到getMaxBufferCountLocked，可以获取可用的BufferSlot数量maxbuffercount，那么这个可用的数量是哪里来的呢。</p>
<p>消费者BufferQueueConsumer 提供了setMaxBufferCount接口来设置可用的BufferSlot数量maxbuffercount，默认是数量是NUM_BUFFER_SLOTS=64。</p>
<p>同时消费者BufferQueueConsumer还提供了setMaxAcquiredBufferCount 接口来设置mMaxAcquiredBufferCount，</p>
<p>mMaxAcquiredBufferCount 是指一次 同时能被消费者使用的最大BufferCount。</p>
<p>另外，生产者还提供了一个setMaxDequeuedBufferCount接口来设置mMaxDequeuedBufferCount，</p>
<p>mMaxDequeuedBufferCount是指一次同时能被生产者用来生产的最大BufferCount</p>
<p>设定完成之后BufferQueueCore 中就会有 maxBufferCount个mlots， NUM_BUFFER_SLOTS- maxBufferCount个mUnusedSlots</p>
<p>maxBufferCount，mMaxDequeuedBufferCount ，mMaxAcquiredBufferCount三者之间的关系如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">maxbuffercount = mMaxDequeuedBufferCount + mMaxAcquiredBufferCount</span><br></pre></td></tr></table></figure>
<h4 id="BufferQueue中的生产者和消费者详解"><a href="#BufferQueue中的生产者和消费者详解" class="headerlink" title="BufferQueue中的生产者和消费者详解"></a>BufferQueue中的生产者和消费者详解</h4><h5 id="1-BufferQueue中的生产者和消费者概述"><a href="#1-BufferQueue中的生产者和消费者概述" class="headerlink" title="1.BufferQueue中的生产者和消费者概述"></a>1.BufferQueue中的生产者和消费者概述</h5><p>上面讲了BufferQueue创建了BufferQueueCore，然后根据BufferQueueCore创建了消费者BufferQueueConsumer和生产者BufferQueueProducer，并详细介绍了数据缓存管理区BufferQueueCore，下面重点介绍一下消费者BufferQueueConsumer和生产者BufferQueueProducer。<br>先介绍一下BufferQueueConsumer和BufferQueueProducer的继承关系和关键方法，然后针对关键函数展开介绍一下BufferQueueConsumer和BufferQueueProducer的工作原理，和流转过程。</p>
<p>BufferQueueConsumer 和 BufferQueueProducer 分别对应文件BufferQueueConsumer.cpp 和 BufferQueueProducer.cpp 和 BufferQueueCore.cpp 在同级目录都在/frameworks/native/libs/gui目录下。</p>
<p>下面是这两个类的继承关系和重要函数：<br><em><strong>生产者继承关系:</strong></em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/libs/gui/include/gui/BufferQueueProducer.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferQueueProducer</span> :</span> <span class="keyword">public</span> BnGraphicBufferProducer &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BnGraphicBufferProducer: IGraphicBufferProducer</span><br></pre></td></tr></table></figure>
<p>可以看到BufferQueueProducer继承了BnGraphicBufferProducer而BnGraphicBufferProducer又继承了IGraphicBufferProducer，来完成主要的BufferSlot的流转操作，也提供了远程代理接口，实现跨进程binder调用。<br>同时BufferQueueProducer还继承了DeathRecipient 用来处理Binder死亡通知。</p>
<p><em><strong>生产者关键方法:</strong></em><br>requestBuffer 获取对应BufferSlot的GraphicBuffer地址。<br>setMaxDequeuedBufferCount 设置最大同时可以dequeue出来的的BufferSlot数量。<br>dequeueBuffer 从FREE状态下的BufferSlots中队列中获取空闲的BufferSlot做生产使用，优先从mFreeBuffers中获取，如果没有则从mFreeSlots中获取。<br>attachBuffer 绑定已经分配好的GraphicBuffer到FREE状态下的BufferSlot中，优先从mFreeSlots中查找BufferSlot，如果没有则从mFreeBuffers中查找并绑定。<br>queueBuffer 生产者把生产好的BufferSlot放到队列中供消费者使用。<br>detachBuffer 把attachBuffer了GraphicBuffer的 Active状态下的BufferSlot的放到mFreeBuffers之后直接取消GraphicBuffer的绑定。<br>detachNextBuffer 把需要释放的BufferSlot中的GraphicBuffer指针赋值到outBuffer输出之后，把BufferSlot的放到mFreeBuffers并解绑定GraphicBuffer。<br>cancelBuffer 把BufferSlot放回到mfreeBuffers中，不会释放graphicbuffer。<br>connect 生产者通过该接口把IProducerListener注册到BufferQueueCore中供消费者回调，同时建立了Binder死亡通知通路。<br>disconnect断开BufferQueueProducer和BufferQueueCore之间建立的链接关系。</p>
<p><em><strong>消费者继承关系:</strong></em><br>(BufferQueueConsumer.cpp) BufferQueueConsumer:BnGraphicBufferConsumer<br>BnGraphicBufferConsumer:IGraphicBufferConsumer<br>可以看到BufferQueueConsumer的实现结构和BufferQueueProducer很相似继承了BnGraphicBufferConsumer 而BnGraphicBufferConsumer又最终继承了IGraphicBufferConsumer，来完成主要的BufferSlot的流转操作，也提供了远程代理接口，实现跨进程binder调用。</p>
<p><em><strong>消费者关键方法:</strong></em><br>acquireBuffer 获取QUEUE状态下的BufferSlot进行消费。<br>releaseBuffer消费完成之后把BufferSlot放回mFreeBuffers队列中。<br>attachBuffer 把消费者的GraphicBuffer绑定到BufferSlot上使用。<br>detachBuffer把消费者的GraphicBuffer从BufferSlot上解绑。<br>setMaxBufferCount 设置最大可用BufferSlot数量。<br>setMaxAcquiredBufferCount 设置最大同时可以acquire的BufferSlot数量。<br>connect 建立消费者和BufferQueueCore之间的链接，注册IConsumerListener回调。<br>disconnect 销毁消费者和BufferQueue之间的链接。</p>
<h5 id="2-BufferQueueConsumer关键流程分析"><a href="#2-BufferQueueConsumer关键流程分析" class="headerlink" title="2.BufferQueueConsumer关键流程分析"></a>2.BufferQueueConsumer关键流程分析</h5><h6 id="1-acquirebuffer的流程"><a href="#1-acquirebuffer的流程" class="headerlink" title="(1). acquirebuffer的流程"></a>(1). acquirebuffer的流程</h6><p>主要流程是首先判断AcquireBuffers是否已经超过最大一次能够Acquire的数量，mQueue是否为空，然后从mQueue中获取第一个迭代器赋值给outBuffer输出，同时把mBufferState状态改为Acquired 并从mQueue中移除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferQueueConsumer::acquireBuffer</span><span class="params">(BufferItem* outBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">nsecs_t</span> expectedPresent, <span class="keyword">uint64_t</span> maxFrameNumber)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//判断AcquireBuffers是否已经超过最大一次能够Acquire的数量。</span></span><br><span class="line">        <span class="keyword">if</span> (numAcquiredBuffers &gt;= mCore-&gt;mMaxAcquiredBufferCount + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//判断mQueue队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mQueue.<span class="built_in">empty</span>() &amp;&amp; !sharedBufferAvailable) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_BUFFER_AVAILABLE;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//从mQueue的第一个迭代器付给front</span></span><br><span class="line">        BufferQueueCore::<span class="function">Fifo::iterator <span class="title">front</span><span class="params">(mCore-&gt;mQueue.begin())</span></span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (sharedBufferAvailable &amp;&amp; mCore-&gt;mQueue.<span class="built_in">empty</span>()) &#123;<span class="comment">//共享buffer的处理逻辑</span></span><br><span class="line">          ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//正常非共享模式下的逻辑</span></span><br><span class="line">            slot = front-&gt;mSlot;    <span class="comment">//从front获取对应的slot，front是一个BufferItem指针</span></span><br><span class="line">            *outBuffer = *front;    <span class="comment">//把front指向的BufferItem赋值给outBuffer</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!outBuffer-&gt;mIsStale) &#123;</span><br><span class="line">            mSlots[slot].mAcquireCalled = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (mCore-&gt;mQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                mSlots[slot].mBufferState.<span class="built_in">acquireNotInQueue</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mSlots[slot].mBufferState.<span class="built_in">acquire</span>();     <span class="comment">//把BufferState修改成acquired状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        mCore-&gt;mQueue.<span class="built_in">erase</span>(front);       <span class="comment">//把acquired slot 对应的BufferItem从mQueue中移除。</span></span><br><span class="line"> </span><br><span class="line">        mCore-&gt;mDequeueCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-releasebuffer的流程"><a href="#2-releasebuffer的流程" class="headerlink" title="(2). releasebuffer的流程"></a>(2). releasebuffer的流程</h6><p>releasebuffer主要流程是先做slot frameNumber 以及 BufferState有效性检查，修改mBufferState状态成FREE状态。然后把对应的slot从mActiveBuffers中移除并放回mFreeBuffers的过程。<br>这个过程中不做GraphicBuffer和BufferSlot的解绑定操作，也就是说GraphicBuffer不会被释放。详细流程如下面的代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferQueueConsumer::releaseBuffer</span><span class="params">(<span class="keyword">int</span> slot, <span class="keyword">uint64_t</span> frameNumber,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">const</span> sp&lt;Fence&gt;&amp; releaseFence, EGLDisplay eglDisplay,</span></span></span><br><span class="line"><span class="params"><span class="function">        EGLSyncKHR eglFence)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//slot的合法性判断。</span></span><br><span class="line">    <span class="keyword">if</span> (slot &lt; <span class="number">0</span> || slot &gt;= BufferQueueDefs::NUM_BUFFER_SLOTS ||</span><br><span class="line">            releaseFence == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">BQ_LOGE</span>(<span class="string">&quot;releaseBuffer: slot %d out of range or fence %p NULL&quot;</span>, slot,</span><br><span class="line">                releaseFence.<span class="built_in">get</span>());</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    sp&lt;IProducerListener&gt; listener;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断frameNumber是否有效，如果做过reallocated frameNumber将会改变。</span></span><br><span class="line">        <span class="keyword">if</span> (frameNumber != mSlots[slot].mFrameNumber &amp;&amp;</span><br><span class="line">                !mSlots[slot].mBufferState.<span class="built_in">isShared</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> STALE_BUFFER_SLOT;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//判断BufferState是否是Acquired状态</span></span><br><span class="line">        <span class="keyword">if</span> (!mSlots[slot].mBufferState.<span class="built_in">isAcquired</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        mSlots[slot].mBufferState.<span class="built_in">release</span>();   <span class="comment">//调用mBufferState.release()将acqiure状态释放。</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!mSlots[slot].mBufferState.<span class="built_in">isShared</span>()) &#123;</span><br><span class="line">            mCore-&gt;mActiveBuffers.<span class="built_in">erase</span>(slot);   <span class="comment">//将slot从mActiveBuffers中移除</span></span><br><span class="line">            mCore-&gt;mFreeBuffers.<span class="built_in">push_back</span>(slot); <span class="comment">//将slot放入到mFreeBuffers队列中</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        listener = mCore-&gt;mConnectedProducerListener;  <span class="comment">//获取ProducerListener</span></span><br><span class="line"> </span><br><span class="line">        mCore-&gt;mDequeueCondition.<span class="built_in">notify_all</span>();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        listener-&gt;<span class="built_in">onBufferReleased</span>();  <span class="comment">//调用Producer的onBufferReleased回调通知Producer完成释放。</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-BufferQueueProducer关键流程分析"><a href="#3-BufferQueueProducer关键流程分析" class="headerlink" title="3.BufferQueueProducer关键流程分析"></a>3.BufferQueueProducer关键流程分析</h5><h6 id="1-dequeuebuffer的流程"><a href="#1-dequeuebuffer的流程" class="headerlink" title="(1). dequeuebuffer的流程"></a>(1). dequeuebuffer的流程</h6><p>dequeuebuffer是生产者端从BufferQueueCore上获取一个GraphicBuffer进行生产的过程，生产者BufferQueueProducer 会在去获取一个FREE状态的的BufferSlot。<br>同时把mBufferState状态修改成Dequeue状态，把BufferSlot放到mActiveBuffers中管理。也由此可见GraphicBuffer是在这里实际创建的。<br>下面是dequeueBuffer的具体流程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferQueueProducer::dequeueBuffer</span><span class="params">(<span class="keyword">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="keyword">uint32_t</span> width, <span class="keyword">uint32_t</span> height, PixelFormat format,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="keyword">uint64_t</span> usage, <span class="keyword">uint64_t</span>* outBufferAge,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            FrameEventHistoryDelta* outTimestamps)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> found = BufferItem::INVALID_BUFFER_SLOT;</span><br><span class="line">        <span class="comment">//调用waitForFreeSlotThenRelock 找到可以dequeue的 FREE状态下的BufferSlot</span></span><br><span class="line">        <span class="keyword">while</span> (found == BufferItem::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">            <span class="keyword">status_t</span> status = <span class="built_in">waitForFreeSlotThenRelock</span>(FreeSlotCaller::Dequeue, lock, &amp;found);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="title">buffer</span><span class="params">(mSlots[found].mGraphicBuffer)</span></span>; <span class="comment">//把获取到的mGraphicBuffer地址赋值给buffer。</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mSharedBufferSlot != found) &#123;</span><br><span class="line">            mCore-&gt;mActiveBuffers.<span class="built_in">insert</span>(found);   <span class="comment">//把找到的slot放到mActiveBuffers中管理</span></span><br><span class="line">        &#125;</span><br><span class="line">        *outSlot = found;  <span class="comment">//赋值给outSlot输出</span></span><br><span class="line"> </span><br><span class="line">        mSlots[found].mBufferState.<span class="built_in">dequeue</span>();  <span class="comment">//修改BufferState 状态成dequeue状态。</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> returnFlags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FREE状态的BufferSlot又包含了mFreeSlots和mFreebuffers两组slots，dequeue的时候会先从mFreebuffers查找如果有可用的就使用，如果没有就从mFreeSlots获取BufferSlot并分配GraphicBuffer。<br>这个过程在waitForFreeSlotThenRelock中实现<br>下面是waitForFreeSlotThenRelock的流程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferQueueProducer::waitForFreeSlotThenRelock</span><span class="params">(FreeSlotCaller caller,</span></span></span><br><span class="line"><span class="params"><span class="function">        std::unique_lock&lt;std::mutex&gt;&amp; lock, <span class="keyword">int</span>* found)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> callerString = (caller == FreeSlotCaller::Dequeue) ?</span><br><span class="line">            <span class="string">&quot;dequeueBuffer&quot;</span> : <span class="string">&quot;attachBuffer&quot;</span>;</span><br><span class="line">    <span class="keyword">bool</span> tryAgain = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (tryAgain) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> ()&#123;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (caller == FreeSlotCaller::Dequeue) &#123;   <span class="comment">//Dequeuebuffer调用这段代码，先调用getFreeBufferLocked从mFreeBuffers中获取，如果找到了就返回。</span></span><br><span class="line">                    <span class="comment">// If we&#x27;re calling this from dequeue, prefer free buffers</span></span><br><span class="line">                    <span class="keyword">int</span> slot = <span class="built_in">getFreeBufferLocked</span>();</span><br><span class="line">                    <span class="keyword">if</span> (slot != BufferQueueCore::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">                        *found = slot;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mCore-&gt;mAllowAllocation) &#123;      <span class="comment">// 如果没找到，在调用getFreeSlotLocked从mFreeSlots中获取。</span></span><br><span class="line">                        *found = <span class="built_in">getFreeSlotLocked</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// If we&#x27;re calling this from attach, prefer free slots</span></span><br><span class="line">                    <span class="keyword">int</span> slot = <span class="built_in">getFreeSlotLocked</span>();         <span class="comment">//attachbuffer调用这段代码，优先先调用getFreeSlotLocked从mFreeSlots中获取，如果找到了就返回。</span></span><br><span class="line">                    <span class="keyword">if</span> (slot != BufferQueueCore::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">                        *found = slot;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        *found = <span class="built_in">getFreeBufferLocked</span>();    如果没找到，在调用getFreeBufferLocked从mFreeBuffers中获取。</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-attachbuffer的流程"><a href="#2-attachbuffer的流程" class="headerlink" title="(2). attachbuffer的流程"></a>(2). attachbuffer的流程</h6><p>正如上面的waitForFreeSlotThenRelock流程，attachBuffer也是从FREE状态的slots上获取BufferSlot，但是和dequeueBuffer不同attachBuffer是优先从mfreeslots上获取，如果mfreeslots没有，在从mfreebuffers上获取。<br>waitForFreeSlotThenRelock获取到BufferSlot之后，再把已有的申请好的GraphicBuffer绑定到这个BufferSlot上。同时把mBufferState状态修改成Dequeued状态。把BufferSlot放到mActiveBuffers中管理。<br>具体流程如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferQueueProducer::attachBuffer</span><span class="params">(<span class="keyword">int</span>* outSlot,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">const</span> sp&lt;android::GraphicBuffer&gt;&amp; buffer)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//调用waitForFreeSlotThenRelock 找到可以FREE状态下的BufferSlot</span></span><br><span class="line">    <span class="keyword">status_t</span> status = <span class="built_in">waitForFreeSlotThenRelock</span>(FreeSlotCaller::Attach, lock, &amp;found);</span><br><span class="line">  </span><br><span class="line">    *outSlot = found; <span class="comment">//把找到的slot赋值给outSlot</span></span><br><span class="line"> </span><br><span class="line">    mSlots[*outSlot].mGraphicBuffer = buffer;  <span class="comment">//把准备好的buffer关联到slot的mGraphicBuffer上</span></span><br><span class="line">    mSlots[*outSlot].mBufferState.<span class="built_in">attachProducer</span>(); <span class="comment">// 修改BufferState成Dequued状态</span></span><br><span class="line">  </span><br><span class="line">    mCore-&gt;mActiveBuffers.<span class="built_in">insert</span>(found);            <span class="comment">// 把slot放到mActiveBuffers中管理。</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> returnFlags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="3-queuebuffer的流程"><a href="#3-queuebuffer的流程" class="headerlink" title="(3). queuebuffer的流程"></a>(3). queuebuffer的流程</h6><p>queuebuffer是生产者完成对GraphicBuffer的处理之后调用queuebuffer把GraphicBuffer放回mQueue的操作，同时把mBufferState修改成QUEUE状态。<br>具体queuebuffer流程如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferQueueProducer::queueBuffer</span><span class="params">(<span class="keyword">int</span> slot,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    sp&lt;IConsumerListener&gt; frameAvailableListener;</span><br><span class="line">    sp&lt;IConsumerListener&gt; frameReplacedListener;</span><br><span class="line"> </span><br><span class="line">    BufferItem item;</span><br><span class="line">    &#123; <span class="comment">// Autolock scope</span></span><br><span class="line">  </span><br><span class="line">        mSlots[slot].mBufferState.<span class="built_in">queue</span>();  <span class="comment">//修改mBufferState状态为QUEUE状态。</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//增加mFrameCounter</span></span><br><span class="line">        ++mCore-&gt;mFrameCounter;</span><br><span class="line">        currentFrameNumber = mCore-&gt;mFrameCounter;</span><br><span class="line">        mSlots[slot].mFrameNumber = currentFrameNumber;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//给BufferItem赋值</span></span><br><span class="line">        item.mGraphicBuffer = mSlots[slot].mGraphicBuffer;</span><br><span class="line">        item.mSlot = slot;</span><br><span class="line"> </span><br><span class="line">        output-&gt;bufferReplaced = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mQueue.<span class="built_in">empty</span>()) &#123; <span class="comment">//如果mQueue为空，就直接把BufferItem push到mQueue尾部。</span></span><br><span class="line">            mCore-&gt;mQueue.<span class="built_in">push_back</span>(item);</span><br><span class="line">            frameAvailableListener = mCore-&gt;mConsumerListener;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//如mQueue不为空，需要判断一下last BufferItem是否被替换，如果可以替换就替换，如果不可以替换就直接把BufferItem放到mQueue尾部。</span></span><br><span class="line">            <span class="keyword">const</span> BufferItem&amp; last = mCore-&gt;mQueue.<span class="built_in">itemAt</span>(</span><br><span class="line">                    mCore-&gt;mQueue.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (last.mIsDroppable) &#123;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (!last.mIsStale) &#123;</span><br><span class="line">                    mSlots[last.mSlot].mBufferState.<span class="built_in">freeQueued</span>();</span><br><span class="line"> </span><br><span class="line">                    <span class="comment">// Don&#x27;t put the shared buffer on the free list.</span></span><br><span class="line">                    <span class="keyword">if</span> (!mSlots[last.mSlot].mBufferState.<span class="built_in">isShared</span>()) &#123;</span><br><span class="line">                        mCore-&gt;mActiveBuffers.<span class="built_in">erase</span>(last.mSlot);</span><br><span class="line">                        mCore-&gt;mFreeBuffers.<span class="built_in">push_back</span>(last.mSlot);</span><br><span class="line">                        output-&gt;bufferReplaced = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                mCore-&gt;mQueue.<span class="built_in">editItemAt</span>(mCore-&gt;mQueue.<span class="built_in">size</span>() - <span class="number">1</span>) = item;</span><br><span class="line">                frameReplacedListener = mCore-&gt;mConsumerListener;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mCore-&gt;mQueue.<span class="built_in">push_back</span>(item);</span><br><span class="line">                frameAvailableListener = mCore-&gt;mConsumerListener;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (frameAvailableListener != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            frameAvailableListener-&gt;<span class="built_in">onFrameAvailable</span>(item);   <span class="comment">//调用消费者的onFrameAvailable通知消费者，有queue状态的BufferSlot可以使用。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frameReplacedListener != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            frameReplacedListener-&gt;<span class="built_in">onFrameReplaced</span>(item);     <span class="comment">//调用消费者的onFrameReplaced通知消费者，有queue状态的BufferSlot可以被替换。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// Autolock scope</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-detachBuffer的流程"><a href="#4-detachBuffer的流程" class="headerlink" title="(4). detachBuffer的流程"></a>(4). detachBuffer的流程</h6><p>detachBuffer主要是对应生产者端的attachbuffer操作，将attachbuffer之后的BufferSlot，放回到mFreeSlots中，并解除对GraphicBuffer的绑定，并通知消费者Buffer释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferQueueProducer::detachBuffer</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    sp&lt;IConsumerListener&gt; listener;</span><br><span class="line">    </span><br><span class="line">        mSlots[slot].mBufferState.<span class="built_in">detachProducer</span>();  <span class="comment">//修改BufferState的Dequeued状态成FREE状态</span></span><br><span class="line">        mCore-&gt;mActiveBuffers.<span class="built_in">erase</span>(slot);           <span class="comment">//把slot从mActiveBuffers中移除</span></span><br><span class="line">        mCore-&gt;mFreeSlots.<span class="built_in">insert</span>(slot);              <span class="comment">//把slot加到mFreeSlots中。</span></span><br><span class="line">        mCore-&gt;<span class="built_in">clearBufferSlotLocked</span>(slot);          <span class="comment">//清除slot和Graphicbuffer的绑定关系。</span></span><br><span class="line">        mCore-&gt;mDequeueCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">        listener = mCore-&gt;mConsumerListener;   <span class="comment">//把消费者回调的listener赋值给listener</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        listener-&gt;<span class="built_in">onBuffersReleased</span>();<span class="comment">//调用消费者的listener接口通知消费者Buffer释放</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BufferQueue的完整生产消费体系"><a href="#BufferQueue的完整生产消费体系" class="headerlink" title="BufferQueue的完整生产消费体系"></a>BufferQueue的完整生产消费体系</h4><h5 id="1-BufferQueue的生产消费和BufferSlot状态关系"><a href="#1-BufferQueue的生产消费和BufferSlot状态关系" class="headerlink" title="1.BufferQueue的生产消费和BufferSlot状态关系"></a>1.BufferQueue的生产消费和BufferSlot状态关系</h5><p>上面分别详细介绍了BufferQueueCore BufferSlot BufferState BufferQueueConsumer BufferQueueProducer，也涉及到了部分流转关系。<br>这一节将用图表和文字说明详细的介绍一下 BufferQueueConsumer BufferQueueProducer 和 BufferSlot BufferState 之间的流转关系。</p>
<p>BufferSlot 包含了FREE DEQUEUED QUEUED ACQUIRED 这几种BufferState对应基本操作方法dequeue/queue/acquire/release的关系如下：</p>
<p>首先初始状态下，所有可用BufferSlot全是FREE状态，在mFreeSlots中管理。</p>
<p>BufferQueueProducer 发出dequeueBuffer请求会优先在mFreeSlots找的一个FREE状态的BufferSlot，后面在做dequeueBuffer的时候优先从mFreeBuffers中获取，发现没有对应的GraphicBuffer，就去申请，申请完成之后把GraphicBuffer与Slot绑定，然后把BufferSlot状态修改程Dequeue状态交由生产者生产。</p>
<p>生产完成之后，BufferQueueProducer 调用queueBuffer，把 BufferSlot放入队列mQueue中供消费者使用，并把BufferSlot的状态设置成QUEUE状态，并调用消费者的onFrameAvailable回调通知消费者，有可消费的BufferSlot可以消费。</p>
<p>消费者接到通知之后，调用acquireBuffer到mQueue队列中取出BufferSlot消费，并将BufferSlot状态修改程Acquired状态。消费完成之后调用releaseBuffer把BufferSlot放到mFreeBuffers中管理，这时不回去解绑GraphicBuffer和BufferSlot,所以GraphicBuffer不会被释放。</p>
<p>同时把BufferSlot状态设置为FREE状态，并调用BufferQueueProducer的回调函数通知生产者BufferSlot释放。这样就完成了一次流转。对应下图:<br><img src="buffer%E6%B5%81%E8%BD%AC.png"></p>
<p>BufferQueue的生产消费关系还有另外一种使用方法。下面是这种操作方法attachbuffer/detachbuffer/cancelbuffer和状态的关系图：<br><img src="buffer%E6%B5%81%E8%BD%AC2.png"><br>同样首先初始状态下，所有可用BufferSlot全是FREE状态，在mFreeSlots中管理。<br>BufferQueueProducer调用attachBuffer 首先优先从mFreeSlots中FREE状态BufferSlot，如果mFreeSlots中没有在从mFreeBuffers中获取，然后把已经分配好的GraphicBuffer关联到该BufferSlot上。<br>并将BufferSlot状态修改成DEQUEUED 这里和dequeueBuffer方式不同，dequeueBuffer是BufferQueueCore负责申请管理GraphicBuffer，而attachBuffer是把申请好的GraphicBuffer关联到BufferQueueCore上。<br>然后BufferQueueProducer 调用queueBuffer，把 BufferSlot放入队列mQueue中供消费者使用，并把BufferSlot的状态设置成QUEUE状态，并调用消费者的onFrameAvailable回调通知消费者消费。<br>消费者接到通知之后，调用acquireBuffer到mQueue队列中取出BufferSlot消费，并将BufferSlot状态修改程Acquired状态。消费完成之后调用releaseBuffer把BufferSlot放到mFreeBuffers中管理，并调用BufferQueueProducer的回调函数通知生产者调用detachBuffer释放GrphicBuffer。这里也可以调用消费者的dettachBuffer完成释放。</p>
<h5 id="2-BufferQueue的封装关系"><a href="#2-BufferQueue的封装关系" class="headerlink" title="2.BufferQueue的封装关系"></a>2.BufferQueue的封装关系</h5><p>BufferQueue的代码在/frameworks/native/libs/gui中，主要有BufferQueue.cpp BufferQueueCore.cpp BufferQueueProducer.cpp BufferQueueConsumer.cpp 这几个文件前面已经详细介绍过了，BufferQueue框架中的核心实现文件。</p>
<p>IConsumerListener.cpp IProducerListener.cpp 是生产者消费者相关的回调接口文件。<br>IGraphicBufferProducer.cpp IGraphicBufferConsumer.cpp 为BufferQueueProducer 和BufferQueueConsumer 提供接口，实现跨进程访问。</p>
<p>BufferItemConsumer.cpp CpuConsumer.cpp GLConsumer.cpp 等都继承ConsumerBase.cpp 来完成对BufferQueueConsumer的封装。</p>
<p>Surface.cpp SurfaceComposerClient.cpp SurfaceControl.cpp surface相关的文件是对BufferQueueProducer的封装。</p>
<p>我们正常使用的时候实际上是接触不到BufferQueue的，都是使用的层层封装之后的类，由此可以总结出：<br>BufferQueue的消费者是层层封装的，核心实现是BufferQueueConsumer。<br>BufferItemConsumer是对BufferQueueConsumer的封装，ImageReader又是对BufferItemConsumer的封装，BufferQueueConsumer BufferItemConsumer ImageReader都是消费者。</p>
<p>BufferQueue的生产者也是层层封装的，核心实现是BufferQueueProducer。<br>Surface 是对BufferQueueProducer的封装，ImageWriter又是对Surface的封装。BufferQueueProducer，Surface ，BufferQueueProducer 都是生产者。<br>每次封装都是有目的，都是为了实现某种特殊的功能。</p>
<h5 id="3-BufferQueue的使用模型"><a href="#3-BufferQueue的使用模型" class="headerlink" title="3.BufferQueue的使用模型"></a>3.BufferQueue的使用模型</h5><p>BufferQueue 有两种使用方式：<br>一种是生产者dequeue buffer用来生产，生产完成之后调用queueBuffer把GraphicBuffer放回BufferQueue并通过回调通知消费者使用，消费者调用acquireBuffer 获取GraphicBuffer进行消费，消费完成之后调用releaseBuffer 把GraphicBuffer放回BufferQueue，并通知生产者detachBuffer。<br><img src="bufferqueue%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9E%8B1.png"></p>
<p>另一种是生产者调用attachBuffer，获取BufferQueue上的一个freeSlot，并将已经分配好的GraphicBuffer与之连接，然后调用queueBuffer放回到BufferQueue上，并通知消费者消费，消费者调用acquireBuffer获取GraphicBuffer进行消费，消费完成之后调用releaseBuffer 把GraphicBuffer放回BufferQueue，并通知生产者detachBuffer。消费完成之后，消费者也可以调用detachBuffer进行释放GraphicBuffer。<br><img src="bufferqueue%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9E%8B2.png"></p>
<h4 id="BufferQueue在java层的应用"><a href="#BufferQueue在java层的应用" class="headerlink" title="BufferQueue在java层的应用"></a>BufferQueue在java层的应用</h4><h5 id="1-ImageReader消费者关系"><a href="#1-ImageReader消费者关系" class="headerlink" title="1.ImageReader消费者关系"></a>1.ImageReader消费者关系</h5><h6 id="1-ImageReader基本概念"><a href="#1-ImageReader基本概念" class="headerlink" title="(1). ImageReader基本概念"></a>(1). ImageReader基本概念</h6><p>ImageReader是消费者，消费者承担创建BufferQueue的责任。所以在ImageReader初始化的时候创建了BufferQueue以及最原始的生产者BufferQueueProducer和消费者BufferItemConsumer。Camera APP获取FrameWork的拍照数据一般就是通过ImageReader来获取的。</p>
<p>ImageReader工作的时候调用acquireNextImage 经过层层调用获取到BufferQueue中的GraphicBuffer来使用，并将状态改成aquired状态。使用完成之后调用releaseBuffer接口放回到mFreeBuffers队列中并通知生产者释放GraphicBuffer。</p>
<h6 id="2-ImageReader的初始化"><a href="#2-ImageReader的初始化" class="headerlink" title="(2). ImageReader的初始化"></a>(2). ImageReader的初始化</h6><p>ImageReader的初始化是调用nativeInit来完成的，nativeinit调用JNI接口ImageReader_init来实现，<br>在ImageReader_init中会调用BufferQueue::createBufferQueue(&amp;gbProducer, &amp;gbConsumer);创建最原始的生产者消费者和BufferQueueCore，之后会讲原始消费者封装到BufferItemConsumer中，然后调用bufferConsumer→setFrameAvailableListener(ctx);把JNIImageReaderContext实现的回调注册到ConsumerBase中去。生产完成之后发现有可以消费的Buffer，会先触发ConsumerBase::onFrameAvailable,在ConsumerBase::onFrameAvailable中会调用setFrameAvailableListener设置下来的回调，通知ImageReader进行消费。<br>然后会调用ctx-&gt;setProducer(gbProducer);保存原始生产者，供后面获取并封装使用。</p>
<h6 id="3-ImageReader的acquirebuffer"><a href="#3-ImageReader的acquirebuffer" class="headerlink" title="(3). ImageReader的acquirebuffer"></a>(3). ImageReader的acquirebuffer</h6><p>ImageReader的acquireBuffer主要根据mFormat创建SurfaceImage，然后用这个SurfaceImage做为参数继续调用acquireNextSurfaceImage完成acquire操作，<br>acquireNextSurfaceImage调用nativeImageSetup进而调用JNI接口ImageReader_imageSetup完成acquire操作，之后把SurfaceImage存储到mAcquiredImages中保存，在Release的时候释放。<br>ImageReader_imageSetup 中首先调用getBufferConsumer获取BufferItemConsumer，然后获取BufferItem，接着调用bufferConsumer-&gt;acquireBuffer(buffer, 0);继续完成acquireBuffer操作。<br>并把获取到的BufferItem通过Image_setBufferItem接口设置到image的mNativeBuffer属性中去<br>acquireBuffer调用ConsumerBase::acquireBufferLocked来完成item的填充，然后用mSlots[item-&gt;mSlot].mGraphicBuffer给item→mGraphicBuffer赋值。<br>acquireBufferLocked则又是调用mConsumer-&gt;acquireBuffer完成的，acquireBuffer流程上面已经分析过了，负责获取对应的BufferItem输出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">frameworks/base/media/java/android/media/ImageReader.<span class="function">java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Image <span class="title">acquireNextImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SurfaceImage si = <span class="keyword">new</span> <span class="built_in">SurfaceImage</span>(mFormat); <span class="comment">//创建一个SurfaceImage</span></span><br><span class="line">        <span class="keyword">int</span> status = <span class="built_in">acquireNextSurfaceImage</span>(si);   <span class="comment">//调用acquireNextSurfaceImage继续acquire操作</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">acquireNextSurfaceImage</span><span class="params">(SurfaceImage si)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">synchronized</span> (mCloseLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mIsReaderValid) &#123;</span><br><span class="line">                status = <span class="built_in">nativeImageSetup</span>(si);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (status == ACQUIRE_SUCCESS) &#123;</span><br><span class="line">                mAcquiredImages.<span class="built_in">add</span>(si);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">frameworks/base/media/jni/android_media_ImageReader.<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">ImageReader_imageSetup</span><span class="params">(JNIEnv* env, jobject thiz, jobject image)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    JNIImageReaderContext* ctx = <span class="built_in">ImageReader_getContext</span>(env, thiz);</span><br><span class="line"> </span><br><span class="line">    BufferItemConsumer* bufferConsumer = ctx-&gt;<span class="built_in">getBufferConsumer</span>();</span><br><span class="line">    BufferItem* buffer = ctx-&gt;<span class="built_in">getBufferItem</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">status_t</span> res = bufferConsumer-&gt;<span class="built_in">acquireBuffer</span>(buffer, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Image_setBufferItem</span>(env, image, buffer);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ACQUIRE_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Image_setBufferItem</span><span class="params">(JNIEnv* env, jobject thiz,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">const</span> BufferItem* buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    env-&gt;<span class="built_in">SetLongField</span>(thiz, gSurfaceImageClassInfo.mNativeBuffer, <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(buffer));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">frameworks/native/libs/gui/BufferItemConsumer.<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferItemConsumer::acquireBuffer</span><span class="params">(BufferItem *item,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">nsecs_t</span> presentWhen, <span class="keyword">bool</span> waitForFence)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    err = <span class="built_in">acquireBufferLocked</span>(item, presentWhen);</span><br><span class="line"> </span><br><span class="line">    item-&gt;mGraphicBuffer = mSlots[item-&gt;mSlot].mGraphicBuffer;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">frameworks/native/libs/gui/ConsumerBase.<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">ConsumerBase::acquireBufferLocked</span><span class="params">(BufferItem *item,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">nsecs_t</span> presentWhen, <span class="keyword">uint64_t</span> maxFrameNumber)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">status_t</span> err = mConsumer-&gt;<span class="built_in">acquireBuffer</span>(item, presentWhen, maxFrameNumber);  <span class="comment">//调用acquireBuffer完成acquireBuffer操作</span></span><br><span class="line">    <span class="keyword">if</span> (item-&gt;mGraphicBuffer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mSlots[item-&gt;mSlot].mGraphicBuffer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">freeBufferLocked</span>(item-&gt;mSlot);</span><br><span class="line">        &#125;</span><br><span class="line">        mSlots[item-&gt;mSlot].mGraphicBuffer = item-&gt;mGraphicBuffer;      <span class="comment">//如果item-&gt;mGraphicBuffer不为空，就用item-&gt;mGraphicBuffer覆盖mSlots[item-&gt;mSlot].mGraphicBuffer</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-ImageReader的release"><a href="#4-ImageReader的release" class="headerlink" title="(4). ImageReader的release"></a>(4). ImageReader的release</h6><p>使用graphicbuffer完成之后的释放需要注意一下：</p>
<p>消费者的最原始的buffer释放流程(BufferItemConsumer中的流程)应该是使用完成之后先调用releasebuffer将mlots 置位成FREE状态，link到mFreeBuffers中，<br>此时GraphicBuffer还是link在mSlots中，但是处于可用状态。在这个时候需要调用discardFreeBuffers来解除GraphicBuffer和mSlots link关系，<br>然后把mSlots标志成mFreeSlots状态完成释放。但是实际释放过程没有这么简单，ImageReader封装了releaseBuffer接口成releaseImage，但是这个接口是私有的，不能被公开调用。<br>ImageReader还封装了一个close接口，close接口完成了release操作，但是同时也清理掉了ImageReader消费者本身。</p>
<p>那么如何去释放呢，发现ImageReader的创建的SurfaceImage可以通过acquireNextImage获取，而SurfaceImage中有close方法，这个方法调用了 releaseImage完成SurfaceImage自身的释放。<br>到此为止看起来，该release的都release了，在调用一下discardFreeBuffers就能解决战斗，其实并没有。在生产者进程中Surface自身还维护了一个BufferSlot mSlots[NUM_BUFFER_SLOTS]，<br>attachBuffer的时候 GraphicBuffer link上，在收到消费者onBufferReleased回调之后调用detachNextBuffer取消关联。<br>但是实际上 mFormat ！= HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED 的时候是走不到detachNextBuffer的所以还是不能即时释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JNIImageWriterContext::onBufferReleased</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Detach the buffer every time when a buffer consumption is done,</span></span><br><span class="line">        <span class="comment">// need let this callback give a BufferItem, then only detach if it was attached to this</span></span><br><span class="line">        <span class="comment">// Writer. Do the detach unconditionally for opaque format now. see b/19977520</span></span><br><span class="line">        <span class="keyword">if</span> (mFormat == HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED) &#123;</span><br><span class="line">            mProducer-&gt;<span class="built_in">detachNextBuffer</span>(&amp;buffer, &amp;fence);</span><br><span class="line">        &#125;</span><br><span class="line">        env-&gt;<span class="built_in">CallStaticVoidMethod</span>(mClazz, gImageWriterClassInfo.postEventFromNative, mWeakThiz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是ImageReader的初始化,acquirebuffer,releasebuffer的操作流程图：<br><img src="ImageReader.png"></p>
<h5 id="2-imageWriter的生产者关系"><a href="#2-imageWriter的生产者关系" class="headerlink" title="2.imageWriter的生产者关系"></a>2.imageWriter的生产者关系</h5><h6 id="1-ImageWriter基本概念"><a href="#1-ImageWriter基本概念" class="headerlink" title="(1). ImageWriter基本概念"></a>(1). ImageWriter基本概念</h6><p>ImageWriter是生产者，根据消费者的创建的原始生产者封装并创建自己，然后link到消费者进程。<br>然后通过dequeueInputImage最终调用BufferQueueProducer:dequeueBuffer拿到GraphicBuffer进行处理。<br>处理完成之后调用queueInputImage 最终调用BufferQueueProducer:queueBuffer 把 buffer放回队列供消费者使用。</p>
<h6 id="2-ImageWriter的初始化"><a href="#2-ImageWriter的初始化" class="headerlink" title="(2). ImageWriter的初始化"></a>(2). ImageWriter的初始化</h6><p>与ImageReader类似，ImageWiter也是调用nativeInit来完成创建工作，nativeInit会调用JNI接口ImageWriter_init，在ImageWriter_init中首先通过surface-&gt;getIGraphicBufferProducer调用获取原始的Producer<br>然后调用new Surface进行封装，然后调用ctx-&gt;setProducer(producer)保存封装好的生产者，封装完成之后调用 producer-&gt;connect链接BufferQueueCOre并注册回调。</p>
<h6 id="3-ImageWriter的dequeue"><a href="#3-ImageWriter的dequeue" class="headerlink" title="(3). ImageWriter的dequeue"></a>(3). ImageWriter的dequeue</h6><p>ImageWriter提供dequeueInputImage接口来完成dequeue操作，dequeueInputImage主要通过nativeDequeueInputImage来实现，获取image之后会放到到mDequeuedImages保存。<br>nativeDequeueInputImage调用JNI接口ImageWriter_dequeueImage实现，ImageWriter_dequeueImage的主要操作是 通过ctx→getProducer()获取Surface，之后用获取到的Surface调用Surface的dequeueBuffer完成dequeue操作。<br>Surface的dequeueBuffer函数则是调用BufferQueueProducer的dequeueBuffer函数最终实现。</p>
<h6 id="4-ImageWriter的queue"><a href="#4-ImageWriter的queue" class="headerlink" title="(4). ImageWriter的queue"></a>(4). ImageWriter的queue</h6><p>dequeBuffer主要就是调用nativeQueueInputImage来完成，nativeQueueInputImage调用JNI接口ImageWriter_queueImage来实现，在ImageWriter_queueImage中通过ctx→getProducer获取生产者<br>然后根据获取到的生产者继续调用anw-&gt;queueBuffer完成queueBuffer的操作，最终调用BufferQueuProducer的queueBuffer函数完成queue操作。</p>
<p>下面是imagewriter 初始化，dequebuffer，queuebuffer的详细的操作流程图：<br><img src="imageWriter.png"></p>
<h6 id="5-ImageWriter的attachandqueue"><a href="#5-ImageWriter的attachandqueue" class="headerlink" title="(5).ImageWriter的attachandqueue"></a>(5).ImageWriter的attachandqueue</h6><p>如果这个imageBuffer是不属于ImageWriter自己的，就会走attach流程，attach之后调用queue放到BufferQueue中供消费者使用。<br>具体的是先调用ownedByMe判断是否属于自己的，如果不是则先找到之前的Owner,然后调用detachImage断开和之前owner的关系。在然后就是调用attachAndQueueInputImage完成attach和queue操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queueInputImage</span><span class="params">(Image image)</span> </span>&#123;</span><br><span class="line">        boolean ownedByMe = <span class="built_in">isImageOwnedByMe</span>(image);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// For images from other components, need to detach first, then attach.</span></span><br><span class="line">        <span class="keyword">if</span> (!ownedByMe) &#123;</span><br><span class="line">            ImageReader prevOwner = (ImageReader) image.<span class="built_in">getOwner</span>();       <span class="comment">//获取之前的owner</span></span><br><span class="line">            prevOwner.<span class="built_in">detachImage</span>(image);            <span class="comment">//调用detachImage释放和之前owner的关联。</span></span><br><span class="line">            <span class="built_in">attachAndQueueInputImage</span>(image);       <span class="comment">//调用attachAndQueueInputImage完成attach和queue操作。</span></span><br><span class="line">            image.<span class="built_in">close</span>();                        <span class="comment">//关闭image</span></span><br><span class="line">            <span class="keyword">return</span>;                                 <span class="comment">//直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">nativeQueueInputImage</span>(mNativeContext, image, image.<span class="built_in">getTimestamp</span>(), crop.left, crop.top,</span><br><span class="line">                crop.right, crop.bottom, image.<span class="built_in">getTransform</span>(), image.<span class="built_in">getScalingMode</span>());         <span class="comment">//如果ownedByMe则调用这里做queue操作。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>具体attach流程如下图：<br><img src="attachandqueue.png"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>综上介绍了消费者模型，BufferQueue的缓存区管理以及关键概念BufferSlot BufferState BufferItem BufferQueue。<br>然后介绍了生产者消费者BufferQueueProducer和 BufferQueueConsumer 的关键方法dequeue/queue/acquire/release。<br>再之后然后介绍了将生产者消费者的生产消费关系和BufferQueue完整的串起来，状态变化，接口回调，Buffer流转。<br>最后介绍了实际应用中BufferQueue的封装层imagereader，imagewriter。<br>BufferQueue的生产消费关系终结如下图，消费者和生产者层层封装，消费者可以跨进程也可以不跨进程，一般不跨。<br>生产者可以跨进程也可以不跨进程一般是跨进程的。<br><img src="bufferqueue%E6%80%BB%E7%BB%93.png"></p>
<p>————————————————</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考链接：https://blog.csdn.net/rabbyheathy/article/details/103748551</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>2. Android Other</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Camera架构概述</title>
    <url>/2021/10/24/2021-10-24-a-Camera-system-architecture/</url>
    <content><![CDATA[<p>谷歌根据职能的不同将Camera框架一共划分成了五层，分别是App交互层、Camera Service、Camera Provider、Camera Driver以及Camera Hardware。</p>
<span id="more"></span>
<p>Android系统利用分层思想，将各层的接口定义与实现分离开来，以接口作为各层的脉络连接整体框架，将具体实现的主导权交由各自有具体实现需求的平台厂商或者Android 开发者，这样既做到把控全局，也给予了众多开发者足够大的创作空间，这体现出了一个优秀的开源系统应有的胸怀和远见。<br>其中，谷歌根据职能的不同将Camera框架一共划分成了五层，分别是App交互层、Camera Service、Camera Provider、Camera Driver以及Camera Hardware，下面的Camera的整体架构图很清晰地显示出了其五层架构以及相互的关联接口。<br><img src="Android-camera-%E6%9E%B6%E6%9E%84.jpg"> </p>
<h4 id="App交互层"><a href="#App交互层" class="headerlink" title="App交互层"></a>App交互层</h4><h5 id="Camera-APP"><a href="#Camera-APP" class="headerlink" title="Camera APP"></a>Camera APP</h5><p>应用层处于整个框架的顶端，承担着于用户直接进行交互的责任，承接来自用户直接或者间接的比如预览/拍照/录像等一系列具体需求，一旦接收到用户相关UI操作，便会通过Camera Api v2标准接口将需求发送至Camera Framework部分，并且等待Camera Framework回传处理结果，其中包括了图像数据以及整体相机系统状态参数，之后将结果以一定方式反馈给用户。<br>Camera APP主要由应用开发者自行开发和维护。</p>
<h5 id="Camera-Framework"><a href="#Camera-Framework" class="headerlink" title="Camera Framework"></a>Camera Framework</h5><p>Camera Framework主要位于Camera App与Camera Service之间，以jar包的形式运行在App进程中，它封装了Camera Api v2接口的实现细节，暴露接口给App进行调用，进而接收来自App的请求，同时维护着请求在内部流转的业务逻辑，最终通过调用Camera AIDL跨进程接口将请求发送至Camera Service中进行处理，紧接着，等待Camera Service结果的回传，进而将最终结果发送至App。<br>Framework由Google负责开发和维护。</p>
<h4 id="Camera-Service"><a href="#Camera-Service" class="headerlink" title="Camera Service"></a>Camera Service</h4><p>Camera Service层位于Camera Framework与Camera Provider之间，作为一个独立进程存在于Android系统中，在系统启动初期会运行起来，它封装了Camera AIDL跨进程接口，提供给Framework进行调用，进而接收来自Framework的图像请求，同时内部维护着关于请求在该层的处理逻辑，最终通过调用Camera HIDL跨进程接口将请求再次下发到Camera Provider中，并且等待结果的回传，进而将结果上传至Framework中。<br>Camera Service由Google负责开发和维护。</p>
<h4 id="Camera-Provider"><a href="#Camera-Provider" class="headerlink" title="Camera Provider"></a>Camera Provider</h4><p>Camera Provider部分一般由一个独立的进程，例如高通叫provider进程，MTK叫camerahalserver进程。对上通过HIDL接口负责与Camera Service的跨进程通信，接收来自Camera Service的图像请求，对下通过标准的HAL3接口下发Camera的实际操作，控制着具体的Camera HAL。</p>
<h5 id="Camera-HAL"><a href="#Camera-HAL" class="headerlink" title="Camera HAL"></a>Camera HAL</h5><p>Camera HAL为各个ODM/OEM厂商负责开发和维护，是各个厂商对自身硬件的抽象，该部分是各个ODM/OEM厂商对谷歌Camera HAL3接口的实现，以so库的形式被加载至Camera Provider中。<br>现今，高通对此部分的实作是CamX-CHI架构，MTK对此部分的此部分的实作是mtkcam3架构。</p>
<h4 id="Camera-Driver"><a href="#Camera-Driver" class="headerlink" title="Camera Driver"></a>Camera Driver</h4><p>Camera Driver位于HAL Moudle与硬件层之间，借助Linux内核驱动框架（V4L2），实现对硬件的驱动和控制。HAL Moudle通过标准文件访问接口，从而能将请求顺利下发内核中。其中，I2C用于对Camera硬件的控制，MIPI用于传输图像数据。</p>
<h4 id="Camera-Hardware"><a href="#Camera-Hardware" class="headerlink" title="Camera Hardware"></a>Camera Hardware</h4><p>相机硬件处在整个相机体系的最底层，是相机系统的物理实现部分，该部分包括镜头、感光器、ISP三个最重要的模块，还有对焦马达、闪光灯、滤光片、光圈等辅助模块。镜头的作用是汇聚光线，利用光的折射性把射入的光线汇聚到感光器上。感光器的作用是负责光电转换，通过内部感光元件将接收到的光信号转换为电子信号进而通过数电转换模块转为数字信号，并最后传给ISP。ISP负责对数字图像进行一些算法处理，如白平衡、降噪、去马赛克等。</p>
<p>从整体结构上看，Android Camera系统根据职能的不同，有着严格的分层，层与层之间通过标准的接口进行连接。极大的降低了开发的耦合性，保持了各层的相互独立，使得不同的开发者能够专注于实现自己的业务逻辑，互不干扰又可以协同运行。</p>
]]></content>
      <categories>
        <category>1. Android Camera</category>
      </categories>
      <tags>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Camera概念篇-相机原理</title>
    <url>/2021/10/25/2021-10-25-Camera-concept-Camera-HW/</url>
    <content><![CDATA[<p>在了解如何调试相机前，首先需要对相机有一些基本认识，这里从网上总结了相关描述。</p>
<span id="more"></span>
<h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><p><img src="Image.png"><br>1.FPC: Flexible Printed Circuit 可挠性印刷电路板<br>2.Sensor:图象传感器<br>3.IR:红外滤波片<br>4.Holder:基座<br>5.Lens:镜头</p>
<h4 id="成像原理"><a href="#成像原理" class="headerlink" title="成像原理"></a>成像原理</h4><p>景物通过镜头（LENS）生成的光学图像投射到图像传感器(Sensor)表面上，然后转为模拟的电信号，经过 A/D（模数转换）转换后变为数字图像信号，再送到数字信号处理芯片（DSP）中加工处理，再通过 IO 接口传输到 CPU 中处理，通过 LCD 就可以看到图像了。<br><img src="Image1.png"><br>　　图像传感器（SENSOR）是一种半导体芯片，其表面包含有几十万到几百万的光电二极管。光电二极管受到光照射时，就会产生电荷。目前的SENSOR类型有两种：</p>
<p>CCD（Charge Couple Device)，电荷耦合器件，它是目前高像素类sensor中比较成熟的成像器件，是以一行为单位的电流信号。</p>
<p>CMOS（Complementary Metal Oxide Semiconductor），互补金属氧化物半导体。CMOS的信号是以点为单位的电荷信号，更为敏感，速度也更快，更为省电。</p>
<p>ISP 的性能是决定影像流畅的关键，JPEG encoder 的性能也是关键指标之一。而 JPEG encoder又分为硬件JPEG压缩方式和软件RGB压缩方式。</p>
<p>DSP控制芯片的作用是：将感光芯片获取的数据及时快速地传到baseband中并刷新感光芯片，因此控制芯片的好坏，直接决定画面品质（比如色彩饱和度、清晰度）与流畅度。</p>
<h4 id="图像数据输出格式"><a href="#图像数据输出格式" class="headerlink" title="图像数据输出格式"></a>图像数据输出格式</h4><p>常见的数据输出格式有：Raw data格式、YUV格式、RGB格式。</p>
<p>RGB格式：采用这种编码方法，每种颜色都可用三个变量来表示红色、绿色以及蓝色的强度。每一个像素有三原色R红色、G绿色、B蓝色组成。</p>
<p>YUV格式:其中“Y”表示明亮度(Luminance或Luma),就是灰阶值；而“U”和“V”表示色度(Chrominance或Chroma),是描述影像色彩及饱和度，用于指定像素的颜色。</p>
<p>RAW DATA格式:是CCD或CMOS在将光信号转换为电信号时的电平高低的原始记录，单纯地将没有进行任何处理的图像数据，即摄像元件直接得到的电信号进行数字化处理而得到的。<br><img src="Image2.png"><br>支持YUV/RGB格式的模组，一般会在模组上集成ISP（Image Single Processor），经过A/D转换过的原始数据经过ISP处理生成YUV标准格式传到BB。一般来说，这种设计适用于低像素Camera的要求，会在主板上省去一个DSP，可降低成本。在调试过程中，YUV/RGB格式的摄像头，其所有参数都可在kernel层通过寄存器来控制。调试一般由sensor的原厂支持。</p>
<p>支持RawData格式的模组，由于感光区域的需求，不会再模组内集成ISP以最大程度的增大感光区域的面积，提高照片质量。模组把原始的数字信号传给BB上的DSP进行处理，MTK自带的DSP一般包含ISP、JPEG encoder和DSP控制芯片。在调试的时候图像的效果需要MTK在HAL层的参数进行支持。</p>
<h4 id="LED-Flash（闪光灯）"><a href="#LED-Flash（闪光灯）" class="headerlink" title="LED Flash（闪光灯）"></a>LED Flash（闪光灯）</h4><p>LED Flash利用发光二极管取代一般相机的xenon flash，可对主体进行补光；和xenon最大的差异在于LED Flash可以做到长时间发光，若使用低电流，甚至可以持续发光。</p>
<p>（一）闪光灯模式<br>LED Flash使用模式可以分为Flash Mode（闪光灯，辅光较强，时间较短）和Torch Mode（手电筒，辅光较弱，持续发光）。<br><img src="Image3.png"><br>（二）MTK闪光过程<br><img src="Image4.png"><br>Pre-Flash的目的为测光，时间较长，强度较弱，使用15帧。<br>Main-Flash的目的为辅光，时间较短，强度较强，使用2帧。<br>Pre-Flash和Main-Flash的强度比例需要校准（MTK提供）。<br>（三）MTK保护机制<br>由于Main-Flash的作用时间有最大值的限制，因此MTK加入了Flash保护机制。<br>假设：<br>　　T：原本曝光时间<br>　　R：Flash限制曝光时间<br>　　S：原本ISO<br>　　Sn：最终ISO<br>　　Tn:最终曝光时间<br>如果：<br>　　T&gt;R<br>那么（提高ISO来补偿少掉的曝光时间）：<br>　　Sn = S*T/R<br>　　Tn = R<br>否则（保持ISO和曝光时间）：<br>　　Sn = S<br>　　Tn = T</p>
]]></content>
      <categories>
        <category>3. Camera基础概念</category>
      </categories>
      <tags>
        <tag>Camera基础概念</tag>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Camera概念篇-色彩校正矩阵</title>
    <url>/2021/10/25/2021-10-25-Camera-concept-Color-Correction-Matrix/</url>
    <content><![CDATA[<p>Color Correction Matrix简称CCM，意为色彩校正矩阵，用来校正人眼和Sensor对色彩的响应的差异。</p>
<span id="more"></span>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>人眼对色彩的识别，是基于人眼对光谱存在三种不同的感应单元，不同的感应单元对不同波段的光有不同的响应曲线的原理，通过大脑的合成得到色彩的感知。一般来说，我们可以通俗的用RGB三基色的概念来理解颜色的分解和合成。</p>
<p>理论上，如果人眼和 sensor对光谱的色光的响应，在光谱上的体现如下的话，基本上对三色光的响应，相互之间不会发生影响，没有所谓的交叉效应。<br><em><strong>RGB理想响应:</strong></em><br><img src="Image.png"></p>
<p>但是，实际情况并没有如此理想，下图表示了人眼的三色感应系统对光谱的响应情况。可见RGB的响应并不是完全独立的。<br><em><strong>RGB真实响应:</strong></em><br><img src="Image2.png"><br><img src="Image3.png"></p>
<p>下图则表示了Kodak某相机光谱的响应。可见其与人眼的响应曲线有较大的区别。<br><img src="Image4.png"></p>
<p>既然我们已经看到 sensor 对光谱的响应，在 RGB各分量上与人眼对光谱的响应通常是有偏差的，当然就需要对其进行校正。不光是在交叉效应上，同样对色彩各分量的响应强度也需要校正。通常的做法是通过一个色彩校正矩阵（Color Correction Matrix）对颜色进行一次校正。<br><img src="Image5.png"><br>该色彩校正的运算通常由 ISP 完成，软件通过修改相关寄存器得到正确的校正结果。值得注意的一点是，由于 RGB -&gt; YUV的转换也是通过一个 3*3 的变换矩阵来实现的，所以有时候这两个矩阵在 ISP 处理的过程中会合并在一起， 通过一次矩阵运算操作完成色彩的校正和颜色空间的转换。</p>
<h4 id="MTK-CCM"><a href="#MTK-CCM" class="headerlink" title="MTK CCM"></a>MTK CCM</h4><p>MTK方案中在前期客观调试时需要通过CCT在各色温光源下进行校准，CCT中CCM界面如下：<br><img src="Image6.png"></p>
]]></content>
      <categories>
        <category>3. Camera基础概念</category>
      </categories>
      <tags>
        <tag>Camera基础概念</tag>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Camera概念篇-图像</title>
    <url>/2021/10/25/2021-10-25-Camera-concept-Image/</url>
    <content><![CDATA[<p>本文介绍Camera成像相关概念。</p>
<span id="more"></span>
<h4 id="Shutter（快门）"><a href="#Shutter（快门）" class="headerlink" title="Shutter（快门）"></a>Shutter（快门）</h4><p>快门，原指传统相机上控制感光片有效曝光时间的一种装置，手机相机上是指曝光时间的长短。</p>
<h4 id="Aperture（光圈）"><a href="#Aperture（光圈）" class="headerlink" title="Aperture（光圈）"></a>Aperture（光圈）</h4><p>光圈表示光通过的有效孔的直径。通常是一个用来控制光线透过镜头，进入机身内感光面的光亮的装置，它在镜头内。它的大小决定着通过镜头进入感光元件的光线的多少。<br>光圈大小用f值表示，光圈F值=镜头的焦距/镜头光圈的直径<br><img src="Image.png"></p>
<h4 id="ISO（感光度）"><a href="#ISO（感光度）" class="headerlink" title="ISO（感光度）"></a>ISO（感光度）</h4><p>原本是传统摄影用来衡量底片感光度的单位，数值越高，感光度越强，但噪声越明显，数码相机也沿用了此标准。ISO数值每增加一倍，感光度也增加一倍；SV为衡量ISO的单位，ISO100时，SV=5。</p>
<h4 id="Focal-Length（焦距）"><a href="#Focal-Length（焦距）" class="headerlink" title="Focal Length（焦距）"></a>Focal Length（焦距）</h4><p>焦距由于摄影机镜头的光学透镜（lens）而形成。摄影机或放映机的金属筒容纳了一组两边或一边有弧度（凸或凹）的透镜，组成一个综合镜头。从物体不同部分射出的光线，通过镜头之后，聚焦在底片的一个点上，使影像具有清晰的轮廓与真实的质感，这个点就叫焦点（focus）。所谓焦距（focal length），正是从镜头之镜片中间点到光线能清晰聚焦的那一点之间的距离。</p>
<p>较常见的有：8mm，15mm，24mm，28mm，35mm，50mm，85mm，105mm，135mm，200mm，400mm，600mm，1200mm等，还有长达2500mm超长焦望远镜头。<br><img src="Image1.png"></p>
<h4 id="Saturation（饱和度）"><a href="#Saturation（饱和度）" class="headerlink" title="Saturation（饱和度）"></a>Saturation（饱和度）</h4><p>色彩有各种不同的表示方式，常见的有RGB、Lab、HSV等色彩域（Color Domain），饱和度（Saturation）为HSV Domain的一个维度。</p>
<p>H：Hue，色相，色彩的色调，色彩在标准色环上的位置，以角度表示</p>
<p>S：Saturation，饱和度，色彩的纯度，以%表示。0%（灰色），100%（完全饱和）</p>
<p>V：Luminance，明度，色彩的亮度，以%表示。0%（黑色），100%（白色）<br><img src="Image2.png"></p>
<h4 id="Sharpness（锐度）"><a href="#Sharpness（锐度）" class="headerlink" title="Sharpness（锐度）"></a>Sharpness（锐度）</h4><p>Sharpness是指影像的锐利度，影像中高频成分越多，影像就越锐利。锐度主要由镜头决定，镜头品质好，成像越锐利；镜头品质差，成像越模糊。Sharpness可以由后端影像处理来加强，但是会有Side Effect：</p>
<p>Over Shoot：为了加强锐度，导致影像在Edge出现白边；</p>
<p>Noise Enhance：为了加强锐度，导致影像的Noise被当成Edge放大。<br><img src="Image3.png"></p>
<h4 id="Contrast（对比度）"><a href="#Contrast（对比度）" class="headerlink" title="Contrast（对比度）"></a>Contrast（对比度）</h4><p>Contrast为对比度，代表影像中亮（白）和暗（黑）的差异。所谓高对比就是白的地方够亮，黑的地方够黑。一般对比度低有以下两种情况：</p>
<p>整体过亮：过曝、Gamma拉得太高</p>
<p>整体过暗：曝光不足、Gamma拉得太低<br><img src="Image4.png"><br><img src="Image5.png"></p>
<h4 id="Color-Temperature（色温）"><a href="#Color-Temperature（色温）" class="headerlink" title="Color Temperature（色温）"></a>Color Temperature（色温）</h4><p>色温的定义：将黑体从绝对零度开始加温，温度每升高一度称为1开氏度(用字母K来表示)，当温度升高到一定程度时候，黑体便辐射出可见光，其光谱成份以及给人的感觉也会着温度的不断升高发生相应的变化。于是，就把黑体辐射一定色光的温度定为发射相同色光光源的色温。常见光源色温：<br><img src="Image-biaoge.png"><br>随着色温的升高，光源的颜色由暖色向冷色过渡，光源中的能量分布也由红光端向蓝光端偏移。<br><img src="Image6.png"><br>值得注意的是，实际光源的光谱分布各不相同，而色温只是代表了能量的偏重程度，并不反映具体的光谱分布，所以即使相同色温的光源，也可能引起不同的色彩反应。</p>
<p>人眼及大脑对色温有一定的生理和心理的自适应性，所以看到的颜色受色温偏移的影响较小，而Camera的Sensor没有这种能力，所以拍出来的照片不经过白平衡处理的话，和人眼看到的颜色会有较大的偏差（虽然人眼看到的和白光下真实的色彩也有偏差）。</p>
<p>太阳光色温随天气和时间变化的原因，与不同频率光的折射率有关：波长长的光线，折射率小，透射能力强，波长短的光线，折射率大，容易被散射，折射率低，这也就是为什么交通灯用红色，防雾灯通常是黄色，天空为什么是蓝色的等等现象的原因。</p>
<h4 id="Shading（渐晕效应）"><a href="#Shading（渐晕效应）" class="headerlink" title="Shading（渐晕效应）"></a>Shading（渐晕效应）</h4><p>Shading是在图像边缘观测到亮度逐渐减小的现象。<br>镜头边沿的成像光线和镜头光轴有一个较大的夹角，沿着视场边缘光线的光圈减小。通光路径变长，边角光线成像的位移就较大，使得镜头边缘的光线是随着视角的变大，成像亮度急剧的下降，呈现出画面角落的影像发暗。<br><img src="Image7.png"></p>
<h4 id="Flare（眩光）"><a href="#Flare（眩光）" class="headerlink" title="Flare（眩光）"></a>Flare（眩光）</h4><p>镜头的表面反射或镜筒、反光镜组的内面所引起的反射光，到达底面后造成画面整体或一部分产生了雾蒙，降低了图像的锐度。镜片的镀膜及内面防反射处理的加强，可以大幅度的减少光斑，但被拍摄物体的状况不相同，不可能完全消除。<br><img src="Image8.png"></p>
<h4 id="Defect-Pixel（坏点）"><a href="#Defect-Pixel（坏点）" class="headerlink" title="Defect Pixel（坏点）"></a>Defect Pixel（坏点）</h4><p>坏点一般指在Sensor制造过程中因为单个像素的电路异常而不能正常表现感光亮度。其表现形式为全黑情况下成像中单个的白色和彩色的点或者全白情况下成像中的黑点。<br>如果坏点无法被校正的话，会影响到正常拍照的图片。</p>
<h4 id="Flicker（频闪-水波纹）"><a href="#Flicker（频闪-水波纹）" class="headerlink" title="Flicker（频闪/水波纹）"></a>Flicker（频闪/水波纹）</h4><p>Flicker是由频率干扰引起，交流电光源都有光强的波动，在中国交流电频率是50Hz，光强的波动就是100Hz，周期为10ms。如果Camera曝光时间不是10ms的整数倍，那么在不同的感光面接收到的光能量一定不一样，体现在图像上就是明暗条纹。<br><img src="Image9.png"></p>
<h4 id="Moire（摩尔纹）"><a href="#Moire（摩尔纹）" class="headerlink" title="Moire（摩尔纹）"></a>Moire（摩尔纹）</h4><p>摩尔纹是数码相机等设备上的感光元件出现的高频干扰，会使图片出现彩色的高频率条纹；</p>
<p>摩尔纹是差拍原理的一种表现，空间频率略有差异的条纹叠加，由于条纹间隔的差异、重合位置会逐渐偏移，也会形成差拍；<br>消除摩尔纹，应该使镜头分辨率远小于感光元件的空间频率或者感光件像素密度能够大大提高、远远超过镜头的分辨率。<br><img src="Image10.png"></p>
<h4 id="False-Color（错误色）"><a href="#False-Color（错误色）" class="headerlink" title="False Color（错误色）"></a>False Color（错误色）</h4><p>False color的形成除了摩尔效应之外，感光器的三原色RGB色块排列也是其产生的原因。<br>在颜色取样的同时，因为空间差而没有取样到颜色，数码相机中的影像处理引擎仍会按照bayer pattern色块的顺序排列（RGB），试图为每一个像素去分配应有的颜色。这种情况在大量色块均匀的分布时是正确的，但当遇到突出部或者细微构造时，这样的颜色换算往往会出现错误和产生False Color。<br><img src="Image11.png"></p>
<h4 id="Purple-Fringe（紫边）"><a href="#Purple-Fringe（紫边）" class="headerlink" title="Purple Fringe（紫边）"></a>Purple Fringe（紫边）</h4><p>紫边，目前产生的原因有好几种说法。比较广为接受的就是镜头色散和颜色插值运算的问题导致。（固有镜片会对不同的波长产生色散，蓝B、红R两色混合误差而产生）。这个问题发生在拍摄高反差的景物时，在明暗交界的边缘部分会出现异常的紫色<br><img src="Image12.png"></p>
<h4 id="Image-File-Format-RGB-YUV-Bayer"><a href="#Image-File-Format-RGB-YUV-Bayer" class="headerlink" title="Image File Format-RGB/YUV/Bayer"></a>Image File Format-RGB/YUV/Bayer</h4><p>RGB：根据三基色原理，大部分光F都可以用不同分量的R、G、B三个相加混合而成。F=r[R]+g[G]+b[B]，其中r、g、b分别为三基色参与混合的系数。调整三者的值可以混合出黑色光和白色光之间的各种颜色的光。</p>
<p>YUV：现代彩色影像系统中，采用彩色的sensor进行摄像，将所得的彩色影像信号进行插值分色，分别放大校正后得到RGB。再经过矩阵变换电路得到亮度信号Y和两个色差信号R-Y（即U）、B-Y（即V）。这种色彩的表示方式就是YUV色彩空间。根据YUV的采样格式可以分为YUV444、YUV4222、YUV420。</p>
<p>Bayer Pattern：Sensor获取彩色图像的方法是在Sensor表面覆盖只含红、绿、蓝3色的马赛克滤镜。对齐输出信号通过一定的处理算法实现彩色，所以这种感光器件的排列方式被称为Bayer Pattern。因为只记录了单个的感光信息，通常也称为raw image。<br><img src="Image13.png"><br>RGB转换YUV公式如下：<br>Y = 0.299R + 0.587G + 0.114B<br>U = -0.147R - 0.289G + 0.436B<br>V = 0.615R - 0.515G - 0.100B<br>YUV转换RGB公式如下：<br>R = Y + 1.14V<br>G = Y - 0.39U - 0.58V<br>B = Y + 2.03U</p>
<h4 id="Resolution（解像力-amp-分辨率）"><a href="#Resolution（解像力-amp-分辨率）" class="headerlink" title="Resolution（解像力&amp;分辨率）"></a>Resolution（解像力&amp;分辨率）</h4><p>分辨率指成像平面上1毫米间距内能分辨开的黑白相间的线条对数，单位为“线对/毫米”（lp/mm、line-pairs/mm）。受限于光学、材料和其它种种因素，每一个镜头、每一台数码相机都有其分辨能力的极限。评判分辨率方法：</p>
<p>MTF：引进反差对比的概念来检定镜头解像力。</p>
<p>目测ISO12233：达到多少TV lines。<br><img src="Image14.png"></p>
<h4 id="Color-Error（色差）"><a href="#Color-Error（色差）" class="headerlink" title="Color Error（色差）"></a>Color Error（色差）</h4><p><img src="Image15.png"></p>
<h4 id="Black-Level（暗电流）"><a href="#Black-Level（暗电流）" class="headerlink" title="Black Level（暗电流）"></a>Black Level（暗电流）</h4><p>由于电子感光元件受热而产生电子的扰动，形成暗电流。此暗电流让电子感光元件在没有外在光源的情况下，仍然会累积信号，导致拍摄黑色的影像结果不够黑、整体呈现雾状或产生偏色。</p>
<p>可以通过sensor本身将output Raw减去对应的Black Level值或通过ISP将Input Raw减去对应的Black Level值来进行校准。<br><img src="Image16.png"></p>
<h4 id="Gamma-Curve（Gamma曲线）"><a href="#Gamma-Curve（Gamma曲线）" class="headerlink" title="Gamma Curve（Gamma曲线）"></a>Gamma Curve（Gamma曲线）</h4><p>数码感光元件对亮部和暗部的敏感度相同，呈线性曝光；人眼对暗部的敏感度较高，呈非线性。Gamma用来提高暗部来补偿感光元件和人眼之间这种亮度的差异。<br>Gamma拉得越高，亮度越亮，但会导致噪声越多。<br><img src="Image17.png"></p>
<h4 id="Image-Noise（图像噪声）"><a href="#Image-Noise（图像噪声）" class="headerlink" title="Image Noise（图像噪声）"></a>Image Noise（图像噪声）</h4><p><em><strong>（一）随机噪声</strong></em><br>1.暗电流（高热激发的电子）散粒噪声<br>2.MOSFET复位噪声（KTC噪声或者电容噪声）<br>3.放大器噪声<br>4.光散粒（光的粒子波动性产生的）噪声<br>5.电源噪声<br>6.量化噪声</p>
<p><em><strong>（二）固定图像噪声（FPN）</strong></em><br>均匀光照条件下单个像素输出的信号变化。<br>由于CMOS每个感光二极管旁都搭配了一个ADC放大器，如果以百万像素计，那么就需要百万个以上的ADC放大器。每个像素结构中的光电二极管的尺寸、掺杂浓度、生成过程中的沾污以及MOS场效应管的参数的偏差等都会造成像素输出信号的变化。表现为：<br>1.转移劣化（低照度黑点和彩色的固定直线）<br>2.光电二极管的观光度不均匀（亮白点、亮点、黑点与亮斑纹）</p>
<h4 id="Latitude（宽容度）"><a href="#Latitude（宽容度）" class="headerlink" title="Latitude（宽容度）"></a>Latitude（宽容度）</h4><p>宽容度是指感光材料按比例正确记录景物亮度范围的能力。被摄景物表面由最亮部分至最暗部分的差别，可以用明暗间的比例数字来表示。假设：景物最亮部分比最暗部分要明亮50倍，那么它们之间的比例数字是1:50，这就是景物的明暗差别。感光片所具有的正确表现被摄景物明暗差别的能力，即为感光材料的宽容度，通常也称为曝光宽容度。<br>黑白胶片的宽容度是1:128左右，彩色负片的宽容度在1:32～64左右， 彩色反转片的宽容度仅为1:16～32左右，相纸的宽容度大约在1:30左右。<br>在摄影曝光中，使用宽容度较大的感光胶片去拍摄亮度差较小的景物，即使曝光量稍微多一些或少一些，对底片密度的影响不大。从实用的角度来讲，感光胶片的宽容度越大，对曝光控制越有利。<br>曝光与感光胶片宽容度之间的关系，大致存在以下三种情况：<br>（一）宽容度等于景物亮度范围<br>当感光胶片宽容度等于景物亮度明暗比例数时，感光胶片所能记录的亮度范围正好与景物由最亮到最暗的间距相同，在曝光上没有其他可选择的余地。如曝光稍有出入，即会使明亮部分或阴暗部分的层次受到损害。<br>（二）宽容度大于景物亮度范围<br>当感光胶片宽容度大于景物亮度明暗比例数时，感光胶片所能记录的这度范围超过景物由最亮到最暗的间距，在曝光上留有很大的选择余地，通常是在可容许的范围内，选用最低曝光量作为曝光标准，这样所获得的底片密度达到最低曝光量的标准，印放照片或拷贝正片均可获得最佳的影像效果。在胶片宽容度大于景物亮度范围的情况下，摄影曝光量的控制即使略有出入，也不会影响到景物明暗层次的再现。<br>（三）宽容度小于景物亮度范围<br>当感光胶片宽容度小于景物亮度明暗比例数时，感光胶片所能记录的亮度范围远不及景物由最亮到最暗的间距范围，在曝光上很难控制，要想全部记录下景物的明暗比例是不可能的。一般来说，这时应按被摄主体的不同情况，选择曝光的侧重点，以被摄景物主要部位的亮度来作为曝光的基准，兼顾到其他部分的层次。很显然，在这种情况下的曝光，势必要损失相当一部分的亮度范围的层次，其关键在于恰当地确定曝光侧重点，所损失的只是次要部位的一些层次。<br><img src="Image18.png"><br>人眼的感光宽容度比胶片要高很多，而胶片的感光宽容度要比数码相机CCD高出很多！了解这个概念之后，我们就不难了解，为什么在逆光的条件下，人眼能看清背光的建筑物以及耀眼的天空云彩。而一旦拍摄出来，要么就是云彩颜色绚烂而建筑物变成了黑糊糊的剪影，要么就是建筑物色彩细节清楚而原本美丽的云彩却成了白色的一片。<br>再看人眼的结构，有瞳孔可以控制通光量，有杆状感光细胞和椎状感光细胞以适应不同的光强，可见即使人眼有着很高的感光宽容度，依然有亮度调节系统，以适应光强变化。</p>
<h4 id="图像质量"><a href="#图像质量" class="headerlink" title="图像质量"></a>图像质量</h4><p>图像质量指人们对一幅图像视觉感受的评价，它包括主观评价和客观评价。<br>（一）主观评价<br>主观评价通常认为图像质量指被测图像（即目标图像）相对于标准图像（即原图像）在人眼视觉系统中产生误差的程度。换一句话说就是相对于原图像，人眼认为目标图像几乎没有降质或损伤，则说目标图像的质量高，否则说图像质量差。另一种定义指在没有原图像的情况下，人眼能清晰地分辨图像中的事物，对图像中前景和背景、物体的轮廓、纹理等等能较好地区分，则说图像质量好，否则说图像质量差。<br>（二）客观评价<br>客观评价是指将测试数据化，由机器算法计算得出结果。<br><img src="Image19.png"><br>在国际上，Imatest和DxO Analyzer是比较有名的影像质量客观评测软件系统。Imatest和DxO Analyzer有异曲同工之处，都是把影响影像质量的各个因素拆分开来，分别对各个因素进行测试，由软件分析得出结论，可以非常直观看到各个方面的表现。Imatest(<a href="http://www.imatest.com/">http://www.imatest.com</a> )是美国Imatest公司旗下的影像质量评测软件系统，测试项目有镜头分辨率测试（SFR－MTF）、色差、色彩还原度、色彩空间等等。DxO Analyzer(<a href="http://www.dxo.com/">http://www.dxo.com</a> )是法国DxO公司旗下的影像质量评测软件系统，测试项目与imatest大同小异。DxO系统不仅可以测试镜头、sensor/ISP/video，甚至是多阵列的摄像头。</p>
]]></content>
      <categories>
        <category>3. Camera基础概念</category>
      </categories>
      <tags>
        <tag>Camera基础概念</tag>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Camera概念篇-岗位职能划分</title>
    <url>/2021/10/25/2021-10-25-Camera-concept/</url>
    <content><![CDATA[<p>Camera岗位划分和职能</p>
<span id="more"></span>
<h4 id="工作岗位"><a href="#工作岗位" class="headerlink" title="工作岗位"></a>工作岗位</h4><p>Camera工作分为APK编写、驱动移植和HAL维护以及效果调试，通常对应了三个岗位，分别为Camera应用工程师、Camera系统工程师、Camera Tuning工程师。我当前所处的岗位就是Camera系统工程师。</p>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>当有新的摄像头模组更换时，都需要做驱动移植、客观校准、主观Tuning三方面的工作，而应用基本上不需要进行对应的更改。<br>当有新的软件feature需要实现时，一般先用Camera系统工程师评估新feature实现的位置（APP/HAL），若主要在HAL实现，则由Camera系统工程师主导整个feature的开发，Camera应用工程师和Camera Tuning工程师配合参与。</p>
<h4 id="学习步骤"><a href="#学习步骤" class="headerlink" title="学习步骤"></a>学习步骤</h4><p>Camera系统是一个比较庞大且专业的系统，因此在学习前需要先了解一些相关的基本概念，例如sensor、模组、3A算法、ISP、图像等一些基本概念；然后阅读平台相关的文档，了解平台的处理流程以及工具的使用；最后是实际问题的解决，这一步是经验的慢慢积累。</p>
]]></content>
      <categories>
        <category>3. Camera基础概念</category>
      </categories>
      <tags>
        <tag>Camera基础概念</tag>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
      </tags>
  </entry>
  <entry>
    <title>C++从入门到进阶之一-从C到C++</title>
    <url>/2024/10/30/2024-10-30-CPP-Basics-C-to-Cpp/</url>
    <content><![CDATA[<p>曾经跟随过朱老师系统地学习过C/C++编程语言，然而一直没有机会对所学内容进行有效的整理。近来，有了较多的空闲时间，于是决定利用这段时间将以往的笔记进行回顾并整理。</p>
<span id="more"></span>
<h2 id="C-基本编程"><a href="#C-基本编程" class="headerlink" title="C++基本编程"></a>C++基本编程</h2><h3 id="何为命名空间"><a href="#何为命名空间" class="headerlink" title="何为命名空间"></a>何为命名空间</h3><h4 id="命名空间的引入"><a href="#命名空间的引入" class="headerlink" title="命名空间的引入"></a>命名空间的引入</h4><ol>
<li><strong>命名空间namespace，是C++引入解决全局变量和函数名（其是全局的）冲突的机制。</strong></li>
<li>C语言中没有namespace，但C++及之后的Java Python等都有。</li>
<li>namespace的关键点有2个：<br>第一、是如何解决名称冲突<br>第二、是如何合法访问变量</li>
</ol>
<h4 id="C语言如何解决名称冲突"><a href="#C语言如何解决名称冲突" class="headerlink" title="C语言如何解决名称冲突"></a>C语言如何解决名称冲突</h4><ol>
<li>大项目中会有很多C文件，全局变量和函数都是extern链接属性，因此名称冲突是客观存在的</li>
<li>一个项目是一个单体程序，项目中的全局变量和函数理应能够相互范围，因此名称冲突是客观存在的</li>
<li>C语言解决名称冲突的办法是：<br>第一、同一个C文件不要太大，由一个人写<br>第二、每个C文件（或几个C文件构成的一个模块）中所有的全局变量和函数前加统一的唯一前缀；<br>第三、不需要文件外访问的全局变量进而函数前面都加static</li>
<li>C语言的解决方案可行，在Linux内核中就是大量使用这种解决方案，C++早期就是这样做的，但是这种方式不够优雅。</li>
</ol>
<h4 id="命名空间如何解决问题"><a href="#命名空间如何解决问题" class="headerlink" title="命名空间如何解决问题"></a>命名空间如何解决问题</h4><ol>
<li>为实现命名空间机制，C++引入namespace关键字，定义格式为：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> XX&#123; &#125;；</span><br></pre></td></tr></table></figure></li>
<li>一个特定名称的namespace的一对大括号内部定义的变量、函数、类等均属于该命名空间内</li>
<li>在命名空间内部相互引用时可以直接使用变量名、函数名等</li>
<li>跨命名空间相互引用时，必须同时指定被引用方的命名空间名和变量名函数名才可以找到</li>
<li>命名空间看起来就好像是一种前缀</li>
<li><strong>命名空间本质上其实是对全局变量和函数在一定范围内链接属性的更改和控制（在命名空间之内是extern，在命名空间之外是static的）</strong></li>
</ol>
<h4 id="关于语言特性的思考"><a href="#关于语言特性的思考" class="headerlink" title="关于语言特性的思考"></a>关于语言特性的思考</h4><ol>
<li><strong>语言特性是语言通过关键字或符号所支持第一种功能特性，如namespace、template、运算符重载、面向对象等</strong>。</li>
<li>语言特性必定对应解决某种问题，必定在某方面对程序员有帮助</li>
<li>语言特性越多或者设计越复杂，则语言本身就越难使用，但语言就越厉害</li>
<li>语言特性体现为某种语法，本质上靠编译工具链提供支持</li>
<li>C++11/14/17/20的版本变迁，无非就是新增或修正某些细节语言特性</li>
<li>就事论事讨论编程语言，其实难点都在掌握和熟练运用语言特性上</li>
</ol>
<h3 id="命名空间的初级定义和使用"><a href="#命名空间的初级定义和使用" class="headerlink" title="命名空间的初级定义和使用"></a>命名空间的初级定义和使用</h3><ol>
<li>同一文件内定义namespace</li>
</ol>
<p>正常情况，一个文件使用一个namespace，或者几个文件共同使用一个namespace</p>
<ol start="2">
<li>同一文件内使用namespace</li>
</ol>
<p><strong>:: (作用域解析符)</strong></p>
<p><strong>using关键字：最常用的作用就是导入命名空间</strong></p>
<ul>
<li><p>namespace的三种引用方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">方式一</span><br><span class="line"></span><br><span class="line">ace::Mutex mutex; <span class="comment">//成本最低，用到那个，就去现场引用那个，没有额外的负担对编译器</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">方式二</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ace::Mutex; <span class="comment">//一次性只声明了指定命名空间里面的一个变量或函数，成本较低</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> NS1::func1 <span class="comment">//告诉编译器如果在默认的命名空间找不到func1可以到NS1中去找一下</span></span><br><span class="line"></span><br><span class="line">Mutex mutex;      <span class="comment">// 定义一个变量</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">方式三</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ace; <span class="comment">//一次性声明指定命名空间里面的所有变量函数等，成本更高，但更方便</span></span><br><span class="line"></span><br><span class="line">Mutex mutex;</span><br></pre></td></tr></table></figure>

<p>  using这里有点像include关键字，就是把整个文件拿过来在这里原地展开，假设include的包含的那个文件有700行，include这行代码就相当于把那700行的代码全部搂过来了，这种做法还是有一定开销的，对编译器的压力就比较大。</p>
<p>  第二种只using进来一个符号，第三种把命名空间的所有符号全部都using进来了。</p>
<p>  从成本的角度来说，第一种到第二种到第三种的成本是依次递升，但是方便性是越来越好的。</p>
<p>  实际开发当中第一种和第三种用的比较多，第二种用的比较少。</p>
</li>
<li><p>不同文件间定义和使用namespace</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> NS2&#123;<span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">void</span>)</span></span>;&#125;; <span class="comment">//你有东西在另一个文件中，你要使用可以，但是你得先声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> NS2&#123;<span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">void</span>)</span></span>;&#125;; <span class="comment">//namespace这种思想与要使用跨文件使用变量或函数是类似的，声明的时候不可以有实体，有实体就变成定义了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> NS2; <span class="comment">//命名空间引用，using是消费型的，因此需要前面先声明NS2，实际开发中，前面的声明一般加在对应的头文件中</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="C-默认命名空间"><a href="#C-默认命名空间" class="headerlink" title="C++默认命名空间"></a>C++默认命名空间</h3><p>在C++语言，所有的代码都应处于某个命名空间中，在同一个namespace中直接引用（类似于C语言中的一个文件内的函数引用），在不同的namespace中，通过上面的方法进行引用（同一个文件）、跨文件引用。</p>
<p><strong>所有没有明确指定放在哪一个namespace中，都是在默认的namespace。</strong></p>
<p>(1)默认命名空间又叫全局命名空间</p>
<p>(2)默认命名空间引用其他命名空间方法（上节最后的内容：using namespace NS2; ）</p>
<p>(3)默认命名空间引用自己的方法</p>
<p>(4)其他命名空间引用默认命名空间中的方法::f();</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数的声明要放在引用它的命名空间之前，因为编译只会往前回顾，不会往后看的。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func5</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">   </span><br><span class="line"><span class="keyword">namespace</span> NS1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ::<span class="built_in">func5</span>();        </span><br><span class="line">       <span class="comment">/* 表示func5定义和声明在默认命名空间，因为命名空间的名字是空的，所以冒号的前面是空的，也可以省略双冒号，最好加上，不加的话给人的感觉func5()是NS1里面定义的函数*/</span></span><br><span class="line">       <span class="comment">//func1();   //如果是特定的命名空间内部访问自己的东西，前面什么都不用加</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在一个命名空间中调用不加前缀的函数（来自其他namespace，但未声明），默认会在自己的这个命名空间中进行寻找。</p>
<h3 id="C-匿名命名空间（没有名字的namespace）"><a href="#C-匿名命名空间（没有名字的namespace）" class="headerlink" title="C++匿名命名空间（没有名字的namespace）"></a>C++匿名命名空间（没有名字的namespace）</h3><ol>
<li>匿名命名空间的定义和使用</li>
</ol>
<ul>
<li><p>定义匿名命名空间和全局命名空间有些类似，他们都没有名字，但是全局命名空间不需要自己定义，而<strong>匿名命名空间需要自己去定义</strong>，方法就是namespace后面没有空间名，直接就是 {}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;“来自匿名命名空间的<span class="built_in">func</span>().”&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>匿名命名空间中引用其他命名空间中的方法（与上小节讲的方法一样）</p>
</li>
<li><p>匿名命名空间中引用自己命名空间中的方法(确保先定义后使用)直接用，无需添加命名空间名前缀，只要确保先声明后使用的顺序就没有问题。</p>
</li>
<li><p>其他命名空间中引用匿名命名空间中的方法</p>
<p>  <strong>一般匿名命名空间定义于文件前面，类似于全局函数位置，之后的命名空间可以正常访问匿名命名空间中的内容</strong>，但是匿名命名空间的作用不在于此，而是在于跨文件访问的时候。因此其实对于单个文件内部，使用匿名命名空间与全局函数并无多大差别。</p>
</li>
</ul>
<ol start="2">
<li>匿名命名空间的价值</li>
</ol>
<ul>
<li>匿名命名空间中的符号纯（只在）文件内部使用，不需要被外部引用</li>
<li><strong>匿名命名空间效果类似于全局变量和函数加static</strong>，但是比C中的static使用范围广，C中static只能使用到函数和全局变量上，无法用到结构体以及枚举类型等等，但匿名的namespace可以。</li>
<li><strong>在文件内部没有什么作用好像没有一样</strong>的，其内的东西是全局的，但改变了文件的外部链接属性。</li>
<li>匿名命名空间的用法逻辑上符合整个命名空间的一贯原则</li>
</ul>
<h3 id="嵌套命名空间"><a href="#嵌套命名空间" class="headerlink" title="嵌套命名空间"></a>嵌套命名空间</h3><p>嵌套namespace的定义和使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> NS1</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">namespace</span> NS2</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;NS1::NS2::func1.&quot;</span> &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;NS1::func1.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;NS1::func2&quot;</span> &lt;&lt; endl;</span><br><span class="line">                NS2::<span class="built_in">func1</span>();</span><br><span class="line">                <span class="built_in">func1</span>();</span><br><span class="line">        &#125;</span><br><span class="line">                        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> NS1::NS2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        NS1::NS2::<span class="built_in">func1</span>();</span><br><span class="line">        <span class="built_in">func1</span>();</span><br><span class="line">        NS1::<span class="built_in">func2</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="C与C-的关系及C-标准库介绍"><a href="#C与C-的关系及C-标准库介绍" class="headerlink" title="C与C++的关系及C++标准库介绍"></a>C与C++的关系及C++标准库介绍</h3><ol>
<li>C++是C的超集</li>
</ol>
<ul>
<li><p>一个典型C程序（后缀名.c）可以完全被视为C++程序来编译，可使用g++来编译；</p>
</li>
<li><p>C程序可以通过__cplusplus符号是否预定义来判断当前是gcc还是g++编译 ，C++编译器中才有__cplusplus。</p>
<p>  __cplusplus的值是long int类型的，值表示当前编译程序的C++编译器的版本号。</p>
</li>
<li><p>一个典型C++程序（后缀名.cpp）只能当C++程序来编译，可见C++是C的超集</p>
</li>
<li><p>C++文件名的常用后缀：源文件（.cpp .cxx .cc .c .c++），头文件（.hpp .hxx .h）</p>
</li>
</ul>
<p>printf其实是属于std命名空间的，之所以未导入命名空间就可以用，是因为C++为了兼容C语言，但并不建议这么用，建议这样包含再使用该语句</p>
<ol start="2">
<li>C++完全接收并兼容了C库</li>
</ol>
<ul>
<li>典型C++程序中可以支持C的形式包含C库头文件，并直接使用C库API</li>
<li>C++更建议的头文件包含形式不是&lt;stdio.h&gt;这样，而是<iostream>（内部还是包含了：#include &lt;stdio.h&gt;）这样</li>
</ul>
<p><code>      </code>要点：C++的标准库的头文件是没有后缀名的</p>
<ul>
<li>ubuntu中gcc工具链的头文件在/usr/include中，可以实际看看</li>
</ul>
<ol start="3">
<li>C++标准库介绍</li>
</ol>
<ul>
<li>C标准库即为C++标准库的一部分，完全继承并以C++方式重写，位于std命名空间中</li>
<li>C++面向对象库，如string、iostream等，位于std命名空间中</li>
<li>C++ STL标准模板库，如vector、map等，位于std命名空间中</li>
</ul>
<ol start="4">
<li>C++标准库的地位和学习</li>
</ol>
<ul>
<li>C++比C在实际工作中更依赖于库，所以学好C++标准库很重要</li>
<li>C++标准库蕴含了C++的各种语言特性的典型用法，学标准库就顺便学好了C++</li>
<li>继承C标准库的部分兼容C的玩法</li>
<li>C++面向对象库难度不大，本次先讲iostream和string等初步用法</li>
<li>STL部分是重难点</li>
</ul>
<p><strong>summary</strong>：越高级的语言库占得比例越多，语言占得越少，比如python，学好其要学好它的库，学标准库就是在学C++；</p>
<h3 id="iostream的cout-cin使用"><a href="#iostream的cout-cin使用" class="headerlink" title="iostream的cout/cin使用"></a>iostream的cout/cin使用</h3><ol>
<li><p>基本使用</p>
<p> &lt;&lt; 流操作符，做输出， &gt;&gt; 做输入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please input an int number:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The int number is x= &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please input a float number:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; y;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;The float number is y= &quot;</span> &lt;&lt; y &lt;&lt;endl;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果如下（↙表示按下回车键）：</span><br><span class="line">Please input an <span class="keyword">int</span> number:</span><br><span class="line"><span class="number">8</span>↙</span><br><span class="line">The <span class="keyword">int</span> number is x= <span class="number">8</span></span><br><span class="line">Please input a <span class="keyword">float</span> number:</span><br><span class="line"><span class="number">7.4</span>↙</span><br><span class="line">The <span class="keyword">float</span> number is y= <span class="number">7.4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>流操作符&lt;&lt;本质上是<strong>左移运算符在iostream中的运算符重载</strong></p>
</li>
</ol>
<h3 id="C-用fstream读写文件"><a href="#C-用fstream读写文件" class="headerlink" title="C++用fstream读写文件"></a>C++用fstream读写文件</h3><ol>
<li>fstream介绍</li>
</ol>
<ul>
<li>fstream是C++标准库中面向对象库的一个，用于操作流式文件</li>
<li>fstream本质上是一个class，提供file操作的一众方法</li>
</ul>
<p>详解：<a href="https://blog.csdn.net/xuleisdjn/article/details/79040688">https://blog.csdn.net/xuleisdjn/article/details/79040688</a></p>
<ol start="2">
<li>C++标准库查询参考</li>
</ol>
<p>man手册：<a href="https://blog.csdn.net/u012675539/article/details/50257343">https://blog.csdn.net/u012675539/article/details/50257343</a></p>
<p>C++ 参考手册1:<a href="http://www.cplusplus.com/reference/">http://www.cplusplus.com/reference/</a></p>
<p>C++ 参考手册2: <a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5</a></p>
<ol start="3">
<li>fstream使用举例</li>
</ol>
<ul>
<li>打开/创建文件，并写入内容，保存关闭</li>
<li>打开文件，并读取内容显示，最后关闭。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        fstream fs;                <span class="comment">// 定义了一个fs对象用来做后续操作</span></span><br><span class="line">        <span class="keyword">char</span> str[] = <span class="string">&quot;i love c++&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span> rstr[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        fs.<span class="built_in">open</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fs.<span class="built_in">is_open</span>())</span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;open success&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;open fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文件写入</span></span><br><span class="line">        fs.<span class="built_in">write</span>(str, <span class="built_in"><span class="keyword">sizeof</span></span>(str));</span><br><span class="line">        fs &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文件读出</span></span><br><span class="line">        fs.<span class="built_in">read</span>(rstr, <span class="built_in"><span class="keyword">sizeof</span></span>(rstr));</span><br><span class="line">        fs &gt;&gt; rstr;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;read content: &quot;</span> &lt;&lt; rstr &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文件关闭</span></span><br><span class="line">        fs.<span class="built_in">close</span>();</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="C-字符串string类使用"><a href="#C-字符串string类使用" class="headerlink" title="C++字符串string类使用"></a>C++字符串string类使用</h3><ol>
<li><p>C++式字符串的使用</p>
<p> <a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">参考手册文档</a></p>
</li>
<li><p>C++字符串和C字符串的对比</p>
</li>
</ol>
<ul>
<li>C语言严格说没有字符串的概念，C字符串其实就是字符数组或字符指针</li>
<li>C++和之后的java等都有字符串，本质是一个class</li>
<li>C++字符串的优势是标准库自带可用于字符串的各种处理算法和方法</li>
<li>C++实际开发中建议使用C++字符串而不是沿用C式字符串</li>
</ul>
<h3 id="C与C-混合编程"><a href="#C与C-混合编程" class="headerlink" title="C与C++混合编程"></a>C与C++混合编程</h3><p>1、为什么需要混合编程</p>
<p>(1)C有很多优秀成熟项目和库，丢了可惜，重写没必要，C++程序里要调用<br>(2)庞大项目划分后一部分适合用C，一部分适合用C++<br>(3)其他情况，如项目组一部分人习惯用C，一部分习惯用C++</p>
<p>2、为什么不同语言可以混合编程</p>
<p>(1)程序编译过程：源文件-&gt;目标（库）文件-&gt;可执行程序-&gt;镜像文件<br>(2)任何编程语言执行时都必须是可执行程序，所以都必须先被编译成目标文件<br>(3)混合编程的“混合”操作发生在链接这一步</p>
<p>3、C++和C混合编程的困难所在<br>(1)C++和C都是编译型语言，互相混合相对容易<br>(2)难点：C++支持函数名重载，而C不支持，因此编译器生成目标文件时，函数名在目标文件中的临时内部名称规则不同。导致链接时符号对不上 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">C语言函数：</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_char</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">编译后生成的中间名字：</span><br><span class="line">add_int</span><br><span class="line">add_char</span><br><span class="line"></span><br><span class="line">C++函数名重载机制：</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> , b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span>, b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, flaot b)</span></span>;</span><br><span class="line"></span><br><span class="line">编译后生成的中间名字：</span><br><span class="line">addii</span><br><span class="line">addcc</span><br><span class="line">addif </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(3)解决方案：使用extern “C”{}; 让C++在对接的局部向C妥协兼容</p>
<p>4、C与C++混合编程的可能情况分析<br>(1)同一个项目C/C++全部有源码，一次编译链接。<br>(2)同一个项目中C是库，C++是源码，C++调用C<br>(3)同一个项目中C++是库，C是源码，C调用C++</p>
<p>5、第一种情况<br>(1)可能性1：全部使用g++编译。不推荐<br>(2)可能性2：在C的头文件中加extern “C”声明</p>
<p>6、第二种情况<br>(1)这种是最典型的常见情况<br>(2)通用解决方案：在C的头文件中加extern “C”声明，在C++中直接包含头文件调用即可</p>
<p>7、C调用C++的麻烦<br>(1)g++和gcc的编译时符号差异<br>(2)c++支持很多c并不支持的特性，如函数重载<br>(3)解决方案：添加一层封装层，因为此时已形成 c++的库，已按照C++的标准编译了，所以无法修改源码添加extern “C”{},所以增加一个封装层，在封装层是上使用extern “C”,封装层使用C++</p>
<h2 id="C-新增和有变化的关键字"><a href="#C-新增和有变化的关键字" class="headerlink" title="C++新增和有变化的关键字"></a>C++新增和有变化的关键字</h2><h3 id="bool关键字"><a href="#bool关键字" class="headerlink" title="bool关键字"></a>bool关键字</h3><p>1、关键字学习<br>(1)研究编程语言从关键字出发不适合学习，但是适合查漏补缺<br>(2)C++全部关键字列表查阅<br>(3)C++关键字相对C有几种情况：新增关键字、新增语义、语义变化、完全无变化<br>(4)限于面向对象和STL没学，因此本篇文章不追求全面讲解关键字，重点是从一些核心关键字出发学习C++语法特性，体会C++与C的不同，熟悉C++。</p>
<p>2、C++的bool关键字<br>(1)bool类型也叫逻辑类型，是个2值enum，值为true或false（这2个也是C++关键字）<br>(2)C语言没有bool关键字，不源生支持bool类型，一般用typedef int bool;这样来自定义<br>(3)C++语言源生支持bool类型，一般占1字节（与平台相关），用法没什么差异<br>(4)bool内建和自定义至少有一个差别：函数重载机制认为bool是不同类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">bool</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">bool</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">C中，<span class="keyword">bool</span>和<span class="keyword">int</span>是一个类型，在C++中不是</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">在C++中，虽然布尔类型只表示<span class="literal">true</span>和<span class="literal">false</span>，看起来好像可以用一个位来存储布尔类型的变量，但其实，布尔类型在C++中是占用一个字节的。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> b </span>= <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>,b);</span><br><span class="line">b++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>,b);</span><br><span class="line">b = b - <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>,b);</span><br><span class="line"></span><br><span class="line">用C++编译器编译运行后得到的是：</span><br><span class="line">b = <span class="number">0</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">从上面我们也可以看到，布尔类型作为C++中的一种基础类型，是完全可以对布尔类型进行运算的，只不过最后遵循非<span class="number">0</span>值为真，<span class="number">0</span>值为假这条规则。</span><br></pre></td></tr></table></figure>
<p><strong>summary：</strong><br>在C语言中，没有bool这种类型，但是在C++中，把bool当做一种基本的数据类型，既然是数据类型，那么久可以对bool类型的变量进行运算，只不过最后遵循非0值为真，0值为假这条规则。同时，bool类型作为一种基本的数据类型，也可以用来定义常量，全局变量，指针还有数组.</p>
<h3 id="C-的字符类型char"><a href="#C-的字符类型char" class="headerlink" title="C++的字符类型char"></a>C++的字符类型char</h3><p>1、char<br>(1)字符类型，一般占1字节，表示字符（ASCI或unicode字符）<br>(2)从C++14开始char默认是unsigned还是signed取决于目标平台，如arm默认unsigned，而X64默认是signed，建议如果在意符号最好显式使用unsigned char或signed char<br>(3)char类型cout输出默认为字符，而int类型cout输出默认为数字<br>(4)1 == sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)<br>=还是&lt;取决于具体的平台</p>
<p>2、wchar_t<br>(1)宽字符，用于应对一个字符编码超过1字节的Unicode编码<br>(2)wchar_t和char的数组都能存下unicode码，区别是需要几个单元才能存一个字符<br>(3)wchar_t占几个字节取决于具体实现（一般不会是一个字节），可能是unsigned short也可能是int<br>(4)wchar_t要用wcin和wcout来输入输出，对应字符串为wstring</p>
<p>3、指定具体字节数的字符类型<br>(1)char8_t (C++20 起) char16_t (C++11 起) char32_t (C++11 起)<br>(2)这三个类型一个套路，最大特征就是明确指定占用字节数，且都是无符号的<br>(3)char8_t很大程度上等同于unsigned char<br>(4)关于char8_t可以参考：<a href="https://stackoverflow.com/questions/57402464/is-c20-char8-t-the-same-as-our-old-char">https://stackoverflow.com/questions/57402464/is-c20-char8-t-the-same-as-our-old-char</a><br>(5)C++20起，新增字符串类u8string, u16string, u32string</p>
<h3 id="C-中无变化关键字和运算符代用关键字"><a href="#C-中无变化关键字和运算符代用关键字" class="headerlink" title="C++中无变化关键字和运算符代用关键字"></a>C++中无变化关键字和运算符代用关键字</h3><p>1、C++中无明显变化的关键字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">while</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">switch</span></span><br><span class="line"><span class="keyword">case</span></span><br><span class="line"><span class="keyword">default</span></span><br><span class="line"><span class="keyword">goto</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">unsigned</span></span><br><span class="line"><span class="keyword">signed</span></span><br><span class="line"><span class="keyword">float</span></span><br><span class="line"><span class="keyword">double</span></span><br><span class="line"><span class="keyword">short</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="keyword">long</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="keyword">sizeof</span></span><br><span class="line"><span class="keyword">register</span></span><br><span class="line"><span class="keyword">volatile</span>  <span class="comment">//volatile是一个类型修饰符（type specifier），就像我们熟悉的const一样，它是被设计用来修饰被不同线程访问和修改的变量；volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。</span></span><br><span class="line"><span class="keyword">extern</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="keyword">asm</span>（内嵌汇编）</span><br></pre></td></tr></table></figure>

<p>2、C++中新增的运算符代用关键字<br>(1)逻辑运算代用关键字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and</span>                        &amp;&amp;</span><br><span class="line"><span class="keyword">or</span>                        ||                </span><br><span class="line"><span class="keyword">not</span>                        !（逻辑取反）</span><br></pre></td></tr></table></figure>
<p>(2)位运算代用关键字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bitand</span>                &amp;</span><br><span class="line"><span class="keyword">bitor</span>                |</span><br><span class="line"><span class="keyword">xor</span>                        ^</span><br><span class="line"><span class="keyword">and_eq</span>                &amp;=</span><br><span class="line"><span class="keyword">or_eq</span>                |=</span><br><span class="line"><span class="keyword">xor_eq</span>                ^=</span><br><span class="line"><span class="keyword">compl</span>                ~（按位取反）</span><br></pre></td></tr></table></figure>
<p>(3)不等判断运算符代用关键字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">not_eq</span>                !=</span><br></pre></td></tr></table></figure>
<p>(4)运算符代用关键字的优势：有些人认为这样便于理解和阅读</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> a = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">bool</span> b = <span class="number">-1</span>;</span><br><span class="line">        string str = <span class="string">&quot;hello world, my cplusplus.&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span> c[] = <span class="string">&quot;Always try to see the best in people.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a = %d.\n&quot;</span>, a);</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; b;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(bool) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">bool</span>) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">and</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a and b are ture.\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">not</span> a);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a\n&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;not b :&quot; &lt;&lt; not b &lt;&lt; endl;</span></span><br><span class="line">         <span class="comment">//cout &lt;&lt; &quot;not a :&quot; &lt;&lt; not a &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">while</span>((<span class="keyword">not</span> a) <span class="built_in"><span class="keyword">or</span></span> (<span class="keyword">not</span> b));</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(not a) or (not b).\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a not_eq b :&quot;</span> &lt;&lt; (a <span class="keyword">not_eq</span> b) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">while</span>(a <span class="keyword">not_eq</span> b);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ending!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-新增的引用（reference）介绍"><a href="#C-新增的引用（reference）介绍" class="headerlink" title="C++新增的引用（reference）介绍"></a>C++新增的引用（reference）介绍</h3><p>1、引用介绍<br>(1)引用的经典案例：实现swap函数实战<br>(2)引用定义和识别的关键：&amp;符号，注意这里和取地址一毛钱关系都没有<br>(3)引用符号（注意我没说变量，引用相当于别名）在定义时 必须 同时初始化，以后不能再另外赋值，只能使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">4</span>, y = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b1 = x;</span><br><span class="line"><span class="comment">//定义了一个引用符号b1，与x关联,关联后只能与x相关，不可与其他变量关联了，类似于linux的软链接</span></span><br><span class="line"></span><br><span class="line">b1 = y;<span class="comment">//相当于x = y;即x = 6;</span></span><br><span class="line">错误：<span class="keyword">int</span> &amp;b1; b1 = x;<span class="comment">//错误，必须定义的同时初始化</span></span><br></pre></td></tr></table></figure>

<p>2、<strong>引用和指针的对比</strong><br>(1)指针在C和C++中都有，且使用方法和实现本质完全相同；引用只有C++可用<br>(2)引用可以理解为功能弱化、安全性增强的低配版指针<br>(3)引用能做的事指针都能做，但指针能做的事儿引用不一定能做<br>(4)引用是它指向变量的“别名”，这个是从引用的使用效果角度讲的，对熟悉指针的人反而不好理解“别名”这个词<br>(5)引用比指针弱的地方就是一个引用定义时绑定了一个变量，后面没法改了<br>(6)引用比指针强的地方也是没法改，所以不存在”野指针”问题，更安全<br>(7)引用主要用在函数传参和返回值</p>
<h3 id="引用的本质剖析"><a href="#引用的本质剖析" class="headerlink" title="引用的本质剖析"></a>引用的本质剖析</h3><p>1、引用可以加const修饰<br>(1)const int &amp;b = a; 表示b是a的const别名，无法通过b修改a了<br>(2)<strong>主要用在函数形参中，告诉大家该函数内部不会修改实参的值</strong>。用在某些时候我们有一个非const类型的变量，但是我们在某个函数调用的过程中，不希望变量的值在函数内部被修改，这时候就可以用const引用来传参。</p>
<p>2、引用和sizeof运算符<br>(1)<strong>sizeof引用得到的不是引用本身的大小，而是引用指向的目标变量的大小</strong><br>(2)在struct或class中定义一个引用，再sizeof整个struct或class就会不一样<br>在这两个里边sizeof(引用)是八个字节，加之考虑结构体对齐，就可得知sizeof的结果</p>
<p>3、<strong>引用的本质是const指针</strong><br>(1)int &amp;b = a; 类似于 int * const b = &a; // 指针本身不能被修改，但是指针指向的内容是可修改的<br>(2)C++标准并没有规定引用是否占用内存空间，但是大多数编译器都把引用实现为const指针，所以大部分编译器中引用也是要占内存空间的<br>(3)<strong>引用是天然const的，所以定义时必须初始化指向变量，否则就没意义了（const修饰之后不可修改）</strong><br>(4)<strong>引用本质是指针，是地址，所以才能实现传址调用的效果</strong></p>
<p>总结：引用就是指针在定义时增加了把指针变量本身const化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *pa, <span class="keyword">int</span> *pb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap3</span><span class="params">(<span class="keyword">int</span> &amp;pa, <span class="keyword">int</span> &amp;pb)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *pa, <span class="keyword">int</span> *pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        temp = *pa;</span><br><span class="line">        *pa = *pb;</span><br><span class="line">        *pb = temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap3</span><span class="params">(<span class="keyword">int</span> &amp;pa, <span class="keyword">int</span> &amp;pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        temp = pa;</span><br><span class="line">        pa = pb;</span><br><span class="line">        pb = temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">test1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">int</span> &amp;a1 = a;         </span><br><span class="line">&#125;mytest1; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">test2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="keyword">char</span> &amp;b1 = b;</span><br><span class="line">        </span><br><span class="line">&#125;mytest2; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0        </span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">3</span>, y = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> &amp;x1 = x, &amp;y1 = y; </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">swap1</span>(x, y);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">swap2</span>(&amp;x, &amp;y);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">swap3</span>(x1, y1);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> z = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">1.11</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> &amp;t1 =t;   </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> &amp;z1 = z;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">double</span> &amp;d1 = d;</span><br><span class="line">                </span><br><span class="line">        <span class="comment">//t1 = 5;//error,不允许被修改</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(t1)&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(t1) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(z1)&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(z1) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(d1)&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(d1) &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//因为引用本质上相当于一个指针，在64为系统上为8字节，加之结构体对齐访问</span></span><br><span class="line">        <span class="comment">//故为两个结构体的大小均为16字节                                                                                </span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(mytest1)&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(mytest1) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(mytest2)&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(mytest2) &lt;&lt; endl;        </span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-的enum枚举"><a href="#C-的enum枚举" class="headerlink" title="C++的enum枚举"></a>C++的enum枚举</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C和C++98等老版本里的写法</span></span><br><span class="line"><span class="comment">//enum day &#123;MON, THU, WEN&#125;;</span></span><br><span class="line"><span class="comment">//enum day2 &#123;MON, xxxx, yyy&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define MON &quot;55&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C中习惯用typedef来重命名类型以避免每次类型使用都加enum</span></span><br><span class="line"><span class="comment">//typedef enum &#123;MON, xxx, xx&#125; day;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">day</span> <span class="title">d1</span>;</span>                <span class="comment">// 定义了一个day类型的变量，变量名是d1</span></span><br><span class="line">        day d1;             <span class="comment">// C++中定义时可以省掉前面的enum</span></span><br></pre></td></tr></table></figure>
<p>1、C++继承C的枚举用法<br>(1)典型枚举类型定义，枚举变量定义和使用<br>(2)枚举类型中的枚举值常量不能和其他外部常量名称冲突：举例1宏定义，举例2另一个枚举<br>即使枚举数据类型中的值实际存储为整数，也不能总是将整数值替换为符号名称。例如，不能使用下面的语句将数值赋值给 student，student是一个枚举变量： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">student = <span class="number">1</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<p>但是，可以使用整数值而不是符号名称来测试枚举变量。例如，以下两个 if 语句是等效的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (student == Bill)</span><br><span class="line"><span class="keyword">if</span> (student == <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>2、C++11中扩展的枚举<br>(1)enum class enumType:valueType{one=xx, two, three};<br>对于其的预处理，会将其变成一个：定义一个命名空间，在其中定义一个枚举<br>(2)两种简写,eg:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">day</span>:</span><span class="keyword">unsigned</span> <span class="keyword">int</span>&#123;MON = <span class="number">44</span>, THU, WEN&#125;;</span><br><span class="line"><span class="comment">// 简化写法1</span></span><br><span class="line"><span class="comment">//enum class day&#123;MON, THU, WEN&#125;;</span></span><br><span class="line"><span class="comment">// 简化写法2</span></span><br><span class="line"><span class="comment">//enum day&#123;MON, THU, WEN&#125;;</span></span><br></pre></td></tr></table></figure>
<p>(3)解决2个枚举中的重名问题（不同的命名空间，互不影响），但是宏定义仍然不能重名</p>
<p>3、关于枚举的3个小细节<br>iostream中的输入输出流不接受枚举类型，必须进行强制类型转换。无法通过隐式转换，必须通过显示转换。C++/C都是强制类型转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">d1 = day::MON;</span><br><span class="line">cout &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)d1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>(1)枚举类型和值类型的互相转换，枚举类型不可以使用++，只能间接使用，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">d1 = (day)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)d1 + <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>(2)枚举类型的前置声明，有时使用在定义之前，所以必须要有 前置声明<br>eg:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">day</span>;</span><span class="comment">//只声明了day是一个enum变量，但不知道其内有哪些成员。使用其中的成员时仍会报错。</span></span><br></pre></td></tr></table></figure>
<p>(3)枚举类型超出范围访问是否会编译时或运行时报错，不会:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译时：g++ enum.cpp -std=c++11，低版本的并不支持某些语法格式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C语言所支持的语法</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">day1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        MON,</span><br><span class="line">        THU,</span><br><span class="line">        WEN</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">//C++所支持的语法</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">day2</span>:</span><span class="keyword">unsigned</span> <span class="keyword">int</span> &#123;</span><br><span class="line">        MON = <span class="number">44</span>,</span><br><span class="line">        THU = <span class="number">55</span>,</span><br><span class="line">        WEN        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 1</span></span><br><span class="line">        <span class="comment">//简化写法1</span></span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">day2</span>&#123;</span>MON, THU, WEN&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 0</span></span><br><span class="line">        <span class="comment">//简化写法2</span></span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">day2</span>&#123;</span>MON, THU, WEN&#125;;<span class="comment">//这种形式下不论使用C还是C++的风格都可以实习其中元素的访问</span></span><br><span class="line">                                                         <span class="comment">//但是使用这种方式会与day1冲突，其内的成员名一样，而使用前两种</span></span><br><span class="line">                                                         <span class="comment">//在一个命名空间中则不会产生干扰</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>        </span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">day1</span> <span class="title">day_c</span>;</span></span><br><span class="line">        day2 day_cplus;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"><span class="comment">//适用于C的语法        </span></span><br><span class="line">        day_c = MON;</span><br><span class="line">        cout &lt;&lt; day_c &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (day_c <span class="keyword">not_eq</span> THU)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//适用于C++的语法        </span></span><br><span class="line">        day_cplus = day2::MON;</span><br><span class="line">        cout &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)day_cplus &lt;&lt; endl;<span class="comment">//iostream中的输入输出流不接受枚举类型，必须进行强制类型转换。</span></span><br><span class="line">        day_cplus = day2::WEN;</span><br><span class="line">        cout &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)day_cplus &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (day2::MON <span class="keyword">not_eq</span> day2::WEN)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;very good.&quot;</span> &lt;&lt; endl; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//枚举类型不可直接使用++,枚举类型超出范围访问是否会编译时或运行时报错，不会</span></span><br><span class="line">        day_cplus = (day2)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)day_cplus + <span class="number">55</span>);</span><br><span class="line">        cout &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)day_cplus &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-的共用体union"><a href="#C-的共用体union" class="headerlink" title="C++的共用体union"></a>C++的共用体union</h3><p>1、C语言中union回顾<br>(1)union翻译成共用体更合适，而不是联合、联合体<br>(2)union中所有成员是多选一的关系，这是union和struct的最大差别<br>(3) 面试笔试常考，必须掌握</p>
<p>2、C++中union和C中不同<br>(1)C++中union类型定义后使用时可以省去union（和上节enum时一样）<br>(2)C++中union里成员除了普通的，还可以是对象，但是对象不能包含自定义构造函数、析构函数，简单说就是不能太复杂<br>(3)C++中经常用到匿名union，一般是内置在class内部做成员变量</p>
<p>3、总结</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//union在C++中没有突出变化，主要还是沿用C中使用</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">myu</span>                        // <span class="title">union</span>类型的定义</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">char</span> *p;</span><br><span class="line">        <span class="built_in"><span class="keyword">void</span></span> (*p1)(<span class="keyword">int</span>);                </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">p1</span>();                                <span class="comment">// 通过p1函数指针来调用函数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">myu</span> <span class="title">m1</span>;</span>                <span class="comment">// C中定义了一个myu类型的变量</span></span><br><span class="line">myu m1;                                <span class="comment">// C++中定义了一个myu类型的变量</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> //没有名字，节省了符号表  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">char</span> *p1;</span><br><span class="line">        <span class="keyword">int</span> *p2;</span><br><span class="line">&#125;m1;                                <span class="comment">// 直接定义了union变量m1</span></span><br></pre></td></tr></table></figure>

<h3 id="inline关键字"><a href="#inline关键字" class="headerlink" title="inline关键字"></a>inline关键字</h3><p>1、C中inline使用关键点强调<br>(1)inline是一种“用于实现的关键字”，而不是一种“用于声明的关键字”，所以关键字 inline 必须与函数定义体放在一起，而不是和声明放在一起<br>(2)如果希望在多个c文件中使用，则inline函数应该定义在h文件中（不需要额外声明）；如果只在一个c文件中使用，则inline函数可以定义在c文件或h文件中（<strong>若定义在c文件时可以声明到h文件中去，声明时可以不加inline</strong>）<br>(3)inline函数在项目中可以多次定义，只要函数体完全相同且在一个c文件范围只定义一次inline函数必须在调用该函数的每个文本文件中定义。当然，对于同一程序的不同文件，如果inline函数出现的话，其定义必须相同。<br>(4)<strong>inline只是一种对编译器的建议而不是强制，所以inline函数不一定真被inline</strong><br>(5)递归函数不应该被声明为inline(递归函数本身被多调用可能会出问题，比如不当inline处理,而且代码量可能太多使得很乱)，超过一定长度（通常是10行）的函数不应该被inline，内含循环的函数不建议被inline<br>(6)<strong>以 inline 修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升程序运行的效率。</strong></p>
<p>2、C++中inline新增的特性<br>(1)<strong>定义在类声明之中的成员函数将自动地成为内联函数</strong>，例如如下代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; ... &#125;   <span class="comment">// 自动地成为内联函数，即使没有inline关键字 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)<strong>如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上 inline，否则就认为不是内联的。</strong>值得注意的是：如果在类体外定义inline函数，则心须将类定义和成员函数的定义都放在同一个头文件中，否则编译时无法进行置换。</p>
<h3 id="C-11引入的nullptr"><a href="#C-11引入的nullptr" class="headerlink" title="C++11引入的nullptr"></a>C++11引入的nullptr</h3><p>1、C语言中的NULL<br>(1)NULL用来标记野指针<br>(2)NULL在C和C++中的定义为什么不同？因为C++不允许void *隐式转为int *等类型<br>(3)C++中也可以继续用NULL，但是因为函数重载的引入，NULL传参会带来歧义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C语言中NULL就是(void *)0</span></span><br><span class="line"><span class="comment">// C++语言中NULL就是0</span></span><br><span class="line"></span><br><span class="line">C++中：</span><br><span class="line"><span class="keyword">int</span> *p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">可以编译通过，因为C++编译器会进行隐式类型转换</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!p)<span class="comment">//判断指针是否为空</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> != p)<span class="comment">//判断指针是否为空</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//指针解引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func int a&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func char *p&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func int *p&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="literal">NULL</span>);<span class="literal">NULL</span>在这存在歧义，使得不知道调用那个函数，是<span class="number">0</span>还是隐式转换（<span class="keyword">int</span> *p = <span class="literal">NULL</span>;）</span><br></pre></td></tr></table></figure>

<p>2、nullptr如何工作<br>(1)<strong>nullptr传参，表示真正的空指针,NULL是个宏定义，而nullptr是个关键字</strong><br>(2)<strong>nullptr的本质是一个const类型的对象</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">class</span> <span class="title">nullptr_t</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="keyword">inline</span> <span class="keyword">operator</span> T*()<span class="keyword">const</span> &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">C</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="keyword">inline</span> <span class="keyword">operator</span> T C::*() <span class="keyword">const</span> &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">operator</span>&amp;() <span class="keyword">const</span>;</span><br><span class="line">&#125; <span class="literal">nullptr</span>=&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>3、nullptr的评价<br>NULL本质是一个数字0，而nullptr本质是一个指针类型 nullptr就是一个可以绕过C++严格的类型检查的NULL，就是因为C++不允许int *p = (void *)0这样，所以才有了nullptr；<br>(1)C++11开始可用，注意版本要求<br>(2)实践中在判断野指针时很多人还是喜欢if (!p)这样•••（因为许多人有C的开发经验，习惯了，并且C++又支持了这种写法）<br>(3)nullptr无法解决char *p和int *p这样的传参重载问题，所以还是有点不完美<br>(4)nullptr不属于任何一种对象指针，但是却可以表示任何类型的空指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is int&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is int *&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">char</span> p = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> *q = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">char</span> *b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!q <span class="keyword">and</span> !b)</span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;these pointers are clear.&lt;1&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (q == <span class="literal">nullptr</span> <span class="keyword">and</span> b == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;these pointers are clear.&lt;2&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;NULL = 0&quot;</span> &lt;&lt; endl;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;NULL = (void *)0&quot;</span> &lt;&lt; endl;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">func</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">func1</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">func1</span>(<span class="literal">nullptr</span>);</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用静态断言"><a href="#使用静态断言" class="headerlink" title="使用静态断言"></a>使用静态断言</h3><p>1、C中的断言assert<br>(1)直接参考：<a href="https://www.cnblogs.com/lvchaoshun/p/7816288.html">https://www.cnblogs.com/lvchaoshun/p/7816288.html</a><br>assert宏的原型定义在&lt;assert.h&gt;中，其作用是如果它的条件返回错误，则终止程序执行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">原型定义：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert</span><span class="params">( <span class="keyword">int</span> expression )</span></span>;</span><br><span class="line"><span class="comment">// assert的作用是先计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">FILE *fp;</span><br><span class="line">fp = <span class="built_in">fopen</span>( <span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span> );<span class="comment">//以可写的方式打开一个文件，如果不存在就创建一个同名文件</span></span><br><span class="line"><span class="built_in">assert</span>( fp );<span class="comment">//所以这里不会出错</span></span><br><span class="line"><span class="built_in">fclose</span>( fp );</span><br></pre></td></tr></table></figure>
<p>(2)C的assert是运行时检测发现错误，而不是编译时<br>已放弃使用assert()的原因是，频繁的调用会极大的影响程序的性能，增加额外的开销。在调试结束后，可以通过在包含#include &lt;assert.h&gt;的语句之前插入 #define NDEBUG 来禁用assert调用，示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>(3)C在编译时 错误用#error来输出</p>
<p>2、C++静态断言<br>(1)C++引入static_assert(表达式, “提示字符串”)来实现编译时的静态断言<br>(2)实例演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in"><span class="keyword">static_assert</span></span>(<span class="number">6</span>==<span class="number">6</span>, <span class="string">&quot;6==6 error&quot;</span>);</span><br><span class="line">        <span class="comment">//static_assert(5==6, &quot;5==6 error&quot;);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、静态断言主要用途<br>(1)static_assert主要用于检查模板参数是否符合期望<br>(2)C++20中引入了concept来进一步更好的实现模板参数的编译时类型匹配检查</p>
<h3 id="C-内存对齐"><a href="#C-内存对齐" class="headerlink" title="C++内存对齐"></a>C++内存对齐</h3><p>1、C语言中内存对齐关键点<br>(1)#pragma 和 attribute((packed)) attribute((aligned(n)))<br>(2)__attribute__是GUN C中极具特设的一大机制，可以用来设置<br>函数属性(Function Attribute)<br>变量属性(Variable Attribute)<br>类型属性(Type Attribute)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">attribute</span>((<span class="built_in">aligned</span>(n)))  <span class="comment">//采用n字节对齐</span></span><br><span class="line"><span class="built_in">attribute</span>((packed))      <span class="comment">//采用1字节对齐</span></span><br></pre></td></tr></table></figure>
<p>attribute((aligned(n)))中，n的有效参数为2的幂值，32位最大为2^32,<br>64位为2^64，这个时候编译器会将让n与默认的对齐字节数进行比较，取较大值为对齐字节数，与#pragma pack(n)恰好相反。</p>
<p>attribute((packed))则为取消结构在编译过程中的优化对齐,按照实际占用字节数进行对齐，也就是采用1字节对齐。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************************使用格式*******************************************/</span></span><br><span class="line"><span class="comment">/*定义结构体时不对类型重命名*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mystruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*成员变量定义*/</span></span><br><span class="line">&#125;__attribute__() <span class="comment">/*(可同时在这定义变量)*/</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>() <span class="title">mystruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*成员变量定义*/</span></span><br><span class="line">&#125;<span class="comment">/*(可同时在这定义变量)*/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义结构体同时对类型进行重命名*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mystruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*成员变量定义*/</span></span><br><span class="line">&#125;__attribute__() MS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>() <span class="title">mystruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*成员变量定义*/</span></span><br><span class="line">&#125;MS;</span><br><span class="line"><span class="comment">/*************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(n) <span class="comment">//作用：C编译器将对以下的结构体按照n个字节对齐。</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义结构体类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack() <span class="comment">//作用：取消自定义字节对齐方式。</span></span></span><br><span class="line"></span><br><span class="line">其中<span class="meta">#<span class="meta-keyword">pragma</span> pack(n)中，n的有效参数为1/2/4/8/16，</span></span><br><span class="line">这个时候编译器会将让n与默认的对齐字节数进行比较，取较小值为对齐字节数。</span><br><span class="line"></span><br><span class="line">在<span class="number">64</span>位操作系统<span class="number">64</span>位编译器的环境下，当n ≥ <span class="number">8</span>时，内存对齐的字节数是<span class="number">8</span>，不然为n</span><br><span class="line">在<span class="number">32</span>位操作系统<span class="number">32</span>位编译器的环境下，当n ≥ <span class="number">4</span>时，内存对齐的字节数是<span class="number">4</span>，不然为n</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push,n)与#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push,n) <span class="comment">//作用：把原来对齐方式设置压栈，并设新的对齐字节为n的对齐方式</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义结构体类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)     <span class="comment">//作用：恢复原来压栈的对齐方式。</span></span></span><br></pre></td></tr></table></figure>
<p>在指令#pragma pack(push,n)里n的一切效果和#pragma pack(n)中是一样的，这里不再赘述。<br>这个指令的优越性在于：他设置新的对齐方式时，会将原来的对齐方式(假设是M)进行压栈保存下来。待#pragma pack(pop)解除#pragma pack(push,n)的作用时，将会对原来的对齐方式进行弹栈恢复，执行之后结构体的对齐方式又变回了M而不是编译器默认的。 </p>
<p>2、C++中内存对齐新增关键字<br>(1)alignof (C++11 起)<br>alignof用来测定变量或者类型的字节对齐数<br>(2)alignas (C++11 起)<br>alianas用来往大改变字节对齐，使用方法类似__attribute__((aligned(n)))</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mystruct1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="keyword">double</span> c;</span><br><span class="line">&#125;__attribute__((packed)) s1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mystruct2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="keyword">double</span> c;</span><br><span class="line">&#125;__attribute__((<span class="built_in">aligned</span>(<span class="number">8</span>))) s2;</span><br><span class="line"></span><br><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">32</span>)</span> mystruct3</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="keyword">double</span> c;</span><br><span class="line">&#125;s3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(char)&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(int)&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(double)&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>) &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;alignof(s1) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">alignof</span></span>(s1) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(s1) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;alignof(s2) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">alignof</span></span>(s2) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(s2) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s2) &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;alignof(s3) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">alignof</span></span>(s3) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(s3) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s3) &lt;&lt; endl;                </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、什么情况下需要人为改变/指定对齐方式<br>(1)往大去对齐。有时候会有一些硬件特殊要求，譬如MMU，cache等。用__attribute__((aligned(n)))实测ok，用#pragma实测不ok<br>(2)往小去对齐。有时候需要节省内存而浪费效率，所以希望忽略内存对齐，紧密排放。用#pramgma实测ok，用__attribute__((aligned(n)))实测不ok </p>
<h3 id="alignas和typeid"><a href="#alignas和typeid" class="headerlink" title="alignas和typeid"></a>alignas和typeid</h3><p>1、alignas的用法补讲<br>(1)使用方法：一般在类型定义时，放在名称前<br>具体用法参考cppreference：<a href="https://zh.cppreference.com/w/cpp/language/alignas">https://zh.cppreference.com/w/cpp/language/alignas</a><br>(2)效果：和__attribute__((aligned(n)))</p>
<p>2、typeid<br>(1)typeid是一个运算符，类似于sizeof<br>(2)typeid定义在头文件typeinfo中，必须包含该头文件<br>(3)typeid用来返回一个变量（表达式）（对象）的类型，类似于C语言中的：typeof() 是GUN C提供的一种特性，它可以取得变量的类型，或者表达式的类型。<br>(4)typeid使用实战 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">        cout &lt;&lt; <span class="string">&quot;a type = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(a).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        int a;                // int类型的type.name是                &quot;i&quot;</span></span><br><span class="line"><span class="comment">//        char a;                // char类型的type.name是        &quot;c&quot;</span></span><br><span class="line"><span class="comment">//        unsigned char a;        // unsigned char类型的type.name是        &quot;h&quot;</span></span><br><span class="line">        <span class="keyword">signed</span> <span class="keyword">char</span> a;                <span class="comment">//  signed char类型的type.name是        &quot;a&quot;</span></span><br></pre></td></tr></table></figure>


<p>3、typeid的深层次说明<br>(1)一个表达式的类型分静态类型（在编译的时候就可以确定类型）和动态类型（在运行的时候才可以确定类型，如C中的void *），分别对应编译期 和 运行时类型决策系统<br>(2)<strong>typeid可用来返回静态类型，也可用来返回动态类型</strong><br>(3)typeid是C++语言本身的特性，由编译器和库函数共同支撑<br>(4)typeid真正大用在引入class和继承后，并结合指针和引用后才能显现出来 </p>
<h3 id="C-的4种cast转换"><a href="#C-的4种cast转换" class="headerlink" title="C++的4种cast转换"></a>C++的4种cast转换</h3><p>1、static_cast</p>
<p>(1)源生类型之间的隐式类型转换，避免警告，转换后可能丢失精度，正确性需要程序员自己保证</p>
<p>(2)<strong>用来将void *p转为具体的指针类型，取回原有的指针类型</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">void</span> *p1 = p;                <span class="comment">// p1已经丢掉了自己的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(p1);                <span class="comment">// p2又取回了自己的类型</span></span><br><span class="line"><span class="keyword">int</span> *p3 = (<span class="keyword">int</span> *)p1;</span><br><span class="line"><span class="keyword">char</span> *p4 = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span> *&gt;(p1);</span><br></pre></td></tr></table></figure>
<p>(3)用于类层次结构中父类和子类之间指针和引用的转换。其中上行转换时安全的，而下行转换时不安全的。<br>(4)总结：<strong>static_cast&lt;&gt;()是编译时静态类型检查，使用static_cast可以尽量发挥编译器的静态类型检查功能，但是并不能保证代码一定“正确”</strong>（譬如可能会丢失精度导致错误，可能经过void *之后导致指针类型错误，可能下行转换导致访问错误。） </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5444</span>;</span><br><span class="line">        <span class="keyword">char</span> c = a;                        </span><br><span class="line">        <span class="keyword">char</span> c = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(a);<span class="comment">// 有可能有错误</span></span><br></pre></td></tr></table></figure>
<p>(5)评价：static_cast必须会用，见了必须认识，能理解使用static_cast的意义，但是实际上只能解决很初级的编程问题，属于初级语法特性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">C++中：</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> *p5 = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span> *&gt;(p);         <span class="comment">// 编译器报错</span></span><br><span class="line">        <span class="keyword">char</span> *p6 = (<span class="keyword">char</span> *)p;                      <span class="comment">// OK的</span></span><br><span class="line">        <span class="keyword">char</span> *p5 = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span> *&gt;(p);    <span class="comment">//可以的</span></span><br><span class="line">        </span><br><span class="line">而C中：</span><br><span class="line">        <span class="keyword">char</span> *p6 = (<span class="keyword">char</span> *)p;<span class="comment">//也是可以的</span></span><br></pre></td></tr></table></figure>

<p>2、reinterpret_cast<br>(1)<strong>用于明确告知编译器该类型转换在编译时放行</strong>，正确性由程序员自己负责<br>(2)reintepret_cast转换前后对象的二进制未发生任何变化，只是对这些二进制位的编译器类型标识发生了变化，或者说是编译器看待这些二进制位的结论不同了<br>(3)reintepret_cast一般用于将指针转成int或者回转，将A类型指针转为B类型指针等</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 把一个16写入内存地址为0x530000e0的寄存器中</span></span><br><span class="line"><span class="comment">unsigned int *p = (unsigned int *)(0x530000e0);</span></span><br><span class="line"><span class="comment">*p = 16;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span> *&gt;(<span class="number">0x530000e0</span>); </span><br></pre></td></tr></table></figure>
<p>(4)<strong>reintepret_cast其实就是让C++在本次转换中放弃严苛的编译器类型检查</strong></p>
<p>3、const_cast<br>(1)<strong>用来修改类型的const或volatile属性</strong><br>(2)格式为：const_cast&lt;type_id&gt; (expression)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">a = <span class="number">6</span>;                             <span class="comment">// 编译报错，因为a是const类型所以编译器发现操作非法</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)&amp;a;                <span class="comment">// 老式转换可以，但是不推荐</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(&amp;a);    <span class="comment">// 新式写法，推荐</span></span><br><span class="line">*p = <span class="number">14</span>;</span><br></pre></td></tr></table></figure>
<p>(3)思考：const_cast为什么能修改const为非const？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *p1, <span class="keyword">const</span> <span class="keyword">char</span> *p2)</span></span>;</span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">&quot;dfdfdf&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *pa = &amp;a;</span><br><span class="line"><span class="built_in">strcmp</span>(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(pa), <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(pb));</span><br></pre></td></tr></table></figure>

<p>4、dynamic_cast<br>(1)<strong>只用在父子class的指针和引用访问时的转换中，尤其是下行转换时</strong><br>(2)属于一种运行时转换机制，运行时才能知道转换结果是NULL还是有效对象<br>(3)运行时确定对象类型RTTI（run time type indentification）是一种需求，C++有一套机制来实现 </p>
<p>5、4种cast转换总结<br><strong>前三种都是在编译时起作用的，最后一种dynamic_cast是在运行时起作用的</strong>。<br>(1)C中一般都用隐式转换或强制类型转换解决，本质上是一种一刀切方案，全靠程序员自己把控<br>(2)C++中4种cast转换实际上是细分了具体场景，让程序员在具体情况下显式的使用相应的cast来转换，让编译器和运行时尽可能帮程序员把关。 </p>
<h3 id="C-的自动类型推导"><a href="#C-的自动类型推导" class="headerlink" title="C++的自动类型推导"></a>C++的自动类型推导</h3><p>1、auto关键字<br>(1)auto在C中修饰局部变量，可以省略，完全无用。C++中的auto完全是一个新关键字<br>(2)auto要求至少不低于C++11标准来支撑<br>(3)<strong>auto在编译器由编译器帮我们自动推导出变量（对象）类型</strong>，所以定义时必须初始化右边右值的类型，自动推导出左值的类型。<br>(4)<strong>auto可以一次定义多个同类型的变量，但是不能一次定义多个类型不同的变量，这是auto的类型推导机制决定的</strong>。</p>
<p>2、decltype关键字<br>(1)C++11新增关键字<br>(2)<strong>decltype可以让编译器推导目标表达式的类型作为一种类型符使用</strong><br>(3)decltype(表达式)作为类型定义变量不要求初始化</p>
<p>3、auto和decltype的对比<br>(1)auto忽略顶层const，而decltype则保 留const<br>(2)auto作为类型占用符，而decltype用法类似于sizeof运算符<br>(3)对引用操作，auto推断出原有类型，decltype推断出引用<br>(4)对解引用操作，auto推断出原有类型，decltype推断出引用<br>(5)auto推断时会实际执行，decltype不会执行，只做分析。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">pf</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">decltype</span>(func) a;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in"><span class="keyword">typeid</span></span>(a) == <span class="built_in"><span class="keyword">typeid</span></span>(pf))</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;haha&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;typeid(a) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(a).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">decltype</span>(i) j = <span class="number">8</span>;</span><br><span class="line">        <span class="comment">// j = 9;         //编译报错，因为j是const的</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;typeid(j) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(j).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">auto</span> j = i;</span><br><span class="line">        j = <span class="number">4</span>;                         <span class="comment">// 正确， 因为auto会忽略顶层const</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;typeid(j) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(j).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">decltype</span>(i) j;                <span class="comment">// 定义了变量j，类型是和i相同</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;typeid(j) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(j).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">auto</span> i1 = <span class="number">5</span>;                        <span class="comment">// 编译器在编译时自动帮我们推导出i1的类型是int</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="keyword">auto</span> a1 = <span class="number">4</span>, b1 = <span class="number">5</span>;              <span class="comment">// 正确</span></span><br><span class="line">        <span class="comment">// auto a = 4, b = 5.5;           // 错误, auto可以一次定义多个同类型的变量，但是不能一次定义多个类型不同的变量</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;typeid(i) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(a1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-类与面向对象"><a href="#C-类与面向对象" class="headerlink" title="C++类与面向对象"></a>C++类与面向对象</h3><p>1、struct和class<br>(1)struct是C中用户自定义类型，主要功能是对功能相关数据的封装<br>(2)struct不能直接封装函数，但可以通过封装函数指针来间接封装函数<br>(3)struct就是class的初级阶段，class在struct基础上做了很多扩展，便有了面向对象</p>
<p>2、访问权限<br>(1)类是对数据（成员变量）和方法（成员函数）的封装<br>(2)封装的一个重要特征就是访问权限管控，本质是为了隐藏实现细节，避免意外篡改,而<strong>struct没有访问权限管控，其内的成员都可任意访问</strong>。<br>(3)C++支持三个访问管控级别：private、protected、public</p>
<p>3、C++的对象创建和销毁<br>(1)对象的本质等同于C中的变量，对象的创建和销毁也就是变量的产生和销毁，本质上是变量对应的内存地址的分配和释放归还<br>(2)C中全局变量和局部变量都是自动分配和回收内存的，堆内存需要用户手工申请和释放（malloc和free调用）<br>(3)C++中因为变量升级成了对象，涉及到构造函数和析构函数，因此malloc和free升级为了new和delete<br>(4)C++中仍然大量使用全局变量和局部变量，但是动态分配占比例越来越多。这是业务（完成的任务）特点决定的，不是C++语言决定的。语言只是提供机制，业务才决定策略。</p>
<p>c：偏控制，体量偏小<br>c++：偏大，数据结构较复杂，动态性较大</p>
<h3 id="C-中static和this关键字"><a href="#C-中static和this关键字" class="headerlink" title="C++中static和this关键字"></a>C++中static和this关键字</h3><p>1、C语言中的static<br>(1)静态全局变量和函数，限制链接属性。C++中建议优先使用命名空间机制替代<br>(2)静态局部变量，更改地址域和生命周期。C++中继续沿用。</p>
<p>2、static在C++中新增用法<br>(1)用在class中，有静态数据成员和静态成员函数<br>(2)简单理解：<strong>静态成员和方法是属于class的，而非静态是属于对象的</strong><br>(3)静态类往往用在单例模式中，实际上和面向对象的思想有所差异<br>(4)要真正理解静态类，得先学习面向对象和普通非静态类后才可以</p>
<p>3、this关键字<br>(1)<strong>本质是个指针，指向当前对象</strong>(编译器在编译时帮我们加入到class内部的)<br>(2)this的主要作用是让我们在未定义对象前可以在方法（函数）中调用对象里的成员</p>
<h3 id="C-面向对象的其他关键字"><a href="#C-面向对象的其他关键字" class="headerlink" title="C++面向对象的其他关键字"></a>C++面向对象的其他关键字</h3><p>1、面向对象允许类的继承机制<br>(1)C++中用” : “来表示继承关系，有些编程语言有extends关键字表示继承关系<br>(2)virtual修饰class的成员函数为虚函数，一般在基类中，只有接口声明没有实体定义<br>(3)基类的virtual成员可以在派生类中override重写，以实现面向对象的多态特性<br>(4)注意区分重写override与重载overload<br>(5)override关键字是C++11引入，用来在派生类中成员函数声明时明确表明需要派生类去重写的那些成员方法，这样如果程序员在成员方法实体定义中做的不对编译器可以报错提醒 </p>
<p>2、继承的终止final<br>(1)<strong>一个class不希望被继承（不想做父类），可以定义时用final修饰</strong><br>(2)<strong>一个成员方法不希望被子类override，可以声明时用final修饰</strong><br>(3)final是C++11引入的<br>(4)很多其他面向对象语言如java中也有final关键字，也是这个作用 </p>
<p>3、using关键字<br>(1)用法1就是using namespace std;这种<br>(2)用法2与class的继承和访问权限限制有关，属于一个声明，<strong>能够让private继承的子类去声明并访问父类中本来无权限访问的成员</strong></p>
<p>4、operator<br>(1)用于运算符重载，也就是为一个class重定义某种运算符</p>
<p>5、friend<br>(1)让不属于一个class的外部函数也能访问class内受保护的成员变量<br>(2)实际上是对面向对象的一种扩展或者说破坏，在面向对象深入理解之后再来学习更好</p>
<p>6、explicit<br>(1)本意为显式的，对应implicit隐式的<br>(2)用来修饰只有一个参数的构造函数，以阻止构造函数不合时宜的类型转换</p>
<h3 id="C-的const关键字以及const有关的其他几个关键字"><a href="#C-的const关键字以及const有关的其他几个关键字" class="headerlink" title="C++的const关键字以及const有关的其他几个关键字"></a>C++的const关键字以及const有关的其他几个关键字</h3><p>1、C语言中const用法回顾<br>(1)const变量，比宏定义的优势是带数据类型，可以让编译器帮我们做类型检查，二者修饰的东西都不可更改<br>(2)const数组，和常量变量类似<br>(3)const指针，三种情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p,             <span class="comment">// p 指针指向的内容不可修改，就是 *p 不可改  </span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p,            <span class="comment">// p 指针本身不可修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p;    <span class="comment">// p 指针和 p指针指向的内容均不可修改</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *pa)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 调用时，int i;                </span></span></span><br><span class="line"><span class="function"><span class="title">func1</span><span class="params">(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span> *&gt;(&amp;i))</span></span>;</span><br></pre></td></tr></table></figure>
<p>2、C++中const新增用法<br>(1)<strong>const引用，主要用于函数传参，限制函数内部对实参进行修改</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a)</span></span></span><br></pre></td></tr></table></figure>
<p>(2)const成员函数，限制函数内部对类的成员变量的修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">func6</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">func8</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span>;          <span class="comment">// 这样写，隐含意思就是func8内部很有可能会修改传参a的值</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">func9</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a)</span></span>;    <span class="comment">// 这样写，隐含意思就是func9内部不会改变a的值</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">func10</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span></span>;    <span class="comment">// const成员，明确告知func10内部不会修改class A</span></span><br><span class="line">                                    <span class="comment">// 的成员变量的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3、mutable<br>(1)mutable用来突破const成员函数的限制，让其可以修改特定的成员变量<br>在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。<br>(2)案例参考：<a href="https://www.cnblogs.com/yongdaimi/p/9565996.html">https://www.cnblogs.com/yongdaimi/p/9565996.html</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">/*调用方法*/</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCallingTimes</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">/*获取上面的getAge方法被调用了多少次*/</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">char</span> *name;</span><br><span class="line">        <span class="keyword">float</span> score;</span><br><span class="line">        <span class="keyword">mutable</span> <span class="keyword">int</span> m_nums;<span class="comment">/*用于统计次数*/</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Person::getAge</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Calling the method&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_nums++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Person::getCallingTimes</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        Person *person = <span class="keyword">new</span> <span class="built_in">Person</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        </span><br><span class="line">                person-&gt;<span class="built_in">getAge</span>();</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;getAge方法被调用了&quot;</span> &lt;&lt; person-&gt;<span class="built_in">getCallingTimes</span>() &lt;&lt; <span class="string">&quot;次&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> person;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、constexpr<br>(1)用法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">multiply</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="built_in">multiply</span>( <span class="number">10</span>, <span class="number">10</span> );                <span class="comment">// 将在编译时计算</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">100</span>;<span class="comment">//效果与上边的相同</span></span><br></pre></td></tr></table></figure>
<p>(2)<strong>本质上是让程序利用编译时的计算能力，增加运行时效率</strong>，<br><strong>inline也可提高运行时的效率</strong><br>(3)由C++11引入，但是实际有一些编译器并不支持，需实际测试</p>
<p>5、C++20新引入的2个<br>(1)constinit <a href="https://zh.cppreference.com/w/cpp/language/constinit">https://zh.cppreference.com/w/cpp/language/constinit</a><br>(2)consteval <a href="https://zh.cppreference.com/w/cpp/language/consteval">https://zh.cppreference.com/w/cpp/language/consteval</a></p>
<h3 id="模板编程的几个关键字"><a href="#模板编程的几个关键字" class="headerlink" title="模板编程的几个关键字"></a>模板编程的几个关键字</h3><p>1、模(mu)板编程初体验(结合自己所写的程序便于理解)<br>(1)template和typename<br>(2)模板实际上是一种抽象，C++的高级编程特性就是不断向抽象化发展</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span><span class="comment">//T就被当作这个模板的泛型数据类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、export<br>(1)用来在cpp文件中定义一个模板类或模板函数，而它的声明在对应的h文件中<br>(2)export专用于模板，类似于extern之于简单类型<br>(3)实际很多环境不支持，暂不必细究，看到代码时能认出即可</p>
<p>3、requires<br>(1)C++20引入，用于表示模板的参数约束，因为有些模板函数的参数是有一定限制的，例如add函数其参数不能是两个结构体，结构体是无法相加的<br>(2)了解即可，暂时不用管</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> METHOD 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> METHOD  </span></span><br><span class="line"><span class="comment">//写一个函数add，完成两个数的求和</span></span><br><span class="line"><span class="comment">//若有十种数据类型要考虑，就需要写多个add的重载函数，十分麻烦</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, in b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;int add(int a, in b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> (a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;double add(double a, double b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> (a+b);        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//如何解决上述问题，可通过模板编程来解决</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span><span class="comment">//T就被当作这个模板的泛型数据类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> i = <span class="number">5</span>, j = <span class="number">6</span>;</span><br><span class="line">        <span class="comment">//short i = 5, j = 6;</span></span><br><span class="line">        <span class="comment">//int i = 5, j = 6;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个不同的数据类型会将低的转为高的类型（不同数据类型的高低级不同）</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a + b = &quot;</span> &lt;&lt; <span class="built_in">add</span>(i ,j) &lt;&lt; endl;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<h3 id="C-的异常处理机制"><a href="#C-的异常处理机制" class="headerlink" title="C++的异常处理机制"></a>C++的异常处理机制</h3><p>1、何为异常处理<br>(1)异常exception，即运行时错误<br>(2)C中没有异常机制，所以运行时遇到错误只能终止程序<br>(3)C++中新增了异常处理机制，允许程序在运行时拦截错误并处理，这样程序就不用终止<br>(4)异常机制的一个典型案例就是：由用户输入2个数字然后相除中的除0异常</p>
<p>2、异常处理编程实践<br>(1)try（其包含的代码表示有可能爆发错误）, catch（捕捉异常）, throw（抛出异常）<br>(2)异常处理机制为什么优于出错条件判断：<a href="https://www.cnblogs.com/wkfvawl/p/10816156.html">https://www.cnblogs.com/wkfvawl/p/10816156.html</a> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C 0</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m, n;</span><br><span class="line">        <span class="comment">//让用户输入两个数，二者相除返回二者的商</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;please input two numbers&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> C        <span class="comment">//在C中这样处理除数为0的情况</span></span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;n can‘t be 0.&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;        </span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;m / n = &quot;</span> &lt;&lt; m/n &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">//在C++中的处理方式</span></span></span><br><span class="line">        <span class="comment">//C++中异常处理机制进行处理</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">//try括号里的代码就是有可能触发异常的代码</span></span><br><span class="line">                <span class="comment">//这部分代码不应过多，会消耗过多的资源</span></span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span>(<span class="number">0</span>);<span class="comment">//抛出异常</span></span><br><span class="line">                        <span class="comment">//throw(&#x27;A&#x27;);//抛出的这个类型异常无法被抓取，因为下方无catch(char e)</span></span><br><span class="line">                                                 <span class="comment">//在执行过程中会出错退出        </span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;m /n = &quot;</span> &lt;&lt; m/n &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span> e)<span class="comment">//catch的()里写上要抓取的异常类型</span></span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;catch int e&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">double</span> e)<span class="comment">//catch的()里写上要抓取的异常类型</span></span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;catch double&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;---other code---&quot;</span> &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、异常和函数<br>(1)在某个函数内throw一个异常后如果没有catch会层层向外传递(顺着函数的调用关系)直到被catch为止<br>(2)函数可以用throw列表来标识自己会抛出的异常<br>有时候有些函数只负责抛出异常，有些函数只负责处理异常<br>void func(void) throw(A, B, C);//这种声明就是告诉调用者可能会抛出A,B,C三种异常 </p>
<p>4、标准库中的exception类（标准异常：不是我们自定义的，是标准库定义好的，包括常见的很多错误）<br>(1)标准库中定义的异常类及其派生类，很多内置代码的错误会抛出这些异常<br>(2)譬如bad_typeid，使用 typeid 运算符时，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常<br>(3)譬如bad_cast，用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常</p>
<p>5、noexcept关键字<br>(1)throw(int, double, A, B, C)表示函数可能会抛出这5种类型的exception<br>(2)throw() 表示函数不会抛出任何异常<br>(3)<strong>C++11中引入noexcept关键字替代throw()表示函数不会抛出任何异常</strong></p>
<ul>
<li>noexcept(bool)//bool值为true表示无异常<br>(4)没有throw列表的函数，表示函数可能会抛出任意类型的异常</li>
</ul>
<p>6、剩余一些关键字<br>(1)线程相关：thread_local (C++11 起)<br>(2)import和module (C++20)<br>(3)协程相关：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">co_await</span></span> (C++<span class="number">20</span> 起)</span><br><span class="line"><span class="built_in"><span class="keyword">co_return</span></span> (C++<span class="number">20</span> 起)</span><br><span class="line"><span class="built_in"><span class="keyword">co_yield</span></span> (C++<span class="number">20</span> 起)</span><br></pre></td></tr></table></figure>

<p>(4)并发相关：synchronized (TM TS)<br>(5)反射相关：reflexpr (反射 TS)<br>(6)其他：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">transaction\_safe (TM TS)</span><br><span class="line">transaction\_safe\_dynamic (TM TS)</span><br><span class="line">atomic\_cancel (TM TS)</span><br><span class="line">atomic\_commit (TM TS)</span><br><span class="line">atomic\_noexcept (TM TS) </span><br></pre></td></tr></table></figure>

<p>7、总结<br>(1)C++关键字和复杂度远超过C语言，语言特性较多<br>(2)面向对象编程相关特性是C++的基础核心，占比非常大<br>(3)模板泛型和抽象化编程是C++的重要特征，甚至可以说是精髓所在<br>(4)和java、python相比，C++的语法细节过多，这也是C++较难学习的重要原因<br>(5)不要试图去记，以理解为主，配合代码实验去消化吸收，形成自己对C++的认知<br>(6)经典C++与C++11、14、17、20的差异其实就是相应增加的关键字带来的新语言特性 </p>
<h2 id="C-的内存管理"><a href="#C-的内存管理" class="headerlink" title="C++的内存管理"></a>C++的内存管理</h2><h3 id="为什么要研究内存管理"><a href="#为什么要研究内存管理" class="headerlink" title="为什么要研究内存管理"></a>为什么要研究内存管理</h3><p>1、<strong>程序就是数据加算法</strong><br>(1)写程序是为了解决某个问题，生活中的问题最终被计算机抽象为控制或运算<br>(2)CPU中的主要构件就是运算器和控制器，本质上是一堆组合逻辑电路，表现为机器指令集<br>(3)一个问题对应一个程序，一个程序分为多个函数，一个函数分为多个机器指令<br>(4)存储机器指令需要内存（ROM），机器指令的执行过程需要内存（RAM）参与，这是内存的2大作用<br>(5)算法对应机器指令（ROM内存），数据对应RAM内存，CPU对应工作机器<br>(6)<strong>越是偏底层的语言，越对内存管理具体化，效率也越高，同时对编程者要求也越高</strong> </p>
<p>2、计算机中如何管理内存<br>(1)C++项目大多数对应在操作系统中运行，很少有裸机的<br>(2)OS提供最基本的内存管理体系，OS直接管理物理内存，并向应用层提供一套内存接口<br>(3)C++语言对OS的内存接口进行封装，提供给编程者一套内存使用方法<br>(4)编程人员写的代码在编译工具链、OS等体系的帮助下最终在计算机物理层运行 </p>
<p>3、总结<br>(1)内存管理的原理虽然庞大而复杂，然而<strong>程序员只需要掌握好C++语言的内存管理语言特性即可</strong><br>(2)C++程序容易出bug，主要就是因为内存管理部分的复杂性<br>(3)Java,python等语言提供了更多的封装，所以降低了程序员操作难度和犯错可能性</p>
<h3 id="C-可用内存区域"><a href="#C-可用内存区域" class="headerlink" title="C++可用内存区域"></a>C++可用内存区域</h3><p>1、C语言可用内存区域<br>(1)<strong>栈，对应局部变量</strong><br>(2)<strong>全局数据区/静态数据区，对应全局变量，静态局部变量</strong><br>(3)<strong>const数据区，在内存层面是不存在的，是C编译器营造出来的，通过编译器的检查来实现只读，实际上并没有这样一个数据区</strong><br>(4)<strong>代码段，放可执行程序的，性质是rom，不是内存，但实质是ram</strong><br>(5)<strong>堆heap，由malloc和free来管理的一块内存,也是动态内存</strong> </p>
<p>2、C++新增内存区域<br><strong>自由存储区，由new申请得到的动态内存区域</strong></p>
<p>3、总结<br>(1)代码段只会读不会写，一般不会出任何问题<br>(2)全局数据区和栈区都是自动管理的，只要可用内存足够不会出问题<br>(3)const数据区实际上是由编译器来保证只读的，本质就是普通的内存区域<br>(4)<strong>灵活性和风险都集中在heap区域，常见问题如内存泄漏、内存碎片</strong>等</p>
<h3 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h3><p>1、简单区别<br>(1)malloc是C库函数，new是C++运算符关键字<br>(2)malloc申请空间大小靠传参确定，而new不需要传参，对象本身大小由编译器自动计算给出<br>(3)<strong>malloc返回值为void *因此需要强转，而new返回值类型为确定的对象指针类型</strong><br>(4)malloc对应free释放，new对应delete和delete[]释放 </p>
<p>2、深度区别<br>(1)<strong>malloc 只能申请内存不能带初始化，而new可以带初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">3</span>);<span class="comment">//即*p = 3;</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;<span class="comment">//即*p = 0;</span></span><br></pre></td></tr></table></figure>
<p>(2)<strong>new会执行类的构造函数而malloc不会</strong><br>(3)malloc失败返回NULL，而new失败引发bad_alloc异常<br>(4)申请和释放数组类型时不同<br><strong>new申请的是数组类型时使用delete[]释放，不是则用delete释放</strong></p>
<p>3、总结<br>(1)linux平台中new内部是通过malloc实现的，new比malloc多一个调用构造函数<br>(2)malloc只是返回一块荒地给你，而new会给你修好路盖好房子规划好田地等</p>
<h3 id="智能指针的引入"><a href="#智能指针的引入" class="headerlink" title="智能指针的引入"></a>智能指针的引入</h3><p>1、指针的优势和劣势<br>(1)<strong>指针的本质是一个变量，变量的值是其他对象的地址，因此可以解引用</strong><br>(2)<strong>指针本质上对应CPU指令中的间接寻址，所以指针是天然存在的，是CPU设计决定了的</strong><br>(3)指针的优势就是灵活、代码效率高<br>(4)<strong>指针的劣势也是太灵活，尤其结合动态内存和构造（比如越界访问）、析构后，在复杂业务中容易出错</strong></p>
<p>2、如何解决<br>(1)底层不用指针是不可能的，因此这个问题是绕不开的<br>(2)解决方案1：由程序员来自主把控，C/C++典型编程就是这样<br>(3)解决方案2：由程序员和专门设计的自动管理机制共同把控，典型代表是智能指针<br>(4)解决方案3：由自动管理机制全权把控，程序员不用管，典型代表是Java的垃圾回收机制</p>
<p>3、智能指针如何实现<br>(1)<strong>将普通的简单纯指针封装为栈式复合指针对象，即智能指针对象</strong><br>(2)<strong>智能指针本身定义为局部变量，分配在栈内存上，因此本身是自动回收的</strong><br>(3)<strong>智能指针内部设计为当智能指针本身要被弹栈释放时，执行事先挂接好的清理函数（在C++中一般是析构函数）</strong><br>(4)智能指针的正常使用通过一些提供的方法和运算符重载来使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> *p;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="comment">//记录使用的次数</span></span><br><span class="line">        函数指针;<span class="comment">//指向一个清理函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单指针 int *p1; 出错一般不是p1本身出错，而是其所指向的那块内存出错。</p>
<p>4、智能指针总结<br>(1)<strong>智能指针是普通指针的升级版，封装版，本身具备指针的功能，且多出一些自动释放资源机制。占用的内存多余普通指针</strong>。<br>(2)<strong>智能指针进行动态内存管理，要比普通指针多出很多（内存和性能上的）开销</strong>。<br>(3)智能指针的实现不是唯一的，C++有很多智能指针，各有优劣和适用场景，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::auto_ptr、boost::scoped_ptr、boost::shared_ptr、boost::scoped_array、boost::shared_array、boost::weak_ptr、boost::intrusive_ptr。</span><br></pre></td></tr></table></figure>
<p>(4)智能指针也要按照设计去正确使用，否则也会出问题。具体用法后续文章再讲。</p>
<h3 id="Java的垃圾回收机制"><a href="#Java的垃圾回收机制" class="headerlink" title="Java的垃圾回收机制"></a>Java的垃圾回收机制</h3><p>1、Java语言整体框架<br>(1)CPU-&gt;操作系统内核-&gt;应用层框架-&gt;JVM（java虚拟机）-&gt;Java字节码-&gt;Java源代码<br>Java虚拟机是java语言的运行环境，Java字节码是java自己定义的一种格式，与任何CPU的机器码都不对应，是虚拟出来的一种机器语言，其在任何CPU和操作系统上都无法直接运行，必须放在java的虚拟机上运行。<br>android与windows的虚拟机并不兼容。<br>Java与C++不在一个层次上，C++在应用层框架，Java运行在java的虚拟机上。<br>(2)Java是解释型语言，而非编译型语言<br>(3)Java虚拟机是Java语言的运行时环境，也是Java语言跨平台的关键</p>
<p>2、Java的垃圾回收机制介绍<br>(1)什么是垃圾？<br>待回收的内存资源（主要指动态内存），本质是生命周期结束了的变量对象等。<br>(2)谁来回收？<br>GC线程，Java虚拟机中的守护线程。<br>(3)什么时候回收？<br>GC机制和算法来决定，程序员不用管。<br>(4)如何确定谁是垃圾？<br>引用计数法和可达性分析法。<br>介绍见：<a href="https://www.cnblogs.com/jiangtunan/p/11025521.html">https://www.cnblogs.com/jiangtunan/p/11025521.html</a><br><strong>引用计数法：</strong></p>
<ul>
<li>引用计数法就是给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的，可以当做垃圾收集。这种方法实现起来很简单而且优缺点都很明显。</li>
<li>优点:执行效率高，程序执行受影响较小</li>
<li>缺点:无法检测出循环引用的情况，导致内存泄露</li>
</ul>
<p><strong>可达性分析算法：</strong></p>
<ul>
<li>这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</li>
</ul>
<p>3、垃圾回收机制点评<br>(1)不止java，其他语言如C#也是类似设计理念，典型特征就是语言没有指针的概念<br>(2)垃圾回收机制让程序员免于考虑对象的生命周期和资源的申请与释放，编程难度大减。<br>(3)垃圾回收机制的稳定性和效率取决于运行时环境(JVM等)设计和实现的好坏<br>(4)垃圾回收机制用效率和内存资源成本，换来了更简单不易错的语言特性。<br>应用了垃圾回收机制的语言没有指针。</p>
<p>4、最后的总结<br>(1)本篇文章主要讲了C/C++/Java等语言的内存管理策略，尤其是动态内存管理策略<br>(2)机制本身有优点就有缺点，没有绝对好坏，适合的场景使用适合的机制才是上策<br>(3)C++掌握好以后再学习Java、Python等就简单多了 </p>
]]></content>
      <categories>
        <category>4. C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++从入门到进阶之五-C++的设计模式</title>
    <url>/2024/11/18/2024-11-20-CPP-Basics-C-Design-Patterns/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>4. C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++从入门到进阶之四-C++编程优化</title>
    <url>/2024/11/18/2024-11-19-CPP-Basics-C-Programming-Optimization/</url>
    <content><![CDATA[<h2 id="C-编程功底和常用规则"><a href="#C-编程功底和常用规则" class="headerlink" title="C++编程功底和常用规则"></a>C++编程功底和常用规则</h2><p>待完成…</p>
<h2 id="C-并发编程"><a href="#C-并发编程" class="headerlink" title="C++并发编程"></a>C++并发编程</h2><h3 id="并发编程相关基础概念"><a href="#并发编程相关基础概念" class="headerlink" title="并发编程相关基础概念"></a>并发编程相关基础概念</h3><p>待完成…</p>
<h3 id="pthread使用讲解和实战"><a href="#pthread使用讲解和实战" class="headerlink" title="pthread使用讲解和实战"></a>pthread使用讲解和实战</h3><p>1、简介<br>POSIX线程（英语：POSIX Threads，常被缩写为Pthreads）是POSIX的线程标准，定义了创建和操纵线程的一套API。<br>实现POSIX 线程标准的库常被称作Pthreads，一般用于Unix-likePOSIX 系统，如Linux、Solaris。</p>
<span id="more"></span>
<p>2、pthread的使用<br>需求：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建线程并运行，验证线程函数会被调度运行</span></span><br><span class="line"><span class="comment">// 2. 向子线程传参并接收</span></span><br><span class="line"><span class="comment">// 3. 使用pthread_join来回收线程，验证主线阻塞等待子线程完成后再执行</span></span><br><span class="line"><span class="comment">// 4. 线程函数使用ptread_exit主动结束</span></span><br><span class="line"><span class="comment">// 5. 子线程向主线程返回值，主线程通过 pthread_join 来接收</span></span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">testFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = *(<span class="keyword">int</span> *)arg;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[cnt];   <span class="comment">// 注意：这里是分配在堆上的,因为这个会return p， 若分配在栈上，这个函数执行完毕之后就被销毁了，无法被return</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;call testFunc , arg: &quot;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        p[i] = i + <span class="number">2</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; p[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//return p;       // 正常返回</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(p);  <span class="comment">//使用 pthread_exit 主动结束当前线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arg = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> *retValue;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, testFunc, &amp;arg);  <span class="comment">// arg 会作为参数传给 testFunc</span></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pthread_create success!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">pthread_join</span>(tid, (<span class="keyword">void</span>**)&amp;retValue);   <span class="comment">// pthread_join 会阻塞，等待子线程执行完成， 接收 testFunc 的返回值</span></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pthread_join success!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; arg; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;retValue[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; retValue[i] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> retValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pthread_create success!</span><br><span class="line">call testFunc , arg: <span class="number">3</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">p[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">p[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line">pthread_join success!</span><br><span class="line">retValue[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">retValue[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">retValue[<span class="number">2</span>] = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="pthread线程分离"><a href="#pthread线程分离" class="headerlink" title="pthread线程分离"></a>pthread线程分离</h3><p>1、 线程的状态</p>
<ol>
<li>   线程有两种状态： <strong>JOINABLE</strong> 和 <strong>DETACHED</strong> ，默认是 JOINABLE</li>
<li>   <strong>JOINABLE 的线程必须在创建它的线程中使用 pthread_join 回收，否则会有资源未释放</strong></li>
<li>   <strong>DETACHED 的线程可以在终止时释放资源，这样创建它的线程就不用通过 pthread_join 来等待回收</strong></li>
<li>   <strong>线程转为 DETACHED 有两种方法</strong>:<br>第一种是线程函数内部自己调用 pthread_detach(pthread_self());<br>第二种是使用线程属性 pthread_attr</li>
</ol>
<p>2、线程函数内部自己调用 pthread_detach(pthread_self());</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">testFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());   <span class="comment">// 注意：将线程状态改为 DETACHED</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = *(<span class="keyword">int</span> *)arg;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[cnt];   <span class="comment">// 注意：这里是分配在堆上的,因为这个会return p， 若分配在栈上，这个函数执行完毕之后就被销毁了，无法被return</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;call testFunc , arg: &quot;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        p[i] = i + <span class="number">2</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; p[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return p;       // 正常返回</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(p);  <span class="comment">//使用 pthread_exit 主动结束当前线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arg = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> *retValue;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, testFunc, &amp;arg);  <span class="comment">// arg 会作为参数传给 testFunc</span></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pthread_create success!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 DETACHED 线程中， pthread_join 其实是不需要的，这里是做实验保留</span></span><br><span class="line">    ret = <span class="built_in">pthread_join</span>(tid, (<span class="keyword">void</span>**)&amp;retValue);   <span class="comment">// pthread_join 会阻塞，等待子线程执行完成， 接收 testFunc 的返回值</span></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pthread_join success!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; arg; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;retValue[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; retValue[i] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> retValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 会跑到这里，因为子线程中已经把线程状态修改成 DETACHED 了，不需要使用  pthread_join 来阻塞等待资源释放</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pthread_join fail!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;start to pthread_exit main …&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 退出主线程，主线程退出后，子线程依旧可以继续执行。因为 pthread_exit 是针对线程的，不是针对进程</span></span><br><span class="line">    <span class="comment">// 若不加这个，随着 return 0的调用，进程就终止了，子线程 testFunc 也会被终止</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pthread_create success!</span><br><span class="line">pthread_join fail!</span><br><span class="line">start to pthread_exit main …</span><br><span class="line">call testFunc , arg: <span class="number">3</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">p[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">p[<span class="number">2</span>] = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>3、使用线程属性 pthread_attr<br>(1) pthread_attr_t attr; //声明一个参数<br>(2) pthread_attr_init(&amp;attr); //对参数进行初始化<br>(3) pthread_attr_setdetachstate(&amp;attr， PTHREAD_CREATE_JOINABLE); //设置线程为可连接的<br>(4) pthread_attr_setdetachstate(&amp;attr， PTHREAD_CREATE_DETACHED); //设置线程为可分离的<br>(5) pthread_attr_destroy(&amp;attr); //销毁属性，防止内存泄露<br>(6) 实战：使用 int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); //设置线程为状态<br>(7) int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">testFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = *(<span class="keyword">int</span> *)arg;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[cnt];   <span class="comment">// 注意：这里是分配在堆上的,因为这个会return p， 若分配在栈上，这个函数执行完毕之后就被销毁了，无法被return</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;call testFunc , arg: &quot;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        p[i] = i + <span class="number">2</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; p[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return p;       // 正常返回</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(p);  <span class="comment">//使用 pthread_exit 主动结束当前线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arg = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> *retValue;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="keyword">int</span> detachstate;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line">    <span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, testFunc, &amp;arg);  <span class="comment">// arg 会作为参数传给 testFunc</span></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pthread_create success!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">pthread_attr_getdetachstate</span>(&amp;attr, &amp;detachstate);</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( detachstate == PTHREAD_CREATE_DETACHED )</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;detachstate == PTHREAD_CREATE_DETACHED&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( detachstate == PTHREAD_CREATE_JOINABLE )</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;detachstate == PTHREAD_CREATE_JOINABLE&quot;</span> &lt;&lt; endl;</span><br><span class="line">            ret = <span class="built_in">pthread_join</span>(tid, (<span class="keyword">void</span>**)&amp;retValue); <span class="comment">// pthread_join 会阻塞，等待子线程执行完成， 接收 testFunc 的返回值</span></span><br><span class="line">            <span class="keyword">if</span> (!ret)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;pthread_join success!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; arg; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;retValue[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; retValue[i] &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span> retValue;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 会跑到这里，因为子线程中已经把线程状态修改成 DETACHED 了，不需要使用  pthread_join 来阻塞等待资源释放</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;pthread_join fail!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_attr_destroy</span>(&amp;attr);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;start to pthread_exit main …&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 退出主线程，主线程退出后，子线程依旧可以继续执行。因为 pthread_exit 是针对线程的，不是针对进程</span></span><br><span class="line">    <span class="comment">// 若不加这个，随着 return 0的调用，进程就终止了，子线程 testFunc 也会被终止</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、关于多线程编程的几个值得注意的点：</p>
<ol>
<li>   <strong>main 所在的线程称之为“初始线程”，从main返回的时候，整个进程就被终止了</strong></li>
<li>   <strong>在任意线程内调用 exit 函数都会让该线程所在的进程整个退出。所以主动退出线程的时候一定要使用 pthread_exit ，而不是 exit</strong></li>
<li>   <strong>当主线程调用 pthread_exit 函数仅仅只是终止主线程，其它线程仍将继续存在</strong></li>
</ol>
<h3 id="线程同步-互斥锁"><a href="#线程同步-互斥锁" class="headerlink" title="线程同步_互斥锁"></a>线程同步_互斥锁</h3><p>1、 <strong>互斥锁: 对共享数据进行锁定，保证同一时刻只能有一个线程去操作。</strong><br>2、注意: <strong>互斥锁是多个线程一起去抢，抢到锁的线程先执行，没有抢到锁的线程需要等待，等互斥锁使用完释放后，其它等待的线程再去抢这个锁。</strong><br>3、互斥锁的使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 互斥锁 mutex</span></span><br><span class="line">(<span class="number">1</span>) 互斥锁静态初始化：<span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">(<span class="number">2</span>) 互斥锁动态初始化： <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">(<span class="number">3</span>) 上锁和解锁： <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">(<span class="number">4</span>) 互斥锁销毁： <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p>实战：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> g_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">testFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;g_mutex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">200</span>*<span class="number">1000</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;g_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">200</span>*<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;g_mutex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">5</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">200</span>*<span class="number">1000</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;g_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;g_mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    ret1 = <span class="built_in">pthread_create</span>(&amp;tid1, <span class="literal">NULL</span>, testFunc, <span class="literal">NULL</span>);</span><br><span class="line">    ret2 = <span class="built_in">pthread_create</span>(&amp;tid2, <span class="literal">NULL</span>, testFunc, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    ret1 = <span class="built_in">pthread_join</span>(tid1, <span class="literal">NULL</span>);   <span class="comment">// pthread_join 会阻塞，等待子线程执行完成， 接收 testFunc 的返回值</span></span><br><span class="line">    <span class="keyword">if</span> (!ret1)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pthread_join tid1 success!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ret2 = <span class="built_in">pthread_join</span>(tid2, <span class="literal">NULL</span>);   <span class="comment">// pthread_join 会阻塞，等待子线程执行完成， 接收 testFunc 的返回值</span></span><br><span class="line">    <span class="keyword">if</span> (!ret2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pthread_join tid2 success!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;g_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">139925917001472</span> <span class="number">0</span></span><br><span class="line"><span class="number">139925917001472</span> <span class="number">1</span></span><br><span class="line"><span class="number">139925917001472</span> <span class="number">2</span></span><br><span class="line"><span class="number">139925917001472</span> <span class="number">3</span></span><br><span class="line"><span class="number">139925917001472</span> <span class="number">4</span></span><br><span class="line"><span class="number">139925908608768</span> <span class="number">0</span></span><br><span class="line"><span class="number">139925908608768</span> <span class="number">1</span></span><br><span class="line"><span class="number">139925908608768</span> <span class="number">2</span></span><br><span class="line"><span class="number">139925908608768</span> <span class="number">3</span></span><br><span class="line"><span class="number">139925908608768</span> <span class="number">4</span></span><br><span class="line"><span class="number">139925917001472</span> <span class="number">5</span></span><br><span class="line"><span class="number">139925917001472</span> <span class="number">6</span></span><br><span class="line"><span class="number">139925917001472</span> <span class="number">7</span></span><br><span class="line"><span class="number">139925917001472</span> <span class="number">8</span></span><br><span class="line"><span class="number">139925917001472</span> <span class="number">9</span></span><br><span class="line">pthread_join tid1 success!</span><br><span class="line"><span class="number">139925908608768</span> <span class="number">5</span></span><br><span class="line"><span class="number">139925908608768</span> <span class="number">6</span></span><br><span class="line"><span class="number">139925908608768</span> <span class="number">7</span></span><br><span class="line"><span class="number">139925908608768</span> <span class="number">8</span></span><br><span class="line"><span class="number">139925908608768</span> <span class="number">9</span></span><br><span class="line">pthread_join tid2 success!</span><br></pre></td></tr></table></figure>

<h3 id="线程同步-读写锁"><a href="#线程同步-读写锁" class="headerlink" title="线程同步_读写锁"></a>线程同步_读写锁</h3><p>1、 读写锁概念</p>
<ol>
<li>   <strong>读写锁（Readers-Writer Lock）顾名思义是一把锁分为两部分：读锁和写锁。</strong></li>
<li>   <strong>其中读锁允许多个线程同时获得，因为读操作本身是线程安全的，而写锁则是互斥锁，不允许多个线程同时获得写锁，并且写操作和读操作也是互斥的。</strong></li>
<li>   总结来说，读写锁的特点是：<strong>读读不互斥、读写互斥、写写互斥</strong></li>
</ol>
<p>2、 读写锁的使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pthread_rwlock_init</span>(&amp;g_rwlock, <span class="literal">NULL</span>); <span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="built_in">pthread_rwlock_wrlock</span>(&amp;g_rwlock);     <span class="comment">// 写锁</span></span><br><span class="line"><span class="built_in">pthread_rwlock_rdlock</span>(&amp;g_rwlock);     <span class="comment">// 读锁</span></span><br><span class="line"><span class="built_in">pthread_rwlock_tryrdlock</span>(&amp;g_rwlock);  <span class="comment">// 非阻塞读锁</span></span><br><span class="line"><span class="built_in">pthread_rwlock_trywrlock</span>(&amp;g_rwlock);  <span class="comment">// 非阻塞写锁</span></span><br><span class="line"><span class="built_in">pthread_rwlock_unlock</span>(&amp;g_rwlock);     <span class="comment">// 将读锁或写锁解锁</span></span><br><span class="line"><span class="built_in">pthread_rwlock_destroy</span>(&amp;g_rwlock);    <span class="comment">// 销毁</span></span><br></pre></td></tr></table></figure>
<p>实战：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> g_rwlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">testFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_rwlock_wrlock</span>(&amp;g_rwlock);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">200</span>*<span class="number">1000</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_rwlock_unlock</span>(&amp;g_rwlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_rwlock_init</span>(&amp;g_rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    ret1 = <span class="built_in">pthread_create</span>(&amp;tid1, <span class="literal">NULL</span>, testFunc, <span class="literal">NULL</span>);</span><br><span class="line">    ret2 = <span class="built_in">pthread_create</span>(&amp;tid2, <span class="literal">NULL</span>, testFunc, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    ret1 = <span class="built_in">pthread_join</span>(tid1, <span class="literal">NULL</span>);   <span class="comment">// pthread_join 会阻塞，等待子线程执行完成， 接收 testFunc 的返回值</span></span><br><span class="line">    <span class="keyword">if</span> (!ret1)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pthread_join tid1 success!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ret2 = <span class="built_in">pthread_join</span>(tid2, <span class="literal">NULL</span>);   <span class="comment">// pthread_join 会阻塞，等待子线程执行完成， 接收 testFunc 的返回值</span></span><br><span class="line">    <span class="keyword">if</span> (!ret2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pthread_join tid2 success!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_rwlock_destroy</span>(&amp;g_rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">140108497356544</span> <span class="number">0</span></span><br><span class="line"><span class="number">140108497356544</span> <span class="number">1</span></span><br><span class="line"><span class="number">140108497356544</span> <span class="number">2</span></span><br><span class="line"><span class="number">140108497356544</span> <span class="number">3</span></span><br><span class="line"><span class="number">140108497356544</span> <span class="number">4</span></span><br><span class="line"><span class="number">140108497356544</span> <span class="number">5</span></span><br><span class="line"><span class="number">140108497356544</span> <span class="number">6</span></span><br><span class="line"><span class="number">140108497356544</span> <span class="number">7</span></span><br><span class="line"><span class="number">140108497356544</span> <span class="number">8</span></span><br><span class="line"><span class="number">140108497356544</span> <span class="number">9</span></span><br><span class="line">pthread_join tid1 success!</span><br><span class="line"><span class="number">140108488963840</span> <span class="number">0</span></span><br><span class="line"><span class="number">140108488963840</span> <span class="number">1</span></span><br><span class="line"><span class="number">140108488963840</span> <span class="number">2</span></span><br><span class="line"><span class="number">140108488963840</span> <span class="number">3</span></span><br><span class="line"><span class="number">140108488963840</span> <span class="number">4</span></span><br><span class="line"><span class="number">140108488963840</span> <span class="number">5</span></span><br><span class="line"><span class="number">140108488963840</span> <span class="number">6</span></span><br><span class="line"><span class="number">140108488963840</span> <span class="number">7</span></span><br><span class="line"><span class="number">140108488963840</span> <span class="number">8</span></span><br><span class="line"><span class="number">140108488963840</span> <span class="number">9</span></span><br><span class="line">pthread_join tid2 success!</span><br></pre></td></tr></table></figure>

<h3 id="线程同步-条件变量"><a href="#线程同步-条件变量" class="headerlink" title="线程同步_条件变量"></a>线程同步_条件变量</h3><p>1、条件变量概念<br>条件变量（condition variable）是为了等待某个条件成立而设计，提供一种线程间通知机制，在条件成立之前，等待线程进入睡眠状态，当某个条件成立时，信号端发射signal/broadcast来“唤醒”等待线程。<br>具体参考：<br><a href="https://www.cnblogs.com/bigosprite/p/11068687.html">https://www.cnblogs.com/bigosprite/p/11068687.html</a><br><a href="https://blog.csdn.net/chengonghao/article/details/51779279">https://blog.csdn.net/chengonghao/article/details/51779279</a></p>
<p>2、条件变量的使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSUMERS_COUNT 2        </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRODUCERS_COUNT 1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">pthread_mutex_t</span> g_mutex ;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> g_cond ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">pthread_t</span> g_thread[CONSUMERS_COUNT + PRODUCERS_COUNT] ;</span><br><span class="line"><span class="keyword">int</span> share_variable = <span class="number">0</span> ;<span class="comment">// this is the share variable, shared by consumer and producer</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer</span><span class="params">( <span class="keyword">void</span>* arg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> num = *(<span class="keyword">int</span> *)arg;</span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">1</span> ) </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">/******* critical section begin *******/</span></span><br><span class="line">      <span class="built_in">pthread_mutex_lock</span>( &amp;g_mutex ) ;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// if share_variable == 0, means consumer shell stop here</span></span><br><span class="line">      <span class="keyword">while</span> ( share_variable == <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">printf</span>( <span class="string">&quot;consumer %d begin wait a condition...\n&quot;</span>, num ) ;</span><br><span class="line">         <span class="comment">// put a thread blocked ont a condition variable( here is g_cond),</span></span><br><span class="line">         <span class="comment">// and unlock the mutex( here is g_mutex )</span></span><br><span class="line">         <span class="built_in">pthread_cond_wait</span>( &amp;g_cond, &amp;g_mutex ) ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// here means n != 0 and consumer can goes on</span></span><br><span class="line">      <span class="comment">// consumer consumed shared variable, so the number of shared variable shell minus</span></span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">&quot;consumer %d end wait a condition...\n&quot;</span>, num ) ;</span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">&quot;consumer %d begin consume product\n&quot;</span>, num ) ;</span><br><span class="line">      --share_variable ;</span><br><span class="line"> </span><br><span class="line">      <span class="built_in">pthread_mutex_unlock</span>( &amp;g_mutex ) ;</span><br><span class="line">      <span class="comment">/******** critial section end *********/</span></span><br><span class="line">      <span class="built_in">sleep</span>( <span class="number">1</span> ) ;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span> ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">( <span class="keyword">void</span>* arg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> num = *(<span class="keyword">int</span> *)arg;</span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">/******* critical section begin *******/</span></span><br><span class="line">      <span class="built_in">pthread_mutex_lock</span>( &amp;g_mutex ) ;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// produce a shared variable</span></span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">&quot;--- producer %d begin produce product...\n&quot;</span>, num ) ;</span><br><span class="line">      ++share_variable ;</span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">&quot;--- producer %d end produce product...\n&quot;</span>, num ) ;</span><br><span class="line">      <span class="comment">// unblock threads blocked on a condition variable( here is g_cond )</span></span><br><span class="line">      <span class="built_in">pthread_cond_signal</span>( &amp;g_cond ) ;</span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">&quot;--- producer %d notified consumer by condition variable...\n&quot;</span>, num ) ;</span><br><span class="line">      <span class="built_in">pthread_mutex_unlock</span>( &amp;g_mutex ) ;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/******** critial section end *********/</span></span><br><span class="line">      <span class="built_in">sleep</span>( <span class="number">5</span> ) ;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// initiate mutex</span></span><br><span class="line">   <span class="built_in">pthread_mutex_init</span>( &amp;g_mutex, <span class="literal">NULL</span> ) ;</span><br><span class="line">   <span class="comment">// initiate condition</span></span><br><span class="line">   <span class="built_in">pthread_cond_init</span>( &amp;g_cond, <span class="literal">NULL</span> ) ;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// initiate consumer threads</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONSUMERS_COUNT; ++ i )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">pthread_create</span>( &amp;g_thread[i], <span class="literal">NULL</span>, consumer, &amp;i ) ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">sleep</span>( <span class="number">1</span> ) ;</span><br><span class="line">   <span class="comment">// initiate producer threads</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = CONSUMERS_COUNT; i &lt; CONSUMERS_COUNT + PRODUCERS_COUNT; ++ i )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">pthread_create</span>( &amp;g_thread[i], <span class="literal">NULL</span>, producer, &amp;i ) ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONSUMERS_COUNT + PRODUCERS_COUNT; ++ i ) </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">pthread_join</span>( g_thread[i], <span class="literal">NULL</span> ) ;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">pthread_mutex_destroy</span>( &amp;g_mutex ) ;</span><br><span class="line">   <span class="built_in">pthread_cond_destroy</span>( &amp;g_cond ) ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">consumer <span class="number">2</span> begin wait a condition...</span><br><span class="line">consumer <span class="number">2</span> begin wait a condition...</span><br><span class="line">--- producer <span class="number">3</span> begin produce product...</span><br><span class="line">--- producer <span class="number">3</span> end produce product...</span><br><span class="line">--- producer <span class="number">3</span> notified consumer by condition variable...</span><br><span class="line">consumer <span class="number">2</span> end wait a condition...</span><br><span class="line">consumer <span class="number">2</span> begin consume product</span><br><span class="line">consumer <span class="number">2</span> begin wait a condition...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--- producer <span class="number">3</span> begin produce product...</span><br><span class="line">--- producer <span class="number">3</span> end produce product...</span><br><span class="line">--- producer <span class="number">3</span> notified consumer by condition variable...</span><br><span class="line">consumer <span class="number">2</span> end wait a condition...</span><br><span class="line">consumer <span class="number">2</span> begin consume product</span><br><span class="line">consumer <span class="number">2</span> begin wait a condition...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--- producer <span class="number">3</span> begin produce product...</span><br><span class="line">--- producer <span class="number">3</span> end produce product...</span><br><span class="line">--- producer <span class="number">3</span> notified consumer by condition variable...</span><br><span class="line">consumer <span class="number">2</span> end wait a condition...</span><br><span class="line">consumer <span class="number">2</span> begin consume product</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">consumer <span class="number">2</span> begin wait a condition...</span><br><span class="line"></span><br><span class="line">--- producer <span class="number">3</span> begin produce product...</span><br><span class="line">--- producer <span class="number">3</span> end produce product...</span><br><span class="line">--- producer <span class="number">3</span> notified consumer by condition variable...</span><br><span class="line">consumer <span class="number">2</span> end wait a condition...</span><br><span class="line">consumer <span class="number">2</span> begin consume product</span><br><span class="line">consumer <span class="number">2</span> begin wait a condition...</span><br></pre></td></tr></table></figure>

<h3 id="std-thread基本使用"><a href="#std-thread基本使用" class="headerlink" title="std::thread基本使用"></a>std::thread基本使用</h3><p>1、基本概念</p>
<ol>
<li>   std::thread 在 <thread> 头文件中声明，因此使用 std::thread 时需要包含 <thread> 头文件。</li>
<li>   std::thread内部实际上也是对pthread做了一层封装<br>学习参考：// <a href="https://zh.cppreference.com/w/cpp/thread">https://zh.cppreference.com/w/cpp/thread</a></li>
</ol>
<p>2、代码实践</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread 1 executing\n&quot;</span>;</span><br><span class="line">        ++n;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>&amp; n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread 2 executing\n&quot;</span>;</span><br><span class="line">        ++n;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread 3 executing\n&quot;</span>;</span><br><span class="line">            ++n;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">baz</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread 4 executing\n&quot;</span>;</span><br><span class="line">            ++n;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    foo f;</span><br><span class="line">    baz b;</span><br><span class="line">    std::thread t1; <span class="comment">// t1 不是线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(f1, n + <span class="number">1</span>)</span></span>; <span class="comment">// 按值传递</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(f2, std::ref(n))</span></span>; <span class="comment">// 按引用传递</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t4</span><span class="params">(std::move(t3))</span></span>; <span class="comment">// t4 现在运行 f2() 。 t3 不再是线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t5</span><span class="params">(&amp;foo::bar, &amp;f)</span></span>; <span class="comment">// 按引用传递,t5 在对象 f 上运行 foo::bar()</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t6</span><span class="params">(b)</span></span>; <span class="comment">// t6 在对象 b 的副本上运行 baz::operator()</span></span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">    t5.<span class="built_in">join</span>();</span><br><span class="line">    t6.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final value of n is &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final value of f.n (foo::n) is &quot;</span> &lt;&lt; f.n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final value of b.n (baz::n) is &quot;</span> &lt;&lt; b.n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Thread <span class="number">1</span> executing</span><br><span class="line">Thread <span class="number">3</span> executing</span><br><span class="line">Thread <span class="number">4</span> executing</span><br><span class="line">Thread <span class="number">2</span> executing</span><br><span class="line">Thread <span class="number">1</span> executing</span><br><span class="line">Thread <span class="number">3</span> executing</span><br><span class="line">Thread <span class="number">4</span> executing</span><br><span class="line">Thread <span class="number">2</span> executing</span><br><span class="line">Thread <span class="number">1</span> executing</span><br><span class="line">Thread <span class="number">3</span> executing</span><br><span class="line">Thread <span class="number">4</span> executing</span><br><span class="line">Thread <span class="number">2</span> executing</span><br><span class="line">Thread <span class="number">1</span> executing</span><br><span class="line">Thread <span class="number">3</span> executing</span><br><span class="line">Thread <span class="number">4</span> executing</span><br><span class="line">Thread <span class="number">2</span> executing</span><br><span class="line">Thread <span class="number">1</span> executing</span><br><span class="line">Thread <span class="number">3</span> executing</span><br><span class="line">Thread <span class="number">2</span> executing</span><br><span class="line">Thread <span class="number">4</span> executing</span><br><span class="line">Final value of n is <span class="number">5</span></span><br><span class="line">Final value of f.<span class="built_in">n</span> (foo::n) is <span class="number">5</span></span><br><span class="line">Final value of b.<span class="built_in">n</span> (baz::n) is <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="thread线程同步"><a href="#thread线程同步" class="headerlink" title="thread线程同步"></a>thread线程同步</h3><p>参考：<a href="https://zh.cppreference.com/w/cpp/thread/lock_guard">https://zh.cppreference.com/w/cpp/thread/lock_guard</a></p>
<h3 id="thread的异步机制future"><a href="#thread的异步机制future" class="headerlink" title="thread的异步机制future"></a>thread的异步机制future</h3><p>类模板 std::future 提供访问异步操作结果的机制<br>学习参考：<a href="https://blog.csdn.net/c_base_jin/article/details/89761718">C++11之std::future对象使用说明</a></p>
<p>代码实践：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板 std::future 提供访问异步操作结果的机制</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;future&lt;<span class="keyword">int</span>&gt;&gt; vfutures;  <span class="comment">// 定义一个容器，里面存放 future&lt;int&gt; 类型的变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vfutures.<span class="built_in">emplace_back</span>(     <span class="comment">// 于容器所提供的位置原位构造 future&lt;int&gt; 类型元素</span></span><br><span class="line">            <span class="built_in">async</span>(std::launch::async,   <span class="comment">// std::async 的第一个传参 std::launch policy</span></span><br><span class="line">            [](<span class="keyword">int</span> sleepTime)&#123;          <span class="comment">// std::async 的第二个传参 Function&amp;&amp; f，即可调用的对象</span></span><br><span class="line">                <span class="built_in">usleep</span>(sleepTime*<span class="number">1000</span>);</span><br><span class="line">                cout &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; sleepTime = &quot;</span> &lt;&lt; sleepTime &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> sleepTime;</span><br><span class="line">            &#125;, </span><br><span class="line">            i)   <span class="comment">// std::async 的第三个传参 Args&amp;&amp;... args，即可调用对象的参数</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; fut : vfutures)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> ret = fut.<span class="built_in">get</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;fut.get() ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    vfutures.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">139759526287104</span> sleepTime = <span class="number">0</span></span><br><span class="line">fut.<span class="built_in">get</span>() ret = <span class="number">0</span></span><br><span class="line"><span class="number">139759517894400</span> sleepTime = <span class="number">1</span></span><br><span class="line">fut.<span class="built_in">get</span>() ret = <span class="number">1</span></span><br><span class="line"><span class="number">139759509501696</span> sleepTime = <span class="number">2</span></span><br><span class="line">fut.<span class="built_in">get</span>() ret = <span class="number">2</span></span><br><span class="line"><span class="number">139759501108992</span> sleepTime = <span class="number">3</span></span><br><span class="line">fut.<span class="built_in">get</span>() ret = <span class="number">3</span></span><br><span class="line"><span class="number">139759376660224</span> sleepTime = <span class="number">4</span></span><br><span class="line">fut.<span class="built_in">get</span>() ret = <span class="number">4</span></span><br><span class="line"><span class="number">139759492716288</span> sleepTime = <span class="number">5</span></span><br><span class="line">fut.<span class="built_in">get</span>() ret = <span class="number">5</span></span><br><span class="line"><span class="number">139759484323584</span> sleepTime = <span class="number">6</span></span><br><span class="line">fut.<span class="built_in">get</span>() ret = <span class="number">6</span></span><br><span class="line"><span class="number">139759475930880</span> sleepTime = <span class="number">7</span></span><br><span class="line">fut.<span class="built_in">get</span>() ret = <span class="number">7</span></span><br><span class="line"><span class="number">139759467538176</span> sleepTime = <span class="number">8</span></span><br><span class="line">fut.<span class="built_in">get</span>() ret = <span class="number">8</span></span><br><span class="line"><span class="number">139759459145472</span> sleepTime = <span class="number">9</span></span><br><span class="line">fut.<span class="built_in">get</span>() ret = <span class="number">9</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>4. C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++从入门到进阶之三-STL等高阶话题</title>
    <url>/2024/11/18/2024-11-18-CPP-Basics-about-STL/</url>
    <content><![CDATA[<h2 id="C-模板编程入门"><a href="#C-模板编程入门" class="headerlink" title="C++模板编程入门"></a>C++模板编程入门</h2><h3 id="一个案例引入模板"><a href="#一个案例引入模板" class="headerlink" title="一个案例引入模板"></a>一个案例引入模板</h3><p>1、模板和泛型编程系类文章介绍<br>(1)模板编程是C++的一种高级特性，很常用，很有用，可以说是 C++的精髓，是C++被广泛使用的关键<br>(2)泛型在C++、java、C#等多种语言中都有，是现代编程语言典型特性<br>(3)本章开始不像以前以理论知识讲解为主，而是以写代码和实践为主，在实践中学为主。因为开始变得抽象起来了 </p>
<span id="more"></span>
<p>2、案例和传统解决方案<br>(1)问题：swap函数交换2个数<br>(2)传统解法：定义重载函数，用引用（或指针）来实现<br>(3)代码实战</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(<span class="keyword">double</span>&amp; a, <span class="keyword">double</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> tmp;</span><br><span class="line"></span><br><span class="line">    tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">3.3</span>, d = <span class="number">4.4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myswap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myswap</span>(c, d);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、传统方案的缺点<br>(1)<strong>要为每个数据类型提供一个重载函数，麻烦</strong><br>(2)<strong>所有重载函数除了类型外其他完全一致，重复而浪费</strong></p>
<p>4、解决办法思考与模板引入<br>(1)用到什么类型再实现相应重载。虽然可行但无法类库化，无法分工<br>(2)函数编写时进一步抽象化，调用时再给定具体类型，由<strong>编译器在编译时再绑定形成代码，这就是模板</strong><br>(3)代码实践，用函数模板来实现swap</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;<span class="comment">//定义一个抽象类型X，在函数被调用时确定具体类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(X&amp; a, X&amp; b)</span><span class="comment">//使用swap作为函数名会与某个库函数名冲突</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X tmp;</span><br><span class="line"></span><br><span class="line">    tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">3.3</span>, d = <span class="number">4.4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myswap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myswap</span>(c, d);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板的理解和几个细节"><a href="#模板的理解和几个细节" class="headerlink" title="模板的理解和几个细节"></a>模板的理解和几个细节</h3><p>1、模板是一种编译时的多态<br>(1)模板是关键是编写函数代码原型时不给定具体类型，每次调用时再给定具体类型<br>(2)模板特性由编译器提供，编译时根据调用时的实参具体类型推导匹配的原型中模板的本次具体类型<br>(3)<strong>模板在最终生成的可执行程序中是不可见的</strong><br>(4)<strong>模板是编译时的多态，也可以叫“静态”多态</strong><br>(5)<strong>模板是一种语法糖，是编译器提供给我们的减少编程劳动量的一种语法特性</strong> </p>
<p>2、模板有什么用<br>(1)让我们编写与类型无关的函数<br>(2)模板是一种抽象的维度，让我们能够写出抽象度更高的代码<br>(3)用模板来写库函数更好，因为这样的模板库可以在调用库函数时再指定各种数据类型<br>(4)模板没那么简单，抽象是拿复杂度换劳动量，所以学起来难，学会了用处大</p>
<p>3、模板的几个小细节<br>(1)函数模板定义时typename和class效果是一样的，视个人习惯而使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">X</span>&gt;</span></span><br><span class="line"><span class="comment">// 两个都可以，效果相同</span></span><br></pre></td></tr></table></figure>
<p>(2)函数模板中可以有多个typename，使用时按名称匹配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br></pre></td></tr></table></figure>

<h3 id="函数模板和类模板"><a href="#函数模板和类模板" class="headerlink" title="函数模板和类模板"></a>函数模板和类模板</h3><p>1、模板分2种<br>(1)<strong>函数模板</strong>。模板类型在函数参数列表中使用<br>(2)<strong>类模板</strong>。模板类型在类中（定义类成员变量，或类成员函数的参数列表）使用</p>
<p>2、类模板举例<br>单模板参数的类模板定义与使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(<span class="keyword">int</span> myage);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T x)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; People&lt;T&gt;::<span class="built_in">People</span>(<span class="keyword">int</span> myage)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = myage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> People&lt;T&gt;::<span class="built_in">print</span>(T x)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上边的部分为类模板的定义</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//类模板的使用</span></span><br><span class="line">    <span class="function">People&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">p2</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">4444</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(<span class="number">5.55</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多模板参数的类模板"><a href="#多模板参数的类模板" class="headerlink" title="多模板参数的类模板"></a>多模板参数的类模板</h3><p>1、同类型多参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(<span class="keyword">int</span> myage);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T x, T y)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; People&lt;T&gt;::<span class="built_in">People</span>(<span class="keyword">int</span> myage)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = myage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> People&lt;T&gt;::<span class="built_in">print</span>(T x, T y)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">p2</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">4444</span>, <span class="number">0000</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(<span class="number">5.55</span>, <span class="number">1.122</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、不同类型多参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(<span class="keyword">int</span> myage);</span><br><span class="line">    ~<span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T1 x, T2 y)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; People&lt;T1, T2&gt;::<span class="built_in">People</span>(<span class="keyword">int</span> myage)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = myage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="keyword">void</span> People&lt;T1, T2&gt;::<span class="built_in">print</span>(T1 x, T2 y)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; <span class="string">&quot;, x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">int</span>, string&gt; <span class="title">p1</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">5</span>, <span class="string">&quot;linux&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、成员函数在类内部的模板类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(<span class="keyword">int</span> myage)&#123;</span><br><span class="line">        age = myage;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T1 x, T2 y)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">int</span>, string&gt; <span class="title">p1</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">2</span>, <span class="string">&quot;linux&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板友元函数"><a href="#模板友元函数" class="headerlink" title="模板友元函数"></a>模板友元函数</h3><p>1、友元函数参数中不带模板的情况<br>(1)友元函数声明在class内，定义实现写在class外<br>(2)友元函数参数中类的直接给出具体类型，譬如<br>(3)这种友元函数实际是削弱了模板参数在使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//friend void friend_function(People&lt;int&gt;&amp; s);//方式一：友元函数定义在类的外部</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function</span><span class="params">(People&lt;<span class="keyword">int</span>&gt;&amp; s)</span><span class="comment">//方式二：友元函数定义在类的内部</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt;s.age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//方式一：友元函数定 义在类的外部</span></span><br><span class="line"><span class="comment">void friend_function(People&lt;int&gt;&amp; s)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;age = &quot; &lt;&lt;s.age &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>; </span><br><span class="line">    <span class="built_in">friend_function</span>(a);<span class="comment">//由于友元函数的类型被指定为int，若是定义的类不是int则无法使用该类的对象传参</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、友元函数参数中带模板参数方法1<br>(1)友元函数声明和定义都写在class内部<br>(2)虽然写在class内，但仍然是友元，而不是member function<br>(3)友元可以适配类的各种模板参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(People&lt;T&gt;&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span></span>;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;wwwwedsfs&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、友元函数参数中带模板参数方法2<br>(1)友元函数声明在class内，定义在class外<br>(2)声明时函数名加后缀，而定义时不用加<br>(3)需要class和friend function的2个前置声明<br>(4)调用friend function时可加&lt;实参类型&gt;后缀，也可以不加，但是加就必须加对了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前置声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;T&gt;&amp; s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> friend_function1&lt;T&gt;(<span class="keyword">const</span> People&lt;T&gt;&amp; s);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;T&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span></span>;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;wwwwedsfs&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、友元函数参数中带模板参数方法3</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span>;<span class="comment">//重定义一个U,不与T重名</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span></span>;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;wwwwedsfs&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板运算符重载函数"><a href="#模板运算符重载函数" class="headerlink" title="模板运算符重载函数"></a>模板运算符重载函数</h3><p>1、实现+和+=的运算符重载函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">+号如果返回引用,一种是返回*<span class="keyword">this</span>,另一种是返回新建的对象的引用</span><br><span class="line"></span><br><span class="line">前者导致加数也被改</span><br><span class="line">后者导致返回垃圾</span><br><span class="line"></span><br><span class="line">所以只能返回对象</span><br><span class="line"></span><br><span class="line">--------------------------------------------</span><br><span class="line">=号返回引用,</span><br><span class="line">保证了效率,</span><br><span class="line">支持了连续的=号操作</span><br><span class="line"></span><br><span class="line">若返回对象,</span><br><span class="line">效率低下,</span><br><span class="line">并不支持连续=号操作</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;<span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;<span class="comment">//自定义构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span>;<span class="comment">//友元函数，重定义一个U,不与T冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//运算符重载函数</span></span><br><span class="line">    People&lt;T&gt; <span class="keyword">operator</span>+(People&lt;T&gt;&amp; other);</span><br><span class="line">    People&lt;T&gt;&amp; <span class="keyword">operator</span>+=(People&lt;T&gt;&amp; other);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; People&lt;T&gt; People&lt;T&gt;::<span class="keyword">operator</span>+(People&lt;T&gt;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    People&lt;T&gt; tmp;</span><br><span class="line"></span><br><span class="line">    tmp.age = <span class="keyword">this</span>-&gt;age + other.age; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; People&lt;T&gt;&amp; People&lt;T&gt;::<span class="keyword">operator</span>+=(People&lt;T&gt;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age += other.age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span>, <span class="title">c1</span><span class="params">(<span class="number">2.222</span>)</span>, c2</span>;</span><br><span class="line">    c2 = c + c1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line">    c2 += c;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;wwwwedsfs&quot;</span>)</span>, <span class="title">b1</span><span class="params">(<span class="string">&quot;ooosdfsdfsdqw&quot;</span>)</span>, b2</span>;</span><br><span class="line">    b2 = b + b1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line">    b2 += b;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板运算符友元函数重载实现"><a href="#模板运算符友元函数重载实现" class="headerlink" title="模板运算符友元函数重载实现"></a>模板运算符友元函数重载实现</h3><p>1、+作为友元运算符重载<br>(1)友元函数在class内实现，ok，但是因为是友元实现的，所以参数要有2个<br>(2)友元函数在class外实现，不ok，编译无法通过<br>(3)友元函数的第三种实现，ok<br>上述三种情况下的代码实现 在《2、+=作为友元运算符重载》中 给出了</p>
<p>2、+=作为友元运算符重载<br>(1)友元函数在class内实现，ok，但必须带2个参数，带1个不行 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;<span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;<span class="comment">//自定义构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span>;<span class="comment">//友元函数，重定义一个U,不与T冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//运算符重载函数</span></span><br><span class="line">    <span class="keyword">friend</span> People&lt;T&gt; <span class="keyword">operator</span>+(People&lt;T&gt;&amp; a, People&lt;T&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        People&lt;T&gt; tmp;</span><br><span class="line"></span><br><span class="line">        tmp.age = a.age + b.age;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> People&lt;T&gt;&amp; <span class="keyword">operator</span>+=(People&lt;T&gt;&amp; a, People&lt;T&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        a.age += b.age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span>, <span class="title">c1</span><span class="params">(<span class="number">2.222</span>)</span>, c2</span>;</span><br><span class="line">    c2 = c + c1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line">    c2 += c;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span>, <span class="title">b1</span><span class="params">(<span class="string">&quot;linux&quot;</span>)</span>, b2</span>;</span><br><span class="line">    b2 = b + b1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line">    b2 += b;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)友元函数在class外实现，ok</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; People&lt;T&gt;&amp; <span class="keyword">operator</span>+=(People&lt;T&gt; &amp;a, People&lt;T&gt; &amp;b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;<span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;<span class="comment">//自定义构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span>;<span class="comment">//友元函数，重定义一个U,不与T冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//运算符重载函数</span></span><br><span class="line">    <span class="keyword">friend</span> People&lt;T&gt; <span class="keyword">operator</span>+(People&lt;T&gt;&amp; a, People&lt;T&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        People&lt;T&gt; tmp;</span><br><span class="line"></span><br><span class="line">        tmp.age = a.age + b.age;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tmp;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> People&lt;T&gt;&amp; <span class="keyword">operator</span>+=&lt;T&gt;(People&lt;T&gt;&amp; a, People&lt;T&gt;&amp; b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; People&lt;T&gt;&amp; <span class="keyword">operator</span>+=(People&lt;T&gt; &amp;a, People&lt;T&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">        a.age += b.age;</span><br><span class="line">        <span class="keyword">return</span> a;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span>, <span class="title">c1</span><span class="params">(<span class="number">2.222</span>)</span>, c2</span>;</span><br><span class="line">    c2 = c + c1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line">    c2 += c;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;wwwwedsfs&quot;</span>)</span>, <span class="title">b1</span><span class="params">(<span class="string">&quot;ooosdfsdfsdqw&quot;</span>)</span>, b2</span>;</span><br><span class="line">    b2 = b + b1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line">    b2 += b;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3)友元函数的第三种实现，ok</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;<span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;<span class="comment">//自定义构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span>;<span class="comment">//友元函数，重定义一个U,不与T冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//运算符重载函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> People&lt;U&gt; <span class="keyword">operator</span>+(People&lt;U&gt;&amp; a, People&lt;U&gt;&amp; b);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> People&lt;U&gt;&amp; <span class="keyword">operator</span>+=(People&lt;U&gt;&amp; a, People&lt;U&gt;&amp; b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; People&lt;U&gt; <span class="keyword">operator</span>+(People&lt;U&gt;&amp; a, People&lt;U&gt;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    People&lt;T&gt; tmp;</span><br><span class="line"></span><br><span class="line">    tmp.age = a.age + b.age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; People&lt;U&gt;&amp; <span class="keyword">operator</span>+=(People&lt;U&gt;&amp; a, People&lt;U&gt;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    a.age += b.age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span>, <span class="title">c1</span><span class="params">(<span class="number">2.222</span>)</span>, c2</span>;</span><br><span class="line">    c2 = c + c1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line">    c2 += c;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span>, <span class="title">b1</span><span class="params">(<span class="string">&quot;linux&quot;</span>)</span>, b2</span>;</span><br><span class="line">    b2 = b + b1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line">    b2 += b;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板类的继承"><a href="#模板类的继承" class="headerlink" title="模板类的继承"></a>模板类的继承</h3><p>1、模板类继承的多种情况（常见的）<br>类模板：不确定的类，类中用到了模板<br>模板类：确定的类，类中用到了模板</p>
<p>(1)类模板 继承 类模板<br>(2)类模板 继承 模板类<br>(3)类模板 继承 普通类<br>(4)普通类 继承 模板类</p>
<p>2、类模板继承类模板<br>(1)单模板参数，类模板继承类模板<br>(2)代码实战中学习</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    T x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">People</span>(T myx):<span class="built_in">x</span>(myx)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> People&lt;T&gt;::<span class="built_in">print</span>(<span class="keyword">void</span>)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">man</span>:</span><span class="keyword">public</span> People&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">man</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">man</span>(T myy):<span class="built_in">y</span>(myy)&#123;&#125;;</span><br><span class="line">    <span class="built_in">man</span>(T a, T b):People&lt;T&gt;(a),<span class="built_in">y</span>(b)&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">man</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> man&lt;T&gt;::<span class="built_in">print</span>(<span class="keyword">void</span>)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// (1)类模板 继承 类模板</span></span><br><span class="line">    <span class="function">People&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">man&lt;<span class="keyword">int</span>&gt; <span class="title">m</span><span class="params">(<span class="number">4</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">print</span>();</span><br><span class="line">    m.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)总结：在继承时，相当于用子类的模板参数T去实例填充了父类的模板参数T<br>(4)作用：用于构建模板化的类体系，写模板化的大框架</p>
<p>3、多模板参数<br>(1)2个或2个以上模板参数的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    T1 x1; <span class="comment">//double</span></span><br><span class="line">    T2 x2;  <span class="comment">//int</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">People</span>(T1 myx1, T2 myx2):<span class="built_in">x1</span>(myx1),<span class="built_in">x2</span>(myx2)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U1, <span class="keyword">typename</span> U2&gt; <span class="class"><span class="keyword">class</span> <span class="title">man</span>:</span>People&lt;U1 ,U2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    U1 y1;  <span class="comment">// int               这里就决定了U1是int ，U2是double， 因此People&lt;U2 ,U1&gt;为People(double, int)，按照符号来决定</span></span><br><span class="line">    U2 y2;  <span class="comment">// double</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">man</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">man</span>( U1 myx1, U2 myx2, U1 myy1, U2 myy2):People&lt;U1, U2&gt;(myx1, myx2),<span class="built_in">y1</span>(myy1),<span class="built_in">y2</span>(myy2)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">man</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U1, <span class="keyword">typename</span> U2&gt; <span class="keyword">void</span> man&lt;U1, U2&gt;::<span class="built_in">print</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this-&gt;x1 = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x1 &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this-&gt;x2 = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x2 &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this-&gt;y1 = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;y1 &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this-&gt;y2 = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;y2 &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双模板参数</span></span><br><span class="line">    <span class="function">man&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; <span class="title">m</span><span class="params">(<span class="number">4</span>, <span class="number">3.3</span>, <span class="number">5</span>, <span class="number">6.6</span>)</span></span>;</span><br><span class="line">    m.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：多个模板参数是按照顺序对应的</p>
<p>4、类模板 继承 模板类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T attribute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(T my_attitude):<span class="built_in">attribute</span>(my_attitude)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> People&lt;T&gt;::<span class="built_in">print</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;attribute = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;attribute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span> <span class="keyword">public</span> People&lt;<span class="keyword">double</span>&gt;<span class="comment">//在这里将People类确定为double</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    U P_attribute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Man</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">Man</span>(<span class="keyword">double</span> a, U b):People&lt;<span class="keyword">double</span>&gt;(a),<span class="built_in">P_attribute</span>(b)&#123;&#125;;<span class="comment">//这里的a的类型也由此确定了</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Man_print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">void</span> Man&lt;U&gt;::<span class="built_in">Man_print</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P_attribute = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;P_attribute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Man&lt;string&gt; <span class="title">s</span><span class="params">(<span class="number">6.666</span>,<span class="string">&quot;asdasd&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">print</span>();</span><br><span class="line">    s.<span class="built_in">Man_print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、类模板 继承 普通类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> attribute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(<span class="keyword">double</span> my_attitude):<span class="built_in">attribute</span>(my_attitude)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">People::print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;attribute = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;attribute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span> <span class="keyword">public</span> People<span class="comment">//</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    U P_attribute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Man</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">Man</span>(<span class="keyword">double</span> a, U b):<span class="built_in">People</span>(a),<span class="built_in">P_attribute</span>(b)&#123;&#125;;<span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Man_print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">void</span> Man&lt;U&gt;::<span class="built_in">Man_print</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P_attribute = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;P_attribute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Man&lt;string&gt; <span class="title">s</span><span class="params">(<span class="number">6.666</span>,<span class="string">&quot;asdasd&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">print</span>();</span><br><span class="line">    s.<span class="built_in">Man_print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、普通类 继承 模板类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T attribute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(T my_attitude):<span class="built_in">attribute</span>(my_attitude)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> People&lt;T&gt;::<span class="built_in">print</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;attribute = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;attribute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span> <span class="keyword">public</span> People&lt;<span class="keyword">double</span>&gt;<span class="comment">//在这里将People类确定为double</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string P_attribute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Man</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">Man</span>(<span class="keyword">double</span> a, string b):People&lt;<span class="keyword">double</span>&gt;(a),<span class="built_in">P_attribute</span>(b)&#123;&#125;;<span class="comment">//这里的a的类型也由此确定了</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Man_print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Man::Man_print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P_attribute = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;P_attribute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Man <span class="title">s</span><span class="params">(<span class="number">6.666</span>,<span class="string">&quot;asdasdsdfsdfoo&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">print</span>();</span><br><span class="line">    s.<span class="built_in">Man_print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非类型模板参数和模板类型推导"><a href="#非类型模板参数和模板类型推导" class="headerlink" title="非类型模板参数和模板类型推导"></a>非类型模板参数和模板类型推导</h3><p>1、非类型模版参数<br>详解阅读：参考 <a href="https://blog.csdn.net/lanchunhui/article/details/49634077">https://blog.csdn.net/lanchunhui/article/details/49634077</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> MAXSIZE&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T elems[MAXSIZE];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">         Stack&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; int10Stack;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非类型模板参数是有类型限制的。一般而言，它可以是常整数（包括enum枚举类型）或者指向外部链接对象的指针。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、模板的本质<br>参数化：将其作为参数一样，通过传参确定<br>(1)类型参数化<br>(2)值参数化<br>(3)类型和值都参数化<br>(4)本质：延迟绑定</p>
<p>3、类型推导的隐式类型转换<br>(1)在决定模板参数类型前，编译器执行隐式类型转换，有时候实际类型和看起来会不同<br>(2)编译器用值类型实例化函数模板，而不是用相应的引用类型<br>(3)编译器用指针类型实例化函数模板，而不是相应的数组类型<br>(4)去除const修饰，绝不会用const类型实例化函数模板，总是用相应的非const类型<br>(5)对于指针来说，指针和 const 指针是不同的类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">（<span class="number">2</span>）</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;</span><br><span class="line">People&lt;b&gt;<span class="comment">//实例化时会将int&amp; 转换为 int</span></span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(a)</span></span>;                <span class="comment">// 数组做实参，实际实参不是数组而是指针</span></span><br><span class="line">People&lt;a&gt;</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">People&lt;a&gt;<span class="comment">//实例化时会去除const</span></span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1;</span><br><span class="line"><span class="keyword">int</span> *p2;</span><br></pre></td></tr></table></figure>

<p>4、模板和库<br>(1)模板无法单独编译，也就不能通过lib连接静态库的形式隐藏实现<br>(2)模板通常会把声明和定义写在头文件里，所以c++的模板总是开源的<br>(3)说明typename的一种用法，这种用法里typename不等同于class<br>详解阅读：<a href="https://www.cnblogs.com/cthon/p/9201649.html">https://www.cnblogs.com/cthon/p/9201649.html</a></p>
<h2 id="STL的容器类和迭代器"><a href="#STL的容器类和迭代器" class="headerlink" title="STL的容器类和迭代器"></a>STL的容器类和迭代器</h2><h3 id="STL的容器类介绍"><a href="#STL的容器类介绍" class="headerlink" title="STL的容器类介绍"></a>STL的容器类介绍</h3><p>1、何为容器<br>(1)顾名思义，容器就是盛放东西的东西，这里被盛放的一般是数据对象，用来盛放的是容器类<br>(2)计算机中一切皆是数据，<strong>数据存储只能在内存中，而容器类是用做容器的内存的管理方法</strong><br>(3)容器类的内核就是：<strong>数据结构 (数据在内存中的排放、存储方法)+ 算法(数据的运算、处理，如排序)</strong><br>  数据结构 -&gt; 类的成员变量<br>  算法     -&gt; 类的成员方法<br>(4)C语言语法内置的数组和结构体，就是语言源生支持的容器（但并未提供相应的算法，不过通过库函数补充了部分算法）<br>(5)C++容器通过类库方式提供，容器类库被模板技术泛化后，就是STL容器了。STL一般指标准模板库。 标准模板库（Standard Template Library，STL） </p>
<p>2、STL有哪些容器类<br>(1)<strong>序列容器</strong>。<br>元素在容器中的位置同元素的值无关，即容器不是排序的（类似于C数组）。包括array、vector、deque、list、forward_list等几个。<br>(2)<strong>排序容器</strong>。<br>数据插入时即自动按照值从小到大排列好。包括set、multiset、map、mutilmap等。<br>(3)<strong>哈希容器</strong>。<br>哈希容器中的元素是未排序的，元素的位置由哈希函数确定，即遵守一定规则的&lt;key,value&gt;对式存储。包括unordered_set、unordered_map、hash_set、hash_multiset、hash_map、hash_multimap等 </p>
<p>3、容器类如何学习<br>(1)<strong>容器类就是STL的核心</strong>，STL其他技术点都围绕容器类开展<br>(2)可见<strong>STL的本质其实就是一套模板技术泛化类型的C++基本数据结构和算法类库</strong><br>(3)本部分文章会集中细致讲几个STL序列容器array、vector等，其他容器类似情况就简略讲过了<br>(4)第一层为学会使用stl容器，第二层为能合理使用stl容器，第三层为理解stl背后设计，第四层为自己能写新的stl容器。 </p>
<h3 id="序列容器之array"><a href="#序列容器之array" class="headerlink" title="序列容器之array"></a>序列容器之array</h3><p>1、array的特性<br>(1)<strong>array是定长、同类型多元素、内存中连续排布的一种容器</strong><br>(2)array其实就是C语言数组的C++ template封装，定义于头文件array</p>
<p>2、array的学习方法<br>(1)参考文档：<a href="https://zh.cppreference.com/w/cpp/container/array">https://zh.cppreference.com/w/cpp/container/array</a><br>(2)挨个理解文档相关所有元素<br>隐式声明与显示声明：<a href="https://www.cnblogs.com/snandy/archive/2011/03/04/1970777.html">https://www.cnblogs.com/snandy/archive/2011/03/04/1970777.html</a> </p>
<p>3、array的构造和初始化<br>(1)和C数组兼容的初始化方式<br>(2)需要C++11或以上标准来支持</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">linux中使用g++编译时需加上：-std=c++<span class="number">11</span>选项</span><br><span class="line">低版本的ubuntu需要，高版本的ubuntu安装的g++并不需要</span><br></pre></td></tr></table></figure>

<p>4、array的元素访问<br>(1)at方法<br>(2)operator[]实现的C数组式访问<br>(3)front和back方法返回第1个和最后1个元素<br>(4)data返回真实存储内存中首元素首地址的值<br>如果array的元素访问越界了，那么编译时没问题，但是运行时会抛出异常</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (1)array是定长、同类型多元素、内存中连续排布的一种容器</span></span><br><span class="line"><span class="comment">// (2)array其实就是C语言数组的C++ template封装，定义于头文件array</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;array&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a1;             <span class="comment">// 定义但是未初始化</span></span><br><span class="line">    <span class="comment">//array&lt;int, 3&gt; a2(1, 3, 5);    // 编译报错，因为这里相当于调用构造函数去初始化，C++不可能提供那么多个构造函数</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a2&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;    <span class="comment">// 定义并初始化 ，聚合初始化</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a3 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;; <span class="comment">// 初始化赋值</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a4 = a3;        <span class="comment">// 拷贝构造</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[0] = &quot;</span> &lt;&lt; a2[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[1] = &quot;</span> &lt;&lt; a2[<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[2] = &quot;</span> &lt;&lt; a2[<span class="number">2</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    a2[<span class="number">0</span>] = <span class="number">11</span>;                  <span class="comment">// 访问指定的元素，但是没有进行越界检查</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[0] = &quot;</span> &lt;&lt; a2[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    a2.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="number">33</span>;               <span class="comment">// 访问指定的元素，同时进行越界检查</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[1] = &quot;</span> &lt;&lt; a2.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//a2.at(3) = 33; //编译报错，越界了，编译没问题，运行时抛出异常 //terminate called after throwing an instance of &#x27;std::out_of_range&#x27;</span></span><br><span class="line"></span><br><span class="line">    a2[<span class="number">4</span>] = <span class="number">11</span>;                   <span class="comment">// 这里已经越界访问了，但是不一定会报错，因为这赋值是不会进行越界检查的</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[4] = &quot;</span> &lt;&lt; a2[<span class="number">4</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2.front = &quot;</span> &lt;&lt; a2.<span class="built_in">front</span>() &lt;&lt;endl;  <span class="comment">// 访问第一个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2.back = &quot;</span> &lt;&lt; a2.<span class="built_in">back</span>() &lt;&lt; endl;   <span class="comment">// 访问最后一个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2.size = &quot;</span> &lt;&lt; a2.<span class="built_in">size</span>() &lt;&lt; endl;   <span class="comment">// 返回容纳的元素数</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、array的容量设置和获取<br>(1)容量设置只能在定义时一次设定，且必须设定，设定后再不能改<br>(2)empty：若容器为空则为 true ，否则为 false<br>(3)size：容器中的元素数量。<br>(4)max_size：返回根据系统或库实现限制的容器可保有的元素最大数量</p>
<p>6、操作<br>(1)fill：以指定值填充容器<br>(2)swap：交换内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array &lt;<span class="keyword">int</span>, 3&gt; a1&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    array &lt;<span class="keyword">int</span>, 3&gt; a2&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[0] = &quot;</span> &lt;&lt; a1[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[1] = &quot;</span> &lt;&lt; a1[<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[2] = &quot;</span> &lt;&lt; a1[<span class="number">2</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[0] = &quot;</span> &lt;&lt; a2[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[1] = &quot;</span> &lt;&lt; a2[<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[2] = &quot;</span> &lt;&lt; a2[<span class="number">2</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x  = get&lt;<span class="number">0</span>&gt;(a1);  <span class="comment">// 获取第0个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt;endl;  </span><br><span class="line"></span><br><span class="line">    a1.<span class="built_in">swap</span>(a2); <span class="comment">//等价于 std::swap(a1, a2);</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[0] = &quot;</span> &lt;&lt; a1[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[1] = &quot;</span> &lt;&lt; a1[<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[2] = &quot;</span> &lt;&lt; a1[<span class="number">2</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[0] = &quot;</span> &lt;&lt; a2[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[1] = &quot;</span> &lt;&lt; a2[<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[2] = &quot;</span> &lt;&lt; a2[<span class="number">2</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    a1.<span class="built_in">fill</span>(<span class="number">0</span>);   <span class="comment">// 将 array 填充 0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[0] = &quot;</span> &lt;&lt; a1[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[1] = &quot;</span> &lt;&lt; a1[<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[2] = &quot;</span> &lt;&lt; a1[<span class="number">2</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    array &lt;string, 1&gt; a3&#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a3.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、非成员函数<br>(1)operator重载函数<br>(2)get<br>(3)swap<br>(4)to_array (C++20 起)，低版本编译器并不支持</p>
<p>8、辅助类tuple_size、tuple_element<br>tuple_size提供作为编译时常量表达式访问 std::array 中元素数量的方法。<br>tuple_element使用类 tuple 接口，提供 array 元素类型的编译时带下标访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[tuple_size&lt;T&gt;::value];<span class="comment">// 能用于编译时</span></span><br><span class="line">        cout &lt;&lt; tuple_size&lt;T&gt;::value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        array&lt;<span class="keyword">int</span>, 3&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        array&lt;string, 4&gt; b = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">         定义 a 并获取位于位置 <span class="number">0</span> 的元素类型,类型为<span class="keyword">int</span></span><br><span class="line">        <span class="keyword">using</span> T = tuple_element&lt;<span class="number">0</span>, <span class="keyword">decltype</span>(a)&gt;::type; <span class="comment">//这里的using作用类似于C中的typedef，给数据类型起别名</span></span><br><span class="line">        T c = <span class="number">6</span>;</span><br><span class="line">        cout &lt;&lt; is_same&lt;T, <span class="keyword">int</span>&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//判断T是否为int，是否都是int类型</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">test</span>(a);</span><br><span class="line">        <span class="built_in">test</span>(b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器的引入"><a href="#迭代器的引入" class="headerlink" title="迭代器的引入"></a>迭代器的引入</h3><p>1、迭代器是干嘛的<br>(1)迭代器就是能 <strong>通过移动 来 遍历处理 的 一种机制</strong><br>(2)C语言中遍历数组元素，用指针*p++方式，指针变量就是遍历迭代器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*        </span></span><br><span class="line"><span class="comment">        for (p=第1个元素; p!=最后一个元素; p++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">                *p就是每一个元素</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>(3)思考：结构体元素能够通过指针运算来遍历？<br>答：不能。因为结构体中元素的类型一般是不同的，无法得知访问下一个元素，地址的偏移量是多少</p>
<p>2、关于迭代器的分析<br>(1)每种容器理论上都可以被遍历，不存在不能被遍历的容器<br>(2)每种容器的遍历实现都可能不同，要结合容器和元素的特点来具体实现<br>(3)<strong>迭代器内部原理肯定是通过指针操作（地址运算）来实现</strong><br>(4)迭代器就是C++为我们设计的一个高层次的“指针”，高层指针是面向容器中的元素的，实现对容器中元素的遍历。其工作时最终会映射到底层指针(即我们C语言中使用指针的方法) </p>
<p>3、C++实际是这么设计迭代器的<br>(1)<strong>所有的迭代器有一个共同基类（接口），规定了迭代器的基本行为规范接口</strong><br>(2)<strong>每个容器类中均包含了一个专属化迭代器成员变量</strong>，这个专属化迭代器专门针对该容器的特点实现了迭代器应该有的所有接口<br>(3)需要遍历某STL容器时，只需要直接调出该容器的这个迭代器成员变量直接用即可，固定名字为iterator </p>
<p>4、典型的迭代器用法<br>(1)代码实战，用迭代器来实现遍历array</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt;::iterator iter;  <span class="comment">//这是一个可读可写的迭代器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">        *iter = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt;::const_iterator citer;  <span class="comment">//这是一个只读的迭代器</span></span><br><span class="line">    <span class="keyword">for</span> ( citer = a.<span class="built_in">cbegin</span>(); citer != a.<span class="built_in">cend</span>(); citer++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; *citer &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//*citer = 3;  //报错 error: assignment of read-only location ‘* citer’</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际写代码中，一般不会像前面这样写，会利用auto</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a1 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = a1.<span class="built_in">begin</span>(); iter != a1.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = a1.<span class="built_in">rbegin</span>(); iter != a1.<span class="built_in">rend</span>(); iter++)   <span class="comment">// 逆向迭代器</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)begin()和end()方法是得到容器遍历的开始和结尾的套路化方法</p>
<h3 id="迭代器的几个细节问题"><a href="#迭代器的几个细节问题" class="headerlink" title="迭代器的几个细节问题"></a>迭代器的几个细节问题</h3><p>1、const与非const<br>(1)begin和end返回可读可写的迭代器，而cbegin和cend返回const的只读迭代器<br>(2)代码验证迭代器的读写权限</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt;::iterator iter;<span class="comment">//可读可写</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt;::const_iterator citer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; iter &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">        *iter = <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(citer = a.<span class="built_in">cbegin</span>(); citer != a.<span class="built_in">cend</span>(); citer++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;citer = &quot;</span> &lt;&lt; citer &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*citer = &quot;</span> &lt;&lt; *citer &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; iter &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">        *iter = <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> citer = a.<span class="built_in">cbegin</span>(); citer != a.<span class="built_in">cend</span>(); citer++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;citer = &quot;</span> &lt;&lt; citer &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*citer = &quot;</span> &lt;&lt; *citer &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、begin和end的半开半闭区间<br>(1)begin返回第0个元素的迭代器（类似于C数组的首元素首地址指针）<br>(2)end指向的不是末尾元素的迭代器，而是末尾元素的（实际不存在的）下一个元素的迭代器<br>(3)前闭后开区间，经常记做[begin end)，这样设计是为了写循环遍历时方便 </p>
<p>3、正向和逆向迭代器<br>(1)rbegin和rend返回逆向迭代器<br>(2)逆向迭代器的begin是最末尾元素，而end是第0个元素去（实际不存在的）前面1个元素的迭代器<br>(3)逆向迭代器++是向前移动，而–是向后移动</p>
<p>4、迭代器越界会怎么样<br>(1)<strong>和数组越界类似，编译时不审查，运行时会崩溃</strong><br>(2)<strong>不管是正向还是逆向迭代器，++不到end，–不到begin，就不会越界</strong></p>
<h3 id="STL的不同类型迭代器"><a href="#STL的不同类型迭代器" class="headerlink" title="STL的不同类型迭代器"></a>STL的不同类型迭代器</h3><p>1、C++17前共有5种迭代器<br>(1)InputIterator，输入迭代器。只能从容器内读出而不能向容器内写入，只能单次读出（读出过一次后不保证再次操作仍然可以，想想流输入输出），只能++走不能–走（就是单向的），不能保证第二次遍历容器时，顺序不变。输入迭代器适用于单通只读型算法。<br>(2)OutputIterator，输出迭代器。用于将信息传输给容器（修改容器中元素的值），但是不能读取。（显示器就是只能写不能读的设备，可用输出容器来表示它）只能++走不能–走（就是单向的），输出迭代器适用于单通只写型算法。<br>(3)ForwardIterator，前向迭代器。只能++走不能–走（就是单向的）<br>(4)BidirectionalIterator，双向迭代器。既能++也可以–，双向移动。<br>(5)RandomAccessIterator，随机访问迭代器。能双向移动，并且可以单次跨越多个元素移动。 </p>
<p>2、C++17新增1种迭代器<br>(1)contiguousIterator,连续迭代器。所指向的逻辑相邻元素也在内存中物理上相邻。</p>
<p>3、STL的6种迭代器总结<br>(1)每种迭代器更应该被看作是具有某些预定义特征（或者满足某接口要求）的一个迭代器的实现。</p>
<p>(2)这些迭代器彼此之间有功能重叠，譬如随机访问迭代器可由双向迭代器扩展而来，详见文档：<a href="https://zh.cppreference.com/w/cpp/iterator">https://zh.cppreference.com/w/cpp/iterator</a></p>
<p>(3)为何定义多种迭代器？<br>  是为了适配容器特性和泛型算法，后面会看到array的迭代器既是一个双向迭代器，也是一个随机访问迭代器。</p>
<p>4、C++20的新迭代器<br>(1)C++20中重新实现了基于concept的新的迭代器体系<br>(2)原有的模板都被加了前缀Legecy，但很长时间仍然可用，甚至还是主流<br>(3)基于concept的新迭代器主要在类型约束和模板特化方面做了优化<br>(4)C++20目前还刚开始，可以先不管，先学好原有的，后面再扩展去学C++20新特性 </p>
<h3 id="序列容器之Vector"><a href="#序列容器之Vector" class="headerlink" title="序列容器之Vector"></a>序列容器之Vector</h3><p>参考学习文档:<a href="https://zh.cppreference.com/w/cpp/container/vector">https://zh.cppreference.com/w/cpp/container/vector</a><br>1、Vector的特征<br>(1)Vector和Array相同点是：都是数组、都是contiguousIterator、容器内元素种类都相同<br>(2)Vector和Array不同点是：<strong>Array是固定数组；Vector是动态数组，可以按需扩展数组大小</strong><br>(3)<strong>vector 的存储是自动管理的，按需扩张收缩。</strong><br>(4)<strong>vector 通常占用多于静态数组的空间，因为要分配更多内存以管理将来的增长</strong><br>(5)vector 所用的内存分配方式不在每次插入元素时，而<strong>只在额外内存耗尽时重分配</strong>。 </p>
<p>使用例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = v.<span class="built_in">cbegin</span>(); iter != v.<span class="built_in">cend</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.size = &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.max_size = &quot;</span> &lt;&lt; v.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.capacity = &quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.size = &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.max_size = &quot;</span> &lt;&lt; v.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;push_back v.capacity  = &quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.size = &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.max_size = &quot;</span> &lt;&lt; v.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;push_back v.capacity = &quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : v)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*iter = <span class="number">1</span></span><br><span class="line">*iter = <span class="number">3</span></span><br><span class="line">*iter = <span class="number">5</span></span><br><span class="line">v.size = <span class="number">3</span></span><br><span class="line">v.max_size = <span class="number">4611686018427387903</span></span><br><span class="line">v.capacity = <span class="number">3</span></span><br><span class="line">v.size = <span class="number">4</span></span><br><span class="line">v.max_size = <span class="number">4611686018427387903</span></span><br><span class="line">push_back v.capacity  = <span class="number">6</span></span><br><span class="line">v.size = <span class="number">5</span></span><br><span class="line">v.max_size = <span class="number">4611686018427387903</span></span><br><span class="line">push_back v.capacity = <span class="number">6</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">i = <span class="number">3</span></span><br><span class="line">i = <span class="number">5</span></span><br><span class="line">i = <span class="number">7</span></span><br><span class="line">i = <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h3 id="序列容器之list"><a href="#序列容器之list" class="headerlink" title="序列容器之list"></a>序列容器之list</h3><p>参考学习：<a href="https://zh.cppreference.com/w/cpp/container/list">https://zh.cppreference.com/w/cpp/container/list</a><br>(1) list 通常实现为双向链表。<br>(2) 可以高效地进行插入删除元素，但是随机访问却比较慢。<br>(3) list不支持随机存取，要访问第n个元素，必须先遍历前n-1个元素才能访问第n个元素。因此，list没有下标[ ]操作，也没有at()接口。</p>
<p>使用例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; l = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;; </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l.size = &quot;</span> &lt;&lt; l.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l.max_size = &quot;</span> &lt;&lt; l.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;is or not empty :&quot;</span> &lt;&lt; l.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : l)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    l.<span class="built_in">assign</span>(<span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    l.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">    l.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">    l.<span class="built_in">insert</span>(l.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">    l.<span class="built_in">sort</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = l.<span class="built_in">begin</span>(); iter != l.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">l.size = <span class="number">6</span></span><br><span class="line">l.max_size = <span class="number">768614336404564650</span></span><br><span class="line">is <span class="keyword">or</span> <span class="keyword">not</span> empty :<span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">9</span> </span><br></pre></td></tr></table></figure>

<h3 id="序列容器之deque"><a href="#序列容器之deque" class="headerlink" title="序列容器之deque"></a>序列容器之deque</h3><p>(1) deque容器为一个给定类型的元素进行线性处理，像向量一样，它能够快速地随机访问任一个元素，并且能够高效地插入和删除容器的尾部元素。<br>(2) 它又与vector不同，deque支持高效插入和删除容器的头部元素，因此也叫做双端队列。<br>参考学习：<br><a href="https://blog.csdn.net/u010710458/article/details/79540505">https://blog.csdn.net/u010710458/article/details/79540505</a><br><a href="https://zh.cppreference.com/w/cpp/container/deque">https://zh.cppreference.com/w/cpp/container/deque</a></p>
<p>使用例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建容纳整数的 deque</span></span><br><span class="line">    std::deque&lt;<span class="keyword">int</span>&gt; d = &#123;<span class="number">7</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">8</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 从 deque 的首尾添加整数</span></span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">13</span>);</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">25</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 迭代并打印 deque 的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : d) &#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>

<h3 id="序列容器选择"><a href="#序列容器选择" class="headerlink" title="序列容器选择"></a>序列容器选择</h3><p>如何选择这四个容器中哪一个，应根据你的需要而定，具体可以遵循下面的原则：</p>
<ol>
<li>   <strong>如果你需要高效的随即存取，而不在乎插入和删除的效率，使用array或vector，前者是固定大小的数组，后者是可变大小的数组</strong></li>
<li>   <strong>如果你需要大量的插入和删除，而不关心随即存取，则应使用list</strong></li>
<li>   <strong>如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque</strong></li>
</ol>
<p>注意：C++提供的容器还有很多，适用于各种场景，但是使用方法都大同小异，这里不再赘述。有需要查询<a href="https://zh.cppreference.com/">C++ 参考手册</a>即可。</p>
<h2 id="STL的泛型算法使用详解"><a href="#STL的泛型算法使用详解" class="headerlink" title="STL的泛型算法使用详解"></a>STL的泛型算法使用详解</h2><h3 id="什么是泛型算法"><a href="#什么是泛型算法" class="headerlink" title="什么是泛型算法"></a>什么是泛型算法</h3><p>1、从容器说起<br>(1)容器是数据结构，是对数据的封装<br>(2)各容器都提供了少量处理元素操作的方法，譬如sort，但没有提供更多<br>(3)同样的操作譬如sort，在不同容器中底层处理肯定会不同<br>(4)<strong>泛型算法是独立于容器类的一些操作方法，可以用于多种容器，所以叫“泛型”算法</strong><br>(5)泛型算法实际上是<strong>更高层次的抽象</strong>，所以设计和实现的难度很大，这也是<strong>STL的核心技术</strong></p>
<p>2、泛型算法使用基础<br>(1)泛型算法学习参考：<a href="https://zh.cppreference.com/w/cpp/algorithm">https://zh.cppreference.com/w/cpp/algorithm</a><br>  泛型算法在元素范围上操作，即其操作的是元素的值。注意范围定义为 [first, last) ，其中 last 指代要查询或修改的最后元素的后一个元素。<br>(2)泛型算法所在头文件 </p>
<h3 id="泛型算法使用实战"><a href="#泛型算法使用实战" class="headerlink" title="泛型算法使用实战"></a>泛型算法使用实战</h3><p>1、泛型算法和容器迭代器的适配<br><strong>(1)算法中对迭代器有要求<br>(2)容器中包含的迭代器有特性<br>(3)2者兼容才可合使用，否则不可使用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; class RandomIt &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">( RandomIt first, RandomIt last )</span></span>;(C++<span class="number">20</span> 前)</span><br><span class="line"></span><br><span class="line">类型要求:</span><br><span class="line">-RandomIt 必须满足值可交换 (ValueSwappable) 和 老式随机访问迭代器 (LegacyRandomAccessIterator) 的要求。</span><br><span class="line">-解引用 RandomIt 结果的类型必须满足可移动赋值 (MoveAssignable) 和可移动构造 (MoveConstructible) 的要求。</span><br></pre></td></tr></table></figure>

<p>2、泛型算法使用举例<br>下面的这个sort函数并非这几个容器自带的算法，而是泛型算法sort：<br><a href="https://zh.cppreference.com/w/cpp/algorithm/sort">https://zh.cppreference.com/w/cpp/algorithm/sort</a><br>(1)使用sort为array默认排序<br>(2)使用sort为list默认排序<br>(3)使用sort为list由大到小排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>();)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter++ &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="keyword">int</span>, 5&gt; a1&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a2&#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; a3&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a1.<span class="built_in">begin</span>(), a1.<span class="built_in">end</span>());<span class="comment">//默认从小到大的顺序排列</span></span><br><span class="line">    <span class="built_in">sort</span>(a2.<span class="built_in">begin</span>(), a2.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());<span class="comment">//按从大到小的顺序排列</span></span><br><span class="line">    a3.<span class="built_in">sort</span>();<span class="comment">//list的迭代器不支持随机访问，故而不可使用泛型算法，可使用其自带的sort方法</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(a1);</span><br><span class="line">    <span class="built_in">print</span>(a2);</span><br><span class="line">    <span class="built_in">print</span>(a3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="谓词predicate和函数对象引入"><a href="#谓词predicate和函数对象引入" class="headerlink" title="谓词predicate和函数对象引入"></a>谓词predicate和函数对象引入</h3><p>1、何为谓词<br>(1)谓词就是可以<strong>做谓语的词，就是“动词、动作”性质语义的词</strong><br>(2)<strong>C/C++中的函数function就是典型的谓词语义</strong><br>(3)C++ STL中的谓词类似这样：<strong>bool func(T&amp; a); 或者 bool func(T&amp;a, T&amp; b);返回值是bool类型</strong><br>(4)常见的谓词：<strong>函数,函数指针,lambda表达式,函数对象,库定义的函数对象</strong></p>
<p>2、函数对象引入<br>(1)函数对象 function object， 也叫仿函数 functor<br>(2)函数对象在语法上不是函数，而是个类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a2.<span class="built_in">begin</span>(), a2.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">greater就是个函数对象。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; class RandomIt, class Compare &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">( RandomIt first, RandomIt last, Compare comp )</span></span>;</span><br></pre></td></tr></table></figure>
<p>(3)函数对象在<strong>调用形式上看起来像个函数</strong></p>
<p>3、函数对象案例实践<br>(1)写一个函数，判断传参是否大于0<br>(2)用函数对象实现，对比、分析、体会</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsGreater_function</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a&gt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsGreater_class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//我们通过()的运算符重载函数实现同样的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(U a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a&gt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用函数实现</span></span><br><span class="line">    <span class="keyword">bool</span> b = <span class="built_in">IsGreater_function</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    b = <span class="built_in">IsGreater_function</span>(<span class="number">-5</span>);</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用函数对象实现</span></span><br><span class="line">    IsGreater_class&lt;<span class="keyword">int</span>&gt; is_greater;</span><br><span class="line">    b = <span class="built_in">is_greater</span>(<span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    b = <span class="built_in">is_greater</span>(<span class="number">-6</span>); </span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数对象的一些细节"><a href="#函数对象的一些细节" class="headerlink" title="函数对象的一些细节"></a>函数对象的一些细节</h3><p>1、自定义函数对象用于STL算法库</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的函数对象，通过字符串的个数进行比较</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mygreater</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> string s1, <span class="keyword">const</span> string s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (s1.<span class="built_in">size</span>() &gt; s2.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>();)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter++ &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;string, 3&gt; a = &#123;<span class="string">&quot;linux&quot;</span>, <span class="string">&quot;android&quot;</span>, <span class="string">&quot;harmonyos&quot;</span>&#125;; </span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());<span class="comment">//默认是根据字符串首字母的字典序进行比较的，排序按照从小到大</span></span><br><span class="line">    <span class="built_in">print</span>(a);</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), greater&lt;string&gt;());<span class="comment">//使用泛型算法提供的函数对象greater</span></span><br><span class="line">    <span class="built_in">print</span>(a);</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">mygreater</span>());<span class="comment">//使用自定义的函数对象mygreater</span></span><br><span class="line">    <span class="built_in">print</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、函数对象的优势<br>(1)<strong>函数对象可以使用template技术实现多类型支持，这比函数的重载技术更有优势</strong><br>(2)函数对象可以有<strong>自己的状态</strong>。我们可以在类中定义状态变量（类私有成员变量），这样一个函数对象在多次的调用中可以共享这个状态。比如我们可以用这个状态表示函数被调用的次数。<br>参考学习：<a href="https://www.cnblogs.com/gis-user/p/5086218.html">https://www.cnblogs.com/gis-user/p/5086218.html</a> </p>
<h3 id="STL典型泛型算法解读"><a href="#STL典型泛型算法解读" class="headerlink" title="STL典型泛型算法解读"></a>STL典型泛型算法解读</h3><p>我们随机打开一个来分析学习：<a href="https://zh.cppreference.com/w/cpp/algorithm/all_any_none_of">https://zh.cppreference.com/w/cpp/algorithm/all_any_none_of</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; class InputIt, class UnaryPredicate &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">all_of</span><span class="params">( InputIt first, InputIt last, UnaryPredicate p )</span></span>;</span><br><span class="line"></span><br><span class="line">UnaryPredicate：一元谓词，表示该谓词只接收一个参数</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Divisible</span> <span class="title">By</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> d;</span><br><span class="line">        <span class="built_in">DivisibleBy</span>(<span class="keyword">int</span> n) : <span class="built_in">d</span>(n) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n % d == <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">any_of</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), <span class="built_in">DivisibleBy</span>(<span class="number">7</span>))) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;At least one number is divisible by 7\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">any_of</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), <span class="built_in">DivisibleBy</span>(<span class="number">7</span>))中的<span class="number">7</span>对应DivisibleBy成员变量</span><br><span class="line">d，这里的<span class="built_in">DivisibleBy</span>(<span class="number">7</span>)既与构造函数有关（进行初始化），也与运算符重载函数有关（作</span><br><span class="line">为函数对象），<span class="built_in">DivisibleBy</span>(<span class="keyword">int</span> n)中的n是在迭代器遍历时内部传参的。</span><br></pre></td></tr></table></figure>

<h3 id="CPP之lamba表达式"><a href="#CPP之lamba表达式" class="headerlink" title="CPP之lamba表达式"></a>CPP之lamba表达式</h3><p>1、实践体会lamba表达式<br>(1)lambda表达式使用举例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::<span class="built_in">all_of</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), [](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>; &#125;))</span><br><span class="line">&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;All numbers are even\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lamba表达式:[](int i)&#123; return i % 2 == 0; &#125;</span></span><br></pre></td></tr></table></figure>
<p>(2)使用函数对象实现类似于lambda表达式的效果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IsEven</span>//若使用<span class="keyword">class</span>关键字，则需将重载函数作为<span class="title">public</span>成员，<span class="keyword">class</span>和<span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span>                         <span class="comment">//关键字默认权限不一样</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if (all_of(v.begin(), v.end(), [](int i) -&gt;bool &#123;return i % 2 == 0;&#125;))//方式一：使用lamba表达式</span></span><br><span class="line">    <span class="comment">//IsEven()不传参，这个()对应使用构造函数进行初始化的参数，i是内部传参，迭代器遍历时容器中的元素</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">all_of</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">IsEven</span>()))<span class="comment">//方式二：使用函数对象</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;All numbers are even\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot; Not all numbers are  even\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、lambda表达式总结<br>(1)lambda表达式就是<strong>一个匿名函数，相当于一次使用的、直接原地展开调用的函数</strong><br>(2)lambda表达式也叫<strong>闭包，就是在别的地方无法调用的封包</strong><br>(3)lambda表达式其实<strong>就是一个函数对象，在内部创建了一个重载()操作符的类</strong></p>
<p>3、lambda表达式格式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)完整格式<span class="number">5</span>部分：[参数捕获] (操作符重载函数参数) <span class="keyword">mutable</span>或exception声明 -&gt;返回值类型 &#123;函数体&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)最简单的lambda表达式：[]()&#123;&#125;，调用执行时为[]()&#123;&#125;();</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)带传参的lambda表达式：[](<span class="keyword">int</span> i)&#123;<span class="comment">//i在这里可以用&#125;</span></span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)使用<span class="keyword">auto</span>将lambda表达式定义为一个变量，再以变量方式调用</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>)使用-&gt;<span class="keyword">int</span>这种方式让lambda表达式函数返回相应类型的值</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例如下：</span><br><span class="line">        (<span class="number">2</span>) []()&#123;&#125;();</span><br><span class="line">        </span><br><span class="line">        (<span class="number">3</span>) []()&#123;cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;&#125;();</span><br><span class="line">                [](<span class="keyword">int</span> i)&#123;cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; i &lt;&lt; endl;&#125;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        (<span class="number">4</span>)、(<span class="number">5</span>) <span class="keyword">auto</span> func = [](<span class="keyword">int</span> i) -&gt;<span class="keyword">bool</span> &#123;cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; i &lt;&lt; endl; <span class="keyword">return</span> <span class="literal">false</span>;&#125;;</span><br><span class="line">        <span class="keyword">bool</span> x = <span class="built_in">func</span>(<span class="number">4</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="lambda表达式之参数捕获"><a href="#lambda表达式之参数捕获" class="headerlink" title="lambda表达式之参数捕获"></a>lambda表达式之参数捕获</h3><p>1、什么是参数捕获<br>(1)实验：在lambda表达式外面定义int a，在表达式内部试图访问<br>(2)解决：在[]中增加捕获说明即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">test</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">test</span>(<span class="keyword">int</span> t)&#123;<span class="keyword">this</span>-&gt;sum = t;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt;endl;</span><br><span class="line">        [&amp;]()&#123;sum++;cout&lt;&lt;<span class="string">&quot;lamba4: sum = &quot;</span> &lt;&lt; sum &lt;&lt;endl;&#125;();</span><br><span class="line">        [<span class="keyword">this</span>]()&#123;<span class="keyword">this</span>-&gt;sum++;cout&lt;&lt;<span class="string">&quot;lamba5: this-&gt;sum = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;sum &lt;&lt; endl;&#125;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    string b = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    [a]()&#123;cout &lt;&lt; <span class="string">&quot;lamba1: a = &quot;</span> &lt;&lt; a &lt;&lt; endl;&#125;();</span><br><span class="line">    [&amp;a]()&#123;a++; cout &lt;&lt; <span class="string">&quot;lamba2: a = &quot;</span> &lt;&lt; a &lt;&lt; endl;&#125;();</span><br><span class="line">    <span class="keyword">auto</span> func = [=](<span class="keyword">int</span> i)&#123;cout &lt;&lt; <span class="string">&quot;lamba3: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;&#125;;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">test <span class="title">s</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    s.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)总结：<strong>所谓参数捕获，就是让lambda表达式内部可以捕获并使用外部的变量</strong></p>
<p>2、lambda表达式的捕获列表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)[] 空，完全不捕获</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)[=] 等号，以值传参方式捕获（复制了一份传进来，这样表达式内修改了变量，但表达式外值</span><br><span class="line">仍未变，与引用传参的效果不同），捕获范围是表达式所在作用范围（包括所在类的<span class="keyword">this</span>）</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)[&amp;] &amp;号，以引用传参方式捕获，捕获范围是表达式所在作用范围（包括所在类的<span class="keyword">this</span>）</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)[<span class="keyword">this</span>] 只捕获lambda表达式所在类的<span class="keyword">this</span>可访问的那些</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>)[a] 仅以值方式捕获a，其他全部不捕获</span><br><span class="line"></span><br><span class="line">(<span class="number">6</span>)[&amp;a] 仅以引用方式捕获a，其他全部不捕获</span><br><span class="line"></span><br><span class="line">(<span class="number">7</span>)[a, &amp;b] 仅以值方式捕获a，以引用方式捕获b，其余完全不捕获</span><br><span class="line"></span><br><span class="line">(<span class="number">8</span>)[=, &amp;a, &amp;b] 仅以引用方式捕获a和b，其余以值方式捕获</span><br><span class="line"></span><br><span class="line">(<span class="number">9</span>)[&amp;, a, b] 仅以值方式捕获a和b，其余以引用方式捕获</span><br></pre></td></tr></table></figure>

<p>3、lambda表达式总结<br>(1)lambda表达式提供<strong>一种单次使用的函数简写方式</strong><br>(2)<strong>通过捕获列表，在lambda表达式内部也可以访问外部的变量，相当于函数传参</strong></p>
<h3 id="CPP函数适配器"><a href="#CPP函数适配器" class="headerlink" title="CPP函数适配器"></a>CPP函数适配器</h3><p>1、什么是函数适配器<br>(1)<strong>适配器，adapter，用来在不适配的2端间对接的连接器</strong><br>(2)<strong>函数适配器是在不同传参个数的函数间进行适配的技术</strong><br>示例理解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">func1</span>(<span class="keyword">int</span> a)</span><br><span class="line"><span class="built_in">func2</span>(<span class="keyword">int</span> a, <span class="keyword">char</span> b)<span class="comment">//可通过手动填充一个参数b进行适配</span></span><br><span class="line"><span class="built_in">func3</span>(<span class="keyword">int</span> a)&#123;<span class="built_in">func2</span>(a, <span class="string">&#x27;A&#x27;</span>);&#125;<span class="comment">//func3则是一个函数适配器，适配了func1与func2</span></span><br></pre></td></tr></table></figure>
<p>(3)几个概念：1元函数、2元函数、1元谓词、2元谓词<br>1元：具有一个参数<br>2元：具有两个参数<br>谓词：返回值是bool类型</p>
<p>2、C++的函数适配器<br>(1)早期C++98时，常用bind1st bind2nd<br>bind1st：预先填充第一个，释放第二个，bind2nd与其刚好相反<br>(2)C++11开始，引入加强版：std::bind</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::<span class="built_in">none_of</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), std::<span class="built_in">bind</span>(std::modulus&lt;<span class="keyword">int</span>&gt;(),                                                 std::placeholders::_1, <span class="number">2</span>)))</span><br><span class="line"><span class="comment">//std::placeholders::_1:表示释放谁，2：表示要填充的值，即将二元谓词的第一个元释放出来，第二个元预先填充，形成一个新的一元谓词</span></span><br><span class="line">&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;None of them are odd\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; class InputIt, class UnaryPredicate &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">all_of</span><span class="params">( InputIt first, InputIt last, UnaryPredicate p )</span></span>;<span class="comment">//UnaryPredicate表示一元谓词</span></span><br><span class="line"></span><br><span class="line">std::modulus::<span class="built_in"><span class="keyword">operator</span></span>()<span class="comment">//二元谓词</span></span><br><span class="line"><span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> T&amp; rhs )</span> <span class="keyword">const</span></span>;</span><br><span class="line">(C++<span class="number">14</span> 前)</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> T&amp; rhs )</span> <span class="keyword">const</span></span>;</span><br><span class="line">(C++<span class="number">14</span> 起)</span><br><span class="line">返回 lhs 除以 rhs 的余数。</span><br><span class="line"></span><br><span class="line">一元谓词和二元谓词并不适配，故需要函数适配器bind</span><br></pre></td></tr></table></figure>

<p>3、bind的学习<br>参考学习：<a href="https://blog.csdn.net/u013654125/article/details/100140328">https://blog.csdn.net/u013654125/article/details/100140328</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestFunc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> c, <span class="keyword">float</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;f = &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> bindFunc1 = <span class="built_in">bind</span>(TestFunc, placeholders::_1, <span class="string">&#x27;A&#x27;</span>, <span class="number">100.1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bindFunc1</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=================================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> bindFunc2 = <span class="built_in">bind</span>(TestFunc, placeholders::_1, placeholders::_2, <span class="number">100.1</span>);</span><br><span class="line">    <span class="built_in">bindFunc2</span>(<span class="number">10</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=================================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> bindFunc3 = <span class="built_in">bind</span>(TestFunc, placeholders::_2, placeholders::_3, placeholders::_1);</span><br><span class="line">    <span class="built_in">bindFunc3</span>(<span class="number">100.1</span>, <span class="number">30</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=================================&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> bindFunc4 = <span class="built_in">bind</span>(TestFunc, <span class="number">10</span>, placeholders::_2, placeholders::_1);</span><br><span class="line">    <span class="built_in">bindFunc4</span>(<span class="number">100.1</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="STL典型泛型算法解读-1"><a href="#STL典型泛型算法解读-1" class="headerlink" title="STL典型泛型算法解读"></a>STL典型泛型算法解读</h3><p>1、for_each、transform、范围 for 循环(C++11)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">参考学习：</span><br><span class="line">https:<span class="comment">//zh.cppreference.com/w/cpp/algorithm/for_each</span></span><br><span class="line">https:<span class="comment">//zh.cppreference.com/w/cpp/algorithm/transform</span></span><br><span class="line">https:<span class="comment">//zh.cppreference.com/w/cpp/language/range-for</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; sum += n; &#125;</span><br><span class="line">    <span class="keyword">int</span> sum&#123;<span class="number">0</span>&#125;;<span class="comment">//使用&#123;&#125;赋初值，若struct Sum类型变量被定义，sum初值为0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">for_each示例：</span><br><span class="line"></span><br><span class="line">可能源码：</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class InputIt, class UnaryFunction&gt;</span></span><br><span class="line"><span class="function">UnaryFunction <span class="title">for_each</span><span class="params">(InputIt first, InputIt last, UnaryFunction f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">        <span class="built_in">f</span>(*first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f; <span class="comment">// C++11 起隐式移动</span></span><br><span class="line">&#125;</span><br><span class="line">使用示例：</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">267</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> print = [](<span class="keyword">const</span> <span class="keyword">int</span>&amp; n) &#123; std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n; &#125;;</span><br><span class="line"> </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;before:&quot;</span>;</span><br><span class="line">std::for_each(nums.<span class="built_in">cbegin</span>(), nums.<span class="built_in">cend</span>(), print);<span class="comment">//实现遍历元素并打印</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">transform示例：</span><br><span class="line">可能源码:</span><br><span class="line"></span><br><span class="line">版本一</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class InputIt, class OutputIt, class UnaryOperation&gt;</span></span><br><span class="line"><span class="function">OutputIt <span class="title">transform</span><span class="params">(InputIt first1, InputIt last1, OutputIt d_first, </span></span></span><br><span class="line"><span class="params"><span class="function">                   UnaryOperation unary_op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (first1 != last1) &#123;</span><br><span class="line">        *d_first++ = <span class="built_in">unary_op</span>(*first1++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d_first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用示例：</span><br><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">transform</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s.<span class="built_in">begin</span>(),</span><br><span class="line">[](<span class="keyword">unsigned</span> <span class="keyword">char</span> c) -&gt; <span class="keyword">unsigned</span> <span class="keyword">char</span> &#123; <span class="keyword">return</span> std::<span class="built_in">toupper</span>(c); &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">范围 <span class="keyword">for</span> 循环示例：</span><br><span class="line"></span><br><span class="line">可能源码：</span><br><span class="line">属性(可选) <span class="keyword">for</span> ( 初始化语句(可选)范围变量声明 : 范围表达式 ) 循环语句                </span><br><span class="line"></span><br><span class="line">使用示例：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; i : v) <span class="comment">// 以 const 引用访问</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : v) <span class="comment">// 以值访问，i 的类型是 int</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; i : v) <span class="comment">// 以转发引用访问，i 的类型是 int&amp;</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cv = v;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; i : cv) <span class="comment">// 以转发引用访问，i 的类型是 const int&amp;</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;) <span class="comment">// 初始化器可以是花括号初始化器列表</span></span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : a) <span class="comment">// 初始化器可以是数组</span></span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> ([[maybe_unused]] <span class="keyword">int</span> n : a)  </span><br><span class="line">        std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 不必使用循环变量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n = v.<span class="built_in">size</span>(); <span class="keyword">auto</span> i : v) <span class="comment">// 初始化语句（C++20）</span></span><br><span class="line">        std::cout &lt;&lt; --n + i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">typedef</span> <span class="keyword">decltype</span>(v)::value_type <span class="keyword">elem_t</span>; <span class="keyword">elem_t</span> i : v)</span><br><span class="line">    <span class="comment">// typedef 声明作为初始化语句（C++20）</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">using</span> <span class="keyword">elem_t</span> = <span class="keyword">decltype</span>(v)::value_type; <span class="keyword">elem_t</span> i : v)</span><br><span class="line">    <span class="comment">// 别名声明作为初始化语句，同上（C++23）</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、再看几个泛型算法<br><a href="https://zh.cppreference.com/w/cpp/algorithm">https://zh.cppreference.com/w/cpp/algorithm</a><br>其他算法的学习方法与上边相同，打开上边的网址自主学习，授之以鱼不如授之以渔。</p>
<p>2、泛型算法总结<br>(1)<strong>理解 谓词 和 函数对象，是学习和使用泛型算法的基础</strong><br>(2)泛型算法很多，但是套路是类似的，学会的关键是理解并会用这种套路<br>(3)<strong>不建议试图死记硬背所有泛型算法，建议实战中去熟悉、去用起来并记住</strong><br>(4)能用现成泛型算法写代码就不要自己造轮子<br>(5)一个潜在问题警告：C++包的越来越多（层层封装），不要想当然，未经验证确认的代码都要有怀疑精神</p>
<h2 id="模板特化和类型萃取"><a href="#模板特化和类型萃取" class="headerlink" title="模板特化和类型萃取"></a>模板特化和类型萃取</h2><h3 id="从案例中理解什么是模板特化"><a href="#从案例中理解什么是模板特化" class="headerlink" title="从案例中理解什么是模板特化"></a>从案例中理解什么是模板特化</h3><p>1、通过一个案例理解模板特化<br>(1)案例前奏：写一个swap函数库，可以适用于各种数据类型。结论是模板比函数重载好用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;<span class="comment">//定义一个抽象类型X，在函数被调用时确定具体类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(X&amp; a, X&amp; b)</span><span class="comment">//使用swap作为函数名会与某个库函数名冲突</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X tmp;</span><br><span class="line"></span><br><span class="line">    tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">3.3</span>, d = <span class="number">4.4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myswap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myswap</span>(c, d);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)案例：写一个GreaterThan函数，可以对比各种数据类型的大小。<br>(3)特殊要求：int等比较数值大小，但string类型对比时，不比较字典序，而是以字符串长短来比较</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GreaterThan</span><span class="params">(T a, T b)</span><span class="comment">//模板泛化函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template GreaterThan&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GreaterThan</span><span class="params">(string a, string b)</span><span class="comment">//模板特化函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;special template GreaterThan&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GreaterThan</span><span class="params">(string a, string b)</span><span class="comment">//普通函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ordinary GreaterThan&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; GreaterThan&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; GreaterThan&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; GreaterThan&lt;<span class="keyword">double</span>&gt;(<span class="number">5.4</span>, <span class="number">5.3</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; GreaterThan&lt;<span class="keyword">double</span>&gt;(<span class="number">5.3</span>, <span class="number">5.4</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面所传的两个参数为const型，不可修改，GreaterThan()函数调用优先级为模板泛化函数最高</span></span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; GreaterThan&lt;string&gt;(<span class="string">&quot;linux&quot;</span>, <span class="string">&quot;harmony&quot;</span>) &lt;&lt; endl;<span class="comment">//执行special</span></span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; <span class="built_in">GreaterThan</span>(<span class="string">&quot;linux&quot;</span>, <span class="string">&quot;harmony&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当比较的两个参数为string类型时，上述三个函数优先级为：</span></span><br><span class="line">    <span class="comment">//普通函数 &gt; 模板特化函数 &gt; 模板泛化函数</span></span><br><span class="line">    string a = <span class="string">&quot;linux&quot;</span>, b = <span class="string">&quot;harmony&quot;</span>; </span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; GreaterThan&lt;string&gt;(a, b) &lt;&lt; endl;<span class="comment">//执行special</span></span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; <span class="built_in">GreaterThan</span>(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考学习：<a href="https://www.cnblogs.com/rickyk/p/3941176.html">C++普通函数与模板函数以及特化函数重载的优先级问题</a></p>
<p>2、模板特化总结<br>(1)<strong>模板特化有点类似于函数重载，而且都是编译链接时确定，而非运行时确定的。</strong><br>(2)特化，specialize，就是<strong>让模板参数T在某个具体类型时可以特殊化指定处理</strong><br>(3)特化的模板声明，前面一般是 template&lt;&gt;</p>
<h3 id="偏特化和全特化"><a href="#偏特化和全特化" class="headerlink" title="偏特化和全特化"></a>偏特化和全特化</h3><p>1、全特化与偏特化概念<br>(1)<strong>全特化，特化原模板的所有模板类型为具体类型</strong><br>(2)<strong>偏特化，又叫局部特化，特化原模板的部分类型，或部分特化原模板的类型</strong><br>(3)全特化比较简单，而偏特化更复杂，是之后讨论的重点。</p>
<p>2、函数模板的全特化<br>(1)代码实践，单个模板参数<br>  上边提供的那个程序中就实现了单个模板参数的全特化。<br>(2)代码实践，多个模板参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T1 a, T2 b)</span> <span class="comment">//模板泛化函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(T1 a, T2 b), a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">int</span> b)</span> <span class="comment">//函数模板的全特化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(double a, int b), a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> b = <span class="number">2.2</span>;</span><br><span class="line">    <span class="built_in">func</span>(a, b);</span><br><span class="line">    <span class="built_in">func</span>(b, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、类模板的全特化<br>(1)代码实践，单个模板参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T attribute;</span><br><span class="line">    <span class="built_in">people</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">people</span>(T attr)&#123;attribute = attr;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T a)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> people&lt;T&gt;::<span class="built_in">print</span>(T a)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template function print: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span><span class="keyword">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> attribute;</span><br><span class="line">    <span class="built_in">people</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">people</span>(<span class="keyword">int</span> attr)&#123;attribute = attr;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span></span>;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> people&lt;<span class="keyword">int</span>&gt;::<span class="built_in">print</span>(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;complete special template function print: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">people&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">people&lt;string&gt; <span class="title">p2</span><span class="params">(<span class="string">&quot;linux&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">10</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(<span class="string">&quot;linux&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)代码实践，多个模板参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 attribute;</span><br><span class="line">    <span class="built_in">people</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">people</span>(T1 attr)&#123;attribute = attr;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T2 a)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="keyword">void</span> people&lt;T1, T2&gt;::<span class="built_in">print</span>(T2 a)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template function print: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span><span class="keyword">int</span>, string&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> attribute;</span><br><span class="line">    <span class="built_in">people</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">people</span>(<span class="keyword">int</span> attr)&#123;attribute = attr;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(string a)</span></span>;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> people&lt;<span class="keyword">int</span>, string&gt;::<span class="built_in">print</span>(string a)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;complete special template function print: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">people&lt;<span class="keyword">int</span>, string&gt; <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">people&lt;string, <span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="string">&quot;linux&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="string">&quot;linux&quot;</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类模板的多种偏特化"><a href="#类模板的多种偏特化" class="headerlink" title="类模板的多种偏特化"></a>类模板的多种偏特化</h3><p>1、类模板的第一种偏特化<br>(1)特化多个模板参数中的一部分参数<br>(2)这种比较简单，代码实践演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>//模板泛化类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T1 a, T2 b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="keyword">void</span> people&lt;T1, T2&gt;::<span class="built_in">print</span>(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span>string, <span class="keyword">int</span>&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(string a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:people&lt;string, int&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span><span class="keyword">int</span>, string&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a, string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:people&lt;int, string&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    people&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p1;</span><br><span class="line">    people&lt;string, string&gt; p2;</span><br><span class="line">    people&lt;<span class="keyword">int</span>, string&gt; p3;</span><br><span class="line">    people&lt;string, <span class="keyword">int</span>&gt; p4;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(<span class="string">&quot;two&quot;</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">    p3.<span class="built_in">print</span>(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">    p4.<span class="built_in">print</span>(<span class="string">&quot;four&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、类模板的第二种偏特化<br>(1)特化为T的指针类型<br>(2)这种特化理解起来稍微有点绕（可以将T理解为一个万能类型，而T则表示这个类型必须为指针，T包含T，所以T*是T的偏特化），实战演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>//模板泛化类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T1 a, T2 b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="keyword">void</span> people&lt;T1, T2&gt;::<span class="built_in">print</span>(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span>T *, <span class="keyword">int</span>&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:peoplepeople&lt;T *, int&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span>T *, string&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T *a,  string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:peoplepeoplepeople&lt;T *, string&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    string c = <span class="string">&quot;two&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> d = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    people&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p1;</span><br><span class="line">    people&lt;<span class="keyword">char</span> *, <span class="keyword">int</span>&gt; p2;</span><br><span class="line">    people&lt;<span class="keyword">int</span> *, string&gt; p3;</span><br><span class="line">    people&lt;string *, <span class="keyword">int</span>&gt; p4;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(d, <span class="number">2</span>);</span><br><span class="line">    p3.<span class="built_in">print</span>(&amp;a, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">    p4.<span class="built_in">print</span>(<span class="string">&quot;four&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、类模板的第三种偏特化<br>(1)特化为T的其他类模板，譬如vector<br>(2)这种特化理解起来难度更大，实战演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>//模板泛化类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T1 a, T2 b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="keyword">void</span> people&lt;T1, T2&gt;::<span class="built_in">print</span>(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span>vector&lt;T&gt;, <span class="keyword">int</span>&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:people&lt;vector&lt;T&gt;, int&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span>array&lt;T, 3&gt;, string&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(array&lt;T, <span class="number">3</span>&gt; a,  string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:people&lt;array&lt;T, 3&gt;, string&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span>T&amp; , string&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T&amp; a,  string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:people&lt;T&amp; , string&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; c;</span><br><span class="line"></span><br><span class="line">    people&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p1;</span><br><span class="line">    people&lt;<span class="keyword">int</span> &amp;, string&gt; p2;</span><br><span class="line">    people&lt;vector&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; p3;</span><br><span class="line">    people&lt;array&lt;<span class="keyword">int</span>, 3&gt;, string&gt; p4;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(a, <span class="string">&quot;int&amp;&quot;</span>);</span><br><span class="line">    p3.<span class="built_in">print</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    p4.<span class="built_in">print</span>(c, <span class="string">&quot;array&lt;int, 3&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、类模板的第四种偏特化<br>(1)特化为带const的版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;template class&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>&lt;</span><span class="keyword">const</span> T &amp;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;People&lt;const T &amp;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    People&lt;string&gt; p1;</span><br><span class="line">    People&lt;<span class="keyword">const</span> <span class="keyword">char</span> &amp;&gt; p2;</span><br><span class="line">    People&lt;<span class="keyword">const</span> <span class="keyword">int</span> &amp;&gt; p3;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">func</span>();</span><br><span class="line">    p2.<span class="built_in">func</span>();</span><br><span class="line">    p3.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数模板为什么不能偏特化"><a href="#函数模板为什么不能偏特化" class="headerlink" title="函数模板为什么不能偏特化"></a>函数模板为什么不能偏特化</h3><p>1、事实<br>(1)<strong>函数模板确实不支持偏特化，只能全特化，这是编译器决定的</strong>（若想求证，可自行写个程序测试一下，比较简单，下面是我的测试程序）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T a)</span><span class="comment">//模板泛化函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template:void func(T a) &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;  endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="comment">//全特化函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;complete template :void func(int a) &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;  endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> func&lt;T*&gt;(T a)<span class="comment">//偏特化函数，但函数没有偏特化，故编译不会通过</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;partial template:void func(T* a) &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;  endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用函数重载来实现T *的偏特化完全相同的效果</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func(T *a), a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="comment">//非模板函数，即普通函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ordinary:void func(int a) &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;  endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3.14</span>);    <span class="comment">//template</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">5</span>);       <span class="comment">//ordinary</span></span><br><span class="line">    func&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>);  <span class="comment">//complete template</span></span><br><span class="line">    <span class="comment">//func&lt;int *&gt;(5);//用于调用偏特化函数，但函数无偏特化</span></span><br><span class="line">    func&lt;<span class="keyword">int</span>&gt;(&amp;a);<span class="comment">//重载函数：func(T *a)</span></span><br><span class="line">    <span class="built_in">func</span>(&amp;a);     <span class="comment">//重载函数：func(T *a)</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="string">&quot;linux&quot;</span>);<span class="comment">//重载函数：func(T *a)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)怎么办？<br>  用模板函数重载即可</p>
<p>(3)总结：为什么函数模板不能偏特化？<br>  因为没必要支持，模板函数重载就能搞定</p>
<p>2、分析深度原因<br>(1)C++语言设计基本原则：<strong>后出现的语法尽量兼容且不破坏原有的语法规则</strong><br>(2)<strong>C++一开始就支持函数重载，所以模板函数自然沿用了支持函数重载</strong><br>(3)<strong>偏特化实现的效果，完全可以用模板函数重载实现，所以没必要让模板函数可以偏特化</strong><br>(4)再思考：类模板为什么可以偏特化？<br>  因为类不能重载 </p>
<h3 id="编译器匹配规则和特化的总结"><a href="#编译器匹配规则和特化的总结" class="headerlink" title="编译器匹配规则和特化的总结"></a>编译器匹配规则和特化的总结</h3><p>1、编译器匹配规则<br>(1)第1步先匹配非模版函数，也就是普通函数，如果匹配到就执行，匹配不到进入下一步<br>(2)第2步再匹配基础泛化版函数，如果匹配不到就报错了，匹配到进入下一步<br>(3)第3步再匹配完全特化版本，如果匹配到就执行，匹配不到就执行上一步匹配到的泛化版本<br>(4)一个小细节：函数模板的特化（当然是全特化）不参与函数重载 </p>
<p>2、特化与递归结合<br>(1)特化与递归结合，可以很巧妙的实现编译期的条件判断</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">int</span> i&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  print&lt;i<span class="number">-1</span>&gt;();</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//特例，终止递归。</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> print&lt;<span class="number">1</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  print&lt;<span class="number">100</span>&gt;();<span class="comment">//在编译期展开相当于100条输出语句</span></span><br><span class="line">  <span class="comment">//即调用void print()并传参100，print&lt;i-1&gt;();开始递归，i初值100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)详见：<a href="https://blog.csdn.net/liuxuejiang158blog/article/details/17678573">https://blog.csdn.net/liuxuejiang158blog/article/details/17678573</a></p>
<p>3、特化的最后总结<br>(1)<strong>特化本质上是我们顶替了编译器的工作，我们帮编译器做了类型推导</strong><br>(2)模板特化和模板实例化这2个概念的对比<br>(3)<strong>全特化本质上是一个实例，而偏特化本质上还是一个模板，只是原来模板的一个子集，所以全特化的函数模板，本质上是实例（但不参与普通函数的重载），从而不会与函数模板产生二义性</strong></p>
<h3 id="类型萃取的目的和意义"><a href="#类型萃取的目的和意义" class="headerlink" title="类型萃取的目的和意义"></a>类型萃取的目的和意义</h3><p>1、类型萃取是用途<br>(1)典型应用就是：在模板函数中区分T是 源生类型POD 还是 自定义类型<br>(2)POD,Plain Old Data,简单理解就是C++从C继承而来的基本类型，如int、double等<br>(3)POD类型的本质是没有C++叠加的那些高级特征（构造析构，拷贝构造，移动语义，虚函数等） </p>
<p>2、为什么要区分POD类型和非POD类型<br>(1)典型案例就是copy时，POD类型直接memcpy(C语言的一个库函数)即可，而非POD类型需要用for循环结合“=”(默认提供的运算符重载后的=可以实现对象拷贝)，挨个对象拷贝<br>(2)非POD类型不能memcpy(涉及到了动态内存)，本质是因为需要深拷贝以避免出错<br>(3)代码演练:int数组和string数组的复制对比 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span><span class="comment">//c语言的那个string.h头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//C++的string头文件，与上边的那个不同</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mycopy</span><span class="params">(T* Dst, T* Src, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(Dst, Src, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0    </span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, b[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    string a[<span class="number">3</span>] = &#123;<span class="string">&quot;linux&quot;</span>, <span class="string">&quot;android&quot;</span>, <span class="string">&quot;harmonyos&quot;</span>&#125;;</span><br><span class="line">    string b[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    mycopy&lt;string&gt;(b, a, <span class="built_in"><span class="keyword">sizeof</span></span>(string)*<span class="number">3</span>);<span class="comment">//虽然可以执行，但会报错，这就是浅拷贝</span></span><br><span class="line">    a[<span class="number">1</span>] = <span class="string">&quot;ubuntu&quot;</span>;                       <span class="comment">//报错信息：free(): invalid size ，已放弃 (核心已转储)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//mycopy&lt;int&gt;(b, a, sizeof(int)*3);</span></span><br><span class="line">    <span class="comment">//a[0] = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; b[k] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型萃取实战演练"><a href="#类型萃取实战演练" class="headerlink" title="类型萃取实战演练"></a>类型萃取实战演练</h3><p>1、使用is_pod解决上面的问题<br>(1)std::is_pod介绍</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m1;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m2;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; std::is_pod&lt;A&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::is_pod&lt;B&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::is_pod&lt;C&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>(2)代码实战，使用is_pod来完善mycopy解决上节中的问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mycopy</span><span class="params">(T* Dst, T* Src, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_pod&lt;T&gt;::value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(Dst, Src, <span class="built_in"><span class="keyword">sizeof</span></span>(T)*count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Dst[i] = Src[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a[<span class="number">3</span>] = &#123;<span class="string">&quot;linux&quot;</span>, <span class="string">&quot;android&quot;</span>, <span class="string">&quot;harmonyos&quot;</span>&#125;;</span><br><span class="line">    string b[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    mycopy&lt;string&gt;(b, a, <span class="number">3</span>);</span><br><span class="line">    a[<span class="number">1</span>] = <span class="string">&quot;ubuntu&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; b[k] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型萃取是如何实现的"><a href="#类型萃取是如何实现的" class="headerlink" title="类型萃取是如何实现的"></a>类型萃取是如何实现的</h3><p>1、一种可能的实现（方法一）<br>(1)把所有pod类型组成列表，在内部挨个判断，借助两个关键字：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeid</span>用来返回一个变量（表达式）（对象）的类型，类似于C语言中的：<span class="built_in">typeof</span>() </span><br><span class="line">是GUN C提供的一种特性，它可以取得变量的类型，或者表达式的类型。</span><br></pre></td></tr></table></figure>
<p>(2)优点：可以实现，且能实现<type_traits>中所有的标准库萃取工具<br>(3)缺点：运行时</p>
<p>2、使用类模板的特化实现（方法二）<br>(1)代码实践演示<br>判断，占用运行时资源，效率低</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛化版本的my_is_pod</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_is_pod</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> my_is_pod&lt;T&gt;::value = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// int类型的特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_is_pod</span>&lt;</span><span class="keyword">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> my_is_pod&lt;<span class="keyword">int</span>&gt;::value = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// double类型的特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_is_pod</span>&lt;</span><span class="keyword">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> my_is_pod&lt;<span class="keyword">double</span>&gt;::value = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// short类型的特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_is_pod</span>&lt;</span><span class="keyword">short</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> my_is_pod&lt;<span class="keyword">short</span>&gt;::value = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string类型使用这样的方法还会报错，我试过，但没有去深入研究</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mycopy</span><span class="params">(T *dest, <span class="keyword">const</span> T *src, <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">// 我们需要一种技术，在这里可以去区分，T到底是pod还是非pod</span></span><br><span class="line">        <span class="keyword">if</span> (my_is_pod&lt;T&gt;::value)</span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;if&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">memcpy</span>(dest, src, cnt*<span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;else&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cnt; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                        dest[i] = src[i];                        <span class="comment">// 非pod类型使用operator=是可以复制的</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; boolalpha &lt;&lt; my_is_pod&lt;double&gt;::value &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">short</span> a[<span class="number">3</span>] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">short</span> b[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        mycopy&lt;<span class="keyword">short</span>&gt;(b, a, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">                cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*        </span></span><br><span class="line"><span class="comment">        string s1[3] = &#123;&quot;linux&quot;, &quot;android&quot;, &quot;harmonyos&quot;&#125;;</span></span><br><span class="line"><span class="comment">        string s2[3];</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        mycopy&lt;string&gt;(s2, s1, 3);                        // 非pod类型不能memcpy，因为会浅拷贝导致错误</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for (int i=0; i&lt;3; i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; &quot;s2[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; s2[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        s1[0] = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;last, s2[0] = &quot; &lt;&lt; s2[0] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">*/</span>        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)总结：特化实现萃取的关键，就是特化版本的优先级高于泛化版本<br>(3)思考：使用类模板特化，是否会增加代码量，影响程序效率？<br>  会增加代码量，不会影响效率，模板特化是在编译时判断的。</p>
<h3 id="类型萃取的另一种可能实现"><a href="#类型萃取的另一种可能实现" class="headerlink" title="类型萃取的另一种可能实现"></a>类型萃取的另一种可能实现</h3><p>1、不使用静态成员变量<br>2、改为使用成员函数<br>3、使用typedef增加一层中间层<br>(1)class/struct内使用typedef定义子类型的方法<br>(2)增加名为value_type的子类型中间层，实现pod判断</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FalseType</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">GetType</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrueType</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">GetType</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛化版本的my_is_pod</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_is_pod</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> FalseType value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_is_pod</span>&lt;</span><span class="keyword">short</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> TrueType value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; my_is_pod&lt;<span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>().<span class="built_in">GetType</span>() &lt;&lt; endl;<span class="comment">//value_type()的这个()表示构造函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器萃取与泛型算法"><a href="#迭代器萃取与泛型算法" class="headerlink" title="迭代器萃取与泛型算法"></a>迭代器萃取与泛型算法</h3><p>1、STL的核心<br>(1)STL，就是C++提供的一套标准实现的template化的library<br>(2)STL有很多内容，但是核心就是2个：<strong>泛型容器、泛型算法</strong><br>(3)为了实现<strong>泛型容器，引入了迭代器，迭代器是指针的泛化抽象</strong><br>(4)泛型算法可以接受多种容器，每种容器内可以存储多种数据载体，这就是泛型算法的2级泛化支持</p>
<p>2、泛型算法实现的难题和解法<br>(1)问题1：泛型算法无法预知自己处理的是什么容器<br>解决思路：<strong>将容器降级为迭代器来对接泛型算法。所以任何容器都必须内置一个迭代器</strong><br>(3)问题2：泛型算法无法预知容器内存储的元素类型，是否POD<br>解决思路：<strong>提供迭代器萃取器，在泛型算法内预先萃取并使用容器元素类型</strong></p>
<h3 id="迭代器萃取器的设计解读"><a href="#迭代器萃取器的设计解读" class="headerlink" title="迭代器萃取器的设计解读"></a>迭代器萃取器的设计解读</h3><p>(1)迭代器萃取器本质是一个类，叫iterator_traits，属于辅助迭代器的第三方类<br>(2)解读参考：<a href="https://blog.csdn.net/virtual_func/article/details/48398451">https://blog.csdn.net/virtual_func/article/details/48398451</a></p>
<h3 id="迭代器萃取器的特化"><a href="#迭代器萃取器的特化" class="headerlink" title="迭代器萃取器的特化"></a>迭代器萃取器的特化</h3><p>1、萃取器的特化讲解<br>(1)参考：<a href="https://blog.csdn.net/terence1212/article/details/52287762">https://blog.csdn.net/terence1212/article/details/52287762</a><br>(2)总结：本质是偏特化结合类型萃取技术</p>
<p>2、本章节文章总结<br>(1)主要讲了2项技术，一个 是特化，一个是萃取<br>(2)特化的核心价值是，<strong>让模板类/函数按一定优先级规则去匹配</strong><br>(3)萃取的核心价值是，让我们在<strong>写泛型算法时可以预先得知未来传参容器及容器内元素的型别特征</strong><br>(4)<strong>如果只是使用STL，实际上不需要关注特化和萃取</strong><br>(5)<strong>真正理解模板技术、特化、萃取等技术的使用和实现，你才会感受到C++的魅力，知道C++为什么效率高</strong><br>(6)<strong>从实用角度讲，不需要真的深度去研究这些。但是如果完全不懂甚至不知道这些技术的存在，那休想用好C++</strong></p>
<h2 id="STL其它容器讲解"><a href="#STL其它容器讲解" class="headerlink" title="STL其它容器讲解"></a>STL其它容器讲解</h2><h3 id="STL的三种容器适配器"><a href="#STL的三种容器适配器" class="headerlink" title="STL的三种容器适配器"></a>STL的三种容器适配器</h3><p>1、什么是容器适配器<br>(1)回顾：C++三种适配器：<strong>函数适配器、容器适配器、迭代器适配器</strong><br>(2)<strong>适配器，adapter，本质是添加一个中间层来转换以适配双方</strong><br>(3)<strong>容器适配器，是用已有容器来二次封装以构建新容器</strong><br>(4)<strong>STL提供三种容器适配器，分别是：stack、queue、priority_queue</strong><br>(5)stack:栈，先进后出，关心压栈和弹栈操作<br>(6)queue:队列，FIFO，关心入队和出队操作<br>(7)priority_queue:优先级队列，内部自排队式进，按优先级出，关心入队和出队操作 </p>
<p>2、为什么会有容器适配器<br>(1)<strong>顺序式容器是基本容器，偏重于“存储”特性，核心是元素如何在内存中管理</strong><br>(2)<strong>栈和队列是数据结构型容器，偏重于“数据操作”特性，核心是元素如何按需要进去出来</strong><br>(3)从层次讲：<strong>顺序式容器是底层实现，而栈和队列是上层应用</strong><br>(4)<strong>栈和队列底层完全可以由vector、list、array等顺序式容器封装形成，没必要完全从零构建</strong> </p>
<p>3、总结<br>(1)<strong>容器适配器很多时候用起来和容器完全一样，所以也可以叫容器</strong><br>(2)容器适配器内部实现和容器不同<br>(3)<strong>容器适配器直接内部没有迭代器，但是间接包含有</strong><br>(4)<strong>容器适配器不能访问内部间接迭代器，而且也没有必要访问</strong><br>(5)容器适配器怎么实现的可以不必关心，除非你自己需要去定义新的容器适配器 </p>
<h3 id="容器适配器之stack详解"><a href="#容器适配器之stack详解" class="headerlink" title="容器适配器之stack详解"></a>容器适配器之stack详解</h3><p>参考学习：<a href="https://zh.cppreference.com/w/cpp/container/stack">https://zh.cppreference.com/w/cpp/container/stack</a><br>  栈(这个容器)是无法进行遍历的，其内没有迭代器。只可以通过弹栈的方式来查看栈内的元素，当元素被依次弹出时，虽然看到了其中的元素，但最终栈将会变为一个空栈。<br>1、stack的构造<br>参考手册：<a href="https://zh.cppreference.com/w/cpp/container/stack/stack">https://zh.cppreference.com/w/cpp/container/stack/stack</a></p>
<p>2、stack的操作函数<br>(1)进栈push<br>(2)出栈pop</p>
<p>3、stack元素查询<br>(1)栈顶元素读取top<br>(2)栈内元素个数获取size<br>(3)栈元素是否空empty</p>
<p>4、栈和栈操作<br>(1)栈元素交换：2个swap<br>(2)栈元素对比：一众运算符重载 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    a.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    a.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    a.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    a.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.size() = &quot;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.top() = &quot;</span> &lt;&lt; a.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; <span class="string">&quot;a.empty() = &quot;</span> &lt;&lt; a.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a.top() = &quot;</span> &lt;&lt; a.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="容器适配器之queue和priority-queue详解"><a href="#容器适配器之queue和priority-queue详解" class="headerlink" title="容器适配器之queue和priority_queue详解"></a>容器适配器之queue和priority_queue详解</h3><p><a href="https://zh.cppreference.com/w/cpp/container/queue">https://zh.cppreference.com/w/cpp/container/queue</a><br>1、queue<br>(1)FIFO，先进先出<br>(2)访问元素用front访问队首，用back访问队尾<br>(3)push时只能push到back的后面，pop时只能从front处pop</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::queue&lt;<span class="keyword">int</span>&gt; c1;</span><br><span class="line">    c1.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c1.size = &quot;</span> &lt;&lt; c1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">queue&lt;<span class="keyword">int</span>&gt; <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c2.size = &quot;</span> &lt;&lt; c2.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; deq&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">queue&lt;<span class="keyword">int</span>&gt; <span class="title">c3</span><span class="params">(deq)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.size = &quot;</span> &lt;&lt; c3.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.front = &quot;</span> &lt;&lt; c3.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.back = &quot;</span> &lt;&lt; c3.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">    c3.<span class="built_in">push</span>(<span class="number">6</span>);</span><br><span class="line">    c3.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">    c3.<span class="built_in">emplace</span>(<span class="number">8</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.front = &quot;</span> &lt;&lt; c3.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.back = &quot;</span> &lt;&lt; c3.<span class="built_in">back</span>() &lt;&lt; endl;    </span><br><span class="line">    c3.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.front = &quot;</span> &lt;&lt; c3.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.back = &quot;</span> &lt;&lt; c3.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        queue&lt;string&gt; q1;</span><br><span class="line">        </span><br><span class="line">        q1.<span class="built_in">push</span>(<span class="built_in">string</span>(<span class="string">&quot;android&quot;</span>));</span><br><span class="line">        q1.<span class="built_in">push</span>(<span class="built_in">string</span>(<span class="string">&quot;linux&quot;</span>));</span><br><span class="line">        q1.<span class="built_in">push</span>(<span class="built_in">string</span>(<span class="string">&quot;harmonyos&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;q1.size = &quot;</span> &lt;&lt; q1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        string s1 = q1.<span class="built_in">front</span>();</span><br><span class="line">        string s2 = q1.<span class="built_in">back</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;s1 = &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;, s2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;q1.size = &quot;</span> &lt;&lt; q1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、priority_queue<br>(1)按照规则进时排队，从top出<br><a href="https://zh.cppreference.com/w/cpp/container/priority_queue">https://zh.cppreference.com/w/cpp/container/priority_queue</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_queue</span><span class="params">(T&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; q.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;)</span><br><span class="line">        q.<span class="built_in">push</span>(n);</span><br><span class="line">    <span class="built_in">print_queue</span>(q);</span><br><span class="line"></span><br><span class="line">    std::priority_queue&lt;<span class="keyword">int</span>, std::vector&lt;<span class="keyword">int</span>&gt;, std::greater&lt;<span class="keyword">int</span>&gt;&gt; q2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;)</span><br><span class="line">        q2.<span class="built_in">push</span>(n);</span><br><span class="line">    <span class="built_in">print_queue</span>(q2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">int</span> left, <span class="keyword">int</span> right)&#123;<span class="built_in"><span class="keyword">return</span></span> (left ^ <span class="number">1</span>) &lt; (right ^ <span class="number">1</span>);&#125;;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">q3</span>(cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;)</span><br><span class="line">        q3.<span class="built_in">push</span>(n);</span><br><span class="line">    <span class="built_in">print_queue</span>(q3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有序关联容器set"><a href="#有序关联容器set" class="headerlink" title="有序关联容器set"></a>有序关联容器set</h3><p>1、什么是有序关联容器<br>(1)顺序容器，<strong>容器中的元素是按它们在容器中的位置来顺序保存和访问的</strong><br>(2)顺序容器有<strong>array、vector、deque、list、forward_list、string</strong>等<br>(3)<strong>关联容器中的元素是按关键字来保存和访问的，关联的意思就是关键字（key）与存储值（value）的关联</strong><br>(4)主要的关联容器类型是<strong>map</strong>和<strong>set</strong><br>(5)<strong>关联容器支持高效的关键字查找和访问</strong><br>(6)有序关联容器：容器内元素按顺序排列，一般用树（譬如红黑树）来实现<br>(7)无序关联容器：容器内元素无顺序排列，一般用哈希表来实现，本质上是一种映射</p>
<p>2、set的基本使用<br><a href="https://zh.cppreference.com/w/cpp/container/set">https://zh.cppreference.com/w/cpp/container/set</a><br><a href="http://c.biancheng.net/view/7192.html">http://c.biancheng.net/view/7192.html</a><br>(1)set的基本理解：<strong>就是一个用来装Key类型对象的筐子，数学上叫集合</strong><br>(2)set的构造函数<br>(3)<strong>插入数据可以用insert，插入时内部自动排序</strong><br>(4)查询set中元素个数用：empty、size，max_size是理论上的最大元素数<br>(5)清除全部元素用clear<br>(6)针对清除某个Key用erase，若erase的元素不存在则不报错<br>(7)<strong>使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;string&gt; s1;</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="string">&quot;cat&quot;</span>);<span class="comment">//这里有个转换的过程，&quot;key&quot;是c中的字符串，这里内部将其转换为了string类型</span></span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="string">&quot;monkey&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1.size = &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; boolalpha &lt;&lt; <span class="string">&quot;, empty = &quot;</span> &lt;&lt; s1.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    s1.<span class="built_in">erase</span>(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1.size = &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; boolalpha &lt;&lt; <span class="string">&quot;, empty = &quot;</span> &lt;&lt; s1.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">    s1.<span class="built_in">erase</span>(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    s1.<span class="built_in">erase</span>(<span class="string">&quot;monkey&quot;</span>);    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1.size = &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; boolalpha &lt;&lt; <span class="string">&quot;, empty = &quot;</span> &lt;&lt; s1.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set的遍历和原地构造"><a href="#set的遍历和原地构造" class="headerlink" title="set的遍历和原地构造"></a>set的遍历和原地构造</h3><p>1、set的三种遍历方法（set具有迭代器）<br>(1)使用ranged for<br>(2)使用迭代器写for循环<br>(3)使用std::for_each</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;string&gt; s1;</span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="string">&quot;house&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1.size() = &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 第一种遍历方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : s1)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种遍历方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = s1.<span class="built_in">cbegin</span>(); iter != s1.<span class="built_in">cend</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种遍历方式</span></span><br><span class="line">    <span class="keyword">auto</span> print = [](<span class="keyword">auto</span> s)&#123;cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;&#125;;</span><br><span class="line">    for_each(s1.<span class="built_in">cbegin</span>(), s1.<span class="built_in">cend</span>(), print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s1.<span class="built_in">size</span>() = <span class="number">3</span></span><br><span class="line">cat dog house </span><br><span class="line">cat dog house </span><br><span class="line">cat dog house </span><br></pre></td></tr></table></figure>

<p>2、set的原地构造<br>在容器的指定位置直接构造元素，而不是先单独生成，再将其复制（或移动）到容器中。即构建一个临时对象直接使用，而不是将值复制过去再去构建一个对象<br>(1)set插入新元素一共有3个方法：insert、emplace、emplace_hint<br>(2)**一般来说，emplace比insert效率更高，详解参考(必读)**：<a href="http://c.biancheng.net/view/6834.html">http://c.biancheng.net/view/6834.html</a> </p>
<h3 id="移动构造和emplace-hint"><a href="#移动构造和emplace-hint" class="headerlink" title="移动构造和emplace_hint"></a>移动构造和emplace_hint</h3><p>1、移动构造函数<br>参考学习:<a href="http://c.biancheng.net/view/7847.html">C++11移动构造函数详解</a><br>(1)移动构造函数特征：传参是一个右值引用的对象（对比copy构造函数）<br>(2)**右值引用的特征就是&amp;&amp;**，lvalue和rvalue相关的内容在之后的文章中会讲解<br><strong>(3)右值引用对应移动语义，对应移动构造函数；而左值引用对应复制语义，对应复制构造函数<br>(4)移动语义就是直接把右值的临时对象给左值，而不是复制右值给左值重新构造一份<br>(5)移动构造函数可以避免不必要的深拷贝，这在很多时候可以提升效率，当拷贝构造函数和移动构造函数同时存在时，insert() 会优先调用移动构造函数。</strong></p>
<p>2、emplace_hint<br>(1)emplace_hint使用得到会比emplace效率更高，主要原因是插入位置会影响内部自排队效率<br>因为set容器中的元素是经过排序的，你插入新的元素可能需要重新排序，而使用emplace_hint可以尽可能减少这个问题的影响。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nof_operations = <span class="number">100500</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_emplace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nof_operations; ++i) &#123;</span><br><span class="line">    set.<span class="built_in">emplace</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> set.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_emplace_hint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">  <span class="keyword">auto</span> it = set.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nof_operations; ++i) &#123;</span><br><span class="line">    set.<span class="built_in">emplace_hint</span>(it, i);</span><br><span class="line">    it = set.<span class="built_in">end</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> set.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_emplace_hint_wrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">  <span class="keyword">auto</span> it = set.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = nof_operations; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    set.<span class="built_in">emplace_hint</span>(it, i);</span><br><span class="line">    it = set.<span class="built_in">end</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> set.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_emplace_hint_corrected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">  <span class="keyword">auto</span> it = set.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = nof_operations; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    set.<span class="built_in">emplace_hint</span>(it, i);</span><br><span class="line">    it = set.<span class="built_in">begin</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> set.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_emplace_hint_closest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">  <span class="keyword">auto</span> it = set.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nof_operations; ++i) &#123;</span><br><span class="line">    it = set.<span class="built_in">emplace_hint</span>(it, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> set.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timeit</span><span class="params">(std::function&lt;<span class="keyword">int</span>()&gt; set_test, std::string what = <span class="string">&quot;&quot;</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">int</span> setsize = <span class="built_in">set_test</span>();</span><br><span class="line">  <span class="keyword">auto</span> stop = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">  std::chrono::duration&lt;<span class="keyword">double</span>, std::milli&gt; time = stop - start;</span><br><span class="line">  <span class="keyword">if</span> (what.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; setsize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">2</span>)</span><br><span class="line">              &lt;&lt; time.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;  ms for &quot;</span> &lt;&lt; what &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">timeit</span>(set_emplace); <span class="comment">// 栈加热</span></span><br><span class="line">   <span class="built_in">timeit</span>(set_emplace, <span class="string">&quot;plain emplace&quot;</span>);</span><br><span class="line">   <span class="built_in">timeit</span>(set_emplace_hint, <span class="string">&quot;emplace with correct hint&quot;</span>);</span><br><span class="line">   <span class="built_in">timeit</span>(set_emplace_hint_wrong, <span class="string">&quot;emplace with wrong hint&quot;</span>);</span><br><span class="line">   <span class="built_in">timeit</span>(set_emplace_hint_corrected, <span class="string">&quot;corrected emplace&quot;</span>);</span><br><span class="line">   <span class="built_in">timeit</span>(set_emplace_hint_closest, <span class="string">&quot;emplace using returned iterator&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可能的输出：</span><br><span class="line"><span class="number">18.96</span>  ms <span class="keyword">for</span> plain emplace</span><br><span class="line"><span class="number">7.95</span>  ms <span class="keyword">for</span> emplace with correct hint</span><br><span class="line"><span class="number">19.39</span>  ms <span class="keyword">for</span> emplace with wrong hint</span><br><span class="line"><span class="number">8.39</span>  ms <span class="keyword">for</span> corrected emplace</span><br><span class="line"><span class="number">7.90</span>  ms <span class="keyword">for</span> emplace <span class="keyword">using</span> returned iterator</span><br></pre></td></tr></table></figure>

<h3 id="set的其他方法"><a href="#set的其他方法" class="headerlink" title="set的其他方法"></a>set的其他方法</h3><p>参考学习：<a href="https://zh.cppreference.com/w/cpp/container/set">https://zh.cppreference.com/w/cpp/container/set</a><br>1、extract和merge</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::set&lt;<span class="keyword">int</span>&gt; cont&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> print = [](<span class="keyword">const</span> <span class="keyword">int</span>&amp; n) &#123; std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n; &#125;;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Start:&quot;</span>;</span><br><span class="line">    std::for_each(cont.<span class="built_in">begin</span>(), cont.<span class="built_in">end</span>(), print);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 释出结点柄并更改键</span></span><br><span class="line">    <span class="keyword">auto</span> nh = cont.<span class="built_in">extract</span>(<span class="number">1</span>);</span><br><span class="line">    nh.<span class="built_in">value</span>() = <span class="number">4</span>; </span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After extract and before insert:&quot;</span>;</span><br><span class="line">    std::for_each(cont.<span class="built_in">begin</span>(), cont.<span class="built_in">end</span>(), print);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 往回插入结点柄</span></span><br><span class="line">    cont.<span class="built_in">insert</span>(<span class="built_in">move</span>(nh));</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;End:&quot;</span>;</span><br><span class="line">    std::for_each(cont.<span class="built_in">begin</span>(), cont.<span class="built_in">end</span>(), print);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Start: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">After extract <span class="keyword">and</span> before insert: <span class="number">2</span> <span class="number">3</span></span><br><span class="line">End: <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 打印出容器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Os</span>, <span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line">Os&amp; <span class="keyword">operator</span>&lt;&lt;(Os&amp; os, <span class="keyword">const</span> std::set&lt;K&gt;&amp; v) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&#x27;[&#x27;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;] &#123;&quot;</span>;</span><br><span class="line">    <span class="keyword">bool</span> o&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : v)</span><br><span class="line">        os &lt;&lt; (o ? <span class="string">&quot;, &quot;</span> : (o = <span class="number">1</span>, <span class="string">&quot; &quot;</span>)) &lt;&lt; e;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">&quot; &#125;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::set&lt;<span class="keyword">char</span>&gt;</span><br><span class="line">        p&#123; <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;A&#x27;</span> &#125;, </span><br><span class="line">        q&#123; <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;C&#x27;</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p: &quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;q: &quot;</span> &lt;&lt; q;</span><br><span class="line"> </span><br><span class="line">    p.<span class="built_in">merge</span>(q);</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p.merge(q);\n&quot;</span> &lt;&lt; <span class="string">&quot;p: &quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;q: &quot;</span> &lt;&lt; q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">p: [<span class="number">3</span>] &#123; A, B, C &#125;</span><br><span class="line">q: [<span class="number">3</span>] &#123; C, D, E &#125;</span><br><span class="line">p.<span class="built_in">merge</span>(q);</span><br><span class="line">p: [<span class="number">5</span>] &#123; A, B, C, D, E &#125;</span><br><span class="line">q: [<span class="number">1</span>] &#123; C &#125;</span><br></pre></td></tr></table></figure>

<p>2、查找和观察器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(s1.<span class="built_in">key_comp</span>()).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(less&lt;<span class="keyword">int</span>&gt;).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有序关联容器map"><a href="#有序关联容器map" class="headerlink" title="有序关联容器map"></a>有序关联容器map</h3><p>1、map介绍<br>(1)<strong>map和set类似，但是map是(key, value)对，而set只有key（可以理解为key就是value）</strong><br>(2)map是映射的意思，此处是key到value的一对一映射。不要理解成地图（根据地图查位置）,一般用key去查value<br>(3)map的用法和特征与set非常类似，学会set了再学map就容易多了 </p>
<p>2、pair<br>(1)<strong>pair即对，也就是(key, value)对，本质是有2个元素的结构体</strong><br>(2)std::pair是STL的标准pair封装<br>(3)<strong>pair中2个元素类型可以不同，也就是说key和value的类型可以不同，也可以相同</strong><br>(4)<strong>pair中2个元素名字是固定的，key叫first，而value叫second</strong><br>(5)<strong>map中存的元素都是一个一个的pair，访问map的key和value要先从map找到pair，再去first和second</strong><br>参考学习：<a href="https://zh.cppreference.com/w/cpp/utility/pair">https://zh.cppreference.com/w/cpp/utility/pair</a><br><a href="http://c.biancheng.net/view/7173.html">http://c.biancheng.net/view/7173.html</a></p>
<p>3、map的构造函数详解<br>(1)直接参考cppreference中构造函数页面的sample即可，链接如下：<br><a href="https://zh.cppreference.com/w/cpp/container/map/map">https://zh.cppreference.com/w/cpp/container/map/map</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Map&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_map</span><span class="params">(Map&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : m)</span><br><span class="line">        std::cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; p.second &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&#125;\n&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span><span class="keyword">double</span> x,y;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PointCmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Point&amp; lhs, <span class="keyword">const</span> Point&amp; rhs)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.x &lt; rhs.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//定义一个函数对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、默认构造函数</span></span><br><span class="line">    std::map&lt;std::string, <span class="keyword">int</span>&gt; map1;</span><br><span class="line">    map1[<span class="string">&quot;something&quot;</span>] = <span class="number">69</span>;<span class="comment">//向位图中添加元素</span></span><br><span class="line">    map1[<span class="string">&quot;anything&quot;</span>] = <span class="number">199</span>;</span><br><span class="line">    map1[<span class="string">&quot;everything&quot;</span>] = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;map1 = &quot;</span>;<span class="built_in">print_map</span>(map1); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、范围构造函数</span></span><br><span class="line">    <span class="function">std::map&lt;std::string, <span class="keyword">int</span>&gt; <span class="title">iter</span><span class="params">(map1.find(<span class="string">&quot;anything&quot;</span>),map1.end())</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\niter = &quot;</span>;<span class="built_in">print_map</span>(iter);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;map1 = &quot;</span>;<span class="built_in">print_map</span>(map1); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、复制（拷贝构造函数）</span></span><br><span class="line">    <span class="function">std::map&lt;std::string, <span class="keyword">int</span>&gt; <span class="title">copied</span><span class="params">(map1)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\ncopied = &quot;</span>;<span class="built_in">print_map</span>(copied);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;map1 = &quot;</span>;<span class="built_in">print_map</span>(map1); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、移动构造函数</span></span><br><span class="line">    <span class="function">std::map&lt;std::string, <span class="keyword">int</span>&gt; <span class="title">moved</span><span class="params">(std::move(map1))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nmoved = &quot;</span>;<span class="built_in">print_map</span>(moved);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;map1 = &quot;</span>;<span class="built_in">print_map</span>(map1); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、initializer_list 构造函数</span></span><br><span class="line">    std::map&lt;std::string, <span class="keyword">int</span>&gt; init&#123;</span><br><span class="line">        &#123;<span class="string">&quot;this&quot;</span>, <span class="number">100</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;can&quot;</span>, <span class="number">100</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;be&quot;</span>, <span class="number">100</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;const&quot;</span>, <span class="number">100</span>&#125;,        </span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\ninit = &quot;</span>;<span class="built_in">print_map</span>(init);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定制关键类选项 1 ：</span></span><br><span class="line">  <span class="comment">// 使用比较 struct</span></span><br><span class="line">  std::map&lt;Point, <span class="keyword">double</span>, PointCmp&gt; mag = &#123;</span><br><span class="line">      &#123; &#123;<span class="number">5</span>, <span class="number">-12</span>&#125;, <span class="number">13</span> &#125;,</span><br><span class="line">      &#123; &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,   <span class="number">5</span> &#125;,</span><br><span class="line">      &#123; &#123;<span class="number">-8</span>, <span class="number">-15</span>&#125;, <span class="number">17</span> &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> p : mag)</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;The magnitude of (&quot;</span> &lt;&lt; p.first.x</span><br><span class="line">                &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.first.y &lt;&lt; <span class="string">&quot;) is &quot;</span></span><br><span class="line">                &lt;&lt; p.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 定制关键类选项 2 ：</span></span><br><span class="line">    <span class="comment">// 使用比较 lambda</span></span><br><span class="line">    <span class="comment">// 此 lambda 按照其模比较点，注意其中模取自局部变量 mag</span></span><br><span class="line">    <span class="keyword">auto</span> cmpLambda = [&amp;mag](<span class="keyword">const</span> Point &amp;lhs, <span class="keyword">const</span> Point &amp;rhs) &#123; <span class="keyword">return</span> mag[lhs] &lt; mag[rhs]; &#125;;</span><br><span class="line">    <span class="comment">// 你亦可使用不依赖局部变量的 lambda ，像这样：</span></span><br><span class="line">    <span class="comment">// auto cmpLambda = [](const Point &amp;lhs, const Point &amp;rhs) &#123; return lhs.y &lt; rhs.y; &#125;;</span></span><br><span class="line">    <span class="function">std::map&lt;Point, <span class="keyword">double</span>, <span class="title">decltype</span><span class="params">(cmpLambda)</span>&gt;   <span class="title">magy</span><span class="params">(cmpLambda)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 各种插入元素的方式：</span></span><br><span class="line">    magy.<span class="built_in">insert</span>(std::pair&lt;Point, <span class="keyword">double</span>&gt;(&#123;<span class="number">5</span>, <span class="number">-12</span>&#125;, <span class="number">13</span>));</span><br><span class="line">    magy.<span class="built_in">insert</span>(&#123; &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, <span class="number">5</span>&#125;);</span><br><span class="line">    magy.<span class="built_in">insert</span>(&#123;Point&#123;<span class="number">-8.0</span>, <span class="number">-15.0</span>&#125;, <span class="number">17</span>&#125;);</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : magy)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The magnitude of (&quot;</span> &lt;&lt; p.first.x</span><br><span class="line">                &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.first.y &lt;&lt; <span class="string">&quot;) is &quot;</span></span><br><span class="line">                &lt;&lt; p.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、其他方法<br>(1)与set非常类似，详见：<a href="https://zh.cppreference.com/w/cpp/container/map">https://zh.cppreference.com/w/cpp/container/map</a><br>(2)<strong>extract是修改map的key值的唯一方法,map和set中的key是不可以重复的，但map的value可以重复，而由于set的key和value是一个东西，所以set的value也不可以重复。</strong><br>(3)map中的排序是根据key进行的，所以一般都不修改key，修改后需要再次排序 </p>
<h3 id="multi-set和multi-map"><a href="#multi-set和multi-map" class="headerlink" title="multi_set和multi_map"></a>multi_set和multi_map</h3><p>1、multi_版本的差异<br>(1)<strong>set和map中每个容器内所有元素的key都是unique(独一无二)的，不能重复</strong><br>(2)<strong>如果需要容器中同一个key有多个元素(也可理解为有多个相同的key)，则需要使用multi_版本的set和map</strong><br>(3)除此区别外，multi_版本和普通版本没有任何差异，所有方法也完全一样<br>(4)工作中用哪个，取决于实际需求。</p>
<p>2、multi_set实战演示<br>学习参考：<a href="https://zh.cppreference.com/w/cpp/container/multiset">https://zh.cppreference.com/w/cpp/container/multiset</a></p>
<p>3、multi_map实战演示<br>学习参考：<a href="https://zh.cppreference.com/w/cpp/container/multimap">https://zh.cppreference.com/w/cpp/container/multimap</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        multimap&lt;<span class="keyword">int</span>, string&gt; m1;</span><br><span class="line">        m1.<span class="built_in">insert</span>(&#123;<span class="number">0</span>, <span class="string">&quot;linux&quot;</span>&#125;);</span><br><span class="line">        m1.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, <span class="string">&quot;android&quot;</span>&#125;);</span><br><span class="line">        m1.<span class="built_in">insert</span>(&#123;<span class="number">2</span>, <span class="string">&quot;windows&quot;</span>&#125;);</span><br><span class="line">        m1.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, <span class="string">&quot;macos&quot;</span>&#125;);</span><br><span class="line">        m1.<span class="built_in">insert</span>(&#123;<span class="number">2</span>, <span class="string">&quot;harmonyos&quot;</span>&#125;);</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;size = &quot;</span> &lt;&lt; m1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> val : m1)</span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;&#123;&quot;</span> &lt;&lt; val.first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;&#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        multiset&lt;string&gt; s1;</span></span><br><span class="line"><span class="comment">        s1.insert(&quot;horse&quot;);                // 按照key去排序</span></span><br><span class="line"><span class="comment">        s1.insert(&quot;cat&quot;);</span></span><br><span class="line"><span class="comment">        s1.insert(&quot;cat&quot;);</span></span><br><span class="line"><span class="comment">        s1.insert(&quot;cat&quot;);</span></span><br><span class="line"><span class="comment">        s1.insert(&quot;dog&quot;);</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;size = &quot; &lt;&lt; s1.size() &lt;&lt; boolalpha &lt;&lt; &quot;, empty = &quot; &lt;&lt; s1.empty() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        for (auto val : s1)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h3><p>1、无序关联容器和有序关联容器的相同点<br>(1)也属于关联容器，<strong>有set和map两种，set只有key，map有(key, value)对</strong><br>(2)<strong>也有带不带multi_的版本</strong>，差异和上节讲的一样<br>(3)<strong>操作方法很多都是重合的，名字和作用也都一样</strong></p>
<p>2、无序关联容器和有序关联容器的差异点<br>(1)<strong>有序内部用红黑树实现，无序内部用哈希函数实现</strong><br>(2)<strong>有序插入元素时会内部自动排序，无序插入时不排序，按照哈希规则直接映射存放</strong></p>
<p>3、无序关联容器初步使用<br>(1)unordered_set和unordered_map<br>参考学习：<br><a href="https://zh.cppreference.com/w/cpp/container/unordered_set">https://zh.cppreference.com/w/cpp/container/unordered_set</a><br><a href="https://zh.cppreference.com/w/cpp/container/unordered_map">https://zh.cppreference.com/w/cpp/container/unordered_map</a></p>
<h3 id="哈希函数和桶"><a href="#哈希函数和桶" class="headerlink" title="哈希函数和桶"></a>哈希函数和桶</h3><p>1、什么是哈希函数(一类函数)<br>(1)哈希表是一种典型数据结构，又被称为是散列表，英文hashmap<br>(2)STL中的哈希表hashmap就是unordered_map<br>(3)哈希函数是可以用来实现哈希表的函数，是一类而不是一个<br>(4)哈希表的本质是k-v结构，也就是给定key可以找到一个位置来对应value</p>
<p>2、哈希冲突及其解决<br>参考学习：<a href="https://blog.csdn.net/WX_East/article/details/56005664?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control">unorder_map的底层实现方法</a></p>
<h3 id="unordered-map中桶相关的方法"><a href="#unordered-map中桶相关的方法" class="headerlink" title="unordered_map中桶相关的方法"></a>unordered_map中桶相关的方法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, string&gt; m1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                m1.<span class="built_in">insert</span>(&#123;i, <span class="string">&quot;abc&quot;</span>&#125;);</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;&#123;&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="string">&quot;abc&quot;</span> &lt;&lt; <span class="string">&quot;&#125;,     &quot;</span>;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;element size = &quot;</span> &lt;&lt; m1.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;, bucket size = &quot;</span> &lt;&lt; m1.<span class="built_in">bucket_count</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>4. C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>MTKcam-ISP7-CamCtrl</title>
    <url>/2024/11/19/2024-11-20-MTKcam-ISP7-CamCtrl/</url>
    <content><![CDATA[<h2 id="CamCtrl简介："><a href="#CamCtrl简介：" class="headerlink" title="CamCtrl简介："></a>CamCtrl简介：</h2><p>文件目录：vendor/mediatek/proprietary/hardware/mtkcam-core/hw/camsys/cam_ctrl/</p>
<span id="more"></span>
<p>CamCtrl是P1Node/PipeMgr/3A HAL/ISP HAL的协调者。其主要有两个作用：</p>
<ul>
<li>搜集从P1 Node过来的request Info，然后queue给driver（使用PipeMgr并通过SensorPipe接口丢给MTK drivers):<br>request Info包含：</li>
<li>Image Info. (from P1Node)，例如上层传下来的buffer size，format等</li>
<li>Setting (from 3A-HAL)，例如需要给到driver的gain值，曝光等</li>
<li>Tuning (from ISP-HAL)，例如从tuning参数中获取的信息等</li>
<li>从driver中做deque(使用PipeMgr并通过SensorPipe接口),并将结果传递给用户：<ul>
<li>Image buffer(to P1Node)</li>
<li>STT buffer(to 3A HAL)，如AAO，AFO等统计信息</li>
</ul>
</li>
</ul>
<p>更多可以参考：<a href="https://shenweikun.github.io/2024/11/18/2024-11-20-MTKcam-ISP7-Camsys-Hw-Lib/">ISP7-Camsys Hw-Lib</a></p>
<h2 id="CamCtrl基本流程"><a href="#CamCtrl基本流程" class="headerlink" title="CamCtrl基本流程:"></a>CamCtrl基本流程:</h2><p>   <img src="image1.png"><br>如上图，描述的是CamCtrl与其它模块相互交互时使用的function。不同颜色的线代表不同的线程，其中requestregulator thread是混色的，代表包含多个线程(实现同一功能)。同一颜色的不同标号代表一串事件的先后顺序。</p>
<h3 id="request-thread"><a href="#request-thread" class="headerlink" title="request thread:"></a>request thread:</h3><ol>
<li>当Pipeline model Queue一个request到P1 Node时，P1 Node会调用的Camtrl的tryEnQ()往Camtrl塞request</li>
<li>随后CamCtrl会调用到3A-HAL的setControl()，把当前request带下来的metadata数据设置到3A-HAL中，让3A-HAL去做一些预处理。</li>
<li>同时，CamCtrl还会调用到RequestRegulator中的enrollRequest()函数，通知RequestRegulator，CamCtrl收到了一帧request，并且已将其相关的metadata参数设置到了3A-HAL。此信息将用于控制request的节奏。</li>
</ol>
<h3 id="requestRegulator-thread"><a href="#requestRegulator-thread" class="headerlink" title="requestRegulator thread:"></a>requestRegulator thread:</h3><ol>
<li>RequestRegulator有一个线程会通过CamCtrl去调用到Sensor-Pipe的wait-SOF()，去等待sof信号。</li>
<li>当RequestRegulator收到sof信号后，会通过CamCtrl的cueFrameStart()去triggerFrameStart（我理解是触发接收下一个request）。</li>
<li>CamCtrl调用RequestRegulator的available()去确认request的节奏，CamCtrl是否可以接收下一个request。</li>
<li>若能接收下一个quest，CamCtrl会调用到P1 Node的requestSubmission()，告诉P1 Node可以继续tryEnQ()塞request下来了。</li>
<li>于此同时,CamCtrl会通过P1 Node的setupSubmission(),去获取上一个request的image buffer。</li>
</ol>
<h3 id="deque-thread"><a href="#deque-thread" class="headerlink" title="deque thread:"></a>deque thread:</h3><ol>
<li>P1 Node会调用CamCtrl的tryDeQ()。tryDeQ()是blocking code，所以只有当真正的driver那边吐出data，CamCtrl的tryDeQ才会被完成，这个时候P1 Node就可以拿到result的数据。</li>
<li>CamCtrl的tryDeQ()实际会去调用Sensor-Pipe的deque()，然后等待driver deque数据出来。这个数据包括Image buffer和STT buffer。</li>
<li>当Sensor-Pipe deque出数据之后，首先CamCtrl会调用3A-HAL 的setSttBuffer()，将统计数据设置到3A-HAL</li>
<li>CamCtrl调用3A-HAL的getResult()，去获取3A的result meta。</li>
<li>CamCtrl调用ISP-HAL的getResultByFrameID()，去获取ISP的result meta。</li>
</ol>
<h3 id="CamCtrl-thread-3A-thread"><a href="#CamCtrl-thread-3A-thread" class="headerlink" title="CamCtrl thread/3A thread:"></a>CamCtrl thread/3A thread:</h3><ol>
<li>当deque thread的第3步，CamCtrl通过setSttBuffer将统计数据给到3A-HAL后，若3A-HAL使用完，会调用notifySettingReadyEvent()告诉CamCtrl有一个request的结果计算完成了。</li>
<li>CamCtrl调用3A-HAL的getSetting()，拿到3A-HAL的计算结果。</li>
<li>CamCtrl调用ISP-HAL的getCamSysMetaTuning()，拿到ISP-HAL的计算结果。</li>
<li>前面2(getSetting())，3(getCamSysMetaTuning())，结合requestRegulator thread中的5(setupSubmission())，这里就获取到了3份数据（3A-HAL的计算结果，ISP-HAL的计算结果，Image Buffer），此时所有数据准备就绪，就可以通过CamCtrl去调用RequestRegulator的informReady()，通知RequestRegulator已经CamCtrl已经准备好了，可以enque了。</li>
<li>RequestRegulator调用CamCtrl的hintForEnQ(),去通知CamCtrl做enque。</li>
<li>CamCtrl去做enque。</li>
<li>当CamCtrl做完enque之后，CamCtrl会调用RequestRegulator的informCount，去告诉RequestRegulator，我已经往driver做enque了。之所以要告诉RequestRegulator，是因为RequestRegulator要控制enque的节奏，避免driver中累积太多的request。</li>
</ol>
<p>参考：[ISP7]CAMSYS_HW-Lib_P1Node_CamCtrl.pdf</p>
]]></content>
      <categories>
        <category>1. Android Camera</category>
      </categories>
      <tags>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
        <tag>MTKCamera</tag>
      </tags>
  </entry>
  <entry>
    <title>MTKcam-ISP7-Camsys Hw-Lib</title>
    <url>/2024/11/18/2024-11-20-MTKcam-ISP7-Camsys-Hw-Lib/</url>
    <content><![CDATA[<h2 id="High-Level-view"><a href="#High-Level-view" class="headerlink" title="High-Level view"></a>High-Level view</h2><p><img src="High-Level-view.png"><br>CAMSYS_HW-Lib所在位置如上图红框所示，包含<strong>CamCtrl</strong>，<strong>PipeMgr</strong>，<strong>CamCoordinator</strong>，<strong>RequestRegulator</strong>四个模块，向上通过CamCtrl沟通P1Node，向下通过PipeMgr对接drivers，访问硬件，同时CamCtrl还可以沟通IHALIsp Adapter和3A control flows。<br><img src="image1.png"></p>
<span id="more"></span>
<h3 id="CamCtrl"><a href="#CamCtrl" class="headerlink" title="CamCtrl:"></a>CamCtrl:</h3><p>文件目录：vendor/mediatek/proprietary/hardware/mtkcam-core/hw/camsys/cam_ctrl/<br>CamCtrl是P1Node/PipeMgr/3A HAL/ISP HAL的协调者。其主要有两个作用：</p>
<ul>
<li>搜集从P1 Node过来的request Info，然后queue给driver（使用PipeMgr并通过SensorPipe接口丢给MTK drivers):<br>request Info包含：</li>
<li>Image Info. (from P1Node)，例如上层传下来的buffer size，format等</li>
<li>Setting (from 3A-HAL)，例如需要给到driver的gain值，曝光等</li>
<li>Tuning (from ISP-HAL)，例如从tuning参数中获取的信息等</li>
<li>从driver中做deque(使用PipeMgr并通过SensorPipe接口),并将结果传递给用户：<ul>
<li>Image buffer(to P1Node)</li>
<li>STT buffer(to 3A HAL)，如AAO，AFO等统计信息</li>
</ul>
</li>
</ul>
<h3 id="PipeMgr-SensorPipe"><a href="#PipeMgr-SensorPipe" class="headerlink" title="PipeMgr/SensorPipe:"></a>PipeMgr/SensorPipe:</h3><p>文件目录：vendor/mediatek/proprietary/hardware/mtkcam-core/hw/camsys/pipe_mgr/<br>pipeMgr的作用：</p>
<ul>
<li>简化和封装V4L2-FW操作</li>
<li>抽象化CamCtrl</li>
<li>构建sensor map，映射driver中的设备文件<br>pipe_mgr兼容isp6，pipe_mgr目录下有isp6s和isp7两个目录。主要有如下几个类：<br><img src="image2.png"><br>PipeCapability类没在代码中找到定义。PiPeMgr和sensorPipe互为友元，PiPeMgr和RawPipe互为友元。剩下三个是PipeMgr的友元，可以访问PipeMgr的数据。</li>
</ul>
<h3 id="CamCoordinator"><a href="#CamCoordinator" class="headerlink" title="CamCoordinator:"></a>CamCoordinator:</h3><p>文件目录：vendor/mediatek/proprietary/hardware/mtkcam-core/hw/camsys/cam_coordinator/<br>CamCoordinator作用：</p>
<ul>
<li>Negotiate and Configure the CAMSYS topology</li>
<li>Align MW-Frame and CAMSYS Request in multiple-sensor sources</li>
</ul>
<h3 id="RequestRegulator"><a href="#RequestRegulator" class="headerlink" title="RequestRegulator:"></a>RequestRegulator:</h3><p>文件目录：vendor/mediatek/proprietary/hardware/mtkcam-core/hw/camsys/request_regulator/<br>RequestRegulator的作用：</p>
<ul>
<li>防止request累积，因为enque给driver的request都需要被消费，不会被drop，所以当P1处理较慢就会形成堆积。</li>
<li>监控和调整request消耗</li>
<li>为Cam Ctrl提供不同的策略选择<br>  <img src="image3.png"><br>主要有ContSttRegulator，ImageRequestRegulator，SttRegulator三个类对IRequestRegulator接口的实现。</li>
</ul>
<h2 id="Instance-view"><a href="#Instance-view" class="headerlink" title="Instance view"></a>Instance view</h2><p>如下是从instance view的视角来看Camsys-HW-Lib各个模块间的关系:<br>   <img src="image4.png"><br>1.此图是一个multicam的例子，可以看到左右两边是对称的<br>2. PipeMgr针对不同的sensor有开出两个SensorPipe接口，不同Sensor的CamCtrl会使用的不同的SensorPipe接口实例<br>3.其他的如：P1Node、HalISP、Hal3A、RequestRegulator也都是每个实例服务对应的单颗sensor<br>4.而像CamCoordinator、PipeMgr、V4L2 Framework因为需要统筹整个系统的资源，所以是Topology的View<br>从这个图也可以看出，<strong>CamCtrl</strong>和<strong>P1Node</strong>等可以有多个实例，<strong>CamCoordinator</strong>和<strong>RequestRegulator</strong>只有单个实例，用于统筹<strong>CamCtrl和P1Node</strong>等模块</p>
<h2 id="The-role-conception-of-module-layer"><a href="#The-role-conception-of-module-layer" class="headerlink" title="The role/conception of module-layer"></a>The role/conception of module-layer</h2><p>下图描述了从PipelineModel→ P1Node→ CamCtrl→ PipeMgr→ V4L2各层级作用和扮演的角色。<br>   <img src="image5.png"></p>
<h2 id="Data-Processing"><a href="#Data-Processing" class="headerlink" title="Data Processing"></a>Data Processing</h2><p>   <img src="image6.png"><br>例如：pipelineModel会送一个request给P1Node，P1Node会送给CamCtrl，到了CamCtrl之后，它会跟P1Node拿image、跟ISP_HAL拿tuning、跟HAL3A拿setting，都准备好后就一整包使用同一个<strong>request-FD</strong>打包好后送给PipeMgr，之后再透过PipeMgr往V4L2 FrameWork进行设置，进而控制底层driver的行为。<br>ISP7 之前 P1Node 会跟 Hal3A、P1Driver、HalISP 都有交互,目前在 ISP7 上对 P1Node 有做解耦操作,P1Node 会跟 MW 对接,处理 feature 相关的部分,而跟其他模块交互的动作就交给了 CamCtrl,使 P1Node 的工作变得单纯,也使得 CamCtrl 可以不用关注 feature 相关的部分。</p>
<p>参考文章：<br>[ISP7]CAMSYS_HW-Lib_P1Node_CamCtrl.pdf</p>
]]></content>
      <categories>
        <category>1. Android Camera</category>
      </categories>
      <tags>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
        <tag>MTKCamera</tag>
      </tags>
  </entry>
  <entry>
    <title>MTKcam-ISP7-P1 Node</title>
    <url>/2024/11/19/2024-11-20-MTKcam-ISP7-P1-Node/</url>
    <content><![CDATA[<h2 id="P1Node-Architecture-Overview"><a href="#P1Node-Architecture-Overview" class="headerlink" title="P1Node Architecture Overview"></a>P1Node Architecture Overview</h2><p>   <img src="image1.png"><br>如上图所示，在旧版的ISP6中，P1Node会直接与HAL3A，NormalPipe，HalIsp进行交互，但是在新的ISP7架构中，引入了CamCtrl作为协调者，统一协调Camsys Hw-Lib，P1Node与CAMCtrl进行交互。关于Camsys Hw-Lib的介绍可以看文档： <a href="https://shenweikun.github.io/2024/11/18/2024-11-20-MTKcam-ISP7-Camsys-Hw-Lib/">ISP7-Camsys Hw-Lib</a><br>由此，P1 Node的工作变得更加清晰简单。</p>
<span id="more"></span>
<h2 id="P1Node-Basic-Flow"><a href="#P1Node-Basic-Flow" class="headerlink" title="P1Node Basic Flow"></a>P1Node Basic Flow</h2><p>   <img src="image2.png"><br>如图是P1Node处理request的Basic Flow：</p>
<ol>
<li>首先P1Node会先实作一些callback，可让CamCtrl回调，主要实作是requestsubmission和setupsubmission。CamCtrl 透过 requestSubmission 去通知 P1Node 送 request 下来,此时 P1Node 会通知 Pipeline 送 request 下来,之后 Pipeline 就会调用 P1Node 的 queue 丢 request 下来,接着P1Node 会 call 到 CamCtrl 的 tryEnQ 将 request 送下来。</li>
<li>接下来 CamCtrl 会调用 setupSubmission,主要是告之 P1Node 已经送了 request 下来,CamCtrl 这边也拿到了对应的设定,让 P1Node 将对应的 buffer 给 acquire 出来,并通知 P1Node 设定 buffer 的address 给 CamCtrl。</li>
<li>P1Node 有一个 deque thread,这个 thread 会 call CamCtrl 的 tryDeQ,tryDeQ 是 blocking code,所以只有当真正 driver 那边有吐 data,CamCtrl 的 tryDeQ 才会放开,这个时候 P1Node 就可以拿到result 的数据。</li>
<li>P1Node 还有一个 deliver thread,deliver thread 会透过 pipeline 的接口进行 dispatch。</li>
</ol>
<h3 id="Nornal-Request："><a href="#Nornal-Request：" class="headerlink" title="Nornal Request："></a>Nornal Request：</h3><p>   <img src="image3.png"><br>上面是描述Normal Request的例子：</p>
<ol>
<li>假设MW透过P1Node的queue接口送request下来，P1Node 会先执行 parseFrame 产生 <strong>S_Queue</strong>，在S_Queue 的时候主要是去 call CamCtrl 的 tryEnQ(图中 S_Queue 后面的 hwOps_try_enque()表达的是它会 call try enque,其他的状态后面表示被相应的事件来 trigger)。</li>
<li>tryEnQ 主要是先告知 CamCtrl 有 request 进来,并将一些 setting 预先告知 CamCtrl。</li>
<li>tryEnQ 之后 state machine 就会进入 <strong>S_Enque</strong>,并等待下一个 event trigger,这个 event 会是setupSubmission,setupSubmission 被 trigger 的时候 S_Enque 相关 function 会被执行,这个过程会跟MW 要 buffer,做完之后 state machine 就会停留在 <strong>S_Deque</strong>。</li>
<li>S_Deque 状态会等 Deque thread trigger,当 deque thread 已经 deque 到东西,这个时候 S_Deque 的stage 就会做事情去产生 metadata,并切到下一个 state <strong>S_Deliver</strong> 等待被 trigger。</li>
<li>当Deliver thread 知道有可以 Deliver 的 frame 进入之后就会 call pipeline 的接口做 deliver。</li>
</ol>
<h3 id="Reprocess："><a href="#Reprocess：" class="headerlink" title="Reprocess："></a>Reprocess：</h3><p>   <img src="image4.png"></p>
<h3 id="FastPreview-fast-launch"><a href="#FastPreview-fast-launch" class="headerlink" title="FastPreview(fast launch):"></a>FastPreview(fast launch):</h3><p>   <img src="image5.png"><br>FastPreview的流程如上图(if preqCnt != -1)的流程，原本正常的流程request需要tryEnQ 并进入S_Enque状态，此时需要等待3A相关的计算。<br>为了加速启动，当((if preqCnt != -1)成立时，会调用preEnQ，进入S_PreQue状态，此时采用<strong>默认的3A计算结果（一般会是上一次退出相机时的3A计算结果）</strong>直接作用在driver，随后调用setupSubmission ，让 P1Node 将对应的 buffer 给 acquire 出来，并将buffer address给到Camctrl, 等待driver 吐帧。随后的流程和Normal Request一致。</p>
<h3 id="Drop-Case："><a href="#Drop-Case：" class="headerlink" title="Drop Case："></a>Drop Case：</h3><p>drop case应用在上层下发flush的场景，通过dropSubmission实现drop：<br>   <img src="image6.png"></p>
]]></content>
      <categories>
        <category>1. Android Camera</category>
      </categories>
      <tags>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
        <tag>MTKCamera</tag>
      </tags>
  </entry>
  <entry>
    <title>C++从入门到进阶之二-C++和面向对象</title>
    <url>/2024/11/17/2024-11-17-CPP-Basics-C-and-ObjectOrientation/</url>
    <content><![CDATA[<p>面向对象是一种编程思想</p>
<span id="more"></span>
<h2 id="从高处看面向对象"><a href="#从高处看面向对象" class="headerlink" title="从高处看面向对象"></a>从高处看面向对象</h2><h3 id="面向对象是一种编程思想"><a href="#面向对象是一种编程思想" class="headerlink" title="面向对象是一种编程思想"></a>面向对象是一种编程思想</h3><p>(1)<strong>面向对象并不是C++特有的，所有编程语言都可以面向对象</strong><br>(2)面向对象语言就是设计语言特性时充分考虑并且原生支持面向对象特征的那些编程语言<br>(3)<strong>面向对象之于编程，就好像比喻修辞法之于写作</strong><br>(4)面向对象只是编程语言语法层面的东西，不影响最终生成的二进制程序，也不关CPU的事</p>
<h3 id="面向对象并不是一个单一概念"><a href="#面向对象并不是一个单一概念" class="headerlink" title="面向对象并不是一个单一概念"></a>面向对象并不是一个单一概念</h3><p>(1)面向对象三大特征：<strong>封装、继承、多态</strong><br>(2)面向对象还会延伸出很多细节，而不同编程语言会选择不同的应对方法<br>(3)C++的语法细节很多，而Java的语法细节少，但都是面向对象的<br>(4)面向对象是设计模式的基础，凡事从简单到复杂其实学起来顺理成章</p>
<h3 id="拓展分析和总结"><a href="#拓展分析和总结" class="headerlink" title="拓展分析和总结"></a>拓展分析和总结</h3><p>1、Linux中面向对象编程、华为LiteOS中面向对象编程、STM32 HAL库中面向对象编程<br>  - 使用C语言，借助结构体和函数指针来实现面向对象的思想。</p>
<p>2、总结<br>(1)面向对象是针对面向过程说的，编程时关注对象由“过程”转为“对象”<br>(2)面向对象的外部表象就是一种组织代码，写程序的方式<br>(3)<strong>面向对象的本质是一种封装数据和看待问题的更高层次的视角</strong><br>(4)<strong>面向对象是应对越来越复杂问题，是处理越来越庞大程序的更有效的方法</strong><br>(5)语言由非面向对象升级到面向对象是自然而然的成长，和人一样</p>
<h2 id="C-的封装和访问权限"><a href="#C-的封装和访问权限" class="headerlink" title="C++的封装和访问权限"></a>C++的封装和访问权限</h2><h3 id="典型的C-面向对象编程"><a href="#典型的C-面向对象编程" class="headerlink" title="典型的C++面向对象编程"></a>典型的C++面向对象编程</h3><p>1、C++面向对象式编程总结<br>(1)整个工作分为2大块：一个是建模和编写类库，一个是使用类库来编写主程序完成任务。<br>(2)有些人只负责建模和编写类库 。<br>(3)有些人直接调用现成类库来编写自己的主任务程序，譬如使用opencv分析一张图片中有没有电动车<br>(4)难度上不确定，2个都可能很难或者很简单。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//person.hpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __PERSON_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PERSON_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> MAN</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">                <span class="comment">//属性</span></span><br><span class="line">                string name;</span><br><span class="line">                <span class="keyword">int</span> age;</span><br><span class="line">                <span class="keyword">int</span> male;<span class="comment">//1表示男，0表示女</span></span><br><span class="line">                <span class="comment">//方法        </span></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:        </span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//person.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MAN::person::<span class="built_in">work</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;male) </span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;working is coding&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;shopping&quot;</span> &lt;&lt; endl;        </span><br><span class="line">        &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MAN::person::<span class="built_in">eat</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;eating food and fruits.&quot;</span> &lt;&lt; endl;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MAN::person::<span class="built_in">sleep</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sleeping.age = &quot;</span> &lt;&lt; age &lt;&lt; endl;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> MAN;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        person zhangsan;</span><br><span class="line">        </span><br><span class="line">        zhangsan.name = <span class="string">&quot;zhangzheng&quot;</span>;</span><br><span class="line">        zhangsan.age = <span class="number">22</span>;</span><br><span class="line">        zhangsan.male = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        zhangsan.<span class="built_in">eat</span>();</span><br><span class="line">        zhangsan.<span class="built_in">work</span>();</span><br><span class="line">        zhangsan.<span class="built_in">sleep</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<p>2、C++学习的三重境界<br>(1)学习C++第一重境界就是语法层面，先学会如何利用C++来建模、来编程，学习语法时先别解决难度大问题。<br>(2)学习C++第二重境界是解决问题层面，学习如果理解并调用现成类库来编写主程序解决问题。<br>(3)学习C++第三重境界是编写类库和sample给别人用，需要基础好且有一定架构思维。</p>
<h3 id="C-的构造函数和析构函数"><a href="#C-的构造函数和析构函数" class="headerlink" title="C++的构造函数和析构函数"></a>C++的构造函数和析构函数</h3><p>1、什么是构造函数<br>(1)constructor，字面意思是用来构造对象的函数；destructor，字面意思是用来析构对象的函数<br>(2)可以理解为语言自带的一种hook函数（回调函数）<br>  回调函数就是一个被作为参数传递的函数。回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。<br>(3)<strong>当对象产生时构造函数会自动被调用，一般用于初始化class的属性、分配class内部需要的动态内存</strong><br>(4)<strong>对象消亡时析构函数会自动被调用，一般用于回收constructor中分配的动态内存，避免内存丢失</strong></p>
<p>2、构造和析构一般用法<br><strong>(1)不写时C++会自动提供默认的构造和析构，也可以显式提供默认构造和析构函数<br>(2)构造和析构函数不需要返回值类型，构造函数可以带参或不带参，析构函数不带参<br>(3)构造函数可以重载（overload），析构函数不需要重载</strong></p>
<p>3、为什么需要构造函数和析构函数<br>(1)构造函数可以看作是<strong>对象的初始化式</strong>，注意对比对象和变量的初始化区别<br>(2)<strong>构造函数可以为对象完成动态内存申请，同时在析构函数中再释放，形成动态内存的完整使用循环。</strong><br>(3)<strong>C语言中struct无构造函数概念，所以struct中需要用到动态内存时必须在定义struct变量后再次单独申请和释放，而这些操作都需要程序员手工完成</strong><br>(4)C++ class的构造和析构特性，是C++支持面向对象编程的一大语言特性。 </p>
<h3 id="在构造和析构函数中使用动态内存"><a href="#在构造和析构函数中使用动态内存" class="headerlink" title="在构造和析构函数中使用动态内存"></a>在构造和析构函数中使用动态内存</h3><p>1、析构函数的使用<br>(1)<strong>析构函数在对象对销毁时自动调用</strong>，一般有2种情况<br>(2)<strong>用new分配的对象，用delete显式析构,才会调用析构函数</strong><br>(3)<strong>分配在栈上的对象（例如局部变量），当栈释放时自动析构</strong><br>(4)普通情况下析构函数都是空的，因为不必做什么特别的事情</p>
<p>2、在class中使用动态内存变量<br>(1)什么情况下用动态内存？<br>  - 需要大块内存，且需要按需灵活的申请和释放，用栈怕爆、用全局怕浪费等<br>(2)在class person中增加一个int *指针，用于指向一个int类型元素的内存空间<br>(3)在构造函数中分配动态内存<br>(4)在析构函数中回收动态内存<br>(5)将动态内存从int变量升级到int数组变量<br>(6)实战中C++常用的动态内存往往是容器vector那些，之后的文章会讲到</p>
<p>3、用valgrind工具查看内存泄漏<br>(1)valgrind工具介绍：参考：<a href="https://blog.csdn.net/u012662731/article/details/78652651">https://blog.csdn.net/u012662731/article/details/78652651</a><br>(2)安装：sudo apt-get install valgrind（ubuntu16.04 X64）<br>(3)编译程序：主要是添加-g参数便于调试时有行号 g++ person.cpp main.cpp -g -o apptest<br>(4)使用：valgrind –tool=memcheck –leak-check=full –show-reachable=yes –trace-children=yes ./可执行程序名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//person.hpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __PERSON_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PERSON_H_</span></span><br><span class="line"><span class="comment">//要学会使用条件宏从而避免重复包含，否则会出现一些奇怪的错误，如</span></span><br><span class="line"><span class="comment">//person()的重载不支持，会报错，只能有一个person函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> MAN&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">person</span>;</span><span class="comment">//声明这个类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">        &#123;</span>                </span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">                <span class="comment">//属性</span></span><br><span class="line">                string name;</span><br><span class="line">                <span class="keyword">int</span> age;</span><br><span class="line">                <span class="keyword">int</span> male;<span class="comment">//0表示女，1表示男</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//构造与析构函数</span></span><br><span class="line">                <span class="built_in">person</span>();<span class="comment">//默认构造函数        </span></span><br><span class="line">                <span class="built_in">person</span>(string name);<span class="comment">//自定义构造函数</span></span><br><span class="line">                ~<span class="built_in">person</span>();<span class="comment">//默认析构函数</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//方法</span></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span>:        </span><br><span class="line">                </span><br><span class="line">        &#125;;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//person.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MAN::person::<span class="built_in">eat</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot;eat&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> MAN::person::<span class="built_in">sleep</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;        </span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot;sleeping&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> MAN::person::<span class="built_in">work</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;male)</span><br><span class="line">        &#123;                </span><br><span class="line">                cout &lt;&lt; name &lt;&lt; <span class="string">&quot;coding&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; name &lt;&lt; <span class="string">&quot;shopping&quot;</span> &lt;&lt; endl;                </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">MAN::person::<span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//默认构造函数是空的</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">MAN::person::<span class="built_in">person</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;<span class="comment">//构造对象后同时对对象的属性初始化</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">MAN::person::~<span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//默认析构函数也是空的</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp 文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> MAN;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        string s1 = <span class="string">&quot;linux&quot;</span>;</span><br><span class="line">        <span class="comment">//person *pPerson = new person;</span></span><br><span class="line">        person *pPerson = <span class="keyword">new</span> <span class="built_in">person</span>(s1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//pPerson-&gt;name = &quot;zhangsan&quot;;</span></span><br><span class="line">        pPerson-&gt;age = <span class="number">23</span>;</span><br><span class="line">        pPerson-&gt;male = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        pPerson-&gt;<span class="built_in">eat</span>();</span><br><span class="line">        pPerson-&gt;<span class="built_in">work</span>();</span><br><span class="line">        pPerson-&gt;<span class="built_in">sleep</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数与类的成员初始化"><a href="#构造函数与类的成员初始化" class="headerlink" title="构造函数与类的成员初始化"></a>构造函数与类的成员初始化</h3><p>1、构造函数一大功能就是初始化成员变量<br>(1)<strong>默认构造函数不带参，无初始化功能</strong><br>(2)若无其他构造函数，则默认构造函数可以省略。但若有个其他构造函数但还想使用默认构造函数，则默认构造函数不能省，必须写上。<br>(3)栈上分配对象时，若使用默认构造函数，则对象变量后面不加空的()，若用带参构造才需要加”(初始化参数)”</p>
<p>2、C++的成员初始化列表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Person::<span class="built_in">Person</span>(string my_name, <span class="keyword">int</span> my_age, <span class="keyword">bool</span> my_male):<span class="built_in">name</span>(my_name),</span><br><span class="line">                                                         <span class="built_in">age</span>(my_age),</span><br><span class="line">                                                         <span class="built_in">male</span>(my_male)</span><br><span class="line">&#123;<span class="comment">//使用构造函数的参数给属性赋值</span></span><br><span class="line">                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="comment">// example 1,构造函数初始化列表</span></span><br><span class="line">    <span class="built_in">CExample</span>(): <span class="built_in">a</span>(<span class="number">0</span>),<span class="built_in">b</span>(<span class="number">8.8</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// example 2,构造函数内部赋值</span></span><br><span class="line">    <span class="built_in">CExample</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        a=<span class="number">0</span>;</span><br><span class="line">        b=<span class="number">8.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的例子中两个构造函数的结果是一样的。上面的构造函数（使用初始化列表的构造函数）显式的初始化类的成员；而没使用初始化列表的构造函数是对类的成员赋值，并没有进行显式的初始化<br><strong>(1)一般用于带参构造函数中，用来给属性传参赋值<br>(2)成员初始化列表和构造函数之间用冒号间隔，多个列表项之间用逗号间隔<br>(3)初始化列表可以替代构造函数内的赋值语句，达到同样效果</strong></p>
<p>3、构造函数使用参数默认值<br><strong>(1)class声明时可以给函数形参赋值一个默认值，实际调用时若不传参就使用默认值<br>(2)方法实现时形参可以不写默认值，但是实际是按照声明时的默认值规则的<br>(3)有默认值情况，要注意实际调用不能有重载歧义，否则编译不能通过</strong><br>要注意这样一种歧义情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">person</span>()&#123;&#125;;</span><br><span class="line"><span class="built_in">person</span>(string myname = <span class="string">&quot;linux&quot;</span>, <span class="keyword">int</span> myage = <span class="number">10</span>, <span class="keyword">bool</span> male = <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>这样去创建对象时:person pPerson;无法判断你是使用的无参数构造函数还是使用有了参数的并且设定了默认值的构造函数。</p>
<p>还有一种情况也会出现歧义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">person</span>(string myname, <span class="keyword">int</span> myage);</span><br><span class="line"><span class="built_in">person</span>(string myname, <span class="keyword">int</span> myage, <span class="keyword">bool</span> male = <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>因为第二个的最后一个形参有默认参数可以不传参，所以就会造成重载上的歧义。<br>函数重载不考虑参数的默认值，只看参数多个形参情况下，<strong>若有一个形参有默认参数，则其之后的形参也必须有默认参数，其之前的可以不必有。否则会报错。</strong><br>(4)所有参数都带默认值的构造函数，1个可以顶多个构造函数（举例说明）,通过传的参数个数和默认参数的结合实现多种情况:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">person</span>(string myname = <span class="string">&quot;linux&quot;</span>, <span class="keyword">int</span> myage = <span class="number">10</span>, <span class="keyword">bool</span> male = <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">person</span>(s1)</span><br><span class="line"><span class="built_in">person</span>(string myname, <span class="keyword">int</span> myage = <span class="number">10</span>, <span class="keyword">bool</span> male = <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">person</span>(s1, <span class="number">23</span>)</span><br><span class="line"><span class="built_in">person</span>(string myname, <span class="keyword">int</span> myage, <span class="keyword">bool</span> male = <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h3 id="拷贝构造函数的引入"><a href="#拷贝构造函数的引入" class="headerlink" title="拷贝构造函数的引入"></a>拷贝构造函数的引入</h3><p>1、用对象来初始化对象<br>(1)<strong>简单变量</strong>定义时，可以直接初始化，<strong>也可以用另一个同类型变量来初始化</strong>（间接初始化）。举例说明:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">//直接初始化</span></span><br><span class="line"><span class="keyword">int</span> b = a;<span class="comment">//间接初始化</span></span><br></pre></td></tr></table></figure>

<p>(2)用class来定义对象时，可以直接初始化，也可以用另一个对象来初始化。举例说明:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(“linux”, <span class="number">100</span>, <span class="number">0</span>)</span></span>;<span class="comment">//直接初始化，调用构造函数初始化</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;  <span class="comment">//间接初始化，调用拷贝构造函数初始化</span></span><br><span class="line">Person p2 = p1; <span class="comment">//间接初始化，调用拷贝构造函数初始化</span></span><br></pre></td></tr></table></figure>

<p>2、为什么可以<br>(1)变量的直接初始化，是变量在被分配内存之后直接用初始化值去填充赋值完成初始化<br>(2)变量用另一个变量来初始化，是给变量分配了内存后执行了一个内存复制操作来完成的初始化<br>(3)<strong>对象的直接初始化，是对象在分配内存之后调用了相应constructor来完成的初始化</strong><br>(4)<strong>对象用另一个对象来初始化，是对象在分配之后调用了相应的copy constructor来完成初始化</strong></p>
<p>3、拷贝构造函数<br>(1)拷贝构造函数是构造函数的一种，符合构造函数的一般性规则<br>(2)<strong>拷贝构造函数的引入是为了让对象在初始化时能够像简单变量一样的被直接用”=”来赋值</strong><br>(3)<strong>拷贝构造函数不需要重载，他的参数列表固定为const classname&amp; xx</strong><br>    &amp;表示引用<br>(4)拷贝构造函数很合适用初始化列表来实现<br>默认提供的拷贝函数会自动去完成拷贝，而我们自己写的拷贝函数需要自己去进行拷贝。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//person.hpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __PERSON_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PERSON_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> MAN</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//声明这个类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">                <span class="comment">//访问权限</span></span><br><span class="line">                <span class="keyword">public</span>:</span><br><span class="line">                        <span class="comment">//属性</span></span><br><span class="line">                        string name;</span><br><span class="line">                        <span class="keyword">int</span> age;</span><br><span class="line">                        <span class="keyword">bool</span> male;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//构造与析构函数</span></span><br><span class="line">                        <span class="built_in">person</span>(string myname, <span class="keyword">int</span> myage, <span class="keyword">bool</span> mymale);</span><br><span class="line">                        <span class="built_in">person</span>(<span class="keyword">const</span> person&amp; pn);  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">                        ~<span class="built_in">person</span>();</span><br><span class="line">                        <span class="keyword">int</span> *p;</span><br><span class="line">                        <span class="keyword">int</span> *p1;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//方法</span></span><br><span class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                        </span><br><span class="line">                <span class="keyword">private</span>:        </span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//person.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> MAN;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">person::eat</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot;eat&quot;</span> &lt;&lt; endl;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">person::work</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;male)</span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot; coding&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot; shopping&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">person::sleep</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot;sleep&quot;</span> &lt;&lt; endl;                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出对象中所有成员的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">person::print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name = &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;male = &quot;</span> &lt;&lt; male &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p = &quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot; p size:&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p) &lt;&lt;endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*p1 = &quot;</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-----------&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person::<span class="built_in">person</span>(string myname, <span class="keyword">int</span> myage, <span class="keyword">bool</span> mymale):<span class="built_in">name</span>(myname),<span class="built_in">age</span>(myage),<span class="built_in">male</span>(mymale)</span><br><span class="line"><span class="comment">//MAN::person::person(string myname, int myage, bool mymale)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">this</span>-&gt;p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;userdefined constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line">person::<span class="built_in">person</span>(<span class="keyword">const</span> person&amp; pn):<span class="built_in">name</span>(pn.name),<span class="built_in">age</span>(pn.age),<span class="built_in">male</span>(pn.male)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //使用初始化成员列表和以下方法的效果相同，已使用初始化列表，这里可以屏蔽</span></span><br><span class="line"><span class="comment">        this-&gt;name = pn.name;</span></span><br><span class="line"><span class="comment">        this-&gt;age = pn.age;</span></span><br><span class="line"><span class="comment">        this-&gt;male = pn.male;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(pn.p));</span><br><span class="line">        <span class="keyword">this</span>-&gt;p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*pn.p1); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person::~<span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;p;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;p1;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;userdefined destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> MAN;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//方式一：直接初始化</span></span><br><span class="line">        <span class="function">person <span class="title">p1</span><span class="params">(<span class="string">&quot;astyon&quot;</span>, <span class="number">35</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式二：用另一个对象来初始化新定义的对象</span></span><br><span class="line">        <span class="comment">//person p2=p1;  // OK </span></span><br><span class="line">        <span class="function">person <span class="title">p2</span><span class="params">(p1)</span></span>;   <span class="comment">// OK</span></span><br><span class="line">        </span><br><span class="line">        p1.<span class="built_in">print</span>();</span><br><span class="line">        p2.<span class="built_in">print</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么是访问权限问题"><a href="#什么是访问权限问题" class="headerlink" title="什么是访问权限问题"></a>什么是访问权限问题</h3><p>1、public访问权限是全局的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="keyword">public</span>的成员变量，在类的成员方法中可以直接访问</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)<span class="keyword">public</span>的成员变量，在任何外部代码中可以通过类的对象来直接访问</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)<span class="keyword">public</span>的成员方法，在类内其他成员方法中可以直接调用</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)<span class="keyword">public</span>的成员方法，在任何外部代码中可以通过类的对象来直接访问</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>)<span class="keyword">public</span>就是完全不设防</span><br></pre></td></tr></table></figure>

<p>2、private访问权限</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="keyword">private</span>的成员变量，在类的成员方法中可以直接访问</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)<span class="keyword">private</span>的成员变量，在任何外部代码中不可以通过对象来直接访问</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)<span class="keyword">private</span>的成员方法，在类内其他成员方法中可以直接调用</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)<span class="keyword">private</span>的成员方法，在任何外部代码中不可以通过对象来直接访问</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>)<span class="keyword">private</span>就是对内不设防，对外完全设防的</span><br></pre></td></tr></table></figure>

<p>3、更多关于访问权限问题的问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="keyword">protected</span>是第三种访问权限修饰符，如果有必要还可以有第<span class="number">4</span>种甚至更多</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)访问权限叠加类的继承、<span class="keyword">static</span>、<span class="keyword">friend</span>等特性后才更加显出复杂性和威力</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)暂时只先引入这个概念，掌握基本用法和规则即可，后面逐步去深入</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)<span class="keyword">protected</span>: 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问</span><br></pre></td></tr></table></figure>

<h3 id="C-为什么要设计访问权限"><a href="#C-为什么要设计访问权限" class="headerlink" title="C++为什么要设计访问权限"></a>C++为什么要设计访问权限</h3><p>1、访问权限作用1：保护内部资源</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="keyword">private</span>的成员是<span class="class"><span class="keyword">class</span>内部使用，外部没必要直接访问（读取或赋值），所以干脆在语法上让你看不见</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(2)访问权限的保护是一种语法层面的保护，而非硬件上限制访问，硬件做不了这么细致</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(3)最终目的也是为了整个程序更安全</span></span><br></pre></td></tr></table></figure>

<p>2、访问权限作用2：隐藏外部无需关心的细节</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)将<span class="class"><span class="keyword">class</span>内部使用而外部绝不会用到的成员变量隐藏起来，以免干扰外部或者不小心被外部修改了</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(2)隐藏细节可以降低使用类库的人的难度，调用时只看到对我有用的东西</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(3)这个隐藏其实是把<span class="keyword">class</span>的作者和使用者专业分工，是很有必要的</span></span><br></pre></td></tr></table></figure>

<p>3、这就是面向对象的封装特性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)封装特性的体现之一就是抽象，抽象的一层意思就是隐藏掉不必要的细节</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)封装特性的体现之一就是组织和保护，便于整个整体和外部更合理的交流</span><br></pre></td></tr></table></figure>

<h3 id="访问权限带来的一些新编程理念"><a href="#访问权限带来的一些新编程理念" class="headerlink" title="访问权限带来的一些新编程理念"></a>访问权限带来的一些新编程理念</h3><p>1、只读或只写变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)问题：你的<span class="class"><span class="keyword">class</span>中需要一个变量，但是希望外部只能读不能写，怎么实现？</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(2)分析：硬件、<span class="title">OS</span>、编程语言都未提供这样的<span class="title">RO</span>或<span class="title">WO</span>的机制，只能间接实现了</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(3)解决方案：利用访问权限，将成员变量设计为<span class="title">private</span>，然后再通过封装成员方法来实现</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(4)如果只提供<span class="title">read</span>方法那就是只读成员，如果只提供<span class="title">write</span>方法那就是只写成员</span></span><br><span class="line"><span class="class"><span class="title">eg</span>:</span>上方的<span class="keyword">private</span>.<span class="built_in">cpp</span></span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>)这样的成员经常被称为属性（property），C#等高级编程语言中就源生支撑这种新编程思想</span><br></pre></td></tr></table></figure>

<p>2、复杂程序架构化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)简单程序规模小，参与人少，靠人本身的逻辑能力就能保证实现和质量</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)复杂程序规模大参与人多，协作成本高，水平良莠不齐，必须靠架构式设计才能保证实现和质量</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)架构化设计中权限管控的思想很重要，每一层的访问权限和主要关注点都不同</span><br></pre></td></tr></table></figure>

<p>3、为什么C语言不需要这些</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)C主要做裸机开发和OS内核开发，都是独立一体化程序，不隔离，所以不需要也没法管控权限</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)C程序一般规模小，不需要管控权限</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)C程序强调性能，而权限管控一定程度会牺牲性能(存储、运行速度等)。凡事都有两面性。</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)越是高级语言，编程越偏业务逻辑，就越需要权限管控和架构思想这些。</span><br></pre></td></tr></table></figure>

<h3 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h3><p>1、C和C++中struct的区别</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)C中不支持成员函数（只能通过函数指针成员变量间接支持），而C++源生支持。</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)C中不支持<span class="keyword">static</span>成员，而C++中支持。后面会详细讲，C++ <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>是一个大知识点</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(3)访问权限，<span class="title">C</span>中默认<span class="title">public</span>，<span class="title">C</span>++中默认<span class="title">public</span>，但是可以显式指定<span class="title">public</span>/<span class="title">private</span>/<span class="title">protected</span>三者之一</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(4)继承特性上，<span class="title">C</span>中不支持（只能通过结构体包含来间接实现），而<span class="title">C</span>++源生支持，且</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>和<span class="keyword">class</span>可以互相继承</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(5)初始化方面，<span class="title">C</span>中靠初始化式（<span class="title">gcc</span>扩展了初始化语法），而<span class="title">C</span>++靠构造函数所以初始化更</span></span><br><span class="line"><span class="class">自由可定制化</span></span><br></pre></td></tr></table></figure>

<p>2、C++中struct和class的区别</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)默认成员权限，<span class="class"><span class="keyword">struct</span>默认<span class="title">public</span>，<span class="keyword">class</span>默认<span class="title">private</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(2)继承关系的权限管控，<span class="keyword">struct</span>默认<span class="title">public</span>，<span class="keyword">class</span>默认<span class="title">private</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(3)<span class="keyword">struct</span>和<span class="keyword">class</span>交叉继承时，默认的权限管控取决于子类而不是基类</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(4)模板相关使用都用<span class="keyword">class</span>，而不用<span class="keyword">struct</span>了</span></span><br></pre></td></tr></table></figure>

<p>3、总结<br>(1)C++中struct和class差别不大，大多数情况下都可以直接替换使用而不出错<br>(2)C++中struct其实有点“人格分裂”，他既要兼容C中struct，又要像C++的class当struct有了一个构造函数，他C的初始化方式就不能用了。<br>(3)结论：<strong>除非是只需要打包几个变量数据就用C方式的struct，否则如果需要面向对象式编程就用class</strong></p>
<h3 id="const和mutable是干嘛的"><a href="#const和mutable是干嘛的" class="headerlink" title="const和mutable是干嘛的"></a>const和mutable是干嘛的</h3><p>1、const可以实现常函数<br>(1)<strong>常函数，就是class的成员函数承诺在函数内部不会修改class的任何成员变量，注意是任何一个</strong><br>(2)思考：C++为什么设计常函数？<br>  为了class的设计者和使用者更好的协作，避免错误的使用类库c++规定，使用函数的参数是一个const类型的引用，则该引用包括的所有成员方法必须是常方法，即常函数 </p>
<p>2、mutable可以局部打破const常函数<br>(1)<strong>const常函数承诺在函数内不会修改class的任何一个成员变量</strong><br>(2)<strong>但是有时候个别成员变量，就是需要在const的常函数中也能修改</strong>（注意只是个别，其他大部分是不需要修改的）<br>(3)怎么办？<br>2个解法：<strong>要么去掉const，要么使用mutable局部打洞</strong> </p>
<p>(4)const、mutable使用演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//person.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __PERSON_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PERSON_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> MAN</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">person</span>;</span><span class="comment">//前置声明</span></span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">person</span>//声明这个类</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">                <span class="keyword">int</span> salary;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">                string name;</span><br><span class="line">                <span class="keyword">int</span> age;</span><br><span class="line">                </span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">add_age</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">radd_age</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">                <span class="keyword">int</span> grade;</span><br><span class="line">                <span class="keyword">mutable</span>        <span class="keyword">int</span> great_grade;</span><br><span class="line">        <span class="keyword">protected</span>:</span><br><span class="line">                        </span><br><span class="line">        &#125;;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//person.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> MAN;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">person::work</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot;is working.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">person::add_age</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age++;</span><br><span class="line">        <span class="keyword">this</span>-&gt;great_grade =<span class="number">149</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age =&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">person::radd_age</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//this-&gt;age++;//这个是不行的，可以取消注释，编译看看实际效果</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;great_grade++;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;age =&quot; &lt;&lt; this-&gt;age &lt;&lt; endl;        </span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;great_grade =&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;great_grade &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> MAN;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> person&amp; pn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        pn.<span class="built_in">radd_age</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        person human;</span><br><span class="line">        </span><br><span class="line">        human.name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">        human.age = <span class="number">22</span>;</span><br><span class="line">        <span class="comment">//human.grade = 59;</span></span><br><span class="line">        <span class="comment">//human.great_grade = 150;</span></span><br><span class="line">        </span><br><span class="line">        human.<span class="built_in">work</span>();</span><br><span class="line">        human.<span class="built_in">add_age</span>();</span><br><span class="line">        <span class="built_in">test</span>(human);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(5)思考：C++为什么设计mutable？<br>和private那里一样，还是“<strong>先全部禁了再按需打开</strong>”的思路。</p>
<p>3、class的前置声明<br>(1)就是class的声明，安慰编译器的<br>(2)看到了认识即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明这个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、inline 成员函数<br>(1)<strong>类的声明中直接写函数体，则此函数会被编译器inline化处理</strong><br>(2)类的声明中正常处理，而成员函数的实现中加inline<br>(3)<strong>inline的成员函数应该放在hpp中而不是cpp中，这个一定要注意，因为inline是在编译时替换的</strong><br>因为C/C++编译时是以当前.c文件为单位的，只考虑当前c文件，如果将inline函数放在另一个文件中，而在这个文件中有使用，编译时是会报错的，提示无法找到函数体，只有在c文件都编译完链接的时候才会发现，所以要将其放在头文件中。</p>
<p>5、本篇文章总结<br>(1)本篇文章主要在讲C++的封装特性，以及由此引发的各种细节语法特性。<br>(2)语法上掌握是第一层，会写代码跑起来是第二层，遇到问题能调出来是第三层，理解设计原理是第四层。</p>
<h2 id="C-的继承和多态特性"><a href="#C-的继承和多态特性" class="headerlink" title="C++的继承和多态特性"></a>C++的继承和多态特性</h2><h3 id="什么是面向对象的继承特性"><a href="#什么是面向对象的继承特性" class="headerlink" title="什么是面向对象的继承特性"></a>什么是面向对象的继承特性</h3><p>1、C++类的继承语法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span>访问控制（继承的权限描述） 基类名<span class="number">1</span>,访问控制 基类名<span class="number">2</span>,访问控制 基类名n</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 成员变量和成员方法列表（除了构造和析构之外的成员方法）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、什么是继承<br>(1)继承是C++源生支持的一种语法特性，是C++面向对象的一种表现<br>(2)<strong>继承特性可以让派生类“瞬间”拥有基类的所有（当然还得考虑权限）属性和方法</strong><br>(3)<strong>继承特性本质上是为了代码复用</strong>（在C语言中可以通过结构体变量中包含结构结构体变量来实现）<br>(4)类在C++编译器的内部可以理解为结构体，派生类是由基类成员叠加派生类新成员得到的</p>
<p>3、继承特性是天然的<br>(1)天然的意思就是：符合现实世界的本质规律，而不是纯粹人为施加的。<br>(2)继承inheritance和组合composition是软件重用的2种有效方式<br>(3)<strong>派生类,范围小,具体。 基类,范围大,抽象</strong><br>(4)派生类又叫子类，基类又叫父类。两种叫法都有人常用</p>
<h3 id="C-继承中的权限管控"><a href="#C-继承中的权限管控" class="headerlink" title="C++继承中的权限管控"></a>C++继承中的权限管控</h3><p>1、C++类中的访问权限管控<br>(1)public 类内部可以访问，类的外部可以访问<br>(2)private 类内部可以访问，类的外部不能访问<br>(3)protected 类内部可以访问，类的外部不能访问</p>
<p>2、继承时的三种权限设置对派生类的影响<br>(1)public继承（公有继承）：父类成员在子类中保持原有访问级别<br>(2)private继承（私有继承）：父类成员在子类中变为private成员<br>(3)protected继承（保护继承）：<strong>父类中public成员会变成protected</strong>,父类中protected成员仍然为protected,父类中private成员仍然为private<br>(4)<strong>如果继承时不写则默认情况下派生类为class时是private继承，而派生类为struct时是public继承</strong> </p>
<p>3、设计类时如何规定成员的访问权限<br>(1)需要被外界访问的成员直接设置为public<br>(2)只能在当前类中访问的成员设置为private<br>(3)只能在当前类和子类中访问的成员设置为protected。</p>
<p>总结：<br>（1）父类的public成员，<strong>经过public继承后</strong>，在子类中是public的。<br>（2）父类的private成员，<strong>经过public继承后</strong>，在子类中是比private还可怜的。意思是这个成员在子类中是存在的，意思是它不能被直接访问（子类的成员方法），怎么能访问？<br>  答：只能通过子类从父类继承而来的父类里实现了的成员函数来间接访问。此时使用的父类实现的函数以及访问的父类继承的成员变量都是子类中继承过来的，并不属于父类，都是子类的。<br>（3）父类的protected成员，<strong>经过public继承后</strong>，在子类中是protected的。意思就是该成员在子类中是子类内部成员可以访问，子类对象外部不可以访问，子类再次去继承产生孙类中他还是protected的。<br>（4）<strong>public继承，对于父类中public和protected成员的权限在子类中，其实是没有增强也没有削弱的；</strong>但是对于父类中private成员，其实在子类中是有削弱的（比private还可怜）<br>（5）<strong>如果是private继承，那么父类中的public成员和protected成员就变成了子类中的private成员，父类中的private成员成了子类中比private还可怜的那种成员。</strong><br>（6）<strong>如果是protected继承，那么父类中的public成员和protected成员就变成了子类中的protected成员，父类中的private成员成了子类中比private还可怜的那种成员。</strong></p>
<p>进一步总结：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、父类的<span class="keyword">private</span>成员，在三种继承下都会变成在子类中是比<span class="keyword">private</span>还可怜的这种成员</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、父类的<span class="keyword">public</span>成员，在<span class="keyword">public</span>继承下到子类中还是<span class="keyword">public</span>，在<span class="keyword">protected</span>继承下到子类</span><br><span class="line">中是<span class="keyword">protected</span>的，在<span class="keyword">private</span>继承下到子类中是<span class="keyword">private</span>的。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、父类的<span class="keyword">protected</span>成员，在<span class="keyword">public</span>继承下到子类中是<span class="keyword">protected</span>的，在<span class="keyword">protected</span>继承下</span><br><span class="line">到子类中是<span class="keyword">protected</span>的，在<span class="keyword">private</span>继承下到子类中是<span class="keyword">private</span>的。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、<span class="keyword">private</span>：如果是父类中的<span class="keyword">private</span>权限成员，那么在继承时会被降到比<span class="keyword">private</span>还惨的</span><br><span class="line">这种；而如果是<span class="keyword">private</span>继承，则不会导致父类中<span class="keyword">public</span>和<span class="keyword">protected</span>的成员降权到比</span><br><span class="line"><span class="keyword">private</span>还惨的这种，只会降级到<span class="keyword">private</span>权限。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、在继承中父类中所有的成员（不管哪种权限）都会被继承给子类，而不会丢失任何一个。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">父类中的成员继承到子类后的权限简单记忆方法：继承权限和继承的权限那个惨用哪个，即那</span><br><span class="line">个更严格用那个。</span><br><span class="line">eg:继承权限：<span class="class"><span class="keyword">class</span> <span class="title">person</span>:</span><span class="keyword">public</span></span><br><span class="line">   继承的权限：<span class="keyword">protected</span></span><br><span class="line">   父类中的成员继承到子类后的权限:<span class="keyword">protected</span></span><br></pre></td></tr></table></figure>

<h3 id="继承体系下子类和父类的关系"><a href="#继承体系下子类和父类的关系" class="headerlink" title="继承体系下子类和父类的关系"></a>继承体系下子类和父类的关系</h3><p>1、本质上是2个独立的类<br>(1)<strong>继承只是通过父类来快速构建子类的一种语法技术，继承后得到的子类和父类是独立的2个类</strong><br>(2)<strong>程序中子类的对象和父类的对象是2个独立的对象，没有任何关系，只是形成对象的模板有部分相同</strong><br>(3)子类对象中访问的子类从父类继承而来的成员，其实是属于子类自己的，并不是父类（对象）里面的</p>
<p>2、站在子类角度看继承<br>(1)非继承体系下的类，完全是自己“手工”构建的，所有成员根据访问权限不同而分为1个层级3大块（逻辑上）<br>(2)继承体系下的子类，部分直接从父类继承，部分自己手工打造，所有成员分成2个层级（继承来的，自己写的），每个层级3大块（访问权限）<br>(3)继承就是子类在构建自己的过程中使用的一种快速批量成员获取方法而已 </p>
<p> 3、为什么父类private成员在子类中还有<br>(1)思考：父类的所有成员在子类中都必须有吗？有没有可能父类有一个成员其实子类没必要具备的？<br>    答：1、不一定；2、有可能<br>(2)思考：如何做到在继承时让程序员指定父类的哪些成员参与继承，哪些不参与？<br>  答：可以通过某个关键字实现。但是C++并没有这么做，他选择了全继承。<br>(3)选择：继承就是父类所有成员全部按分类规则传给子类</p>
<p>4、为什么父类private成员在子类中还有但不能直接访问<br>(1)思考：这个规定是天然的，还是人为规定的？其实是：人为规定的。 因为：访问权限这一套本身就是人为的<br>(2)为什么这样设计1：如果能直接访问，那就打破了父类private的含义（父类私有），破坏了class的封装性<br>(3)为什么这样设计2：父类的private成员在子类中很大可能本来就不需要去访问，所以能直接访问反而有风险，没必要<br>(4)为什么这样设计3：间接访问合乎一个原则：在哪里定义的成员变量在哪里操作。子类和父类不是一个人写的时尤其要这样，避免问题<br>(5)这也是一个如何选择的设计哲学问题。 </p>
<h3 id="派生类和基类的构造析构关系"><a href="#派生类和基类的构造析构关系" class="headerlink" title="派生类和基类的构造析构关系"></a>派生类和基类的构造析构关系</h3><p>1、<strong>派生类并不继承基类的构造和析构函数，只继承成员变量和普通成员方法</strong><br>(1)不继承，意思是派生类中确实没有，不包含基类的构造和析构函数<br>(2)派生类自己有自己的构造和析构，规则和之前讲过的完全一样<br>(3)研究构造和析构函数时，一定要注意默认规则</p>
<p>2、<strong>派生类的构造函数一定会调用基类的构造函数，析构也一样</strong><br>(1)代码验证：在基类和派生类中都显式提供“默认构造”并添加打印信息，通过执行结果来验证</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()&#123; cout &lt;&lt; <span class="string">&quot;Person()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    ~<span class="built_in">Person</span>()&#123; cout &lt;&lt; <span class="string">&quot;~Person()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">man</span>:</span><span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">man</span>()&#123; cout &lt;&lt; <span class="string">&quot;man()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    ~<span class="built_in">man</span>()&#123; cout &lt;&lt; <span class="string">&quot;~man()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    man *m = <span class="keyword">new</span> <span class="built_in">man</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上面代码输出：</span></span><br><span class="line"><span class="built_in">Person</span>()</span><br><span class="line"><span class="built_in">man</span>()</span><br><span class="line">~<span class="built_in">man</span>()</span><br><span class="line">~<span class="built_in">Person</span>()</span><br></pre></td></tr></table></figure>
<p>通过代码执行结果看到的现象总结：<strong>派生类的构造函数执行之前，会先调用基类的构造函数，然后再调用自己的构造函数。而在派生类的析构函数之后，会先执行自己的析构函数，再执行基类的析构函数。</strong></p>
<p>3、为什么派生类的构造（析构）必须调用基类的某个构造（析构）<br>(1)<strong>牢记构造函数的2大作用：初始化成员，分配动态内存</strong><br>(2)派生类和基类各自有各自的构造函数和析构函数，所以是各自管理各自的成员初始化，各自分配和释放各自所需的动态内存<br>(3)继承的语言特性，允许派生类调用基类的构造和析构函数，以管理派生类从基类继承而来的那些成员。<br>(4)明确：<strong>派生类的构造和析构处理的永远是派生类自己的对象，只是派生类对象模板中有一部分是从基类继承而来的而已。</strong></p>
<p>4、其他几个细节<br>派生类构造函数可以直接全部写在派生类声明的class中，也可以只在clas中声明时只写派生类构造函数名和自己的参数列表，不写继承基类的构造函数名和参数列表，而在派生类的cpp文件中再写满整个继承列表，这就是语法要求<br>(2)派生类析构函数则不用显式调用，直接写即可直接调用基类析构函数。猜测是因为参数列表问题。<br>(3)构造函数的调用顺序是先基类再派生类，而析构函数是先派生类再基类，遵循栈规则。<br>(4)派生类的构造函数可以在调用基类构造函数同时，用逗号间隔同时调用初始化式来初始化派生类自己的成员 </p>
<p>5、派生类做的三件事<br>(1)吸收基类成员：除过构造和析构函数以外的所有成员全部吸收进入派生类中<br>(2)更改继承的成员。1是更改访问控制权限(根据继承类型还有成员在基类中的访问类型决定) 2是同名覆盖(派生类中同名成员覆盖掉基类中)<br>(3)添加派生类独有的成员。</p>
<h3 id="派生类和基类的同名成员问题"><a href="#派生类和基类的同名成员问题" class="headerlink" title="派生类和基类的同名成员问题"></a>派生类和基类的同名成员问题</h3><p>1、<strong>派生类中再实现一个基类中的方法会怎样</strong><br>(1)代码实验：派生类和基类中各自实现一个内容不同但函数原型完全相同的方法，会怎么样？<br>(2)结论：<strong>基类对象调用的是基类的方法，派生类对象调用执行的是派生类中重新提供的方法</strong><br>(3)<strong>这种派生类中同名同参方法替代掉基类方法的现象，叫做：重定义（redefining），也有人叫做隐藏。</strong><br>(4)隐藏特性生效时派生类中实际同时存在2份同名同参（但在不同类域名中）的方法，同时都存在，只是一个隐藏了 另一个 </p>
<p>2、<strong>派生类中如何访问被隐藏的基类方法</strong><br>(1)<strong>派生类对象直接调用时，隐藏规则生效，直接调用的肯定是派生类中重新实现的那一个</strong><br>(2)<strong>将派生类强制类型转换成基类的类型，再去调用则这时编译器认为是基类在调用，则调用的是基类那一个，隐藏规则被绕过了</strong><br>(3)在派生类内部，使用父类::方法()的方式，可以强制绕过隐藏规则，调用父类实现的那一个 </p>
<p>3、注意和总结<br>(1)其实不止成员方法，成员变量也遵循隐藏规则。<br>(2)<strong>隐藏规则本质上是大小作用域内同名变量的认领规则问题，实际上2个同名成员都存在当前派生类的对象内存中的</strong><br>(3)<strong>隐藏（重定义，redefining）</strong>，与<strong>重载（overload）</strong>、<strong>重写（override，又叫覆盖）</strong>，这三个概念一定要区分清楚。 </p>
<h3 id="子类和父类的类型兼容规则"><a href="#子类和父类的类型兼容规则" class="headerlink" title="子类和父类的类型兼容规则"></a>子类和父类的类型兼容规则</h3><p>1、何为类型兼容规则<br>(1)C和C++都是强类型语言，任何变量和对象，指针，引用等都有类型，编译器根据类型来确定很多事<br>(2)派生类是基类的超集，基类有的派生类都有（但构造函数和析构函数例外），派生类有的基类不一定有，所以这2个类型间有关联<br>(3)派生类对象可以cast(类型转换相关的关键字)后当作基类对象，而基类对象不能放大成派生类对象，否则就可能会出错<br>(4)考虑到指针和引用与对象指向后，派生类和基类对象的访问规则就是所谓类型兼容规则。</p>
<p>2、类型兼容规则的常见情况及演示<br><strong>(1)子类对象可以当作父类对象使用，也就是说子类对象可以无条件隐式类型转换为一个父类对象，但是将父类强转成子类是隐藏危险的。<br>(2)子类对象可以直接初始化或直接赋值给父类对象<br>(3)父类指针可以直接指向子类对象<br>(4)父类引用可以直接引用子类对象</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()&#123; cout &lt;&lt; <span class="string">&quot;Person()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    ~<span class="built_in">Person</span>()&#123; cout &lt;&lt; <span class="string">&quot;~Person()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Person::eat()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">man</span>:</span><span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">man</span>()&#123; cout &lt;&lt; <span class="string">&quot;man()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    ~<span class="built_in">man</span>()&#123; cout &lt;&lt; <span class="string">&quot;~man()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;man::eat()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">eat</span>();</span><br><span class="line">        Person::<span class="built_in">eat</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    man m1;</span><br><span class="line"></span><br><span class="line">    Person&amp; p2 = m1;  <span class="comment">// 父类引用可以直接引用子类对象，类型兼容，没有警告没有错误，</span></span><br><span class="line">    p2.<span class="built_in">eat</span>();         <span class="comment">// 编译器在解析这句时，认为p2是 Person&amp; 类型的，所以会调用:Person::eat()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//man *m2 = &amp;p1; // 子类的指针指向父类，会编译报错，因为编译器认为父类对象不能直接当做之类对象使用</span></span><br><span class="line"></span><br><span class="line">    Person *p3 = &amp;p1;</span><br><span class="line">    Person *p4 = &amp;m1;  <span class="comment">// 父类的指针指向子类的对象，类型兼容，没有警告没有错误，</span></span><br><span class="line">    p4-&gt;<span class="built_in">eat</span>();         <span class="comment">// 编译器在解析这句时，认为p2是 Person* 类型的，所以会调用:Person::eat()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Person</span>()</span><br><span class="line"><span class="built_in">Person</span>()</span><br><span class="line"><span class="built_in">man</span>()</span><br><span class="line">Person::<span class="built_in">eat</span>()</span><br><span class="line">Person::<span class="built_in">eat</span>()</span><br><span class="line">~<span class="built_in">man</span>()</span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">~<span class="built_in">Person</span>()</span><br></pre></td></tr></table></figure>

<p>3、总结<br>(1)派生类对象可以作为基类的对象使用，但是只能使用从基类继承的成员。<br>(2)类型兼容规则是<strong>多态性</strong>的重要基础之一。<br>(3)总结：子类就是特殊的父类 (base *p = &child;)</p>
<h3 id="继承的优势与不良继承"><a href="#继承的优势与不良继承" class="headerlink" title="继承的优势与不良继承"></a>继承的优势与不良继承</h3><p>1、为什么会有继承<br>(1)本质上为了代码复用<br>(2)继承方式很适合用来构建复杂框架体系<br>(3)用继承来设计类进而构建各层级对象，符合现实中的需要。举例：描述人的种群</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">人类</span><br><span class="line">男人     女人</span><br><span class="line">小男孩   青年   中年男人   老年男人</span><br></pre></td></tr></table></figure>

<p>2、何为不良继承<br>(1)鸵鸟不是鸟问题。因为鸵鸟从鸟继承了fly方法但是鸵鸟不会飞<br>(2)圆不是椭圆问题。因为圆从椭圆继承了长短轴属性然而圆没有长短轴属性<br>(3)不良继承是天然的，是现实世界和编程的继承特性之间的不完美契合</p>
<p>3、如何解决不良继承<br>(1)修改继承关系设计。既然圆继承椭圆是一种不良类设计就应该杜绝。去掉继承关系，两个类可以继承自同一个共同的父类，不过该类不能执行不对称的setSize计算，然后在圆和椭圆这2个子类中分别再设计以区分<br>(2)所有不良继承都可以归结为“圆不是椭圆”这一著名具有代表性的问题上。在不良继承中，基类总会有一些额外能力，而派生类却无法满足它。这些额外的能力通常表现为一个或多个成员函数提供的功能。要解决这一问题，<strong>要么使基类弱化，要么消除继承关系</strong>，需要根据具体情形来选择。 </p>
<h3 id="组合介绍以及与继承对比"><a href="#组合介绍以及与继承对比" class="headerlink" title="组合介绍以及与继承对比"></a>组合介绍以及与继承对比</h3><p>1、什么是组合<br>(1)composition，组合，就是在一个class内使用其他多个class的对象作为成员<br>(2)用五官做案例讲解</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">eye</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">eyebrow</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">nose</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mouth</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ear</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FacialFeatures</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    eye      ey;</span><br><span class="line">    eyebrow  eb;</span><br><span class="line">    nose     n;</span><br><span class="line">    mouth    m;</span><br><span class="line">    ear      er;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>(3)组合也是一种代码复用方法，本质也是结构体包含</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用组合的方式实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    C c;</span><br><span class="line">    <span class="keyword">short</span> s1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用继承的方式实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A, <span class="keyword">public</span> B, <span class="keyword">public</span> C </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">short</span> s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、继承与组合的特点对比<br>(1)继承是a kind of（is a）关系，具有传递性,不具有对称性。<br>(2)组合是a part of（has a）的关系，<br>(3)继承是白盒复用。因为类继承允许我们根据自己的实现来覆盖重写父类的实现细节，父类的实现对于子类是可见的。<br>(4)继承的白盒复用特点，一定程度上破坏了类的封装特性，因为这会将父类的实现细节暴露给子类<br>(5)组合属于黑盒复用。被包含对象的内部细节对外是不可见的，所以它的封装性相对较好，实现上相互依赖比较小<br>(6)组合中被包含类会随着包含类创建而创建，消亡而消亡。组合属于黑盒复用，并且可以通过获取其它具有相同类型的对象引用或指针，在运行期间动态的定义组合（例如上边提到的子类对象可作为一个父类对象使用）。而缺点就是致使系统中的对象过多。<br>(7)OO设计原则是<strong>优先组合，而后继承</strong> </p>
<h3 id="多继承及其二义性问题"><a href="#多继承及其二义性问题" class="headerlink" title="多继承及其二义性问题"></a>多继承及其二义性问题</h3><p>1、多继承<br>(1)多继承就是一个子类有多个父类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;</span>派生类名&gt;:&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">    &lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>(2)多继承演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类 Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line">      <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类 PaintCost</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintCost</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getCost</span><span class="params">(<span class="keyword">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> area * <span class="number">70</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line">   <span class="keyword">int</span> area;</span><br><span class="line"> </span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">   area = Rect.<span class="built_in">getArea</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出总花费</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total paint cost: $&quot;</span> &lt;&lt; Rect.<span class="built_in">getCost</span>(area) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)多继承和单继承的原理，效果并无明显区别<br>(4)多继承会导致二义性问题</p>
<p>2、多继承的二义性问题1<br>(1)场景：<strong>C多继承自A和B，则C中调用A和B的同名成员时会有二义性</strong><br>(2)原因：<strong>C从A和B各自继承了一个同名（不同namespace域）成员，所以用C的对象来调用时编译器无法确定我们想调用的是哪一个</strong><br>(3)解决办法1：避免出现，让A和B的public成员命名不要重复冲突。但这个有时不可控。<br>(4)解决办法2：编码时明确指定要调用哪一个，用c.A::func()明确指定调用的是class A的func而不是class B的<br>(5)解决办法3：在C中重定义func，则调用时会调用C中的func，A和B中的都被隐藏了<br>(6)总结：能解决，但是都没有很好的解决。 </p>
<p>3、多继承的二义性问题2<br>(1)场景：菱形继承问题。即A为祖类，B1:A, B2:A, C:B1,B2，此时用C的对象调用A中的某个方法时会有二义性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>:</span> <span class="keyword">public</span> A&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span>:</span> <span class="keyword">public</span> A&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B1, <span class="keyword">public</span> B2&#123;.....&#125;;</span><br></pre></td></tr></table></figure>
<p>(2)分析：c.func()有二义性，c.A::func()也有二义性，但是c.B1::func()和c.B2::func()却没有二义性<br>(3)解决办法：和问题1中的一样，但是问题2更隐蔽，也更难以避免</p>
<p>4、总结<br>(1)二义性就是歧义，好的情况表现为编译错误，不好的情况表现为运行时错误，最惨的情况表现为运行时莫名其妙<br>(2)随着系统的变大和变复杂，难免出现二义性，这不是程序员用不用心的问题，是系统自身带来的<br>(3)<strong>解决二义性问题不能靠程序员个人的细心和调试能力，而要靠机制，也就是编程语言的更高级语法特性</strong><br>(4)<strong>虚函数、虚继承、纯虚函数、抽象类、override（重写，覆盖）、多态等概念就是干这些事的</strong><br>(5)感慨：欲戴王冠必承其重，要揽瓷器活就得有金刚钻，C++学得越清楚就越能想象将来用C++去解决的都是些什么层次的问题 </p>
<h3 id="虚继承解决菱形继承的二义性问题"><a href="#虚继承解决菱形继承的二义性问题" class="headerlink" title="虚继承解决菱形继承的二义性问题"></a>虚继承解决菱形继承的二义性问题</h3><p>1、虚继承怎么用<br>(1)场景：菱形继承导致二义性问题，本质上是在孙子类C中有B1和B2中包含的2份A对象，所以有了二义性。<br>(2)虚继承解决方案：让A和B虚继承D，C再正常多继承A和B即可，虚继承会使得C继承A、B时只选择AB其中的一份D，不会重复，类似于头文件不重复包含</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>()&#123;cout&lt;&lt;<span class="string">&quot;D()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">D</span>()&#123;cout&lt;&lt;<span class="string">&quot;~D()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> D</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;B()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;~B()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> D</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;~A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> B, <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>()&#123;cout&lt;&lt;<span class="string">&quot;C()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">C</span>()&#123;cout&lt;&lt;<span class="string">&quot;~C()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    C c;   <span class="comment">//D, B, A ,C</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(c)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)<strong>虚继承就这么简单，就是为了解决菱形继承的二义性问题而生，和虚函数（为了实现多态特性）并没有直接关系</strong></p>
<p>2、虚继承的实现原理<br>(1)虚继承的原理是：虚基类表指针vbptr 和 虚基类表virtual table<br>  vbptr指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。<br>  菱形继承中，两个虚基类表指针vbptr通过指针偏移量来找寻虚基类表（避免了二义性），但通过两个虚基类表最终找到的是同一个基类。<br>详解参考：<a href="https://blog.csdn.net/xiejingfa/article/details/48028491">https://blog.csdn.net/xiejingfa/article/details/48028491</a> </p>
<h3 id="多态和虚函数"><a href="#多态和虚函数" class="headerlink" title="多态和虚函数"></a>多态和虚函数</h3><p>1、通过案例学多态<br>(1)案例：父类Animal，2个子类Dog和Cat，实现speak方法<br>(2)用父类指针指向各对象，调用各方法看效果，记下来</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Animal::speak</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Speaking!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dog::speak</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wang wang wang!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cat::speak</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;miao miao miao!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal a;</span><br><span class="line">    Dog d;</span><br><span class="line">    Cat c;</span><br><span class="line">    </span><br><span class="line">    a.<span class="built_in">speak</span>();  <span class="comment">// 打印 Speaking!</span></span><br><span class="line">    d.<span class="built_in">speak</span>();  <span class="comment">// 打印 wang wang wang!</span></span><br><span class="line">    c.<span class="built_in">speak</span>();  <span class="comment">// 打印 miao miao miao!</span></span><br><span class="line"></span><br><span class="line">    Animal *p; </span><br><span class="line">    p = &amp;a;</span><br><span class="line">    p-&gt;<span class="built_in">speak</span>();  <span class="comment">// 打印 Speaking!</span></span><br><span class="line"></span><br><span class="line">    p = &amp;d;</span><br><span class="line">    p-&gt;<span class="built_in">speak</span>();  <span class="comment">// 打印 Speaking!</span></span><br><span class="line">    </span><br><span class="line">    p = &amp;c;</span><br><span class="line">    p-&gt;<span class="built_in">speak</span>();  <span class="comment">// 打印 Speaking!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Speaking!</span><br><span class="line">wang wang wang!</span><br><span class="line">miao miao miao!</span><br><span class="line">Speaking!</span><br><span class="line">Speaking!</span><br><span class="line">Speaking!</span><br></pre></td></tr></table></figure>
<p>(3)将父类speak方法声明为virtual，再用父类指针调用各方法看效果，记下来</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// 添加 virtual 关键字</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Speaking!</span><br><span class="line">wang wang wang!</span><br><span class="line">miao miao miao!</span><br><span class="line">Speaking!</span><br><span class="line">wang wang wang!</span><br><span class="line">miao miao miao!</span><br></pre></td></tr></table></figure>
<p>(4)对比差异，理解什么叫多态</p>
<p>2、什么是多态<br>(1)<strong>polymorphism，多态，面向对象的三大特征之一</strong>。<br>(2)<strong>从宏观讲，多态就是要实现一套逻辑多种具体适配的执行结果</strong>。猫就应该是猫的叫声，狗就应该是狗的叫声.<br>(3)<strong>从微观讲，多态就是要一套代码在运行时根据实际对象的不同来动态绑定/跳转执行相匹配的具体函数</strong>.<br>(4)<strong>函数声明前加virtual的即是虚函数</strong><br>(5)虚函数是C++实现多态特性的基础，从语法上讲多态特性的基类方法必须是虚函数 </p>
<p>3、多态中的override（复写）<br>(1)<strong>基类中方法声明为virtual，派生类中重新实现同名方法以实现多态，这就叫override</strong>（中文为覆盖，或重写）<br>(2)注意区分<strong>override</strong>和<strong>redefining</strong>，微观上最大区别就是是否有virtual，宏观上最大区别就是是否表现为多态</p>
<p>4、多态一定要通过面向对象和override来实现吗？<br>(1)<strong>宏观上的多态是一种编程效果，微观上的多态是一种C++支持的编程技术，微观是为了去实现宏观</strong><br>(2)不用C++的virtual和override，也可以实现宏观上的多态，C中我们就经常这么干。<br>(3)C中实现多态的案例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Cat,</span><br><span class="line">    Dog</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dog_speak</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wang wang wang!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cat_speak</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;miao miao miao!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (type == Dog)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Dog_speak</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == Cat)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Cat_speak</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tmp);</span><br><span class="line">    <span class="built_in">speak</span>(tmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4)C++源生支持多态，实现起来更容易，后续修改和维护更容易，架构复杂后优势更大。</p>
<p>5、对比<strong>重载、重定义、重写</strong>三个概念<br>(1)<strong>overload，重载</strong>  同一个类里面的多个方法，函数名相同但参数列表不同<br>(2)<strong>redifining，重定义，隐藏</strong>  继承中子类再次实现父类中同名方法然后把父类方法隐藏掉<br>(3)<strong>override，覆盖，重写</strong>  继承中子类去实现父类中同名virtual方法然后实现多态特性 </p>
<h3 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h3><p>(1)<strong>纯虚函数就是基类中只有原型没有实体的一种虚函数</strong><br>(2)<strong>纯虚函数形式：virtual 函数原型=0；</strong><br>纯虚函数在实现多态时与虚函数一样，可当作虚函数使用。<br>(3)代码实践：在基类Animal中使用纯虚函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span>=<span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cat::speak</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;miao miao miao!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal *p;</span><br><span class="line">    Cat c;</span><br><span class="line"></span><br><span class="line">    p = &amp;c;</span><br><span class="line">    p-&gt;<span class="built_in">speak</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4)纯虚函数为什么没有实体？<br>  因为语义上不需要<br>(5)纯虚函数是否占用内存？<br>  不会，因为<strong>纯虚函数所在的类根本无法实例化对象！</strong></p>
<p>2、抽象类(abstract type)<br><strong>(1)带有纯虚函数的类成为抽象类。抽象类只能作为基类来派生新类，不可实例化对象（即抽象类不可用来定义对象）。<br>(2)派生类 必须实现 基类的纯虚函数 后 才能用于实例化对象。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;wang wang wang!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Animal p;  // 会编译报错，因为抽象类不能用来实例化对象</span></span><br><span class="line">    Dog g;     <span class="comment">// 正常，因为子类实现了基类的纯虚函数，已经不是抽象类了，可以用来实例化对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)抽象类的作用：将有关的数据和行为组织在一个继承层次结构中，保证派生类必须具有所要求的方法。对应暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现。这种机制可以让语法和语义保持一致。<br>(4)<strong>抽象类的子类必须实现基类中的纯虚函数，这样子类才能创建对象，否则子类就还是个抽象类</strong></p>
<p>3、接口（interface）<br>(1)接口是一种特殊的类，用来定义一套访问接口，也就是定义一套规约<br>(2)<strong>接口类中不应该定义任何成员变量</strong><br>(3)<strong>接口类中所有成员函数都是公有且都是纯虚函数</strong><br>(4)有些高级语言中直接提供关键字interface定义接口，接口其实就是个纯粹的抽象基类</p>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>1、什么是虚析构函数<br>(1)析构函数前加virtual，则析构函数变为虚析构函数<br>(2)规则：<strong>基类有1个或多个虚函数时（注意不要求是纯虚函数），则其析构函数应该声明为virtual</strong></p>
<p>2、为什么需要虚析构函数<br>(1)代码演示：父子类各自添加析构函数，用2种分配和回收对象的方式分别实验，观察析构函数被调用的规律</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span>=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>();</span><br><span class="line">    <span class="comment">//~Animal();//这个和上面的执行结果相同</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~Animal()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">Cat</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Cat::~<span class="built_in">Cat</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~cat()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cat::speak</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;miao miao miao!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal *p;</span><br><span class="line">    Cat c;</span><br><span class="line"></span><br><span class="line">    p = &amp;c;</span><br><span class="line">    p-&gt;<span class="built_in">speak</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">miao miao miao!</span><br><span class="line">~<span class="built_in">cat</span>()</span><br><span class="line">~<span class="built_in">Animal</span>()</span><br></pre></td></tr></table></figure>
<p>上面这种情况实际析构时只执行了子类Cat的析构函数，并没有执行父类Animal的析构函数，是子类的析构函数调用了父类的析构函数.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span>=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>();</span><br><span class="line">    <span class="comment">//~Animal();//这个和上面的执行结果不相同</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~Animal()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">Cat</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Cat::~<span class="built_in">Cat</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~cat()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cat::speak</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;miao miao miao!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal *p = <span class="keyword">new</span> <span class="built_in">Cat</span>();<span class="comment">//对象是Cat类对象，分配在堆上</span></span><br><span class="line">    p-&gt;<span class="built_in">speak</span>();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">当 <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>();时，输出：</span><br><span class="line">miao miao miao!</span><br><span class="line">~<span class="built_in">cat</span>()</span><br><span class="line">~<span class="built_in">Animal</span>()</span><br><span class="line"></span><br><span class="line">当 ~<span class="built_in">Animal</span>(); 时，输出：</span><br><span class="line">miao miao miao!</span><br><span class="line">~<span class="built_in">Animal</span>()</span><br><span class="line">上面这种情况实际析构时只执行了父类Animal的析构函数，并没有执行子类Cat的析构函数。</span><br></pre></td></tr></table></figure>
<p>(2)结论：<strong>虚析构函数在各种情况下总能调用正确的（和对象真正匹配的）析构函数</strong>。</p>
<p>3、分析和总结<br>(1)<strong>其实虚函数的virtual的价值，就是让成员函数 在运行时 动态解析 和 绑定 具体执行的函数，这是RTTI机制（动态运行时类型识别机制）的一部分</strong>。<br>(2)析构函数也是成员函数，加virtual的效果和普通成员函数加virtual没什么本质差异<br>(3)<strong>加virtual是有开销的，运行时动态绑定不如编译时静态绑定效率高资源消耗优，但是可以多态</strong>。 </p>
<h3 id="using重新定义继承时访问权限"><a href="#using重新定义继承时访问权限" class="headerlink" title="using重新定义继承时访问权限"></a>using重新定义继承时访问权限</h3><p>1、using关键字 在非public继承时的 权限重开作用<br>(1)<strong>父类的public方法在private/protected继承时，到了子类就成了private/protected而不是public了，无法用子类对象来调用了</strong><br>(2)解决方法1：是改为public继承，有用但是有时候不得不protected或者private继承时就没办法了<br>(3)解决方法2：是在子类中再实现一个public的方法，内部调用父类继承而来的那个方法，能用但是有点麻烦而且有额外开销<br>(4)解决方法3：是在子类中使用using关键字将该方法声明为public访问权限，本质上类似于权限打洞<br>(5)用法：在子类public声明中使用 <strong>using Base::func;</strong> 即可，不带返回值类型不带参数列表。<br>(6)注意：using只用于private/protected继承中的权限损失找回，如果方法在父类中本来就是private的子类中没法using后访问。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">father</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">live</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">father::work</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I am working.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">father::live</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I am living.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span>:</span><span class="keyword">private</span> father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">way</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="keyword">using</span> father::live;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">son::way</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">work</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    son s;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">way</span>();</span><br><span class="line">    s.<span class="built_in">live</span>();  <span class="comment">// live是通过private继承过来的，权限会变成private，正常不能像这样通过</span></span><br><span class="line">               <span class="comment">// 对象来访问，但是使用了   using father::live; 就可以了</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>权限 本身是 编译器在编译时的一种设定。</p>
<p>3、C++继承和多态特性总结<br>(1)本部分主要讲了OO的2个特性：<strong>继承和多态</strong>，其中继承和权限管控、继承中的构造和析构、隐藏和覆盖、虚函数和多态、纯虚函数和抽象类、接口、静态和动态绑定等是重点。<br>(2)面向对象三大特征中：<strong>封装是基础、继承是关键、多态是延伸</strong>。<br>(3)本部分内容很重要，属于C++知识体系中关键基础零件，对于以后理解复杂代码和架构意义重大，必须彻底理解和熟悉。<br>(4)要求要见过、认识、会写、理解原理、熟练运用。 </p>
<h2 id="C-的运算符重载"><a href="#C-的运算符重载" class="headerlink" title="C++的运算符重载"></a>C++的运算符重载</h2><h3 id="运算符重载引入"><a href="#运算符重载引入" class="headerlink" title="运算符重载引入"></a>运算符重载引入</h3><p>1、从函数重载说起<br>(1)<strong>函数重载是在一定作用域内，多个相同名称但不同参数列表的函数重载</strong><br>(2)<strong>编译时由编译器根据实际调用时给的实参情况来判定本次实际用哪个函数，这个过程叫重载决策</strong><br>(3)<strong>重载函数本质上就是多个独立函数，重载机制在编译时发生，运行时不参与</strong><br>(4)函数重载的意义就是避免我们胡乱起名，方便编写类库覆盖所有可能操作，是一种语法糖 </p>
<p>2、什么是运算符重载<br>(1)什么是运算符？<br>  譬如+ - * / %等算术运算符和&gt; &lt; == !=等关系运算符就是典型的可重载运算符（但不是所有的运算符都可以重载，譬如sizeof）<br>(2)运算符诞生于C语言中，用来对变量进行某种“预定义”的运算操作，这种预定义是编译器预制好的，编译时会翻译对应到CPU机器码<br>(3)面向对象时代带来新的问题：两个对象如何运算？<br>  譬如：Person a, b, c; c = a + b; 此处的+让编译器如何解读？见下面示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1, p2, p3;</span><br><span class="line"></span><br><span class="line">    p3 = p1 + p2;  <span class="comment">// 这里会编译报错，因为编译器不知道如何去解析 &quot;+&quot; 运算符</span></span><br><span class="line">                   <span class="comment">// 要让编译器认识这个 &quot;+&quot; ,需要在Person类中实现 operator+ 函数</span></span><br><span class="line">                   <span class="comment">// 这就是&quot;+&quot;运算符重载</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、运算符重载示例<br>(1)class coordinate, 2个属性x和y，直接对2个对象执行+，编译不通过<br>(2)重载+运算符后，再编译并执行，查看结果，分析结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">coordinate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;  <span class="comment">//x轴的坐标</span></span><br><span class="line">    <span class="keyword">int</span> y;  <span class="comment">//y轴的坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">coordinate</span>();</span><br><span class="line">    <span class="built_in">coordinate</span>(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义类的时候，提供一个运算符重载的对应的解析函数即可</span></span><br><span class="line">    coordinate <span class="keyword">operator</span>+(<span class="keyword">const</span> coordinate&amp; other);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">coordinate::<span class="built_in">coordinate</span>()</span><br><span class="line">&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">coordinate::<span class="built_in">coordinate</span>(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0)</span><br><span class="line">&#123;   </span><br><span class="line">    x = x0;</span><br><span class="line">    y = y0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">coordinate::print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">coordinate coordinate::<span class="keyword">operator</span>+(<span class="keyword">const</span> coordinate&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在该函数内实现 “+” 应该实现的操作</span></span><br><span class="line">    coordinate tmp;</span><br><span class="line"></span><br><span class="line">    tmp.x = <span class="keyword">this</span>-&gt;x + other.x;</span><br><span class="line">    tmp.y = <span class="keyword">this</span>-&gt;y + other.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">coordinate <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">coordinate <span class="title">b</span><span class="params">(<span class="number">2</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    coordinate c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//c = a + b;//编译时被翻译成 c = a.operator+(b)</span></span><br><span class="line">    c = a.<span class="keyword">operator</span>+(b);<span class="comment">//和上边等效</span></span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line">    c.<span class="built_in">print</span>();    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line">(<span class="number">3</span>,<span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<h3 id="深度理解运算符重载"><a href="#深度理解运算符重载" class="headerlink" title="深度理解运算符重载"></a>深度理解运算符重载</h3><p>1、运算符重载的本质<br>(1)表面上，<strong>运算符重载是对C++源生运算符的意义，在某个class中做重定义</strong><br>(2)本质上，<strong>运算符被映射到执行相应的成员函数，所以运算符重载其实是重定义对象的运算符所对应的函数</strong></p>
<p>2、运算符重载的意义<br>(1)运算符重载是一种语法特性，C++全面支持，Java不支持，python有限度的支持<br>(2)没有运算符重载照样写代码，所有操作全部通过显式调用相应成员函数来完成即可<br>(3)运算符重载是一种语法糖，可以让代码“看起来更简洁，更优雅”，将复杂实现隐藏在类的内部<br>(4)运算符重载机制加大了类库作者的工作量，减少了调用类库写功能的人的书写量<br>(5)C++支持运算符重载机制有其理念和历史原因，是对写法简洁和效率优秀的综合考量<br>(6)<strong>赋值运算符，=重载和引用结合，可有效提升代码效率，</strong>后面会有案例详解<br>(7)<strong>赋值运算符=重载时要注意有指针成员时会涉及浅拷贝和深拷贝，后面会有案例详解</strong><br>(8)<strong>运算符重载一定程度上体现了C++的多态性，因为同样的运算符在不同的class中表现是不同的</strong></p>
<p>3、运算符重载如何学习<br>(1)本篇文章内讲的基本理论、写法、理解方法等要全部掌握，见了认识、理解原理、会用。<br>(2)实际工作中遇到别人的类库中有使用运算符重载时，利用本篇文章讲的基础原理去研究和理解，看懂并用好，如此可加深功力。</p>
<h3 id="理解运算符重载的关键点"><a href="#理解运算符重载的关键点" class="headerlink" title="理解运算符重载的关键点"></a>理解运算符重载的关键点</h3><p>1、理解运算符重载机制的两部曲<br>(1)记住、理解、并且能轻松认出写出运算符重载函数的格式、名称、对应的运算符。<br>(2)理解在运算符重载函数中this表示谁，参数表示谁，返回值对应谁，这个是重中之重。</p>
<p>2、通过代码实践来深度理解运算符重载函数<br>(1)运算符 + 的重载中的对应关系回顾<br>  总结：<strong>a + b; -&gt; a.operator+(b)，a对应this，b对应函数参数other，a+b的表达式的值对应函数返回值</strong><br>(2)运算符=的重载中的对应关系</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">coordinate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;<span class="comment">//x轴的坐标</span></span><br><span class="line">    <span class="keyword">int</span> y;<span class="comment">//y轴的坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">coordinate</span>();</span><br><span class="line">    <span class="built_in">coordinate</span>(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义类的时候，提供一个运算符重载的对应的解析函数即可</span></span><br><span class="line">    coordinate <span class="keyword">operator</span>+(<span class="keyword">const</span> coordinate&amp; other);</span><br><span class="line">    <span class="comment">//coordinate operator=(const coordinate&amp; other);</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> coordinate&amp; other);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">coordinate coordinate::<span class="keyword">operator</span>+(<span class="keyword">const</span> coordinate&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在该函数内实现 “+” 应该实现的操作</span></span><br><span class="line">    coordinate tmp;</span><br><span class="line"></span><br><span class="line">    tmp.x = <span class="keyword">this</span>-&gt;x + other.x;</span><br><span class="line">    tmp.y = <span class="keyword">this</span>-&gt;y + other.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">coordinate coordinate::operator=(const coordinate&amp; other)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    //在该函数内实现 “=” 应该实现的操作</span></span><br><span class="line"><span class="comment">    this-&gt;x = other.x;</span></span><br><span class="line"><span class="comment">    this-&gt;y = other.y;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return *this;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">上述两个“=”不同的运算符重载函数对于表达式</span><br><span class="line">d = (c = a);</span><br><span class="line">有着不同的结果，但对于表达式</span><br><span class="line">c = a;</span><br><span class="line">而言，结果是相同的，赋值操作是在函数内部就已经完成的，和返回值无关</span><br></pre></td></tr></table></figure>
<p>总结：c = a; -&gt; c.operator=(a); c对应this，a对应other，c=a整个表达式的值（其实就是c）对应函数返回值<br>运算符重载总的规则：运算符左边的是this，右边的是other，运算符加操作数的整个表达式的返回值就是返回值</p>
<p>3、运算符=的默认提供问题<br>(1)=运算符有点特殊，编译器会提供一个默认的=运算符的重载，所以不提供时也能用<br>(2)如果自己显式写了=运算符的重载函数，则会覆盖编译器自动提供的那一个</p>
<p>4、+=运算符<br>(1)运算符+=的重载中的对应关系</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> coordinate::<span class="keyword">operator</span>+=(<span class="keyword">const</span> coordinate&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x = <span class="keyword">this</span>-&gt;x + other.x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = <span class="keyword">this</span>-&gt;y + other.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为我们一般不会写：c = (a+=b);这样的表达式，所以这个运算符函数重载函数不需要返回值</span></span><br></pre></td></tr></table></figure>
<p>总结：a += b; -&gt; a.operator+=(b); a对应this，b对应other，a+=b的整体表达式对应返回值</p>
<p>5、总结<br>(1)编译器会为每个自定义class提供一个默认的赋值运算符的重载，而我们可以覆盖这个重载<br>(2)盯紧表达式实际对应执行哪个函数，盯紧函数的参数是谁，this是谁，返回值是谁，一切都清楚了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a是this，b是other， a &gt; b这个整体表达式的bool值就是返回值，所以返回值才是关键</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)a+b有可能不等于b+a，这个也是运算符重载衍生出来的不好把控的风险问题<br>(4)运算符重载给了类库作者非常大自由度，所以容易失控，实际中不乏写的很雷人的运算符重载，或者纯粹炫技的代码惹人讨厌</p>
<h3 id="运算符重载函数中的细节"><a href="#运算符重载函数中的细节" class="headerlink" title="运算符重载函数中的细节"></a>运算符重载函数中的细节</h3><p>1、赋值运算符重载与拷贝构造函数<br>(1)区分初始化时的赋值（一般就叫初始化），和非初始化时的赋值（一般就叫赋值）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">“=”运算符重载函数中：<span class="keyword">return</span> *<span class="keyword">this</span>;会执行拷贝构造函数</span><br><span class="line"></span><br><span class="line">    <span class="function">coordinate <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    coordinate c = a;<span class="comment">//通过类的拷贝构造函数生成b,这个“=”并未执行运算符重载函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">coordinate <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    coordinate c;</span><br><span class="line">    c = a;          <span class="comment">//这个“=”执行运算符重载函数</span></span><br></pre></td></tr></table></figure>
<p>(2)实验验证初始化和赋值时各自对应</p>
<p>2、赋值运算符重载函数参数中的const<br>(1)如果运算符对其右侧的操作数并不改变，则应该在参数列表中使用const引用<br>(2)C++的const要求非常严格，在c = a + b;中如果=运算符的重载函数参数列表中没有用const会编译报错。</p>
<p>3、避免赋值运算符中的自赋值<br>(1)自赋值就是Person a; a = a;<br>(2)<strong>自赋值如果不处理，轻则浪费效率，重则导致内存丢失（该深拷贝时做了浅拷贝）</strong><br>(3)避免自赋值很简单，只需要在赋值运算符重载函数所有操作前加上一个判断 if (this != &amp;other)即可（一个变量的引用，对引用取地址，可以当变量的地址使用） </p>
<h3 id="赋值运算符重载函数返回引用"><a href="#赋值运算符重载函数返回引用" class="headerlink" title="赋值运算符重载函数返回引用"></a>赋值运算符重载函数返回引用</h3><p>1、返回引用好处1：提升程序效率<br>(1)赋值运算符重载函数返回值可以返回对象类型，也可以返回对象引用类型，都能工作。代码验证</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">C++</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">coordinate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="comment">//coordinate&amp; operator=(const coordinate&amp; other);</span></span><br><span class="line">    coordinate <span class="keyword">operator</span>=(<span class="keyword">const</span> coordinate&amp; other);</span><br><span class="line">    <span class="built_in">coordinate</span>();</span><br><span class="line">    <span class="built_in">coordinate</span>(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0);</span><br><span class="line">    <span class="built_in">coordinate</span>(<span class="keyword">const</span> coordinate&amp; rhs);    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">coordinate::print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=(&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">coordinate&amp; coordinate::<span class="keyword">operator</span>=(<span class="keyword">const</span> coordinate&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x = other.x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = other.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">coordinate coordinate::<span class="keyword">operator</span>=(<span class="keyword">const</span> coordinate&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x = other.x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = other.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">coordinate::<span class="built_in">coordinate</span>()<span class="comment">//默认构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">coordinate::<span class="built_in">coordinate</span>(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0)<span class="comment">//自定义构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------constructor-------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;x = x0;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = y0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">coordinate::<span class="built_in">coordinate</span>(<span class="keyword">const</span> coordinate&amp; rhs)<span class="comment">//拷贝构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------copy_constructor-------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;x = rhs.x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = rhs.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">coordinate <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">coordinate <span class="title">b</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    coordinate c;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------c = a---------&quot;</span> &lt;&lt;endl;</span><br><span class="line">    c = a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------c = a---------&quot;</span> &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line">    c.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)区别在于：<strong>返回引用可以避免一次返回值值传递的对象复制，这需要消耗资源的</strong>。<br>(3)总结：虽然C++语法并未强制要求，但是好的写法是应该返回引用</p>
<p>2、返回引用好处2：允许连续赋值式<br>(1)返回对象而不是引用时，在连续赋值（c = a = b;）时会编译可以，运行也可以，但是效率低同1中所讲。<br>(2)原因是先执行a=b操作，返回值再作为第2次赋值运算的右值（也就是函数参数），对象和引用是类型兼容的<br>(3)总结：<strong>连等在返回对象和引用时都可以，但是在返回void时就不可以了</strong></p>
<p>3、思考：<strong>传参为什么要传引用</strong><br>(1)<strong>如果传对象，则调用时是值传递，调用时需要复制一次，增加额外开销</strong><br>(2)如果传指针，则重载后，使用时为了符合函数参数格式必须写成 a = &b;这种，不符合C语言写法习惯，也有歧义<br>(3)实际测试发现真的传指针时，写 c=a; c=&a;都能编译通过，且运行正确。但是确实很别扭。<br>(4)总结：有资料表明，其实C++早期发明引用概念时，就是为了解决此处运算符重载传参的尴尬。 </p>
<h3 id="String类的赋值运算符重载"><a href="#String类的赋值运算符重载" class="headerlink" title="String类的赋值运算符重载"></a>String类的赋值运算符重载</h3><p>1、标准库中String类的运算符重载<br>(1)<a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5</a><br>(2)String类提供了 = 和 + 等多个运算符重载函数的成员<br>(3)标准库只给了API，没给实现，咱们可以自己实现个=运算符重载函数</p>
<p>2、String的=运算符重载演练<br>(1)自己编写一个MyString类，成员变量char *buf指向实际存储字符串的buf，new动态内存来使用。<br>(2)实践：先完成构造函数，成员函数print，len等基础设计，写代码测试ok<br>(3)<strong>编写=运算符重载函数，引出浅拷贝深拷贝问题</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mystring</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *buf; <span class="comment">//指针指向实际存储字符串内容的buffer空间，采用动态分配</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> len;   <span class="comment">//字符中存储的有效字符个数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Mystring</span>();                <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Mystring</span>(<span class="keyword">const</span> <span class="keyword">char</span> *pSrc);      <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">Mystring</span>();               <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;          <span class="comment">//普通成员函数</span></span><br><span class="line">    Mystring&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Mystring&amp; other);<span class="comment">//运算符重载函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Mystring::<span class="built_in">Mystring</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//不写，空着等需要时再写，因为提供了自定义的构造函数，</span></span><br><span class="line">    <span class="comment">//所以必须要由默认的构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;len = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">32</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mystring::<span class="built_in">Mystring</span>(<span class="keyword">const</span> <span class="keyword">char</span> *pSrc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//计算有效字符的个数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p = pSrc;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">this</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*p++ != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;cnt of pSrc is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;len &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先给buf分配动态内存空间</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;len+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将pSrc指向的源字符串内容，复制给当前Mystring对象来存储</span></span><br><span class="line">    p = pSrc;</span><br><span class="line">    <span class="keyword">char</span> *tmp = <span class="keyword">this</span>-&gt;buf;</span><br><span class="line">    <span class="keyword">while</span>(*p != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *tmp++ = *p++;            </span><br><span class="line">    &#125;</span><br><span class="line">    *tmp = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mystring::~<span class="built_in">Mystring</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mystring::print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;length of string = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;len &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *p = <span class="keyword">this</span>-&gt;buf;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this string is : &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(*p != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *p++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mystring&amp; Mystring::<span class="keyword">operator</span>=(<span class="keyword">const</span> Mystring&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;buf;<span class="comment">//释放掉原来的内存，重新申请内存</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;buf = <span class="keyword">new</span> <span class="keyword">char</span>[other.len+<span class="number">1</span>];<span class="comment">//避免字符串内存越界</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;len = other.len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *p1 = <span class="keyword">this</span>-&gt;buf;</span><br><span class="line">    <span class="keyword">char</span> *p2 = other.buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*p2 != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p1++ = *p2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return *this;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Mystring <span class="title">s1</span><span class="params">(<span class="string">&quot;123456&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Mystring <span class="title">s2</span><span class="params">(<span class="string">&quot;absjhlllbsb&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">print</span>();</span><br><span class="line">    s2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl; </span><br><span class="line">    s1 = s2;</span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">print</span>();</span><br><span class="line">    s2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、总结<br>(1)运算符重载技术本身很简单，就是个语法糖，前面讲的完全够了<br>(2)运算符重载会牵出其他技术点（譬如浅拷贝，深拷贝）共同完成某个工作，这就有难点，讲究功底了<br>(3)C++编程中涉及到动态内存的地方一定要慎重，三思五思再慎重都不为过,运算符重载函数返回值类型不是引用而是对象可能会引发段错误，我上面提供的程序就会，调试了半小时才发现（我太菜了）。 </p>
<h3 id="和–运算符的前置后置如何实现"><a href="#和–运算符的前置后置如何实现" class="headerlink" title="++和–运算符的前置后置如何实现"></a>++和–运算符的前置后置如何实现</h3><p>1、可前置可后置的运算符<br>(1)int a = 5; a++; ++a;结果不同<br>(2)重载++和–有无意义？<br>  有意义，因为我们有时习惯了C语言的++和–的便利性。</p>
<p>2、如何重载++和–</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">C++编译器认为：</span><br><span class="line"></span><br><span class="line">a++; 对应Type&amp; <span class="keyword">operator</span>++(<span class="keyword">int</span> x); <span class="comment">//int x用来做区分，此外没有任何其他作用。</span></span><br><span class="line"></span><br><span class="line">++a对应Type&amp; <span class="keyword">operator</span>++(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">示例代码：https:<span class="comment">//www.runoob.com/cplusplus/increment-decrement-operators-overloading.html</span></span><br></pre></td></tr></table></figure>

<p>3、总结<br>(1)即使你觉得没必要，但是也得会，因为总有人会这样写<br>(2)掌握最本质的规律的人最强大，遇到越困难的问题越需要这种能力来解决</p>
<h3 id="两种运算符重载方法"><a href="#两种运算符重载方法" class="headerlink" title="两种运算符重载方法"></a>两种运算符重载方法</h3><p>1、并非所有运算符都支持重载<br>(1)下面是不可重载的运算符列表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">.                        成员访问运算符</span><br><span class="line">.*, -&gt;*                成员指针访问运算符</span><br><span class="line">::                        域运算符</span><br><span class="line"><span class="keyword">sizeof</span>                长度运算符</span><br><span class="line">? :                        条件运算符 </span><br><span class="line">#           预处理符号</span><br></pre></td></tr></table></figure>

<p>2、并非只有一种方式实现重载<br>(1)有两种方法可以使运算符重载<br>第一种：使重载运算符成为该类的<strong>成员函数</strong>。这允许运算符函数访问类的私有成员。它也允许函数使用隐式的<strong>this</strong>指针形参来访问调用对象。<br>第二种：使重载的成员函数成为<strong>独立分开的函数</strong>。当以这种方式重载时，运算符函数必须声明为类的友元才能访问类的私有成员。 </p>
<p>3、如何选择两种运算符重载<br>(1)大多数运算符（如+ =等）既可以作为成员函数也可以作为独立函数重载。<br>(2)更好的做法是将二元运算符重载为釆用相同类型形参的独立函数。这是因为，与独立运算符的重载不同，成员函数的重载通过使左侧形参变成隐式的，造成了两个形参之间的人为区别，这将允许转换构造函数应用右侧形参，但不应用左侧形参，从而产生了更改形参顺序的情况，导致正确的程序如果换个方式却出现了编译器错误。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Length <span class="title">a</span><span class="params">(<span class="number">4</span>, <span class="number">2</span>)</span>, <span class="title">c</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">c = a + <span class="number">2</span>; <span class="comment">//编译，当于 c = a.operator+(2)</span></span><br><span class="line">c = <span class="number">2</span> + a; <span class="comment">//不能编译：相当于 c = 2.operator+(a);</span></span><br></pre></td></tr></table></figure>
<p>参考学习：<a href="https://blog.csdn.net/jacket_/article/details/89714947">https://blog.csdn.net/jacket_/article/details/89714947</a></p>
<h2 id="C-的静态类和静态成员"><a href="#C-的静态类和静态成员" class="headerlink" title="C++的静态类和静态成员"></a>C++的静态类和静态成员</h2><h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><p>1、static关键字<br>(1)static，C语言中有2种用法：static修饰局部变量和全局变量，含义完全不同<br>(2)static，C++中扩展了第3种用法：静态类、静态成员，含义和前2种完全不同</p>
<p>2、什么是静态成员<br>(1)<strong>用static修饰成员变量，即为静态成员变量；用static修饰成员方法，即为静态成员方法</strong><br>(2)<strong>静态成员属于class本身，而不属于对象</strong></p>
<p>3、静态成员的特征和实践验证<br>(1)<strong>静态成员变量在类的多个对象中均可访问，且是同一个实体，被多个对象“共享”。</strong><br>(2)<strong>静态成员变量和方法可以用对象调用，也可以根本不产生对象而用类本身来调用。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、静态方法只能访问静态成员</span><br><span class="line"><span class="number">2</span>、静态方法中不可以定义<span class="keyword">this</span>，super关键字</span><br><span class="line">因为静态优先于对象存在，所以静态方法中不可以出现<span class="keyword">this</span></span><br></pre></td></tr></table></figure>
<p>(3)静态成员函数在类外实现时只需在类内声明时加static，类外实体无须加static关键字，否则是错误的（思考下为什么？）<br>答：修改了函数的链接属性，将函数变为一个静态函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;        <span class="comment">//普通成员变量  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> flag;<span class="comment">//静态成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> t)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sample::print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt;<span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;flag = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;flag &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sample::test</span><span class="params">(<span class="keyword">int</span> aage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this is a test function.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; flag &lt;&lt; endl;<span class="comment">//不可以使用this-&gt;flag</span></span><br><span class="line">    cout &lt;&lt; sample::flag &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; aage &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; age &lt;&lt; endl;//非静态成员引用必须与特定对象相对,这个报错，静态方法只能访问静态成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sample::flag = <span class="number">0</span>;<span class="comment">//静态成员变量与普通成员变量的不同之处，否则该类的对象无法使用该变量 </span></span><br><span class="line"><span class="comment">//void sample::test(void);//静态成员方法不需要这样,虽然写了编译也不会报错</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sample s1, s2;</span><br><span class="line"></span><br><span class="line">    s1.flag = <span class="number">2</span>;</span><br><span class="line">    s1.age = <span class="number">21</span>;</span><br><span class="line">    s1.<span class="built_in">print</span>();</span><br><span class="line">    s1.<span class="built_in">test</span>(s1.age);</span><br><span class="line"></span><br><span class="line">    s2.age = <span class="number">22</span>;</span><br><span class="line">    s2.<span class="built_in">print</span>();</span><br><span class="line">    s2.<span class="built_in">test</span>(s2.age);</span><br><span class="line"></span><br><span class="line">    sample::flag = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态成员的深度理解"><a href="#静态成员的深度理解" class="headerlink" title="静态成员的深度理解"></a>静态成员的深度理解</h3><p>1、静态数据成员的使用<br>(1)<strong>静态数据成员不能在类中初始化</strong>，因为类定义实际只是模型，本身并没有和变量/对象实体去关联<br>(2)<strong>静态数据成员不能在类的构造函数中初始化</strong>，因为构造函数是用来构造具体单个对象的，而静态成员属于类（或者说类和他的所有对象共享），如果在构造函数中允许对静态成员初始化或赋值，就会每多创建一个对象，原有对象中该静态成员的值莫名其妙变了，不合理<br>(3)静态数据成员不能用初始化列表方式来初始化<br>(4)<strong>静态数据成员如果不初始化则值默认为0</strong><br>(5)静态成员仍然遵循public，private，protected访问准则。</p>
<p>2、静态成员和普通成员的互相调用规则<br>(1)普通成员函数中可以调用静态成员变量和方法，调用方法有3种：直接访问、this指针访问、类名::func()方式访问<br>(2)<strong>静态方法中只能访问静态成员变量和方法，不能访问任何非静态的东西</strong><br>(3)<strong>静态方法中如果确实需要访问非静态成员，应该通过函数传参方式</strong></p>
<p>3、从内存角度出发<br>(1)<strong>class定义时只是定义类型，并不定义变量和对象，静态成员变量真正定义是在外部，类似于全局变量</strong><br>(2)<strong>静态成员变量在编译链接时分配，程序加载时被落实到内存中，程序结束时死亡，等同于全局变量</strong><br>(3)<strong>静态成员函数在编译链接时分配，程序加载时被落实到内存中，程序结束时死亡，类似于全局函数</strong><br>(4)普通成员和对象绑定，随对象的创建和释放而生死（不管在栈里还是堆里），类似于局部变量和malloc堆内存<br>(5)<strong>静态成员变量在对象中不占用存储空间</strong> </p>
<h3 id="静态成员的用途"><a href="#静态成员的用途" class="headerlink" title="静态成员的用途"></a>静态成员的用途</h3><p>1、用途举例<br>(1)静态数据成员的用途之一是统计有多少个对象实际存在，比如声明一个学生类，其中一个成员为学生总数，则这个变量就应当声明为静态变量，应该根据实际需求来设置成员变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> grade;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">student</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="string">&quot;student&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;grade = <span class="number">0</span>;</span><br><span class="line">        student::cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">student</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        student::cnt--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The number of students is &quot;</span> &lt;&lt; student::cnt &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> student::cnt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    student p1;</span><br><span class="line">    p1.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    student p2;</span><br><span class="line">    p2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)<strong>静态方法就是与该类相关的，是类的一种行为，而不是与该类的实例对象相关</strong></p>
<p>2、静态成员与面向对象<br>(1)静态成员仍然在class内，仍可通过对象调用，因此表面上遵守面向对象规则。<br>(2)静态成员一定程度上破坏了面向对象，因为没有对象直接用class名也可以调用静态成员。<br>(3)静态成员可被看做是类外部的全局变量和全局函数被封装到了类的内部<br>(4)一个类的静态成员和非静态成员是完全不同的，两者唯一的关联可能就是隶属于同一个class的作用域内。</p>
<h3 id="静态类的扩展讲解"><a href="#静态类的扩展讲解" class="headerlink" title="静态类的扩展讲解"></a>静态类的扩展讲解</h3><p>1、什么是静态类<br>(1)class声明时使用static，整个类是个静态类<br>(2)<strong>静态类内部全是静态成员，没有非静态成员</strong><br>(3)<strong>静态类不能被实例化</strong><br>(4)静态类是密封(sealed)的。 补充：什么是密封？<br>(5)静态类不包括构造函数<br>(6)静态类不能指定任何接口实现，不能有任何实例成员<br>(7)静态类的成员不能有protected或protected internal访问保护修饰符。<br>(8)静态类不能包含构造函数，但仍可声明静态构造函数以分配初始值或设置某个静态状态。</p>
<p>2、静态类的优势<br>(1)编译器能够执行检查以确保不致偶然地添加实例成员。编译器将保证不会创建此类的实例。<br>(2)静态类是密封的，因此不可被继承。</p>
<p>3、C++不支持静态类<br>(1)<strong>Java/C#等高级语言支持静态类，而C++并不支持。</strong><br>(2)C++中创建静态类与创建仅包含静态成员和私有构造函数的类大致一样。私有构造函数阻止类被实例化。 </p>
<h2 id="C-的友元函数和友元类"><a href="#C-的友元函数和友元类" class="headerlink" title="C++的友元函数和友元类"></a>C++的友元函数和友元类</h2><h3 id="什么是友元函数"><a href="#什么是友元函数" class="headerlink" title="什么是友元函数"></a>什么是友元函数</h3><p>1、外部函数访问类内成员<br>(1)写一个Person类，内部有private、protected、public的三类访问权限的成员<br>(2)写一个外部函数disp_info来打印这三类成员<br>(3)代码实战</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">person</span>()&#123;&#125;;<span class="comment">//由于使用了自己的构造函数，编译器不会再为我们提供默认构造函数</span></span><br><span class="line">    <span class="built_in">person</span>(<span class="keyword">int</span> age, <span class="keyword">int</span> height, string name);<span class="comment">//自定义构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person::<span class="built_in">person</span>(<span class="keyword">int</span> age, <span class="keyword">int</span> height, string name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;height = height;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disp_info</span><span class="params">(person&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;My name is &quot;</span> &lt;&lt; p.name &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;I am &quot; &lt;&lt; p.age &lt;&lt; &quot;years old.&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;My height is &quot; &lt;&lt; p.height &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">155</span>, <span class="string">&quot;Jack&quot;</span>)</span></span>;</span><br><span class="line">    person &amp;p2 = p1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">disp_info</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4)总结：可以访问public的，但是protected和private的无法访问<br>(5)想办法：除非把disp_info挪到Person类内部成为成员函数，否则没办法</p>
<p>2、友元函数的引入<br>(1)将外部函数disp_info声明为Person类的友元函数即可解决<br>(2)代码实战验证</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">person</span>()&#123;&#125;;<span class="comment">//由于使用了自己的构造函数，编译器不会再为我们提供默认构造函数</span></span><br><span class="line">    <span class="built_in">person</span>(<span class="keyword">int</span> age, <span class="keyword">int</span> height, string name);<span class="comment">//自定义构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">disp_info</span><span class="params">(person&amp; p)</span></span>;<span class="comment">//友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line">person::<span class="built_in">person</span>(<span class="keyword">int</span> age, <span class="keyword">int</span> height, string name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;height = height;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disp_info</span><span class="params">(person&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;My name is &quot;</span> &lt;&lt; p.name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I am &quot;</span> &lt;&lt; p.age &lt;&lt; <span class="string">&quot;years old.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;My height is &quot;</span> &lt;&lt; p.height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">155</span>, <span class="string">&quot;Jack&quot;</span>)</span></span>;</span><br><span class="line">    person &amp;p2 = p1;</span><br><span class="line">    <span class="built_in">disp_info</span>(p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、总结<br>(1)<strong>友元函数不是本类的成员函数，而是一个外部函数</strong><br>(2)友元函数的标志就是<strong>在类内部加friend关键字来声明</strong><br>(3)友元函数声明的位置不要求，写在private或者protected或者public内都可以，反正只要有声明就行<br>(4)<strong>一个外部函数成为类的友元后，访问权限被扩展了，等同于类的内部成员函数了</strong><br>(5)友元函数是单向的，反过来是不行的，一个类可以有多个友元函数<br>例如：类Y为类X的友元类，类Y中的类内函数可访问类X的类内数据，但，类X并不能访问类Y中的数据。<br>(6)友元函数就好像在类的封装和访问权限保护上打了个“洞”，所以<strong>是对面向对象的一种破坏，所以不能滥用</strong></p>
<h3 id="友元函数的2种实现"><a href="#友元函数的2种实现" class="headerlink" title="友元函数的2种实现"></a>友元函数的2种实现</h3><p>1、友元函数的2种实现<br>(1)<strong>友元函数为外部函数</strong><br>(2)<strong>友元函数为另一个类中的成员函数</strong>（也叫友元成员，友元成员方法，友元成员函数）<br>(3)第2种实现的代码实战</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span>//如果将<span class="title">person</span>类与<span class="title">animal</span>类调换位置，声明<span class="title">animal</span>类，是不可以的，编译报错</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//person p1;//编译不通过</span></span><br><span class="line">    person *p1;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(person&amp; p)</span></span>;<span class="comment">//类的前置声明不包括类的详细信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">person</span>()&#123;&#125;;<span class="comment">//由于使用了自己的构造函数，编译器不会再为我们提供默认构造函数</span></span><br><span class="line">    <span class="built_in">person</span>(<span class="keyword">int</span> age, <span class="keyword">int</span> height, string name);<span class="comment">//自定义构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">disp_info</span><span class="params">(person&amp; p)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">animal::eat</span><span class="params">(person&amp; p)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">person::<span class="built_in">person</span>(<span class="keyword">int</span> age, <span class="keyword">int</span> height, string name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;height = height;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">animal::eat</span><span class="params">(person&amp; p)</span><span class="comment">//注意该函数的位置，不能放在person类之前，负责编译无法通过</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This animal wants to eat a person.His message is as follows.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;My name is &quot;</span> &lt;&lt; p.name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I am &quot;</span> &lt;&lt; p.age &lt;&lt; <span class="string">&quot;years old.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;My height is &quot;</span> &lt;&lt; p.height &lt;&lt; endl;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disp_info</span><span class="params">(person&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;My name is &quot;</span> &lt;&lt; p.name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I am &quot;</span> &lt;&lt; p.age &lt;&lt; <span class="string">&quot;years old.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;My height is &quot;</span> &lt;&lt; p.height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">155</span>, <span class="string">&quot;Jack&quot;</span>)</span></span>;</span><br><span class="line">    person &amp;p2 = p1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">disp_info</span>(p2);</span><br><span class="line"></span><br><span class="line">    animal a;</span><br><span class="line">    a.<span class="built_in">eat</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、类的前置声明<br>(1)<strong>两个类要互相引用，就会出现“未定义”尴尬，此时可以用前置声明来解决</strong><br>(2)前置声明<strong>不包括类的详细信息，所以编译器无法得到前置声明类的size，成员等详细信息</strong><br>(3)不能试图通过前置声明解决类成员的调用。<br>(4)不能试图通过前置声明来定义类的对象，<strong>只能改为定义类对象的指针</strong>。 </p>
<p>3、总结<br>(1)理解编译器的工作原理和“脾气”，很多事自然就很简单了<br>(2)设计多个类的体系时，尽量设计好层次关系成单向的，尽量避免互相引用的情况</p>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>1、友元类的概念和使用<br>(1)将类A声明为B中的friend class后，则A中所有成员函数都成为类B的友元函数了<br>(2)友元类的定义和使用友元类是单向的<br>(3)友元类是单向的和上边的友元函数一样</p>
<p>2、互为友元类<br>(1)2个类可以互为友元类<br>(2)互为友元类要注意互相引用的细节规则</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">monkey</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">monkey</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">monkey</span>(<span class="keyword">int</span> mage, string mfood):<span class="built_in">age</span>(mage),<span class="built_in">food</span>(mfood)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_friend_monkey</span><span class="params">(people&amp; s1)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string food;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">people</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> male;</span><br><span class="line">    <span class="built_in">people</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">people</span>(<span class="keyword">int</span> mmale, string mname):<span class="built_in">male</span>(mmale),<span class="built_in">name</span>(mname)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_friend_people</span><span class="params">(monkey&amp; s2)</span></span>;    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">monkey</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">monkey::test_friend_monkey</span><span class="params">(people&amp; s1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test_friend_monkey function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;class people male = &quot;</span> &lt;&lt; s1.male &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;class people name = &quot;</span> &lt;&lt; s1.name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">people::test_friend_people</span><span class="params">(monkey&amp; s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test_friend_people function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;class monkey age = &quot;</span> &lt;&lt; s2.age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;class monkey food = &quot;</span> &lt;&lt; s2.food &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">monkey <span class="title">a</span><span class="params">(<span class="number">11</span>, <span class="string">&quot;banana&quot;</span>)</span></span>;</span><br><span class="line">    monkey&amp; a1 = a;</span><br><span class="line">    <span class="function">people <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;Jack&quot;</span>)</span></span>;</span><br><span class="line">    people b1 = b;</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">test_friend_monkey</span>(b1);</span><br><span class="line">    b.<span class="built_in">test_friend_people</span>(a1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、友元类总结<br>(1)友元类其实就是批量制造友元函数<br>(2)友元类中所有全部成员都成为了友元函数，相当于一次打了很多洞，极大破坏了面向对象<br>(3)除非确实有必要，否则建议按需定义友元函数，尽量维护面向对象，让代码更安全健壮</p>
<h3 id="为什么会有友元函数"><a href="#为什么会有友元函数" class="headerlink" title="为什么会有友元函数"></a>为什么会有友元函数</h3><p>1、使用友元函数的优缺点<br>(1)缺点：破坏了封装机制，尽量不使用友元函数，不得已才使用友元函数<br>(2)优点：在实现类之间数据共享时，减少系统开销，提高效率。</p>
<p>2、使用友元函数的两种情况<br>(1)运算符重载的某些场合需要使用友元<br>(2)两个类要共享数据的时候</p>
<p>3、运算符重载中使用友元回顾<br>(1)并非所有运算符重载都可用友元函数，有四个运算符 =, -&gt;, [], ()就不可以<br>(2)详解可参考：<a href="https://www.jb51.net/article/40143.htm">https://www.jb51.net/article/40143.htm</a><br>(3)总结：<strong>C++的语法特性确实大而细，正确的方法是去理解而不是死记硬背</strong>。</p>
<p>4、两个类如何共享数据<br>(1)类内的数据，其实就是类的成员变量<br>(2)2个类共享数据方法1：将共享数据访问权限设置为public。<br>(3)2个类共享数据方法2：通过第三个专门封装数据的类，和2个类中带参数的成员函数来传参共享<br>(4)2个类共享数据方法3：通过友元函数打洞</p>
<p>5、友元函数和类的成员函数的区别<br>(1)成员函数有this指针，而<strong>友元函数没有this指针。为什么？因为友元只是朋友，并不是类内“自家人”</strong><br>(2)友元函数是不能被继承的，就像父亲的朋友未必是儿子的朋友。<br>(3)友元关系不具有传递性。类B是类A的友元，类C是B的友元，类C不一定是类A的友元，要看类中是否有相应的声明</p>
<p>6、共有友元函数<br>(1)1个函数同时成为2个类的友元函数<br>(2)共有友元函数可以是外部函数，也可以是某个（第3个）类的成员函数<br>(3)共有友元函数内可同时访问2个类的受保护成员，间接将2个完全无关的类的数据打通了</p>
<h3 id="嵌套类和局部类"><a href="#嵌套类和局部类" class="headerlink" title="嵌套类和局部类"></a>嵌套类和局部类</h3><p>1、嵌套类<br>(1)在一个类（叫外围类）的内部定义一个类（叫内部类）。<br>(2)<strong>嵌套类技术也是一种类的组合技术</strong>，和前面讲的继承、组合有类似。<br>(3)<strong>嵌套类主要是限定了内部类的作用域</strong><br>(4)嵌套类的内部类和外围类各自有各自的访问权限限定符，且遵守传统权限规则<br>(5)嵌套类中的成员函数可以在它的类体外定义，但是要附加类名的作用域限定说明<br>(6)<strong>嵌套类的内部类中声明的友元，并不是外围类的友元</strong><br>(7)<strong>定义嵌套类的目的在于隐藏类名，减少全局标识符，限制用户使用该类建立对象。以提高类的抽象能力，强调两个类(外围类和嵌套类)之间的主从关系。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string food;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;   </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">People::print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;People print function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> People::Animal::<span class="built_in">print</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Animal print function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;food is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;food &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;count is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    People s1;</span><br><span class="line">    People::Animal s2;</span><br><span class="line"></span><br><span class="line">    s1.age = <span class="number">10</span>;</span><br><span class="line">    s1.name = <span class="string">&quot;wqewqe&quot;</span>;</span><br><span class="line"></span><br><span class="line">    s2.count = <span class="number">100</span>;</span><br><span class="line">    s2.food = <span class="string">&quot;rice&quot;</span>;</span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">print</span>();</span><br><span class="line">    s2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、局部类<br>(1)<strong>定义在函数内部的类，叫做局部类，只在定义他的作用域内可见，也是一种类型隐藏技术</strong><br>(2)局部类除作用域外其他和正常类一样<br>(3)局部类一般不需要访问权限限定，因为本身作用域就很小了<br>(4)局部类内还可以再做嵌套类，如果有需要的话<br>(5)<strong>C++允许在函数内定义类，但是不允许在函数内定义函数，所以没有局部函数一说</strong></p>
<p>3、总结<br>(1)不管是嵌套类还是局部类，都是为了隐藏类型，将没必要给外部看的类型隐藏在实现内部<br>(2)没必要纠结嵌套类和局部类的各种访问细节，真的需要用时写代码验证让编译器告诉你即可<br>(3)不要求会写这些，不写框架是用不到的，只需要知道，见了能认识即可。<br>(4)模板中会用到嵌套类，讲到模板时再说</p>
<h3 id="数值与对象互转"><a href="#数值与对象互转" class="headerlink" title="数值与对象互转"></a>数值与对象互转</h3><p>1、数值与对象概念<br>(1)数值是简单类型，如int，float，double等，是C++从C继承而来的<br>(2)数值类型是源生类型，数值类型定义的是变量，非面向对象概念<br>(3)纯正的面向对象中是没有数值类型和变量的，会提供类库来替代数值类型，用数值对象来替代变量</p>
<p>2、C++中数值与对象互转<br>(1)数值转对象，实际是调用形参类型相匹配的构造函数来实现。<br>(2)对象转数值，不能默认转，必须调用对象的相应转换函数来实现。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Int</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Int</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Int()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Int</span>(<span class="keyword">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Int(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Int a;</span><br><span class="line">    a = <span class="number">7</span>;<span class="comment">//这句会先把数值7内部隐式转成一个临时Int对象，</span></span><br><span class="line">          <span class="comment">//然后再将临时对象（调用Int类的默认的oprator=函数）赋值给a</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    b = a.<span class="built_in">toint</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、对象数组<br>(1)就是一次定义多个对象<br>(2)对象数组的访问和普通变量数组没区别<br>(3)要注意如果是用new来分配的对象数组，则销毁时要用delete[] xx;</p>
]]></content>
      <categories>
        <category>4. C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>MTKcam-ISP7-enable fast launch</title>
    <url>/2024/11/19/2024-11-20-MTKcam-ISP7-enable-fast-launch/</url>
    <content><![CDATA[<h2 id="Breakdown"><a href="#Breakdown" class="headerlink" title="Breakdown"></a>Breakdown</h2><p>相机的冷/热启动，若从systrace上分析耗时，可以按照cameraservice进程来分5个阶段：</p>
<span id="more"></span>
<ol>
<li> <strong>S1: AppLaunch_dispatchPtr:Up –&gt; connectDevice</strong><br>点击APP按钮到连接相机，这部分主要是APP和framework的耗时；</li>
<li> <strong>S2: connectDevice</strong><br>连接相机的耗时，对应HAL层的open操作，主要包括遍历sensorlist，加载tuning算法库（并行化的，不需要等上下电），主要是HAL部分耗时</li>
<li> <strong>S3: connectDevice –&gt; endConfigure</strong><br>CameraDevice callback之后，就可以调用createcapturesession（endConfigure），因此这部分耗时主要来源于APP和framework</li>
<li> <strong>S4:endConfigure</strong><br>对应HAL层的configstream，需要等待sensor上电完成，以及3A初始化，耗时主要是HAL部分</li>
<li> <strong>S5: endConfigure –&gt; first full buffer call back</strong><br>流配置完成到回帧到APP，需要等待HAL pipeline创建完成，3A计算和吐帧，主要耗时是HAL部分</li>
</ol>
<h2 id="analysis"><a href="#analysis" class="headerlink" title="analysis"></a>analysis</h2><p>breakdown的结果是<strong>S5: endConfigure –&gt; first full buffer call back</strong>耗时长，流配置完成到回帧到APP，需要等待HAL pipeline创建完成，3A计算和吐帧，主要耗时是HAL部分;<br>在这个阶段MTK有一个fast lunch功能可以开启</p>
<h2 id="fast-launch功能介绍"><a href="#fast-launch功能介绍" class="headerlink" title="fast launch功能介绍"></a>fast launch功能介绍</h2><p>fast launch又叫Fast Preview，在了解fast launch功能之前，我们首先需要知道request在MTK P1 Node中是如何流转的，具体过程可以参考文档<a href="https://shenweikun.github.io/2024/11/19/2024-11-20-MTKcam-ISP7-P1-Node/">ISP7-P1 node</a>简介 ，里面有相关介绍。<br>开启fast launch主要时节省了3A相关的计算，使用<strong>默认的3A计算结果（一般会是上一次退出相机时的3A计算结果）</strong>直接作用在driver，随后等待driver出帧。</p>
<h2 id="SysTrace分析"><a href="#SysTrace分析" class="headerlink" title="SysTrace分析"></a>SysTrace分析</h2><h3 id="Normal-Request："><a href="#Normal-Request：" class="headerlink" title="Normal Request："></a>Normal Request：</h3><p>cameraservice通过sendRequestsBatch下发quest，正常需要等待P1Node.queue走完之后才会返回：<br>   <img src="image1.png"><br>   <img src="image2.png"><br>并且会调用tryEnQ 并进入S_Enque状态，此时需要等待3A相关的计算：<br>   <img src="image3.png"></p>
<h3 id="fast-launch-Request："><a href="#fast-launch-Request：" class="headerlink" title="fast launch Request："></a>fast launch Request：</h3><p>   <img src="image4.png"><br>这里有3个sendRequestsBatch执行时间特别短，原因就是开启了fast launch功能。我们看来下这些request在HAL中是怎么走的：<br>   <img src="image5.png"><br>request下发到HAL之后并没有等待queue。queue动作在另一个线程中完成：<br>   <img src="image6.png"><br>另外，第一个queue函数执行很长，主要是在等res寄存器的写入。<br>   <img src="image7.png"><br>这里做的实际上是调用preEnQ，进入S_PreQue状态，这里便是核心区别。用preEnQ，进入S_PreQue状态，此时采用<strong>默认的3A计算结果（一般会是上一次退出相机时的3A计算结果）</strong>直接作用在driver，随后调用setupSubmission ，让 P1Node 将对应的 buffer 给 acquire 出来，并将buffer address给到Camctrl, 等待driver 吐帧。随后的流程和Normal Request一致。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>通过设置：<br>adb shell setprop vendor.debug.camera.pass1initrequestnum 4 //可以开启功能4-1=3帧，理论优化耗时3*33=99ms<br>或者直接在代码里面修改</p>
]]></content>
      <categories>
        <category>1. Android Camera</category>
      </categories>
      <tags>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
        <tag>MTKCamera</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>Memory libmemunreachable</title>
    <url>/2024/11/20/2024-11-20-memory-libmemunreachable/</url>
    <content><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>libmemunreachable is a zero-overhead native memory leak detector. </p>
<span id="more"></span>
<p>It uses an imprecise mark-and-sweep garbage collector pass over all native memory, reporting any unreachable blocks as leaks. It is similar to the Heap Checker from tcmalloc, but with a few key differences to remove the overhead. Instead of instrumenting every call to malloc and free, it queries the allocator (jemalloc) for active allocations when leak detection is requested. In addition, it performs a very short stop-the-world data collection on the main process, and then forks a copy of the process to perform the mark-and-sweep, minimizing disruption to the original process.</p>
<p>In the default (zero-overhead) mode, the returned data on leaks is limited to the address, approximate (upper bound) size, and the the first 32 bytes of the contents of the leaked allocation. If malloc_debug backtraces are enabled they will be included in the leak information, but backtracing allocations requires significant overhead.</p>
<hr>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><h3 id="In-Android-apps"><a href="#In-Android-apps" class="headerlink" title="In Android apps"></a>In Android apps</h3><p>libmemunreachble is loaded by zygote and can be triggered with dumpsys -t 600 meminfo –unreachable [process].</p>
<p>To enable malloc_debug backtraces on allocations for a single app process on a userdebug device, use:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell setprop libc.debug.malloc.program app_process</span><br><span class="line">adb shell setprop wrap.[process] <span class="string">&quot;\$\@&quot;</span></span><br><span class="line">adb shell setprop libc.debug.malloc.options backtrace=<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>Kill and restart the app, trigger the leak, and then run dumpsys -t 600 meminfo –unreachable [process].</p>
<p>To disable malloc_debug:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">adb shell setprop libc.debug.malloc.options <span class="string">&quot;&#x27;&#x27;&quot;</span></span><br><span class="line">adb shell setprop libc.debug.malloc.program <span class="string">&quot;&#x27;&#x27;&quot;</span></span><br><span class="line">adb shell setprop wrap.[process]  <span class="string">&quot;&#x27;&#x27;&quot;</span></span><br></pre></td></tr></table></figure>
<p>Starting with Android U, new malloc debug options have been added that allow specific sized allocation to be backtraced. The three new options are:</p>
<ul>
<li>backtrace_size</li>
<li>backtrace_min_size</li>
<li>backtrace_max_size</li>
</ul>
<p>When enabling backtracing on all allocations, it is possible to have the process run so slowly that the app does not come up. Or the app runs so slowly that the leaks do not occur. The best way to avoid any slowdowns or timeouts is to first run libmemunreachable and look at the sizes of the leaking allocations. If there is only a single allocation size, then use backtrace_size which will indicate that backtraces should only be collected for that exact size. For example, if the output of dumpsys is:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Unreachable memory</span><br><span class="line"> <span class="number">24</span> bytes in <span class="number">2</span> unreachable allocations</span><br><span class="line"> ABI: <span class="string">&#x27;arm64&#x27;</span></span><br><span class="line"></span><br><span class="line"> <span class="number">24</span> bytes unreachable at <span class="number">71</span>d37787d0</span><br><span class="line">  first <span class="number">20</span> bytes of contents:</span><br><span class="line">  <span class="number">71</span>d37787d0: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> ................</span><br><span class="line">  <span class="number">71</span>d37787e0: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> ................</span><br><span class="line"></span><br><span class="line"> <span class="number">24</span> bytes unreachable at <span class="number">71</span>d37797d0</span><br><span class="line">  first <span class="number">20</span> bytes of contents:</span><br><span class="line">  <span class="number">71</span>d37797d0: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> ................</span><br><span class="line">  <span class="number">71</span>d37797e0: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> ................</span><br></pre></td></tr></table></figure>
<p>Then set the malloc debug options thusly:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">adb shell setprop libc.debug.malloc.options <span class="string">&quot;&#x27;backtrace backtrace_size=24&#x27;&quot;</span></span><br></pre></td></tr></table></figure>
<p>This will backtrace only 24 byte allocations.</p>
<p>If the output of libmemunreachable has multiple sized allocations, set the backtrace_min_size and backtrace_max_size options to cover all of the sizes. For example, if the output of dumpsys is:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Unreachable memory</span><br><span class="line"> <span class="number">512</span> bytes in <span class="number">2</span> unreachable allocations</span><br><span class="line"> ABI: <span class="string">&#x27;arm64&#x27;</span></span><br><span class="line"></span><br><span class="line"> <span class="number">320</span> bytes unreachable at <span class="number">71</span>d37787d0</span><br><span class="line">  first <span class="number">20</span> bytes of contents:</span><br><span class="line">  <span class="number">71</span>d37787d0: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> ................</span><br><span class="line">  <span class="number">71</span>d37787e0: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> ................</span><br><span class="line"></span><br><span class="line"> <span class="number">192</span> bytes unreachable at <span class="number">71b</span>37b2f50</span><br><span class="line">  first <span class="number">20</span> bytes of contents:</span><br><span class="line">  <span class="number">71b</span>37b2f50: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> ................</span><br><span class="line">  <span class="number">71b</span>37b2f60: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> ................</span><br></pre></td></tr></table></figure>

<p>Then set the malloc debug options thusly:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">adb shell setprop libc.debug.malloc.options <span class="string">&quot;&#x27;backtrace backtrace_min_size=192 backtrace_max_size=320&#x27;&quot;</span></span><br></pre></td></tr></table></figure>
<p>This will backtrace allocations of any size between 192 bytes and 320 bytes inclusively.</p>
<p>After setting the backtrace size options, restart the application so that running dumpsys again will include the actual backtrace of the leaking allocations.</p>
<h3 id="C-interface"><a href="#C-interface" class="headerlink" title="C interface"></a>C interface</h3><h4 id="bool-LogUnreachableMemory-bool-log-contents-size-t-limit"><a href="#bool-LogUnreachableMemory-bool-log-contents-size-t-limit" class="headerlink" title="bool LogUnreachableMemory(bool log_contents, size_t limit)"></a>bool LogUnreachableMemory(bool log_contents, size_t limit)</h4><p>Writes a description of leaked memory to the log. A summary is always written, followed by details of up to limit leaks. If log_contents is true, details include up to 32 bytes of the contents of each leaked allocation. Returns true if leak detection succeeded.</p>
<h4 id="bool-NoLeaks"><a href="#bool-NoLeaks" class="headerlink" title="bool NoLeaks()"></a>bool NoLeaks()</h4><p>Returns true if no unreachable memory was found.</p>
<h3 id="C-interface-1"><a href="#C-interface-1" class="headerlink" title="C++ interface"></a>C++ interface</h3><h4 id="bool-GetUnreachableMemory-UnreachableMemoryInfo-amp-info-size-t-limit-100"><a href="#bool-GetUnreachableMemory-UnreachableMemoryInfo-amp-info-size-t-limit-100" class="headerlink" title="bool GetUnreachableMemory(UnreachableMemoryInfo&amp; info, size_t limit = 100)"></a>bool GetUnreachableMemory(UnreachableMemoryInfo&amp; info, size_t limit = 100)</h4><p>Updates an UnreachableMemoryInfo object with information on leaks, including details on up to limit leaks. Returns true if leak detection succeeded.</p>
<h4 id="std-string-GetUnreachableMemoryString-bool-log-contents-false-size-t-limit-100"><a href="#std-string-GetUnreachableMemoryString-bool-log-contents-false-size-t-limit-100" class="headerlink" title="std::string GetUnreachableMemoryString(bool log_contents = false, size_t limit = 100)"></a>std::string GetUnreachableMemoryString(bool log_contents = false, size_t limit = 100)</h4><p>Returns a description of leaked memory. A summary is always written, followed by details of up to limit leaks. If log_contents is true, details include up to 32 bytes of the contents of each leaked allocation. Returns true if leak detection succeeded.</p>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>The sequence of steps required to perform a leak detection pass is divided into three processes - the original process, the collection process, and the sweeper process.</p>
<ol>
<li>Original process: Leak detection is requested by calling GetUnreachableMemory()</li>
<li>Allocations are disabled using malloc_disable()</li>
<li>The collection process is spawned. The collection process, created using clone, is similar to a normal fork() child process, except that it shares the address space of the parent - any writes by the original process are visible to the collection process, and vice-versa. If we forked instead of using clone, the address space might get out of sync with observed post-ptrace thread state, since it takes some time to pause the parent.</li>
<li>Collection process: All threads in the original process are paused with ptrace().</li>
<li>Registers contents, active stack areas, and memory mapping information are collected.</li>
<li>Original process: Allocations are re-enabled using malloc_enable(), but all threads are still paused with ptrace().</li>
<li>Collection process: The sweeper process is spawned using a normal fork(). The sweeper process has a copy of all memory from the original process, including all the data collected by the collection process.</li>
<li>Collection process releases all threads from ptrace and exits</li>
<li>Original process: All threads continue, the thread that called GetUnreachableMemory() blocks waiting for leak data over a pipe.</li>
<li>Sweeper process: A list of all active allocations is produced by examining the memory mappings and calling malloc_iterate() on any heap mappings.</li>
<li>A list of all roots is produced from globals (.data and .bss sections of binaries), and registers and stacks from each thread.</li>
<li>The mark-and-sweep pass is performed starting from roots.</li>
<li>Unmarked allocations are sent over the pipe back to the original process.</li>
</ol>
<hr>
<h2 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h2><ul>
<li>MemUnreachable.cpp: Entry points, implements the sequencing described above.</li>
<li>PtracerThread.cpp: Used to clone the collection process with shared address space.</li>
<li>ThreadCapture.cpp: Pauses threads in the main process and collects register contents.</li>
<li>ProcessMappings.cpp: Collects snapshots of /proc/pid/maps.</li>
<li>HeapWalker.cpp: Performs the mark-and-sweep pass over active allocations.</li>
<li>LeakPipe.cpp: transfers data describing leaks from the sweeper process to the original process.</li>
</ul>
<h2 id="Heap-allocator-requirements"><a href="#Heap-allocator-requirements" class="headerlink" title="Heap allocator requirements"></a>Heap allocator requirements</h2><p>libmemunreachable requires a small interface to the allocator in order to collect information about active allocations.</p>
<ul>
<li>malloc_disable(): prevent any thread from mutating internal allocator state.</li>
<li>malloc enable(): re-enable allocations in all threads.</li>
<li>malloc_iterate(): call a callback on each active allocation in a given heap region.</li>
<li>malloc_backtrace(): return the backtrace from when the allocation at the given address was allocated, if it was collected.</li>
</ul>
<p>上文来源于官方文档，但是需要翻墙访问，原文链接：<a href="https://android.googlesource.com/platform/system/memory/libmemunreachable/+/master/README.md">libmemunreachable</a></p>
<hr>
<h2 id="在相机中的应用"><a href="#在相机中的应用" class="headerlink" title="在相机中的应用"></a>在相机中的应用</h2><p>unreachable是一个零开销的内存泄露检测工具，使用mark-and-sweep（一种垃圾回收算法） 遍历所有的native memory，统计出所有unreachable内存。</p>
<p>什么是unreachable内存：如果堆内存中的内存没有引用指向他，那么该内存就无法被调用，这样的内存称为不可达(unreachable)</p>
<h3 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h3><p>使用unreachable检查camera provider 内存泄露。</p>
<h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>1、链接库libmemunreachable.so, 在dumpsys  media.camera 时通过GetUnreachableMemory获取unreachable memory信息</p>
<p>在dumpsys 的流程中加入一下如下代码（除此之外还需要在mk中链接一下，具体看patch）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// dump_unreachable_info</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump_unreachable_info</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    android::UnreachableMemoryInfo info;</span><br><span class="line">    <span class="keyword">bool</span> success = <span class="built_in">GetUnreachableMemory</span>(info, <span class="comment">/*limit*/</span> <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        CamX::OsUtils::<span class="built_in">DPrintF</span>(fd, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\n== Unable to dump unreachable memory. &quot;</span></span><br><span class="line">                <span class="string">&quot;Try disabling SELinux enforcement. ==\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        CamX::OsUtils::<span class="built_in">DPrintF</span>(fd,<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\n== Dumping unreachable memory: ==\n&quot;</span>);</span><br><span class="line">        std::string s = info.<span class="built_in">ToString</span>(<span class="comment">/*log_contents*/</span> <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">write</span>(fd, s.<span class="built_in">c_str</span>(), s.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>limit ： 打印最多的内存泄露信息，如果只需要统计总的内存泄露大小，limit设置为0就可以了。<br>log_contents ：为true时会打印泄露位置前32字节的内容。</p>
<h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><p>adb shell dumpsys media.camera  &gt; dumpsys.txt<br>   <img src="image1.png"><br>把limit 设置为0后dump出的结果将更加简洁：<br>   <img src="image2.png"></p>
]]></content>
      <categories>
        <category>5. Memory</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Android相机体系结构之一：相机简史</title>
    <url>/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-1/</url>
    <content><![CDATA[<p>几千年来，人类主要通过文字以及绘画的方式记录着对于客观世界的认知，为了更直观地呈现客观世界的图景，摄影技术应运而生。</p>
<span id="more"></span>
<p>摄影是一门光与影的艺术，通过透镜将光线导入并依靠其折射特性，将光线最终导向到感光器件中，而感光器件在收到光线刺激之后进行一定的转换，进而形成影像，而这一系列的硬件设备的组合统一被称之为相机系统，同时由于现代计算机科学的迅猛发展，该系统依托其强大的传播力，彻底改变和提升了人类感知客观世界的方式和速度。</p>
<p>与现在相比，早期的相机系统十分简陋，同时成像效果也一直是灰白色调为主，但随着技术的不断革新，具有成像效果好，感光能力强的胶卷一经推出，便彻底提升了相机系统的成像效果。之后又随着CCD感光器件的发明，彻底将相机系统推入了数字成像时代，它直接将光信号转换为电子信号，进而转换为数字信号，最终将数据存储到计算机系统中。之后又在相机系统加入了图像处理模块，依托其强大的运算能力，成功地将成像效果再一次提升了一个维度，因此该时期的相机系统发展迅速，同时也基于技术的不断发展，各大厂商也推陈出新，打造了各式各样的相机系统，比较有代表性的便是单反和傻瓜相机，其中主打成像效果的单反相机，具有成像效果优秀，受到了众多摄像发烧友的追捧，而具有操作简单的傻瓜式相机，更加适合普通人群使用，在普通市场上反响也相当不错。之后随着手机的普及，对于使用手机进行拍照的需求越发强烈，同时随着制造工艺的进一步发展，一种低成本、小体积感光器件CMOS便顺势被推了出来，就这样手机端相机系统便正式登上了历史舞台。</p>
<p>但是由于相机系统在手机端起步较晚，所以初期的手机软件系统并没有对其有很好的支持，无论从开始的WINCE系统、还是塞班系统亦或是而今Android系统，在开始阶段，都只是简单实现了基本相机功能，使其仅仅能够满足简单的预览拍照录像需求，但是手机市场竞争异常激烈，各个厂商也看到了手机相机这块蓝海，便都投入了巨额资金进行研发，以Android系统为例，开始的相机系统功能简单，成像效果一般，并且无法满足用户的诸如高动态范围拍照等需求，但是经过了全球开发者的不懈努力，针对性为相机系统设计出了一套优秀的软件框架，并且借助一系列优秀的图像算法，再依托强大的硬件模块，而今Android相机系统在某些领域完全可以媲美专业相机。</p>
<p>而今的手机相机系统，除了成像效果有着显著的提高外，各大厂商在手机相机的功能性上也做足了功夫，最显著的代表便是单摄到多摄的演化，刚开始的手机系统仅仅采用了一个后置摄像头，但是由于人们对于自拍的需求日益增长，双摄系统便应运而生，一前一后两个相机模组，后者用于日常拍摄，前者用于自拍，之后随着时代的进步，互联网进一步的普及，将更多的专业照片带到了人们面前，由于审美能力的提高，人们对于手机相机系统便有了更高的要求，再加上技术水平的进一步提高，各大厂商便顺势提出了多摄相机系统，针对不同的拍摄场景或者拍摄效果在一部手机终端上集成多个相机模组，极大的满足了用户对于随手一拍便是大片的需求。</p>
<p>纵观整个Android相机系统的发展，从之前的小分辨率，一步步发展到而今的一亿像素，从之前的成像效果差强人意，到而今的完美呈现各种场景光影效果，从之前的单一模组到而今的多摄系统，它克服了一个又一个的技术难题，解决了一个又一个用户痛点问题，而其发展的背后都源于一个简单的目的，那就是让每一个人都能享受到科技带来的乐趣。</p>
]]></content>
      <categories>
        <category>1. Android Camera</category>
      </categories>
      <tags>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Android相机体系结构之十：安卓相机架构总结</title>
    <url>/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-10/</url>
    <content><![CDATA[<p>Android 相机体系庞大且复杂，在我刚开始接触到该框架的时候，如盲人摸象一般，一点一点地在代码的世界中探索，在很长的一段时间内，都只能局限于某一个特定的区域，而且在解决问题的过程中，虽然通过对代码的深入梳理，最终都会顺利解决难题，但是到最后依然缺乏一个对于整个框架的理解，正如管中窥豹一般，只见细节而无法把握全貌。但是进入现在的公司之后，通过与相机前辈的沟通，我发现框架思维能力尤为重要，针对整个框架结构需要做到掌控全局，这样在遇到问题的时候便可以迅速定位，此时再进行代码层面的深入研究，发现问题根源，进而达到最终解决问题的目的。</p>
<span id="more"></span>
<p>Android相机体系随处可见接口与实现相分离的设计思想，而之前提及的对于体系结构的梳理正是按照其接口的逻辑定义来完成，再结合其接口具体实现，进而完善整个框架体系的代码地图的构建，而在本人六年多的相机开发过程中，经历了多次的Android 相机的框架调整，接口演变，接下来以个人经历为主线，简单为整个相机架构做一个总结。</p>
<p>起初，首先接触到的相机框架部分便是驱动，那时接触的是高通MSM8953平台，该平台还是采用的QCamera &amp; MM-Camera框架，底层驱动并没有负责复杂业务逻辑控制，而是主要用于控制上下电，以及数据流的开启以及停止等，并且依然使用的是vb2进行图像帧缓冲区的管理，但是现如今的7150，其驱动部分俨然发生了翻天覆地的变化，高通为了配合UMD的业务处理，为驱动设计了一套KMD的框架，包含了复杂的业务处理流程，并且数据的管理也摒弃了vb2，采用了新的管理手段，赋予了驱动更多的职能。</p>
<p>之后由于工作需要，进一步将工作重心过渡到Camera HAL层，开发的平台依然是8953平台上，当时采用还是QCamera &amp; MM-Camera框架，在该平台上见证了HAL接口的演变，首先接触最多的便是HAL1接口，该接口使用起来比较简单，通过几个特定接口分别实现预览、拍照以及录像的功能，此时，谷歌已经意识到该接口具有一定的局限，所以自然而然地进行接口的升级，提出了HAL2接口，但是由于接口定义存在问题，所有很快谷歌便摒弃了该接口，迅速推出HAL3接口，并且一直沿用至今。HAL3接口相比于HAL1，优势明显，通过将所有的采集流程高度抽象为一个统一逻辑，所有的场景都可以通过这一统一逻辑进行扩展，使该接口具有很强的灵活性和扩展性，所以通过这几代HAL接口的演变，不难得出一个结论，那便是接口的定义需要高度抽象，而抽象的目的就是为了更好的灵活性和可扩展性，就单单这一点而言，HAL3接口可以说是成功的。</p>
<p>在后续HAL层的开发过程中，也见证了HIDL接口的诞生，在进行Android 8.0系统的升级过程中，发现谷歌将Camera Hal Module从Camera Service 解耦出来，放入一个独立的进程Camera Provider中进行管理，而该进程负责向外暴露HIDL接口，对内完成对其的实现，并且开始针对system分区以及vendor分区进行了严格的权限控制，该目的显而易见，那边是将平台厂商的实现与谷歌Framework相分离，这样便可以进行快速的迭代升级。</p>
<p>进入现在的公司之后，工作内容进一步扩大，涉及到了App部分，而这部分在之前也有所接触，但是并不深入，那个时候还是使用Camera Api v1接口，其定义和HAL1类似，但为了增加其灵活性和扩展性，之后谷歌提出了Camera Api v2接口，现在主要接触的便是该接口，通过简单的几个控制语句便可以实现图像的采集，使用起来比较简单，进一步降低了开发者的门槛，这也从侧面体现出了该接口定义的巧妙。同时，对于Camera Api v2的实现，是通过Camera Framework来完成的，而该层也有着一次不小的演变，刚开始Framework层并不是直接通过AIDL接口与Camera Service进行通信，而是通过一个JNI层来完成从Java到Native的转换，而Native部分作为客户端，保持对Service的通信。这种设计，很显然会比较臃肿，并且代码难以维护，所以之后由于AIDL接口的提出，谷歌直接将其加入到相机框架中，用于保持Framework与Service的通信，进而摈弃了JNI层，进一步减少了不必要的层级结构，保持了整个体系简洁性。</p>
<p>整个相机体系，经历了多次的发展，最终形成了而今的框架结构，一路走来，不难发现都是对于接口的升级，而其升级主要是更新其逻辑定义，完善其具体实现。</p>
]]></content>
      <categories>
        <category>1. Android Camera</category>
      </categories>
      <tags>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Android相机体系结构之十一：手机相机的未来与发展</title>
    <url>/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-11/</url>
    <content><![CDATA[<p>Android相机发展至今，通过开发者对框架的不断优化，算法人员对图像处理算法的不断提升，硬件工程师对硬件性能地不断调教，换来了在某些领域完全可以媲美专业相机的成像效果，这些成绩是有目共睹的，但是我们不能仅仅着眼于过去，试着将眼光放得长远些，如何将Android相机推向更高的维度，使其成为手机相机的王者，想必这是每一个热衷于技术的开发者都需要反复思考的问题，当然就我个人而言，对于它的未来，有着我自己的思考。</p>
<span id="more"></span>
<p>Android相机，首先是基于Android系统，所以对于系统端的优化，我相信Google依然会不断的进行完善，特别地，谷歌一直奉行着接口与实现相分离的设计原则， 这就将很多的实现让渡给各自有实现需求的开发者，所以其实我们有很大的创作空间，比如App部分，通过设计良好的业务框架，让整个相机应用在一个高效且稳定的框架中运行，处理来自用户需求，下发图像需求至相机框架中。又比如对于Camera Hal的实现，其实这部分高通做的已经相当完备，从QCamera&amp;MM-Camera架构到而今的CamX-CHI，都是在为上层提供更好地相机而努力着，但是框架谈不上完美，只能是比较符合当下实际情况，针对CamX-CHI而言，存在着内存占用过大以及CPU负载较高的问题，这些也是我们作为开发者所需要去攻克的难题。</p>
<p>麻雀虽小，五脏俱全，Android相机的小体积中俨然具备着一个完整的相机硬件体系，从光圈到透镜组，再到感光器件最后到后期的图像处理模块，每一个器件都承担着自己特有的使命。对于整套硬件体系而言，对于每一个器件的一个小小的提升都有可能使其在一系列竞争者中脱颖而出，比如某品牌的一亿像素，由于机身厚度的限制，大尺寸的CMOS会给透镜组乃至后期的算法处理带来不小的压力。<br>一张完美的图像，仅仅依靠前期的成像系统是远远不够的，就像当我们看见一副美景时，心中所呈现的并不是单单眼前的景色而已，我们所独有的人生阅历会在我们心中不经意地给其铺上一层独特的滤镜，赋予其独特的意义，而对于相机系统而言，算法便是其给图像铺上灵魂滤镜的关键因素，不同的算法可以赋予图像不同的属性，但是评价算法的好坏，经常会通过效果与效率两个方面来衡量，所以图像的更多意义，需要更多的算法来实现，而算法的更好更快处理便是其实现的目标，一个好的算法往往能够为平庸无奇的图像带来质的飞跃。</p>
<p>而今的Android相机已经完全不局限于记录身边的美好，而是在创造属于每个人的美好，可以通过它来和相隔万里的亲人朋友进行视频通讯，可以编辑属于自己的独一无二的图像表情，可以让多个自己存在在同一个空间中，以及通过萌拍模式记录下自己的可爱瞬间等，这一切的一切都极大的扩展了Android相机的功能性和可玩性，所以针对新Feature的开发，势必是一个大的趋势，这也印证了一个道理，对于相机的开发，我们有时候不是在满足需求，而是在创造需求。</p>
<p>最后，纵观Android历史，不难发现谷歌自始至终秉承着开源普惠大众的宗旨，从未停止过对Android系统的迭代优化，在整个Android相机系统架构中，不难发现接口与实现相分离的这一简单设计原则在其身上随处可见，这样既保证了整体架构的足够稳定，也实现了系统细节实现的多样性，同时也体现出了强大的灵活性，总的来讲，这样一套优秀的架构体系并且依托如今强大的硬件设备，加之全球开发者们在算法、新feature的不懈努力，我相信Android 相机会在以后的发展中一路高歌猛进，超越苹果成为手机相机领域的王者。</p>
]]></content>
      <categories>
        <category>1. Android Camera</category>
      </categories>
      <tags>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Android相机体系结构之二：安卓相机架构概览</title>
    <url>/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-2/</url>
    <content><![CDATA[<p>Android系统利用分层思想，将各层的接口定义与实现分离开来，以接口作为各层的脉络连接整体框架，将具体实现的主导权交由各自有具体实现需求的平台厂商或者Android 开发者，这样既做到把控全局，也给予了众多开发者足够大的创作空间，这体现出了一个优秀的开源系统应有的胸怀和远见。</p>
<span id="more"></span>
<p>其中，谷歌根据职能的不同将Camera框架一共划分成了五层，分别是App、Service、Provider、Driver以及Hardware，下面的Camera的整体架构图很清晰地显示出了其五层架构以及相互的关联接口。<br>   <img src="image1.png"></p>
<h2 id="Camera-App"><a href="#Camera-App" class="headerlink" title="Camera App"></a>Camera App</h2><p>应用层处于整个框架的顶端，承担着于用户直接进行交互的责任，承接来自用户直接或者间接的比如预览/拍照/录像等一系列具体需求，一旦接收到用户相关UI操作，便会通过Camera Api v2标准接口将需求发送至Camera Framework部分，并且等待Camera Framework回传处理结果，其中包括了图像数据以及整体相机系统状态参数，之后将结果以一定方式反馈给用户，达到记录显示种种美好瞬间的目的。</p>
<h2 id="Camera-Framework"><a href="#Camera-Framework" class="headerlink" title="Camera Framework"></a>Camera Framework</h2><p>该层主要位于Camera App与Camera Service之间，以jar包的形式运行在App进程中，它封装了Camera Api v2接口的实现细节，暴露接口给App进行调用，进而接收来自App的请求，同时维护着请求在内部流转的业务逻辑，最终通过调用Camera AIDL跨进程接口将请求发送至Camera Service中进行处理，紧接着，等待Camera Service结果的回传，进而将最终结果发送至App。</p>
<h2 id="Camera-Service"><a href="#Camera-Service" class="headerlink" title="Camera Service"></a>Camera Service</h2><p>该层位于Camera Framework与Camera Provider之间，作为一个独立进程存在于Android系统中，在系统启动初期会运行起来，它封装了Camera AIDL跨进程接口，提供给Framework进行调用，进而接收来自Framework的图像请求，同时内部维护着关于请求在该层的处理逻辑，最终通过调用Camera HIDL跨进程接口将请求再次下发到Camera Provider中，并且等待结果的回传，进而将结果上传至Framework中。</p>
<h2 id="Camera-Provider"><a href="#Camera-Provider" class="headerlink" title="Camera Provider"></a>Camera Provider</h2><p>该层位于Camera Service与Camera Driver之间，作为一个独立的进程存在于Android系统中，同时在系统启动初期被运行，提供Camera HIDL跨进程接口供Camera Service进行调用，封装了该接口的实现细节，接收来自Service的图像请求，并且内部加载了Camera HAL Module，该Module由OEM/ODM实现，遵循谷歌制定的标准Camera HAL3接口，进而通过该接口控制通过谷歌标准HAL3接口控制Camera HAL部分，最后等待Camera HAL的结果回传，紧接着Provider将结果通过Camera HIDL接口将结果发送至Camera Service。</p>
<h2 id="CamX-CHI-Camera-HAL"><a href="#CamX-CHI-Camera-HAL" class="headerlink" title="CamX-CHI(Camera HAL)"></a>CamX-CHI(Camera HAL)</h2><p>该部分是高通对谷歌Camera HAL3接口的实现，以so库的形式被加载至Camera Provider中，之前采用的是QCamera &amp; MM-Camera架构，但是为了更好灵活性和可扩展性，而今高通又提出了CamX-CHI架构，该架构提供HAL3接口给Provider进行调用，接收来自Provider的请求，而内部对HAL3接口进行了实现，并且通过V4L2标准框架控制着相机驱动层，将请求下发至驱动部分，并且等待结果回传，进而上报给Camera Provider。<br>CamX-CHI架构由CamX和CHI两个部分组成，CamX负责一些基础服务代码的实现，不经常改动，CHI负责实现一些可扩展性和定制化的需求，方便OEM/ODM添加自己的扩展功能。CamX主要包括实现HAL3入口的hal模块，实现与V4L2驱动交互的csl模块，实现硬件node的hwl和实现软件node的swl。CHI通过抽象出Usecase、Featrue、Session、Pipeline、Node的概念，使厂商可以通过实现Node接口来接入自己的算法，并通过XML文件灵活配置Usecase、Pipeline、Node的结构关系。</p>
<h2 id="Camera-Driver"><a href="#Camera-Driver" class="headerlink" title="Camera Driver"></a>Camera Driver</h2><p>Linux为视频采集设备制定了标准的V4L2接口，并在内核中实现了其基础框架V4L2 Core。用户空间进程可以通过V4L2接口调用相关设备功能，而不用考虑其实现细节。V4L2提出了总设备和子设备的概念，并通过media controller机制向用户空间暴露自己的硬件拓扑结构。视频采集设备驱动厂商按照V4L2 Core的要求开发自己的驱动程序，只需要实现相应的结构体和函数接口并调用注册函数注册自己就行。<br>在高通平台上，高通对相机驱动部分进行了实现，利用了V4L2框架的可扩展特性，设计出了一套独特的KMD框架。在该框架内部主要包含了三个部分，CRM、Camera Sync以及一系列子设备，首先，作为框架顶层管理者，CRM创建了一个V4L2主设备用来管理所有的子设备，并且暴露设备节点video0给用户空间，同时内部维护着整个底层驱动业务逻辑。其次，Camera Sync创建了一个V4L2主设备，同时暴露了设备节点video1给用户空间，主要用于向用户空间反馈图像数据处理状态。最后，子设备模块被抽象成v4l2_subdev设备，同样也暴露设备节点v4l2-subdev给用户空间进行更精细化的控制。另外，在整个框架初始化的过程中，通过media controller机制，保持了在用户空间进行枚举底层硬件设备的能力。</p>
<h2 id="Camera-Hardware"><a href="#Camera-Hardware" class="headerlink" title="Camera Hardware"></a>Camera Hardware</h2><p>相机硬件处在整个相机体系的最底层，是相机系统的物理实现部分，该部分包括镜头、感光器、ISP三个最重要的模块，还有对焦马达、闪光灯、滤光片、光圈等辅助模块。镜头的作用是汇聚光线，利用光的折射性把射入的光线汇聚到感光器上。感光器的作用是负责光电转换，通过内部感光元件将接收到的光信号转换为电子信号进而通过数电转换模块转为数字信号，并最后传给ISP。ISP负责对数字图像进行一些算法处理，如白平衡、降噪、去马赛克等。</p>
<p>通过上面的介绍，我们可以发现，谷歌通过以上五级分层，形成了整个相机框架体系，其中层与层之间通过行业协会、开源社区或者谷歌制订的标准接口进行连接，上层通过调用标准接口下发请求到下层，下层负责对标准接口进行实现，最终将请求再次封装并调用下一层级的对外接口下发到下层。所以总得来说，谷歌使用标准接口作为骨架搭建整体框架，而其具体实现交由各层自己负责，从整体上来看，职责划分明确，界限分明，这样的设计，一来利用标准接口，保持了整个框架业务正常流转，二来极大地降低了各层耦合度，保持了各层的相互独立，最终让整个框架处于一个稳定同时高效的运行状态。</p>
]]></content>
      <categories>
        <category>1. Android Camera</category>
      </categories>
      <tags>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Android相机体系结构之三：相机应用层</title>
    <url>/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-3/</url>
    <content><![CDATA[<h2 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h2><p>相机应用处于整个框架的上层，在现实生活中，为了满足各式各样的应用场景，会加入很多业务处理逻辑，但是一旦当我们拨开繁杂的业务逻辑，便会发现其核心部分依然是通过调用谷歌制订的一系列Camera Api接口来完成的，而所有的相机行为都包含在该接口中。</p>
<span id="more"></span>
<p>起初，相机系统采用的是Camera Api v1接口，它通过一个Camera 类以及该类中的几个标准方法来实现整个相机系统的预览、拍照以及录像功能，控制逻辑比较简单，同时也比较容易理解，但也正是这种简单，导致了它无法逐帧控制底层硬件，无法通过元数据进行修改进而增强帧的表达能力，再加之应用场景的多样化趋势，该接口在新功能的实现上显得些许力不从心。面对该接口难以进一步扩展相机功能这一局面，谷歌在Andorid 5.0(API Level 21)便重新对Camera进行了设计，摒弃了Camera Api v1的设计逻辑，提出了一个全新的API – camera2，引入了Session以及Request概念，将控制逻辑统一成一个视图，因此在使用上更加复杂，同时也支持了更多特性，比如逐帧控制曝光、感光度以及支持Raw格式的输出等。并且由于对控制逻辑的高度抽象化，使得该接口具有很高的灵活性，可以通过简单的操作实现30fps的全高清连拍的功能，总得来说，该接口极大地提高了对于相机框架的控制能力，同时也进一步大幅度提升了其整体性能。</p>
<p>谷歌提出Camera Api v2接口的同时，将其具体实现放入了Camera Framework中来完成，Framework内部负责解析来自App的请求，并且通过AIDL跨进程接口下发到Camera Service中进行处理，并且等待结果的回传。接下来我们首先以Camera Api v2接口为主简单讲解下其逻辑含义，然后详细梳理下Camera Framework对于它的实现，最后以一个简单App Demo为例，来介绍下如何使用该接口来控制整个相机体系。<br>   <img src="Image.png"></p>
<h2 id="二、Camera-Api-v2"><a href="#二、Camera-Api-v2" class="headerlink" title="二、Camera Api v2"></a>二、Camera Api v2</h2><p>在介绍Camera Api v2之前，首先我们来回顾下Api v1接口的基本逻辑，该接口主要通过一个Camera.java类来定义了所有的控制行为，通过定义诸如open、startPreview、takePicture、AutoFocus等标准的接口来实现打开设备、预览、拍照以及对焦操作的功能，同时通过定义Camera.Parameters来实现了参数的读取与设置，其中包括了帧率、图片格式的控制，另外，通过定义了Camera.CameraInfo来实现了图像元数据的获取。而为了更加细致化地控制相机系统的Camera Api v2接口，相对于Api v1接口而言，复杂了许多，通过不同的接口类以及接口方法定义了复杂的相机系统行为，接下来我们来逐一进行介绍：</p>
<h3 id="CameraManager"><a href="#CameraManager" class="headerlink" title="CameraManager"></a>CameraManager</h3><p>谷歌将CameraManager定义为一个系统服务，通过Context.getSystemService来获取，主要用于检测以及打开系统相机，其中打开操作通过openCamera方法来完成。除此之外，还定义了getCameraCharacteristics方法来获取当前Camera 设备支持的属性信息，而该属性信息通过CameraCharacteristics来表示，其中包括了图像数据的大小以及帧率等信息。</p>
<h3 id="CameraDevice"><a href="#CameraDevice" class="headerlink" title="CameraDevice"></a>CameraDevice</h3><p>代表了一个被打开的系统相机，类似于Camera Api v1中的Camera类，用于创建CameraCaptureSession以及对于最后相机资源的释放。</p>
<h3 id="CameraDevice-StateCallback"><a href="#CameraDevice-StateCallback" class="headerlink" title="CameraDevice.StateCallback"></a>CameraDevice.StateCallback</h3><p>该类定义了一系列的回调方法，其实现交由App来完成，主要用于返回创建Camera设备的结果，一旦创建成功相机框架会通过回调其onOpened方法将CameraDevice实例给到App，如果失败，则调用onError返回错误信息。</p>
<h3 id="CameraCaptureSession"><a href="#CameraCaptureSession" class="headerlink" title="CameraCaptureSession"></a>CameraCaptureSession</h3><p>该类代表了一个具体的相机会话，建立了与Camera设备的通道，而之后对于Camera 设备的控制都是通过该通道来完成的。当需要进行预览或者拍照时，首先通过该类创建一个Session，并且调用其startRepeatingRequest方法开启预览流程，或者调用capture方法开始一次拍照动作。</p>
<h3 id="CameraCaptureSession-StateCallback"><a href="#CameraCaptureSession-StateCallback" class="headerlink" title="CameraCaptureSession.StateCallback"></a>CameraCaptureSession.StateCallback</h3><p>该接口类定义了一系列回调方法，其实现交由App完成，主要用于返回创建CameraCaptureSession的结果，成功则通过onConfigured方法返回一个CameraCaptureSession实例，如果失败则通过onConfigureFailed返回错误信息。</p>
<h3 id="CameraCaptureSession-CaptureCallback"><a href="#CameraCaptureSession-CaptureCallback" class="headerlink" title="CameraCaptureSession.CaptureCallback"></a>CameraCaptureSession.CaptureCallback</h3><p>该接口类定义了一系列回调方法，用于返回来自Camera Framework的数据和事件，其中onCaptureStarted方法在下发图像需求之后立即被调用，告知App此次图像需求已经收到，onCaptureProgressed方法在产生partial meta data的时候回调，onCaptureCompleted方法在图像采集完成，上传meta data数据时被调用。</p>
<h3 id="CaptureRequest"><a href="#CaptureRequest" class="headerlink" title="CaptureRequest"></a>CaptureRequest</h3><p>该类用于表示一次图像请求，在需要进行预览或者拍照时，都需要创建一个CaptureRequest，并且将针对图片的一系列诸如曝光/对焦设置参数都加入到该Request中，通过CameraCaptureSessin下发到相机系统中。</p>
<h3 id="TotalCaptureResult"><a href="#TotalCaptureResult" class="headerlink" title="TotalCaptureResult"></a>TotalCaptureResult</h3><p>每当通过CameraDevice完成了一次CaptureRequest之后会生成一个TotalCaptureResult对象，该对象包含了此次抓取动作所产生的所有信息，其中包括关于硬件模块(包括Sensor/lens/flash)的配置信息以及相机设备的状态信息等。</p>
<h3 id="CaptureResult"><a href="#CaptureResult" class="headerlink" title="CaptureResult"></a>CaptureResult</h3><p>该类代表了某次抓取动作最终生成的图像信息，其中包括了此次关于硬件软件的配置信息以及输出的图像数据，以及显示了当前Camera设备的状态的元数据(meta data)，该类并不保证拥有所有的图像信息。</p>
<h2 id="三、Camera-Framework"><a href="#三、Camera-Framework" class="headerlink" title="三、Camera Framework"></a>三、Camera Framework</h2><p>基于接口与实现相分离的基本设计原则，谷歌通过Camera Api 接口的定义，搭建起了App与相机系统的桥梁，而具体实现便是由Camera Framework来负责完成的。在采用Camera Api v1接口的时期，该部分是通过JNI层来进行java到C++的转换，进而到达native层，而在native层会通过实现CameraClient建立与Camera Service的通讯 ，整个过程比较繁琐，使得整体框架略显繁杂，而随着Camera Api v2的提出，在该层便大量使用AIDL机制，直接在Java层建立与Camera Service的通信，进一步简化了整体框架。，接下来我们以几个主要接口为主线，简单梳理下其具体实现。<br>   <img src="Image1.png"></p>
<h3 id="CameraManager-1"><a href="#CameraManager-1" class="headerlink" title="CameraManager"></a>CameraManager</h3><p>实现主要在CameraManager.java中，通过CameraManager查询、获取以及打开一个Camera 设备。在该类中还实现了内部类CameraManagerGlobal，该类继承于ICameraServiceListener.Stub，在打开相机设备的时候，在内部会获取到ICameraService远程代理，并且调用ICameraService的addListener方法将自己注册到Camera Service中，一旦Camera Service状态有所变更便会通过其实现的回调方法通知到Camera Manager服务，另外，该类还通过调用ICameraService.connectDevice()方法获取到Camera Service中的CameraDevice远程代理，并且将该代理传入CameraDeviceImpl中，进而与Camera Service建立了连接。</p>
<h3 id="CameraDeviceImpl"><a href="#CameraDeviceImpl" class="headerlink" title="CameraDeviceImpl"></a>CameraDeviceImpl</h3><p>该类定义在CameraDeviceImpl.java文件中，继承并实现了CameraDevice接口，代表了一个相机设备，可以完成CameraCaptureSession的创建以及CaptureRequest创建等工作，内部定义了CameraDeviceCallbacks类(该类继承于ICameraDeviceCallbacks.Stub，对应于Camera Service中的 ICameraDeviceCallbacks接口)，用于接收来自Camera Service中的Camera Device的状态回调，并且内部维护着一个Camera Service 的远程ICameraDevice代理，进而可以下发图像请求到Camera Service中。</p>
<h3 id="CameraCaptureSessionImpl"><a href="#CameraCaptureSessionImpl" class="headerlink" title="CameraCaptureSessionImpl"></a>CameraCaptureSessionImpl</h3><p>该类定义在CameraCaptureSessionImpl.java文件中，继承并实现了CameraCaptureSession接口，每一个相机设备在一个时间段中，只能创建并存在一个CameraCaptureSession，其中该类包含了两种Session，一种是普通的，适用于一般情况下的会话操作，另一种是用于Reprocess流程的会话操作，该流程主要用于对于现有的图像数据进行再处理的操作。该类维护着来自实例化时传入的Surface列表，这些Surface正是包含了每一个图像请求的数据缓冲区。<br>除了以上这几个接口，还有几个接口是需要App部分进行实现的，用于返回App所需要的对象或者数据：</p>
<h3 id="CameraDevice-StateCallback-1"><a href="#CameraDevice-StateCallback-1" class="headerlink" title="CameraDevice.StateCallback"></a>CameraDevice.StateCallback</h3><p>被App端进行继承并实现，用于在调用CameraManager的openCamera方法时，通过参数的形式传入Framework，在Framework中，一旦CameraDeviceImpl创建成功便通过其中的onOpened方法将其返回给App，如果失败，便会通过其他方法返回给App错误信息。</p>
<h3 id="CameraCaptureSession-StateCallback-1"><a href="#CameraCaptureSession-StateCallback-1" class="headerlink" title="CameraCaptureSession.StateCallback"></a>CameraCaptureSession.StateCallback</h3><p>被App端进行继承并实现，用于在调用CameraDevice的createCaptureSession方法时作为参数传入Framework中，一旦创建成功，Framework便会通过调用该类的onConfigured接口返回一个CameraCaptureSessionImpl的对象，如果失败，Framework会调用其onConfigureFailed方法将错误信息返回至App。</p>
<h3 id="CameraCaptureSession-CaptureCallback-1"><a href="#CameraCaptureSession-CaptureCallback-1" class="headerlink" title="CameraCaptureSession.CaptureCallback"></a>CameraCaptureSession.CaptureCallback</h3><p>被App端进行继承并实现，App通过调用CameraCaptureSessionImpl的setReaptingRequest或者capture方法是作为参数传入Framework，一旦Framework接收到来自CameraService的数据时，便会通过调用这个回调类将数据发送至App中。</p>
<h3 id="主要接口流程"><a href="#主要接口流程" class="headerlink" title="主要接口流程"></a>主要接口流程</h3><p>   <img src="Image2.png"><br>Camera Framework 中针对几个接口的调用流程如上图，接下来我们依次进行分析：</p>
<h4 id="a-openCamera"><a href="#a-openCamera" class="headerlink" title="a) openCamera"></a>a) openCamera</h4><p>当用户打开相机应用时，会去调用该方法打开一个相机设备，其中该方法最终经过层层调用会调用到Camera Framework中的openCameraDeviceUserAsync方法，在该方法中主要做了三件事：</p>
<ul>
<li>首先是获取ICameraService代理，调用其getCameraInfo方法获取当前设备的属性。</li>
<li>其次是实例化了一个CameraDeviceImpl对象，并将来自App的CameraDevice.StateCallback接口存入该对象中，再将CameraDeviceImpl中的内部类CameraDeviceCallback作为参数通过ICameraService的connectDevice方法传入Camera Service去打开并获取一个ICameraDeviceUser代理，并将该代理存入CameraDeviceImpl中进行管理。</li>
<li>最后通过App传入的回调将CameraDeviceImpl返回给App使用，至此整个流程便完成了。</li>
</ul>
<h4 id="b-createCaptureSession"><a href="#b-createCaptureSession" class="headerlink" title="b) createCaptureSession"></a>b) createCaptureSession</h4><p>在打开相机设备之后便需要去创建一个相机会话，用于传输图像请求，其最终实现是调用该方法来进行实现的，而该方法会去调用到Camera Framework中的createCaptureSessionInternal方法，该方法主要做了两件事：</p>
<ul>
<li>首先调用configureStreamsChecked方法来配置数据流。</li>
<li>其次实例化了一个CameraCaptureImpl对象，并通过传入CameraCaptureSession.StateCallback回调类将该对象发送至至App中。<br>而在configureStreamsChecked方法中会去调用ICameraDeviceUser代理的一些列方法进行数据流配置，其中调用cancelRequest方法停掉当前的的预览流程，调用deleteStream方法删除之前的数据流，调用createStream创建新的数据流，最后调用endConfigure来进行数据流的配置工作，针对的配置便在最后这个endConfigure方法中。</li>
</ul>
<h4 id="c-createCaptureRequest"><a href="#c-createCaptureRequest" class="headerlink" title="c) createCaptureRequest"></a>c) createCaptureRequest</h4><p>在创建并获取相机会话之后，便可以开始下发图像请求了，而在此之前，需要通过该方法来创建一个CaptureRequest，一旦调用该方法，最终会调用到Camera Service中ICameraDeviceUser的createDefaultRequest方法来创建一个默认配置的CameraMetadataNative，其次实例化一个CaptureRequest.Builder对象，并将刚才获取的CameraMetadataNative传入其中，之后返回该CaptureRequest.Builder对象，在App中，直接通过调用该Buidler对象的build方法，获取一个CaptureRequest对象。<br>CaptureRequest对象也创建成功了，接下来需要下发图像请求了，一般常用请求分为两种,一个是预览一个是拍照。</p>
<h4 id="d-setRepeatingRequest"><a href="#d-setRepeatingRequest" class="headerlink" title="d) setRepeatingRequest"></a>d) setRepeatingRequest</h4><p>App调用该方法开始预览流程，通过层层调用最终会调用到Framework中的submitCaptureRequest方法，该方法主要做了两件事：</p>
<ul>
<li>首先调用CameraService层CameraDeviceUser的submitRequestList方法，将此次Request下发到CameraService中。</li>
<li>其次将App通过参数传入的CameraCaptureSession.CaptureCallbakc对象存到CameraDeviceImpI对象中。</li>
</ul>
<p>接下来看下拍照请求的处理流程：</p>
<h4 id="e-capture"><a href="#e-capture" class="headerlink" title="e) capture"></a>e) capture</h4><p>该方法最终也会调用到Framework中的submitCaptureRequest方法，接下来边和预览流程大致相同，会去调用Camera Service 中的ICameraDeviceUser的submitRequestList方法传入请求，之后将App实现的回调对象存入CameraDeviceImpl对象中。</p>
<h4 id="f-onCaptureProgressed"><a href="#f-onCaptureProgressed" class="headerlink" title="f) onCaptureProgressed"></a>f) onCaptureProgressed</h4><p>一旦Request下发到Camera Service之后，当底层生成了Partial Meta data数据，Camera Service会调用通过调用在打开相机设备时传入的ICameraDeviceCallback代理，通过其onResultReceived方法将数据传回Framework，之后调用App传入的CameraCaptureSession.CaptureCallback中的onCaputreProgressed方法将结果回传至App进行解析以及后处理。</p>
<h4 id="g-onCaptureCompleted"><a href="#g-onCaptureCompleted" class="headerlink" title="g) onCaptureCompleted"></a>g) onCaptureCompleted</h4><p>一旦Request下发到Camera Service之后，当底层生成了Meta data数据，Camera Service会调用通过调用在打开相机设备时传入的ICameraDeviceCallback代理，通过其onResultReceived方法将数据传回Framework，之后调用App传入的CameraCaptureSession.CaptureCallback中的onCaputreCompleted方法将结果回传至App进行解析以及后处理。</p>
<h4 id="h-onImageAvailable"><a href="#h-onImageAvailable" class="headerlink" title="h) onImageAvailable"></a>h) onImageAvailable</h4><p>之前已经通过两个回调接口onCaptureProgressed以及onCaptureCompleted方法将meta data上传到了App，一般情况下，图像数据会在他们之后上传，而且这个上传过程并不经过Camera Framework，而是通过BufferQueue来进行的，当Camera Service接收到底层传来的图像数据，便会立即调用processCaptureResult_3_4方法，该方法中会去调用BufferQueue中生产者角色的Surface的queueBuffer方法，将数据入队并通知消费者去消费，而此时的消费者正是App端的ImageReader，并经过一层层回调，最终会通过调用ImageReader的onImageAvailable方法，通知ImageReader去将数据取出，并做后期操作。<br>从上面的梳理不难发现，整个Camera Framework除了是对Camera Api v2的实现外，还承担着与Camera Service跨进程通信的任务，充当了一个位于App与Service之间的中转站的角色。</p>
<h2 id="四、Camera-App-Demo"><a href="#四、Camera-App-Demo" class="headerlink" title="四、Camera App Demo"></a>四、Camera App Demo</h2><p>经过上面的梳理总结，我们已经对整个Camera Api v2接口以及实现都有了一个较为深入的认识，但是认识暂时仅仅停留在代码层面，为了更好理解其功能，接下来我们以一个简单的相机应用入手来加深下对其的应用流程的理解：<br>该相机Demo比较简单，界面有两个元素，一个是用于预览显示的TextureView，以及一个用于拍照的按钮，整个代码就采用了一个MainActiviy，相机操作就在该类中进行，其主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bruce.camerademo1;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.ActivityCompat;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> android.Manifest;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager;</span><br><span class="line"><span class="keyword">import</span> android.graphics.ImageFormat;</span><br><span class="line"><span class="keyword">import</span> android.graphics.SurfaceTexture;</span><br><span class="line"><span class="keyword">import</span> android.hardware.camera2.CameraAccessException;</span><br><span class="line"><span class="keyword">import</span> android.hardware.camera2.CameraCaptureSession;</span><br><span class="line"><span class="keyword">import</span> android.hardware.camera2.CameraDevice;</span><br><span class="line"><span class="keyword">import</span> android.hardware.camera2.CameraManager;</span><br><span class="line"><span class="keyword">import</span> android.hardware.camera2.CaptureRequest;</span><br><span class="line"><span class="keyword">import</span> android.hardware.camera2.TotalCaptureResult;</span><br><span class="line"><span class="keyword">import</span> android.media.Image;</span><br><span class="line"><span class="keyword">import</span> android.media.ImageReader;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Environment;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.util.Size;</span><br><span class="line"><span class="keyword">import</span> android.view.Surface;</span><br><span class="line"><span class="keyword">import</span> android.view.TextureView;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    TextureView mTextureView = <span class="keyword">null</span>;</span><br><span class="line">    CameraManager mCamManager = <span class="keyword">null</span>;</span><br><span class="line">    CameraDevice mCamDevice = <span class="keyword">null</span>;</span><br><span class="line">    CameraCaptureSession mCamSession = <span class="keyword">null</span>;</span><br><span class="line">    Button mClick = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//预览数据大小 1080 × 720</span></span><br><span class="line">    <span class="keyword">private</span> Size mPreviewSize = <span class="keyword">new</span> Size(<span class="number">1080</span>, <span class="number">720</span>);</span><br><span class="line">    <span class="comment">//拍照数据图像大小 1080 × 720</span></span><br><span class="line">   <span class="keyword">private</span> Size mCaptureSize = <span class="keyword">new</span> Size(<span class="number">1080</span>, <span class="number">720</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Surface mPreviewSurface = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> CaptureRequest.Builder mCaptureRequestBuilder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> CaptureRequest mCaptureRequest = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> ImageReader mImageReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> String LOG_TAG = <span class="string">&quot;Camera&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) &#123;</span><br><span class="line">            Log.e(LOG_TAG, <span class="string">&quot;s is empty&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(LOG_TAG, <span class="string">&quot;&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        mTextureView = findViewById(R.id.textview);</span><br><span class="line">        mTextureView.setSurfaceTextureListener(textureListener);</span><br><span class="line">        mClick = findViewById(R.id.button);</span><br><span class="line">        mImageReader = ImageReader.newInstance(mCaptureSize.getWidth(), mCaptureSize.getHeight(), ImageFormat.JPEG, <span class="number">2</span>);</span><br><span class="line">        mImageReader.setOnImageAvailableListener(<span class="keyword">new</span> ImageReader.OnImageAvailableListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onImageAvailable</span><span class="params">(ImageReader reader)</span> </span>&#123;</span><br><span class="line">                Image image = reader.acquireNextImage();</span><br><span class="line">                ByteBuffer buffer = image.getPlanes()[<span class="number">0</span>].getBuffer();</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.remaining()];</span><br><span class="line">                <span class="comment">//由缓冲区存入字节数组</span></span><br><span class="line">                buffer.get(bytes);</span><br><span class="line">                <span class="comment">//字节数组转换为jpeg格式图片，并存储在设备中</span></span><br><span class="line">                doByte2JpegFile(bytes);</span><br><span class="line">                image.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">null</span> <span class="comment">/*mCameraHandler*/</span>);</span><br><span class="line">        mClick.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//创建CaptureRequest.Builder,TEMPLATE_STILL_CAPTURE代表了此Request是用于拍照</span></span><br><span class="line">                    CaptureRequest.Builder b = mCamDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);</span><br><span class="line">                    b.addTarget(mImageReader.getSurface());</span><br><span class="line">                    mCamSession.capture(b.build(), <span class="keyword">new</span> CameraCaptureSession.CaptureCallback() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCaptureCompleted</span><span class="params">(<span class="meta">@NonNull</span> CameraCaptureSession session, <span class="meta">@NonNull</span> CaptureRequest request, <span class="meta">@NonNull</span> TotalCaptureResult result)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">super</span>.onCaptureCompleted(session, request, result);</span><br><span class="line">                            <span class="comment">//返回result --&gt; meta data</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> TextureView.SurfaceTextureListener textureListener = <span class="keyword">new</span> TextureView.SurfaceTextureListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureAvailable</span><span class="params">(SurfaceTexture surface, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (ActivityCompat.checkSelfPermission(MainActivity.<span class="keyword">this</span>, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                ActivityCompat.requestPermissions(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> String[]&#123;Manifest.permission.CAMERA&#125;, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (ActivityCompat.checkSelfPermission(MainActivity.<span class="keyword">this</span>, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                ActivityCompat.requestPermissions(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//获取CameraManager服务</span></span><br><span class="line">            mCamManager = (CameraManager)getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//打开主摄</span></span><br><span class="line">                mCamManager.openCamera(<span class="string">&quot;0&quot;</span>, mStateCallback, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//App需要实现该接口，用于接收CameraDevice实例</span></span><br><span class="line">        <span class="keyword">public</span> CameraDevice.StateCallback mStateCallback = <span class="keyword">new</span> CameraDevice.StateCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpened</span><span class="params">(CameraDevice camera)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (camera != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    log(<span class="string">&quot;camera is not null&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;onOpened&quot;</span>);</span><br><span class="line">                <span class="comment">//返回CameraDevice,将其存入mCamDevice</span></span><br><span class="line">                mCamDevice = camera;</span><br><span class="line">                startPreview();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisconnected</span><span class="params">(CameraDevice camera)</span> </span>&#123;</span><br><span class="line">                camera.close();</span><br><span class="line">                mCamDevice = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(CameraDevice camera, <span class="keyword">int</span> error)</span> </span>&#123;</span><br><span class="line">                camera.close();</span><br><span class="line">                mCamDevice = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startPreview</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            SurfaceTexture mSurfaceTexture = mTextureView.getSurfaceTexture();</span><br><span class="line">            <span class="comment">// 设置TextureView 用于显示的缓冲区大小</span></span><br><span class="line">            mSurfaceTexture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());</span><br><span class="line">            <span class="comment">//创建Surface，用于显示预览数据</span></span><br><span class="line">            mPreviewSurface = <span class="keyword">new</span> Surface(mSurfaceTexture);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//创建CameraCaptureSession,App需要实现CameraCaptureSession.StateCallback用于接收CameraCaptureSession实例</span></span><br><span class="line">                mCamDevice.createCaptureSession(Arrays.asList(mPreviewSurface, mImageReader.getSurface()), <span class="keyword">new</span> CameraCaptureSession.StateCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigured</span><span class="params">(CameraCaptureSession session)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//创建用于预览的CaptureRequest.Builder,进而得到CaptureRequest</span></span><br><span class="line">                            CaptureRequest.Builder b = mCamDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">                            b.addTarget(mPreviewSurface);</span><br><span class="line">                            CaptureRequest r = b.build();</span><br><span class="line">                            mCamSession = session;</span><br><span class="line">                            <span class="comment">//下发预览需求</span></span><br><span class="line">                            mCamSession.setRepeatingRequest(r, mPreviewCaptureCallback, <span class="keyword">null</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    CameraCaptureSession.CaptureCallback mPreviewCaptureCallback = <span class="keyword">new</span> CameraCaptureSession.CaptureCallback() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCaptureCompleted</span><span class="params">(CameraCaptureSession session, CaptureRequest request, TotalCaptureResult result)</span> </span>&#123;</span><br><span class="line">                            <span class="comment">//返回result --&gt; meta data</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line"> </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReady</span><span class="params">(CameraCaptureSession session)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">super</span>.onReady(session);</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigureFailed</span><span class="params">(CameraCaptureSession session)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureSizeChanged</span><span class="params">(SurfaceTexture surface, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">            log(<span class="string">&quot;onSurfaceTextureSizeChanged Enter&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSurfaceTextureDestroyed</span><span class="params">(SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line">            log(<span class="string">&quot;onSurfaceTextureDestroyed Enter&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureUpdated</span><span class="params">(SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line">            log(<span class="string">&quot;onSurfaceTextureUpdated Enter&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">doByte2JpegFile</span><span class="params">(<span class="keyword">byte</span>[]... jpeg)</span> </span>&#123;</span><br><span class="line">        File photo = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory(), <span class="string">&quot;photo-test.jpg&quot;</span>);</span><br><span class="line">        log(<span class="string">&quot;dir : &quot;</span> + Environment.getExternalStorageDirectory());</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (photo.exists()) &#123;</span><br><span class="line">            photo.delete();</span><br><span class="line">            log(<span class="string">&quot;photo exists&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log(<span class="string">&quot;photo not exists&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(photo.getPath());</span><br><span class="line">            log(<span class="string">&quot;photo path : &quot;</span> + photo.getPath());</span><br><span class="line"> </span><br><span class="line">            fos.write(jpeg[<span class="number">0</span>]);</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">            Log.e(LOG_TAG, <span class="string">&quot;Exception in photoCallback&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        log(<span class="string">&quot;get jpeg files done&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较简单，其主要逻辑如下：</p>
<ul>
<li><p>a) 初始化<br>随着应用的打开，首先在MainActivity的onResume方法中去初始化用于拍照的按钮和接收数据的ImageReader，并且设置其各自回调方法。</p>
</li>
<li><p>b) 获取CameraManager/打开Camera 设备<br>其次在TextureView.SurfaceTextureListener中的回调方法onSurfaceTextureAvailable会被调用，在该方法中会去获取CameraManager服务，并打调用其openCamera方法打开后主摄相机设备，并通过回调接口获取该设备，紧接着调用startPreview方法。</p>
</li>
<li><p>c) 创建Camera Capture Session/下发预览需求<br>在startPreview方法中会去下发预览需求，主要工作有设置TextureView缓冲区大小，创建用于接收预览数据的Surface，并调用CameraDevice的createCaptureSession方法创建CameraCaptureSession，在其回调接口onConfigured方法中，去创建CaptureRequest，并调用CameraCaptureSession的setRepeatingRequest方法下发Request到相机框架中。</p>
</li>
<li><p>d) 返回预览Metadata/图像数据<br>在完成了预览需求的Requet的下发工作后，相机框架便会不断通过传入的CaptureCallback中的onCaptureComplete方法上传Meta Data以及通过BufferQueue框架上传图像数据进行预览显示。</p>
</li>
<li><p>e) 下发拍照需求<br>当点击应用界面的拍照按钮的时候，会触发按钮的View.OnClickListener监听类中的onClick方法，在该方法中，初始化了一个用于拍照的CaptureRequest，并且通过调用CameraCaptureSession的capture方法下发拍照需求.</p>
</li>
<li><p>f) 返回拍照Metadata/图像数据<br>一旦拍照图像数据生成，便会通过回调接口CaptureCallback中的onCaptureComplete方法上传Meta Data以及通过BufferQueue框架上传图像数据到ImageReader中，触发其onImageAvailable方法，在该方法中通过ImageReader的acquireNextImage获取到拍照图像数据，并通过doByte2JpegFile将其转存外JPEG格式的图片保存在设备中。</p>
</li>
</ul>
<p>Camera App作为整个框架体系的最上层，直接面向的主体是普通用户，其关键性不言而喻，一点点的卡顿或者停滞都会降低用户体验性，为了保证整个框架的稳定性以及高效性，谷歌重新设计了Camera 接口Api v2，由于该接口将控制逻辑高度抽象成了一个控制视图，所以可以逐帧控制硬件参数，进而实现一系列强大的功能，比如可以直接在预览过程中，手动控制曝光、感光度、对焦以及白平衡的参数，动态地输出不同效果的图像，又比如可以利用该接口与HDR算法相配合，实现高动态成像效果。而其中，对于Api v2接口的实现是在Camera Framework中完成的，由上面分析可以看出，其内部并没有采用十分复杂的控制逻辑，整套代码流程清晰明朗，而这样的设计，进一步保证了该层的稳定性以及高效性，为整个相机框架体系的稳定奠定了坚实的基础。</p>
]]></content>
      <categories>
        <category>1. Android Camera</category>
      </categories>
      <tags>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Android相机体系结构之四：相机服务层</title>
    <url>/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-4/</url>
    <content><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Camera Service被设计成一个独立进程，作为一个服务端，处理来自Camera Framework 客户端的跨进程请求，并在内部进行一定的操作，随后作为客户端将请求再一次发送至作为服务端的Camera Provider，整个流程涉及到了两个跨进程操作，前者通过AIDL机制实现，后者通过HIDL机制实现，由于在于Camera Provider通信的过程中，Service是作为客户端存在的，所以此处我们重点关注AIDL以及Camera Service 主程序的实现。</p>
<span id="more"></span>
<p>   <img src="Image.png"></p>
<h2 id="二、Camera-AIDL-接口"><a href="#二、Camera-AIDL-接口" class="headerlink" title="二、Camera AIDL 接口"></a>二、Camera AIDL 接口</h2><p>在介绍Camera AIDL之前，不妨来简单了解下何为AIDL，谷歌为什么要实现这么一套机制？</p>
<p>在Android系统中，两个进程通常无法相互访问对方的内存，为了解决该问题，谷歌提出了Messager/广播以及后来的Binder，来解决这个问题，但是如果某个进程需要对另一个进程中进行多线程的并发访问，Messager和广播效果往往不是很好，所以Binder会作为主要实现方式，但是Binder的接口使用起来比较复杂，对开发者特别是初学者并不是很友好，所以为了降低跨进程开发门槛，谷歌开创性地提出了AIDL(自定义语言)机制，主动封装了Binder的实现细节，提供给开发者较为简单的使用接口，极大地提升了广大开发者的开发效率。</p>
<p>按照谷歌的针对AIDL机制的要求，需要服务端创建一系列*.aidl文件，并在其中定义需要提供给客户端的公共接口，并且予以实现，接下来我们来看下几个主要的aidl文件。<br>   <img src="Image1.png"><br>ICameraService.aidl定义了ICameraService 接口，实现主要通过CameraService类来实现，主要接口如下：</p>
<ul>
<li>getNumberOfCameras： 获取系统中支持的Camera 个数</li>
<li>connectDevice()：打开一个Camera 设备</li>
<li>addListener(): 添加针对Camera 设备以及闪光灯的监听对象</li>
</ul>
<p>ICameraDeviceCallbacks.aidl文件中定义了ICameraDeviceCallbacks接口，其实现主要由Framework中的CameraDeviceCallbacks类进行实现，主要接口如下：</p>
<ul>
<li>onResultReceived： 一旦Service收到结果数据，便会调用该接口发送至Framework</li>
<li>onCaptureStarted()： 一旦开始进行图像的采集，便调用该接口将部分信息以及时间戳上传至Framework</li>
<li>onDeviceError(): 一旦发生了错误，通过调用该接口通知Framework</li>
</ul>
<p>ICameraDeviceUser.aidl定义了ICameraDeviceUser接口，由CamerawDeviceClient最终实现，主要接口如下：</p>
<ul>
<li>disconnect： 关闭Camera 设备</li>
<li>submitRequestList：发送request</li>
<li>beginConfigure： 开始配置Camera 设备，需要在所有关于数据流的操作之前</li>
<li>endConfigure： 结束关于Camera 设备的配置，该接口需要在所有request下发之前被调用</li>
<li>createDefaultRequest： 创建一个具有默认配置的request</li>
</ul>
<p>ICameraServiceListener.aidl定义了ICameraServiceListener接口，由Framework中的CameraManagerGlobal类实现，主要接口如下：</p>
<ul>
<li>onStatusChanged： 用于告知当前Camera 设备的状态的变更</li>
</ul>
<h2 id="三、Camera-Service-主程序"><a href="#三、Camera-Service-主程序" class="headerlink" title="三、Camera Service 主程序"></a>三、Camera Service 主程序</h2><p>Camera Service 主程序，是随着系统启动而运行，主要目的是向外暴露AIDL接口给Framework进行调用，同时通过调用Camera Provider的HIDL接口，建立与Provider的通信，并且在内部维护从Framework以及Provider获取到的资源，并且按照一定的框架结构保持整个Service在稳定高效的状态下运行，所以接下来我们主要通过几个关键类、初始化过程以及处理来自App的请求三个部分来详细介绍下。</p>
<h3 id="1-关键类解析"><a href="#1-关键类解析" class="headerlink" title="1. 关键类解析"></a>1. 关键类解析</h3><p>首先我们来看下几个关键类，Camera Service中主要包含了以下几个类，用于提供AIDL接口，并负责内部一系列逻辑的控制，并且通过HIDL接口保持与Provider的通信。<br>   <img src="Image2.png"><br>首先我们看下<strong>CameraService</strong>的这个类，它主要实现了AIDL中ICameraService 接口，并且暴露给Camera Framework进行调用，这个类在初始化的时候会去实例化一个<strong>CameraProviderManager</strong>对象，而在实例化的过程中，该对象会去获取系统中所有的Camera Provider，并且在其内部实例化了对应Provider个数的ProviderInfo对象，并且随着每一个ProviderInfo的实例化，将一个Camera Provider作为参数存入ProviderInfo中，并且最终将所有的ProviderInfo存入一个vec容器中进行统一管理，就这样，CameraProviderManager便达到了管理所有的Camera Provider的目的。</p>
<p>而对于单个<strong>ProviderInfo</strong>而言，内部会维护一个Camera Provider代理，而在系统运行初期，ProviderInfo会去向Camera Provider获取当前这设备所支持的Camera 设备，拿到Camera Provider中的ICameraDevice代理，并且依次存入提前实例化好的<strong>DeviceInfo3</strong>对象中，最后会将所有的DeviceInfo3存入一个内部容器，进行统一管理，而DeviceInfo3维护着Camera Provider中的ICameraDevice代理，保持了对Camera Provider的控制。</p>
<p>另外，Camera Service 中还包含了<strong>CameraDeviceClient</strong>类，该类在打开设备的时候被实例化，一次打开设备的操作对应一个该类对象，它实现了ICameraDeviceUser接口，以AIDL方式暴露接口给Camera Framework进行调用，于此同时，该类在打开设备的过程中，获取了来自Camera Framework对于ICameraDeviceCallback接口的实现代理，通过该代理可以将结果上传至Camera Framewor中，其中还包含了一个Camera3Device以及FrameProcessorBase，<strong>Camera3Device</strong>主要实现了对Camera Provider 的ICameraDeviceCallbacks会调接口的实现，通过该接口接收来自Provider的结果上传，进而传给CameraDeviceClient以及FrameProcessBase，其中，Camera3Device会将事件通过notify方法给到CameraDeviceClient，而meta data以及image data 会给到FrameProcessBase，进而给到CameraDeviceClient，所以<strong>FrameProcessBase</strong>主要用于metadata以及image data的中转处理。而Camera3Device中RequestThread主要用于处理Request的接收与下发工作。</p>
<p>对于Camera Service而言，主要包括了两个阶段，一个是系统刚启动的时候，会通过运行其主程序将其Camera Service 服务运行起来，等待Camera Framework的下发图像需求，另一个阶段就是当用户打开相机应用的时候，会去获取相机设备，进而开始图像采集过程，接下来我们就主要以这两个阶段分别来详细介绍下内部运行逻辑。</p>
<h3 id="2-启动初始化"><a href="#2-启动初始化" class="headerlink" title="2. 启动初始化"></a>2. 启动初始化</h3><p>当系统启动的时候，会首先运行Camera Service的主程序，将整个进程运行起来，这里我们首先来看下Camera Service 是怎样运行起来的。<br>   <img src="Image3.png"><br>当系统启动的时候会首先运行main_cameraserver程序，紧接着调用了CameraService的instantiate方法，该方法最终会调用到CameraService的onFirstRef方法，在这个方法里面便开始了整个CameraService的初始化工作。<br>而在onFirstRef方法内又调用了enumerateProviders方法，该方法中主要做了两个工作：</p>
<ul>
<li>一个是实例化一个CameraProviderManager对象，该对象管理着有关Camera Provider的一些资源。</li>
<li>一个是调用CameraProviderManager的initialize方法对其进行初始化工作。</li>
</ul>
<p>而在CameraProviderManager初始化的过程中，主要做了三件事：</p>
<ul>
<li>首先通过getService方法获取ICameraProvider代理。</li>
<li>随后实例化了一个ProviderInfo对象，之后调用其initialize方法进行初始化。</li>
<li>最后将ProviderInfo加入到一个内部容器中进行管理。</li>
</ul>
<p>而在调用ProviderInfo的initialize方法进行初始化过程中存在如下几个动作：</p>
<ul>
<li>首先接收了来自CameraProviderManager获取的ICameraProvider代理并将其存入内部成员变量中。</li>
<li>其次由于ProviderInfo实现了ICameraProviderCallback接口，所以紧接着调用了ICameraProvider的setCallback将自身注册到Camera Provider中，接收来自Provider的事件回调。</li>
<li>再然后，通过调用ICameraProvider代理的getCameraDeviceInterface_V3_X接口，获取Provider端的ICameraDevice代理，并且将这个代理作为参数加入到DeviceInfo3对象实例化方法中，而在实例化DeviceInfo3对象的过程中会通过ICameraDevice代理的getCameraCharacteristics方法获取该设备对应的属性配置，并且保存在内部成员变量中。</li>
<li>最后ProviderInfo会将每一个DeviceInfo3存入内部的一个容器中进行统一管理，至此整个初始化的工作已经完成。</li>
</ul>
<p>通过以上的系列动作，Camera Service进程便运行起来了，获取了Camera Provider的代理，同时也将自身关于Camera Provider的回调注册到了Provider中，这就建立了与Provider的通讯，另一边，通过服务的形式将AIDL接口也暴露给了Framework，静静等待来自Framework的请求。</p>
<h3 id="3-处理App请求"><a href="#3-处理App请求" class="headerlink" title="3. 处理App请求"></a>3. 处理App请求</h3><p>一旦用户打开了相机应用，便会去调用CameraManager的openCamera方法进而走到Framework层处理，Framework通过内部处理，最终将请求下发到Camera Service中，而在Camera Service主要做了获取相机设备属性、打开相机设备，然后App通过返回的相机设备，再次下发创建Session以及下发Request的操作，接下来我们来简单梳理下这一系列请求在Camera Service中是怎么进行处理的。</p>
<h4 id="a-获取属性"><a href="#a-获取属性" class="headerlink" title="a) 获取属性"></a>a) 获取属性</h4><p>对于获取相机设备属性动作，逻辑比较简单，由于在Camera Service启动初始化的时候已经获取了相应相机设备的属性配置，存在DeviceInfo3中，所以该方法就是从相应的DeviceInfo3中取出属相返回即可。</p>
<h4 id="b-打开相机设备"><a href="#b-打开相机设备" class="headerlink" title="b) 打开相机设备"></a>b) 打开相机设备</h4><p>对于打开相机设备动作，主要由connectDevice来实现，内部实现比较复杂，接下来我们详细梳理下。<br>当CameraFramework通过调用ICameraService的connectDevice接口的时候，主要做了两件事情：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 一个是创建CameraDeviceClient。</span><br><span class="line"><span class="number">2.</span> 一个是对CameraDeviceClient进行初始化，并将其给Framework。</span><br></pre></td></tr></table></figure>

<p>而其中创建CameraDevcieClient的工作是通过makeClient方法来实现的，在该方法中首先实例化一个CameraDeviceClient，并且将来自Framework针对ICameraDeviceCallback的实现存入CameraDeviceClient中，这样一旦有结果产生便可以将结果通过这个回调回传给Framework，其次还实例化了一个Camera3Device对象。</p>
<p>其中的CameraDeviceClient的初始化工作是通过调用其initialize方法来完成的，在该方法中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 首先调用父类Camera2ClientBase的initialize方法进行初始化。</span><br><span class="line"><span class="number">2.</span> 其次实例化FrameProcessorBase对象并且将内部的Camera3Device对象传入其中，这样就建立了和Camera3Device的联系，之后将内部线程运行起来，等待来自Camera3Device的结果。</span><br><span class="line"><span class="number">3.</span> 最后将CameraDeviceClient注册到内部，这样就建立了与CameraDeviceClient的联系。</span><br></pre></td></tr></table></figure>

<p>而在Camera2ClientBase的intialize方法中会调用Camera3Device的intialize方法对其进行初始化工作，并且通过调用Camera3Device的setNotifyCallback方法将自身注册到Camera3Device内部，这样一旦Camera3Device有结果产生就可以发送到CameraDeviceClient中。</p>
<p>而在Camera3Device的初始化过程中，首先通过调用CameraProviderManager的openSession方法打开并获取一个Provider中的ICameraDeviceSession代理，其次实例化一个HalInterface对象，将之前获取的ICameraDeviceSession代理存入其中，最后将RequestThread线程运行起来，等待request的下发。</p>
<p>而对于CameraProviderManager的openSession方法，它会通过内部的DeviceInfo保存的ICameraDevice代理，调用其open方法从Camera Provider中打开并获取一个ICameraDeviceSession远程代理，并且由于Camera3Device实现了Provider中ICameraDeviceCallback方法，会通过该open方法传入到Provider中，接收来自Provider的结果回传。</p>
<p>至此，整个connectDevice方法已经运行完毕，此时App已经获取了一个Camera设备，紧接着，由于需要采集图像，所以需要再次调用CameraDevice的createCaptureSession操作，到达framework，再通过ICameraDeviceUser代理进行了一系列操作，分别包含了cancelRequest/beginConfigure/deleteStream/createStream以及endConfigure方法来进行数据流的配置。</p>
<h4 id="c-配置数据流"><a href="#c-配置数据流" class="headerlink" title="c) 配置数据流"></a>c) 配置数据流</h4><p>其中cancelRequest逻辑比较简单，对应的方法是CameraDeviceClient的cancelRequest方法，在该方法中会去通知Camera3Device将RequestThread中的request队列清空，停止request的继续下发。</p>
<p>beginConfigure方法是空实现，这里不进行阐述。</p>
<p>deleteStream/createStream 分别是用于删除之前的数据流以及为新的操作创建数据流。</p>
<p>紧接着调用位于整个调用流程的末尾–endConfigure方法，该方法对应着CameraDeviceClient的endConfigure方法，其逻辑比较简单，在该方法中会调用Camera3Device的configureStreams的方法，而该方法又会去通过ICameraDeviceSession的configureStreams_3_4的方法最终将需求传递给Provider。</p>
<p>到这里整个数据流已经配置完成，并且App也获取了Framework中的CameraCaptureSession对象，之后便可进行图像需求的下发了，在下发之前需要先创建一个Request，而App通过调用CameraDeviceImpl中的createCaptureRequest来实现，该方法在Framework中实现，内部会再去调用Camera Service中的AIDL接口createDefaultRequest，该接口的实现是CameraDeviceClient，在其内部又会去调用Camera3Device的createDefaultRequest方法，最后通过ICameraDeviceSession代理的constructDefaultRequestSettings方法将需求下发到Provider端去创建一个默认的request配置，一旦操作完成，Provider会将配置上传至Service，进而给到App中。</p>
<h4 id="d-处理图像需求"><a href="#d-处理图像需求" class="headerlink" title="d) 处理图像需求"></a>d) 处理图像需求</h4><p>在创建Request成功之后，便可下发图像采集需求了，这里大致分为两个流程，一个是预览，一个拍照，两者差异主要体现在Camera Service中针对request获取优先级上，一般拍照的Request优先级高于预览，具体表现是当预览Request在不断下发的时候，来了一次拍照需求，在Camera3Device 的RequestThread线程中，会优先下发此次拍照的request。这里我们主要梳理下下发拍照request的大体流程：</p>
<p>下发拍照request到Camera Service，其操作主要是由CameraDevcieClient的submitRequestList方法来实现，在该方法中，会调用Camera3Device的setStreamingRequestList方法，将需求发送到Camera3Device中，而Camera3Device将需求又加入到RequestThread中的RequestQueue中，并唤醒RequestThread线程，在该线程被唤醒后，会从RequestQueue中取出request，通过之前获取的ICameraDeviceSession代理的processCaptureRequest_3_4方法将需求发送至Provider中，由于谷歌对于processCaptureRequest_3_4的限制，使其必须是非阻塞实现，所以一旦发送成功，便立即返回，在App端便等待这结果的回传。</p>
<h4 id="e-接收图像结果"><a href="#e-接收图像结果" class="headerlink" title="e) 接收图像结果"></a>e) 接收图像结果</h4><p>针对结果的获取是通过异步实现，主要分别两个部分，一个是事件的回传，一个是数据的回传，而数据中又根据流程的差异主要分为Meta Data和Image Data两个部分，接下来我们详细介绍下：</p>
<p>在下发Request之后，首先从Provider端传来的是Shutter Notify，因为之前已经将Camera3Device作为ICameraDeviceCallback的实现传入Provider中，所以此时会调用Camera3Device的notify方法将事件传入Camera Service中，紧接着通过层层调用，将事件通过CameraDeviceClient的notifyShutter方法发送到CameraDeviceClient中，之后又通过打开相机设备时传入的Framework的CameraDeviceCallbacks接口的onCaptureStarted方法将事件最终传入Framework，进而给到App端。</p>
<p>在Shutter事件上报完成之后，当一旦有Meta Data生成，Camera Provider便会通过ICameraDeviceCallback的processCaptureResult_3_4方法将数据给到Camera Service，而该接口的实现对应的是Camera3Device的processCaptureResult_3_4方法，在该方法会通过层层调用，调用sendCaptureResult方法将Result放入一个mResultQueue中，并且通知FrameProcessorBase的线程去取出Result，并且将其发送至CameraDeviceClient中，之后通过内部的CameraDeviceCallbacks远程代理的onResultReceived方法将结果上传至Framework层，进而给到App中进行处理。</p>
<p>随后Image Data前期也会按照类似的流程走到Camera3Device中，但是会通过调用returnOutputBuffers方法将数据给到Camera3OutputStream中，而该Stream中会通过BufferQueue这一生产者消费者模式中的生产者的queue方法通知消费者对该buffer进行消费，而消费者正是App端的诸如ImageReader等拥有Surface的类，最后App便可以将图像数据取出进行后期处理了。</p>
<p>初代Android相机框架中，Camera Service层就已经存在了，主要用于向上与Camera Framework保持低耦合关联，承接其图像请求，内部封装了Camera Hal Module模块，通过HAL接口对其进行控制，所以该层从一开始就是谷歌按照分层思想，将硬件抽象层抽离出来放入Service中进行管理，这样的好处显而易见，将平台厂商实现的硬件抽象层与系统层解耦，独立进行控制。之后随着谷歌将平台厂商的实现放入vendor分区中，彻底将系统与平台厂商在系统分区上保持了隔离，此时，谷歌便顺势将Camera HAL Moudle从Camera Service中解耦出来放到了vendor分区下的独立进程Camera Provider中，所以之后，Camera Service 的职责便是承接来自Camera Framework的请求，之后将请求转发至Camera Provider中，作为一个中转站的角色存在在系统中。</p>
]]></content>
      <categories>
        <category>1. Android Camera</category>
      </categories>
      <tags>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Android相机体系结构之五：相机硬件抽象层</title>
    <url>/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-5/</url>
    <content><![CDATA[<h2 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h2><p>始于谷歌的Treble开源项目，基于接口与实现的分离的设计原则，谷歌加入了Camera Provider这一抽象层，该层作为一个独立进程存在于整个系统中，并且通过HIDL这一自定义语言成功地将Camera Hal Module从Camera Service中解耦出来，承担起了对Camera HAL的封装工作，纵观整个Android系统，对于Camera Provider而言，对上是通过HIDL接口负责与Camera Service的跨进程通信，对下通过标准的HAL3接口下发针对Camera的实际操作，这俨然是一个中央枢纽般的调配中心的角色，而事实上正是如此，由此看来，对Camera Provider的梳理变得尤为重要，接下来就以我个人理解出发来简单介绍下Camera Provider。</p>
<span id="more"></span>
<p>Camera Provider通过提供标准的HIDL接口给Camera Service进行调用，保持与Service的正常通信，其中谷歌将HIDL接口的定义直接暴露给平台厂商进行自定义实现，其中为了极大地减轻并降低开发者的工作量和开发难度，谷歌很好地封装了其跨进程实现细节，同样地，Camera Provider通过标准的HAL3接口，向下控制着具体的Camera HAL Module，而这个接口依然交由平台厂商负责去实现，而进程内部则通过简单的函数调用，将HIDL接口与HAL3接口完美的衔接起来，由此构成了Provider整体架构。<br><img src="Image.png" alt="alt text"></p>
<p>由图中可以看出Camera Provider进程由两部分组成，一是运行在系统中的主程序通过提供了标准的HIDL接口保持了与Camera Service的跨进程通讯，二是为了进一步扩展其功能，通过dlopen方式加载了一系列So库，而其中就包括了实现了Camera HAL3接口的So库，而HAL3接口主要定义了主要用于实现图像控制的功能，其实现主要交由平台厂商或者开发者来完成，所以Camera HAL3 So库的实现各式各样，在高通平台上，这里的实现就是我们本文重点需要分析的CamX-CHI框架。<br>在开始梳理CamX-CHI之前，不防先从上到下，以接口为主线简单梳理下Camera Provider的各个部分:</p>
<h2 id="二、Camera-HIDL-接口"><a href="#二、Camera-HIDL-接口" class="headerlink" title="二、Camera HIDL 接口"></a>二、Camera HIDL 接口</h2><p>首先需要明确一个概念，就是HIDL是一种自定义语言，其核心是接口的定义，而谷歌为了使开发者将注意力落在接口的定义上而不是机制的实现上，主动封装了HIDL机制的实现细节，开发者只需要通过*.hal文件定义接口，填充接口内部实际的实现即可，接下来来看下具体定义的几个主要接口：<br><img src="Image-1.png" alt="alt text"></p>
<p>因为HIDL机制本身是跨进程通讯的，所以Camera Service本身通过HIDL接口获取的对象都会有Bn端和Bp端，分别代表了Binder两端，接下来为了方便理解，我们都省略掉Bn/Bp说法,直接用具体接口类代表，忽略跨进程两端的区别。<br>ICameraProvider.hal源码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2016 The Android Open Source Project</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">package android.hardware.camera.provider@<span class="number">2.4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ICameraProviderCallback;</span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.common@<span class="number">1.0</span>::types;</span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.device@<span class="number">1.0</span>::ICameraDevice;</span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.device@<span class="number">3.2</span>::ICameraDevice;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Camera provider HAL, which enumerates the available individual camera devices</span></span><br><span class="line"><span class="comment"> * known to the provider, and provides updates about changes to device status,</span></span><br><span class="line"><span class="comment"> * such as connection, disconnection, or torch mode enable/disable.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The provider is responsible for generating a list of camera device service</span></span><br><span class="line"><span class="comment"> * names that can then be opened via the hardware service manager.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Multiple camera provider HALs may be present in a single system.</span></span><br><span class="line"><span class="comment"> * For discovery, the service names, and process names, must be of the form</span></span><br><span class="line"><span class="comment"> * &quot;android.hardware.camera.provider@&lt;major&gt;.&lt;minor&gt;/&lt;type&gt;/&lt;instance&gt;&quot;</span></span><br><span class="line"><span class="comment"> * where</span></span><br><span class="line"><span class="comment"> *   - &lt;major&gt;/&lt;minor&gt; is the provider HAL HIDL version,</span></span><br><span class="line"><span class="comment"> *   - &lt;type&gt; is the type of devices this provider knows about, such as</span></span><br><span class="line"><span class="comment"> *     &quot;internal&quot;, &quot;legacy&quot;, &quot;external&quot;, &quot;remote&quot; etc. The camera framework</span></span><br><span class="line"><span class="comment"> *     must not differentiate or chage its behavior based on the specific type.</span></span><br><span class="line"><span class="comment"> *   - &lt;instance&gt; is a non-negative integer starting from 0 to disambiguate</span></span><br><span class="line"><span class="comment"> *     between multiple HALs of the same type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The &quot;legacy&quot; type is only used for passthrough legacy HAL mode, and must</span></span><br><span class="line"><span class="comment"> * not be used by a standalone binderized HAL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The device instance names enumerated by the provider in getCameraIdList() or</span></span><br><span class="line"><span class="comment"> * ICameraProviderCallback::cameraDeviceStatusChange() must be of the form</span></span><br><span class="line"><span class="comment"> * &quot;device@&lt;major&gt;.&lt;minor&gt;/&lt;type&gt;/&lt;id&gt;&quot; where</span></span><br><span class="line"><span class="comment"> * &lt;major&gt;/&lt;minor&gt; is the HIDL version of the interface. &lt;id&gt; is either a small</span></span><br><span class="line"><span class="comment"> * incrementing integer for &quot;internal&quot; device types, with 0 being the main</span></span><br><span class="line"><span class="comment"> * back-facing camera and 1 being the main front-facing camera, if they exist.</span></span><br><span class="line"><span class="comment"> * Or, for external devices, a unique serial number (if possible) that can be</span></span><br><span class="line"><span class="comment"> * used to identify the device reliably when it is disconnected and reconnected.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Multiple providers must not enumerate the same device ID.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">interface ICameraProvider &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * setCallback:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Provide a callback interface to the HAL provider to inform framework of</span></span><br><span class="line"><span class="comment">     * asynchronous camera events. The framework must call this function once</span></span><br><span class="line"><span class="comment">     * during camera service startup, before any other calls to the provider</span></span><br><span class="line"><span class="comment">     * (note that in case the camera service restarts, this method must be</span></span><br><span class="line"><span class="comment">     * invoked again during its startup).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param callback</span></span><br><span class="line"><span class="comment">     *     A non-null callback interface to invoke when camera events occur.</span></span><br><span class="line"><span class="comment">     * @return status</span></span><br><span class="line"><span class="comment">     *     Status code for the operation, one of:</span></span><br><span class="line"><span class="comment">     *     OK:</span></span><br><span class="line"><span class="comment">     *         On success</span></span><br><span class="line"><span class="comment">     *     INTERNAL_ERROR:</span></span><br><span class="line"><span class="comment">     *         An unexpected internal error occurred while setting the callbacks</span></span><br><span class="line"><span class="comment">     *     ILLEGAL_ARGUMENT:</span></span><br><span class="line"><span class="comment">     *         The callback argument is invalid (for example, null).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">setCallback</span>(ICameraProviderCallback callback) <span class="built_in">generates</span> (Status status);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getVendorTags:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Retrieve all vendor tags supported by devices discoverable through this</span></span><br><span class="line"><span class="comment">     * provider. The tags are grouped into sections.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return status</span></span><br><span class="line"><span class="comment">     *     Status code for the operation, one of:</span></span><br><span class="line"><span class="comment">     *     OK:</span></span><br><span class="line"><span class="comment">     *         On success</span></span><br><span class="line"><span class="comment">     *     INTERNAL_ERROR:</span></span><br><span class="line"><span class="comment">     *         An unexpected internal error occurred while setting the callbacks</span></span><br><span class="line"><span class="comment">     * @return sections</span></span><br><span class="line"><span class="comment">     *     The supported vendor tag sections; empty if there are no supported</span></span><br><span class="line"><span class="comment">     *     vendor tags, or status is not OK.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">getVendorTags</span>() <span class="built_in">generates</span> (Status status, vec&lt;VendorTagSection&gt; sections);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getCameraIdList:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Returns the list of internal camera device interfaces known to this</span></span><br><span class="line"><span class="comment">     * camera provider. These devices can then be accessed via the hardware</span></span><br><span class="line"><span class="comment">     * service manager.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * External camera devices (camera facing EXTERNAL) must be reported through</span></span><br><span class="line"><span class="comment">     * the device status change callback, not in this list. Only devices with</span></span><br><span class="line"><span class="comment">     * facing BACK or FRONT must be listed here.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return status Status code for the operation, one of:</span></span><br><span class="line"><span class="comment">     *     OK:</span></span><br><span class="line"><span class="comment">     *         On a succesful generation of camera ID list</span></span><br><span class="line"><span class="comment">     *     INTERNAL_ERROR:</span></span><br><span class="line"><span class="comment">     *         A camera ID list cannot be created. This may be due to</span></span><br><span class="line"><span class="comment">     *         a failure to initialize the camera subsystem, for example.</span></span><br><span class="line"><span class="comment">     * @return cameraDeviceNames The vector of internal camera device</span></span><br><span class="line"><span class="comment">     *     names known to this provider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">getCameraIdList</span>()</span><br><span class="line">            <span class="built_in">generates</span> (Status status, vec&lt;string&gt; cameraDeviceNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * isSetTorchModeSupported:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Returns if the camera devices known to this camera provider support</span></span><br><span class="line"><span class="comment">     * setTorchMode API or not. If the provider does not support setTorchMode</span></span><br><span class="line"><span class="comment">     * API, calling to setTorchMode will return METHOD_NOT_SUPPORTED.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that not every camera device has a flash unit, so even this API</span></span><br><span class="line"><span class="comment">     * returns true, setTorchMode call might still fail due to the camera device</span></span><br><span class="line"><span class="comment">     * does not have a flash unit. In such case, the returned status will be</span></span><br><span class="line"><span class="comment">     * OPERATION_NOT_SUPPORTED.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return status Status code for the operation, one of:</span></span><br><span class="line"><span class="comment">     *     OK:</span></span><br><span class="line"><span class="comment">     *         On a succesful call</span></span><br><span class="line"><span class="comment">     *     INTERNAL_ERROR:</span></span><br><span class="line"><span class="comment">     *         Torch API support cannot be queried. This may be due to</span></span><br><span class="line"><span class="comment">     *         a failure to initialize the camera subsystem, for example.</span></span><br><span class="line"><span class="comment">     * @return support Whether the camera devices known to this provider</span></span><br><span class="line"><span class="comment">     *     supports setTorchMode API or not. Devices launched with SDK</span></span><br><span class="line"><span class="comment">     *     level 29 or higher must return true.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">isSetTorchModeSupported</span>() <span class="built_in">generates</span> (Status status, <span class="keyword">bool</span> support);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getCameraDeviceInterface_VN_x:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return a android.hardware.camera.device@N.x/ICameraDevice interface for</span></span><br><span class="line"><span class="comment">     * the requested device name. This does not power on the camera device, but</span></span><br><span class="line"><span class="comment">     * simply acquires the interface for querying the device static information,</span></span><br><span class="line"><span class="comment">     * or to additionally open the device for active use.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A separate method is required for each major revision of the camera device</span></span><br><span class="line"><span class="comment">     * HAL interface, since they are not compatible with each other.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Valid device names for this provider can be obtained via either</span></span><br><span class="line"><span class="comment">     * getCameraIdList(), or via availability callbacks from</span></span><br><span class="line"><span class="comment">     * ICameraProviderCallback::cameraDeviceStatusChange().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The returned interface must be of the highest defined minor version for</span></span><br><span class="line"><span class="comment">     * the major version; it&#x27;s the responsibility of the HAL client to ensure</span></span><br><span class="line"><span class="comment">     * they do not use methods/etc that are not valid for the actual minor</span></span><br><span class="line"><span class="comment">     * version of the device.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param cameraDeviceName the name of the device to get an interface to.</span></span><br><span class="line"><span class="comment">     * @return status Status code for the operation, one of:</span></span><br><span class="line"><span class="comment">     *     OK:</span></span><br><span class="line"><span class="comment">     *         On a succesful generation of camera ID list</span></span><br><span class="line"><span class="comment">     *     ILLEGAL_ARGUMENT:</span></span><br><span class="line"><span class="comment">     *         This device name is unknown, or has been disconnected</span></span><br><span class="line"><span class="comment">     *     OPERATION_NOT_SUPPORTED:</span></span><br><span class="line"><span class="comment">     *         The specified device does not support this major version of the</span></span><br><span class="line"><span class="comment">     *         HAL interface.</span></span><br><span class="line"><span class="comment">     *     INTERNAL_ERROR:</span></span><br><span class="line"><span class="comment">     *         A camera interface cannot be returned due to an unexpected</span></span><br><span class="line"><span class="comment">     *         internal error.</span></span><br><span class="line"><span class="comment">     * @return device The inteface to this camera device, or null in case of</span></span><br><span class="line"><span class="comment">     *     error.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">getCameraDeviceInterface_V1_x</span>(string cameraDeviceName) <span class="built_in">generates</span></span><br><span class="line">            (Status status,</span><br><span class="line">             android.hardware.camera.device@<span class="number">1.0</span>::ICameraDevice device);</span><br><span class="line">    <span class="built_in">getCameraDeviceInterface_V3_x</span>(string cameraDeviceName) <span class="built_in">generates</span></span><br><span class="line">            (Status status,</span><br><span class="line">             android.hardware.camera.device@<span class="number">3.2</span>::ICameraDevice device);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该文件中定义了ICameraProvider接口类，由CameraProvider继承并实现，在Camera Provider启动的时候被实例化，主要接口如下：</p>
<ul>
<li>getCameraDeviceInterface_V3_x: 该方法主要用于Camera Service获取ICameraDevice，通过该对象可以控制Camera 设备的诸如配置数据流、下发request等具体行为。</li>
<li>setCallback： 将Camera Service 实现的ICameraProviderCallback传入Camera Provider，一旦Provider有事件产生时便可以通过该对象通知Camera Service。</li>
</ul>
<p>ICameraProviderCallback.hal源码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2016 The Android Open Source Project</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">package android.hardware.camera.provider@<span class="number">2.4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.common@<span class="number">1.0</span>::types;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callback functions for a camera provider HAL to use to inform the camera</span></span><br><span class="line"><span class="comment"> * service of changes to the camera subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">interface ICameraProviderCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cameraDeviceStatusChange:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Callback to the camera service to indicate that the state of a specific</span></span><br><span class="line"><span class="comment">     * camera device has changed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * On camera service startup, when ICameraProvider::setCallback is invoked,</span></span><br><span class="line"><span class="comment">     * the camera service must assume that all internal camera devices are in</span></span><br><span class="line"><span class="comment">     * the CAMERA_DEVICE_STATUS_PRESENT state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The provider must call this method to inform the camera service of any</span></span><br><span class="line"><span class="comment">     * initially NOT_PRESENT devices, and of any external camera devices that</span></span><br><span class="line"><span class="comment">     * are already present, as soon as the callbacks are available through</span></span><br><span class="line"><span class="comment">     * setCallback.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param cameraDeviceName The name of the camera device that has a</span></span><br><span class="line"><span class="comment">     *     new status.</span></span><br><span class="line"><span class="comment">     * @param newStatus The new status that device is in.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">cameraDeviceStatusChange</span>(string cameraDeviceName,</span><br><span class="line">            CameraDeviceStatus newStatus);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * torchModeStatusChange:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Callback to the camera service to indicate that the state of the torch</span></span><br><span class="line"><span class="comment">     * mode of the flash unit associated with a specific camera device has</span></span><br><span class="line"><span class="comment">     * changed. At provider registration time, the camera service must assume</span></span><br><span class="line"><span class="comment">     * the torch modes are in the TORCH_MODE_STATUS_AVAILABLE_OFF state if</span></span><br><span class="line"><span class="comment">     * android.flash.info.available is reported as true via the</span></span><br><span class="line"><span class="comment">     * ICameraDevice::getCameraCharacteristics call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param cameraDeviceName The name of the camera device that has a</span></span><br><span class="line"><span class="comment">     *     new status.</span></span><br><span class="line"><span class="comment">     * @param newStatus The new status that device is in.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">torchModeStatusChange</span>(string cameraDeviceName,</span><br><span class="line">            TorchModeStatus newStatus);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该文件中定义了ICameraDeviceCallback接口类，由Camera Service中的Camera3Device继承并实现，通过调用ICameraDevice::open方法注册到Provider中，其主要接口如下：</p>
<ul>
<li>processCaptureResult_3_4: 一旦有图像数据产生会通过调用该方法将数据以及meta data上传至Camera Service。</li>
<li>notify: 通过该方法上传事件至Camera Service中，比如shutter事件等。</li>
</ul>
<p>ICameraDeviceSession.hal源码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2016 The Android Open Source Project</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">package android.hardware.camera.device@<span class="number">3.2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.common@<span class="number">1.0</span>::types;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Camera device active session interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Obtained via ICameraDevice::open(), this interface contains the methods to</span></span><br><span class="line"><span class="comment"> * configure and request captures from an active camera device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">interface ICameraDeviceSession &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * constructDefaultRequestSettings:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Create capture settings for standard camera use cases.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The device must return a settings buffer that is configured to meet the</span></span><br><span class="line"><span class="comment">     * requested use case, which must be one of the CAMERA3_TEMPLATE_*</span></span><br><span class="line"><span class="comment">     * enums. All request control fields must be included.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This must be a non-blocking call. The HAL should return from this call</span></span><br><span class="line"><span class="comment">     * in 1ms, and must return from this call in 5ms.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     * @return status Status code for the operation, one of:</span></span><br><span class="line"><span class="comment">     *     OK:</span></span><br><span class="line"><span class="comment">     *         On a successful construction of default settings.</span></span><br><span class="line"><span class="comment">     *     INTERNAL_ERROR:</span></span><br><span class="line"><span class="comment">     *         An unexpected internal error occurred, and the default settings</span></span><br><span class="line"><span class="comment">     *         are not available.</span></span><br><span class="line"><span class="comment">     *     ILLEGAL_ARGUMENT:</span></span><br><span class="line"><span class="comment">     *         The camera HAL does not support the input template type</span></span><br><span class="line"><span class="comment">     *     CAMERA_DISCONNECTED:</span></span><br><span class="line"><span class="comment">     *         An external camera device has been disconnected, and is no longer</span></span><br><span class="line"><span class="comment">     *         available. This camera device interface is now stale, and a new</span></span><br><span class="line"><span class="comment">     *         instance must be acquired if the device is reconnected. All</span></span><br><span class="line"><span class="comment">     *         subsequent calls on this interface must return</span></span><br><span class="line"><span class="comment">     *         CAMERA_DISCONNECTED.</span></span><br><span class="line"><span class="comment">     * @return template The default capture request settings for the requested</span></span><br><span class="line"><span class="comment">     *     use case, or an empty metadata structure if status is not OK.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">constructDefaultRequestSettings</span>(RequestTemplate type) <span class="built_in">generates</span></span><br><span class="line">            (Status status, CameraMetadata requestTemplate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * configureStreams:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Reset the HAL camera device processing pipeline and set up new input and</span></span><br><span class="line"><span class="comment">     * output streams. This call replaces any existing stream configuration with</span></span><br><span class="line"><span class="comment">     * the streams defined in the streamList. This method must be called at</span></span><br><span class="line"><span class="comment">     * least once before a request is submitted with processCaptureRequest().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The streamList must contain at least one output-capable stream, and may</span></span><br><span class="line"><span class="comment">     * not contain more than one input-capable stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The streamList may contain streams that are also in the currently-active</span></span><br><span class="line"><span class="comment">     * set of streams (from the previous call to configureStreams()). These</span></span><br><span class="line"><span class="comment">     * streams must already have valid values for usage, maxBuffers, and the</span></span><br><span class="line"><span class="comment">     * private pointer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the HAL needs to change the stream configuration for an existing</span></span><br><span class="line"><span class="comment">     * stream due to the new configuration, it may rewrite the values of usage</span></span><br><span class="line"><span class="comment">     * and/or maxBuffers during the configure call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework must detect such a change, and may then reallocate the</span></span><br><span class="line"><span class="comment">     * stream buffers before using buffers from that stream in a request.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If a currently-active stream is not included in streamList, the HAL may</span></span><br><span class="line"><span class="comment">     * safely remove any references to that stream. It must not be reused in a</span></span><br><span class="line"><span class="comment">     * later configureStreams() call by the framework, and all the gralloc</span></span><br><span class="line"><span class="comment">     * buffers for it must be freed after the configureStreams() call returns.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the stream is new, the client must set the consumer usage flags in</span></span><br><span class="line"><span class="comment">     * requestedConfiguration. Upon return, the HAL device must set producerUsage,</span></span><br><span class="line"><span class="comment">     * maxBuffers, and other fields in the configureStreams() return values. These</span></span><br><span class="line"><span class="comment">     * fields are then used by the framework and the platform gralloc module to</span></span><br><span class="line"><span class="comment">     * allocate the gralloc buffers for each stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Newly allocated buffers may be included in a capture request at any time</span></span><br><span class="line"><span class="comment">     * by the framework. Once a gralloc buffer is returned to the framework</span></span><br><span class="line"><span class="comment">     * with processCaptureResult (and its respective releaseFence has been</span></span><br><span class="line"><span class="comment">     * signaled) the framework may free or reuse it at any time.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Preconditions:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework must only call this method when no captures are being</span></span><br><span class="line"><span class="comment">     * processed. That is, all results have been returned to the framework, and</span></span><br><span class="line"><span class="comment">     * all in-flight input and output buffers have been returned and their</span></span><br><span class="line"><span class="comment">     * release sync fences have been signaled by the HAL. The framework must not</span></span><br><span class="line"><span class="comment">     * submit new requests for capture while the configureStreams() call is</span></span><br><span class="line"><span class="comment">     * underway.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Postconditions:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL device must configure itself to provide maximum possible output</span></span><br><span class="line"><span class="comment">     * frame rate given the sizes and formats of the output streams, as</span></span><br><span class="line"><span class="comment">     * documented in the camera device&#x27;s static metadata.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This call is expected to be heavyweight and possibly take several hundred</span></span><br><span class="line"><span class="comment">     * milliseconds to complete, since it may require resetting and</span></span><br><span class="line"><span class="comment">     * reconfiguring the image sensor and the camera processing pipeline.</span></span><br><span class="line"><span class="comment">     * Nevertheless, the HAL device should attempt to minimize the</span></span><br><span class="line"><span class="comment">     * reconfiguration delay to minimize the user-visible pauses during</span></span><br><span class="line"><span class="comment">     * application operational mode changes (such as switching from still</span></span><br><span class="line"><span class="comment">     * capture to video recording).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL should return from this call in 500ms, and must return from this</span></span><br><span class="line"><span class="comment">     * call in 1000ms.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return Status Status code for the operation, one of:</span></span><br><span class="line"><span class="comment">     *     OK:</span></span><br><span class="line"><span class="comment">     *          On successful stream configuration.</span></span><br><span class="line"><span class="comment">     *     INTERNAL_ERROR:</span></span><br><span class="line"><span class="comment">     *         If there has been a fatal error and the device is no longer</span></span><br><span class="line"><span class="comment">     *         operational. Only close() can be called successfully by the</span></span><br><span class="line"><span class="comment">     *         framework after this error is returned.</span></span><br><span class="line"><span class="comment">     *     ILLEGAL_ARGUMENT:</span></span><br><span class="line"><span class="comment">     *         If the requested stream configuration is invalid. Some examples</span></span><br><span class="line"><span class="comment">     *         of invalid stream configurations include:</span></span><br><span class="line"><span class="comment">     *           - Including more than 1 INPUT stream</span></span><br><span class="line"><span class="comment">     *           - Not including any OUTPUT streams</span></span><br><span class="line"><span class="comment">     *           - Including streams with unsupported formats, or an unsupported</span></span><br><span class="line"><span class="comment">     *             size for that format.</span></span><br><span class="line"><span class="comment">     *           - Including too many output streams of a certain format.</span></span><br><span class="line"><span class="comment">     *           - Unsupported rotation configuration</span></span><br><span class="line"><span class="comment">     *           - Stream sizes/formats don&#x27;t satisfy the</span></span><br><span class="line"><span class="comment">     *             StreamConfigurationMode requirements for non-NORMAL mode, or</span></span><br><span class="line"><span class="comment">     *             the requested operation_mode is not supported by the HAL.</span></span><br><span class="line"><span class="comment">     *           - Unsupported usage flag</span></span><br><span class="line"><span class="comment">     *         The camera service cannot filter out all possible illegal stream</span></span><br><span class="line"><span class="comment">     *         configurations, since some devices may support more simultaneous</span></span><br><span class="line"><span class="comment">     *         streams or larger stream resolutions than the minimum required</span></span><br><span class="line"><span class="comment">     *         for a given camera device hardware level. The HAL must return an</span></span><br><span class="line"><span class="comment">     *         ILLEGAL_ARGUMENT for any unsupported stream set, and then be</span></span><br><span class="line"><span class="comment">     *         ready to accept a future valid stream configuration in a later</span></span><br><span class="line"><span class="comment">     *         configureStreams call.</span></span><br><span class="line"><span class="comment">     * @return finalConfiguration The stream parameters desired by the HAL for</span></span><br><span class="line"><span class="comment">     *     each stream, including maximum buffers, the usage flags, and the</span></span><br><span class="line"><span class="comment">     *     override format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">configureStreams</span>(StreamConfiguration requestedConfiguration)</span><br><span class="line">            <span class="built_in">generates</span> (Status status,</span><br><span class="line">                    HalStreamConfiguration halConfiguration);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * processCaptureRequest:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Send a list of capture requests to the HAL. The HAL must not return from</span></span><br><span class="line"><span class="comment">     * this call until it is ready to accept the next set of requests to</span></span><br><span class="line"><span class="comment">     * process. Only one call to processCaptureRequest() must be made at a time</span></span><br><span class="line"><span class="comment">     * by the framework, and the calls must all be from the same thread. The</span></span><br><span class="line"><span class="comment">     * next call to processCaptureRequest() must be made as soon as a new</span></span><br><span class="line"><span class="comment">     * request and its associated buffers are available. In a normal preview</span></span><br><span class="line"><span class="comment">     * scenario, this means the function is generally called again by the</span></span><br><span class="line"><span class="comment">     * framework almost instantly. If more than one request is provided by the</span></span><br><span class="line"><span class="comment">     * client, the HAL must process the requests in order of lowest index to</span></span><br><span class="line"><span class="comment">     * highest index.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The cachesToRemove argument contains a list of buffer caches (see</span></span><br><span class="line"><span class="comment">     * StreamBuffer document for more information on buffer cache) to be removed</span></span><br><span class="line"><span class="comment">     * by camera HAL. Camera HAL must remove these cache entries whether or not</span></span><br><span class="line"><span class="comment">     * this method returns OK.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The actual request processing is asynchronous, with the results of</span></span><br><span class="line"><span class="comment">     * capture being returned by the HAL through the processCaptureResult()</span></span><br><span class="line"><span class="comment">     * call. This call requires the result metadata to be available, but output</span></span><br><span class="line"><span class="comment">     * buffers may simply provide sync fences to wait on. Multiple requests are</span></span><br><span class="line"><span class="comment">     * expected to be in flight at once, to maintain full output frame rate.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework retains ownership of the request structure. It is only</span></span><br><span class="line"><span class="comment">     * guaranteed to be valid during this call. The HAL device must make copies</span></span><br><span class="line"><span class="comment">     * of the information it needs to retain for the capture processing. The HAL</span></span><br><span class="line"><span class="comment">     * is responsible for waiting on and closing the buffers&#x27; fences and</span></span><br><span class="line"><span class="comment">     * returning the buffer handles to the framework.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL must write the file descriptor for the input buffer&#x27;s release</span></span><br><span class="line"><span class="comment">     * sync fence into input_buffer-&gt;release_fence, if input_buffer is not</span></span><br><span class="line"><span class="comment">     * valid. If the HAL returns -1 for the input buffer release sync fence, the</span></span><br><span class="line"><span class="comment">     * framework is free to immediately reuse the input buffer. Otherwise, the</span></span><br><span class="line"><span class="comment">     * framework must wait on the sync fence before refilling and reusing the</span></span><br><span class="line"><span class="comment">     * input buffer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The input/output buffers provided by the framework in each request</span></span><br><span class="line"><span class="comment">     * may be brand new (having never before seen by the HAL).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * Performance considerations:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Handling a new buffer should be extremely lightweight and there must be</span></span><br><span class="line"><span class="comment">     * no frame rate degradation or frame jitter introduced.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This call must return fast enough to ensure that the requested frame</span></span><br><span class="line"><span class="comment">     * rate can be sustained, especially for streaming cases (post-processing</span></span><br><span class="line"><span class="comment">     * quality settings set to FAST). The HAL should return this call in 1</span></span><br><span class="line"><span class="comment">     * frame interval, and must return from this call in 4 frame intervals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return status Status code for the operation, one of:</span></span><br><span class="line"><span class="comment">     *     OK:</span></span><br><span class="line"><span class="comment">     *         On a successful start to processing the capture request</span></span><br><span class="line"><span class="comment">     *     ILLEGAL_ARGUMENT:</span></span><br><span class="line"><span class="comment">     *         If the input is malformed (the settings are empty when not</span></span><br><span class="line"><span class="comment">     *         allowed, there are 0 output buffers, etc) and capture processing</span></span><br><span class="line"><span class="comment">     *         cannot start. Failures during request processing must be</span></span><br><span class="line"><span class="comment">     *         handled by calling ICameraDeviceCallback::notify(). In case of</span></span><br><span class="line"><span class="comment">     *         this error, the framework retains responsibility for the</span></span><br><span class="line"><span class="comment">     *         stream buffers&#x27; fences and the buffer handles; the HAL must not</span></span><br><span class="line"><span class="comment">     *         close the fences or return these buffers with</span></span><br><span class="line"><span class="comment">     *         ICameraDeviceCallback::processCaptureResult().</span></span><br><span class="line"><span class="comment">     *     INTERNAL_ERROR:</span></span><br><span class="line"><span class="comment">     *         If the camera device has encountered a serious error. After this</span></span><br><span class="line"><span class="comment">     *         error is returned, only the close() method can be successfully</span></span><br><span class="line"><span class="comment">     *         called by the framework.</span></span><br><span class="line"><span class="comment">     * @return numRequestProcessed Number of requests successfully processed by</span></span><br><span class="line"><span class="comment">     *     camera HAL. When status is OK, this must be equal to the size of</span></span><br><span class="line"><span class="comment">     *     requests. When the call fails, this number is the number of requests</span></span><br><span class="line"><span class="comment">     *     that HAL processed successfully before HAL runs into an error.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">processCaptureRequest</span>(vec&lt;CaptureRequest&gt; requests,</span><br><span class="line">            vec&lt;BufferCache&gt; cachesToRemove)</span><br><span class="line">            <span class="built_in">generates</span> (Status status, <span class="keyword">uint32_t</span> numRequestProcessed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getCaptureRequestMetadataQueue:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Retrieves the queue used along with processCaptureRequest. If</span></span><br><span class="line"><span class="comment">     * client decides to use fast message queue to pass request metadata,</span></span><br><span class="line"><span class="comment">     * it must:</span></span><br><span class="line"><span class="comment">     * - Call getCaptureRequestMetadataQueue to retrieve the fast message queue;</span></span><br><span class="line"><span class="comment">     * - In each of the requests sent in processCaptureRequest, set</span></span><br><span class="line"><span class="comment">     *   fmqSettingsSize field of CaptureRequest to be the size to read from the</span></span><br><span class="line"><span class="comment">     *   fast message queue; leave settings field of CaptureRequest empty.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return queue the queue that client writes request metadata to.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">getCaptureRequestMetadataQueue</span>() <span class="built_in">generates</span> (fmq_sync&lt;<span class="keyword">uint8_t</span>&gt; queue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getCaptureResultMetadataQueue:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Retrieves the queue used along with</span></span><br><span class="line"><span class="comment">     * ICameraDeviceCallback.processCaptureResult.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Clients to ICameraDeviceSession must:</span></span><br><span class="line"><span class="comment">     * - Call getCaptureRequestMetadataQueue to retrieve the fast message queue;</span></span><br><span class="line"><span class="comment">     * - In implementation of ICameraDeviceCallback, test whether</span></span><br><span class="line"><span class="comment">     *   .fmqResultSize field is zero.</span></span><br><span class="line"><span class="comment">     *     - If .fmqResultSize != 0, read result metadata from the fast message</span></span><br><span class="line"><span class="comment">     *       queue;</span></span><br><span class="line"><span class="comment">     *     - otherwise, read result metadata in CaptureResult.result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return queue the queue that implementation writes result metadata to.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">getCaptureResultMetadataQueue</span>() <span class="built_in">generates</span> (fmq_sync&lt;<span class="keyword">uint8_t</span>&gt; queue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * flush:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Flush all currently in-process captures and all buffers in the pipeline</span></span><br><span class="line"><span class="comment">     * on the given device. Generally, this method is used to dump all state as</span></span><br><span class="line"><span class="comment">     * quickly as possible in order to prepare for a configure_streams() call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * No buffers are required to be successfully returned, so every buffer</span></span><br><span class="line"><span class="comment">     * held at the time of flush() (whether successfully filled or not) may be</span></span><br><span class="line"><span class="comment">     * returned with CAMERA3_BUFFER_STATUS_ERROR. Note the HAL is still allowed</span></span><br><span class="line"><span class="comment">     * to return valid (CAMERA3_BUFFER_STATUS_OK) buffers during this call,</span></span><br><span class="line"><span class="comment">     * provided they are successfully filled.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * All requests currently in the HAL are expected to be returned as soon as</span></span><br><span class="line"><span class="comment">     * possible. Not-in-process requests must return errors immediately. Any</span></span><br><span class="line"><span class="comment">     * interruptible hardware blocks must be stopped, and any uninterruptible</span></span><br><span class="line"><span class="comment">     * blocks must be waited on.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * flush() may be called concurrently to processCaptureRequest(), with the</span></span><br><span class="line"><span class="comment">     * expectation that processCaptureRequest returns quickly and the</span></span><br><span class="line"><span class="comment">     * request submitted in that processCaptureRequest call is treated like</span></span><br><span class="line"><span class="comment">     * all other in-flight requests. Due to concurrency issues, it is possible</span></span><br><span class="line"><span class="comment">     * that from the HAL&#x27;s point of view, a processCaptureRequest() call may</span></span><br><span class="line"><span class="comment">     * be started after flush has been invoked but has not returned yet. If such</span></span><br><span class="line"><span class="comment">     * a call happens before flush() returns, the HAL must treat the new</span></span><br><span class="line"><span class="comment">     * capture request like other in-flight pending requests (see #4 below).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * More specifically, the HAL must follow below requirements for various</span></span><br><span class="line"><span class="comment">     * cases:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. For captures that are too late for the HAL to cancel/stop, and must be</span></span><br><span class="line"><span class="comment">     *    completed normally by the HAL; i.e. the HAL can send shutter/notify</span></span><br><span class="line"><span class="comment">     *    and processCaptureResult and buffers as normal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. For pending requests that have not done any processing, the HAL must</span></span><br><span class="line"><span class="comment">     *    call notify CAMERA3_MSG_ERROR_REQUEST, and return all the output</span></span><br><span class="line"><span class="comment">     *    buffers with processCaptureResult in the error state</span></span><br><span class="line"><span class="comment">     *    (CAMERA3_BUFFER_STATUS_ERROR). The HAL must not place the release</span></span><br><span class="line"><span class="comment">     *    fence into an error state, instead, the release fences must be set to</span></span><br><span class="line"><span class="comment">     *    the acquire fences passed by the framework, or -1 if they have been</span></span><br><span class="line"><span class="comment">     *    waited on by the HAL already. This is also the path to follow for any</span></span><br><span class="line"><span class="comment">     *    captures for which the HAL already called notify() with</span></span><br><span class="line"><span class="comment">     *    CAMERA3_MSG_SHUTTER but won&#x27;t be producing any metadata/valid buffers</span></span><br><span class="line"><span class="comment">     *    for. After CAMERA3_MSG_ERROR_REQUEST, for a given frame, only</span></span><br><span class="line"><span class="comment">     *    processCaptureResults with buffers in CAMERA3_BUFFER_STATUS_ERROR</span></span><br><span class="line"><span class="comment">     *    are allowed. No further notifys or processCaptureResult with</span></span><br><span class="line"><span class="comment">     *    non-empty metadata is allowed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. For partially completed pending requests that do not have all the</span></span><br><span class="line"><span class="comment">     *    output buffers or perhaps missing metadata, the HAL must follow</span></span><br><span class="line"><span class="comment">     *    below:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.1. Call notify with CAMERA3_MSG_ERROR_RESULT if some of the expected</span></span><br><span class="line"><span class="comment">     *         result metadata (i.e. one or more partial metadata) won&#x27;t be</span></span><br><span class="line"><span class="comment">     *         available for the capture.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.2. Call notify with CAMERA3_MSG_ERROR_BUFFER for every buffer that</span></span><br><span class="line"><span class="comment">     *         won&#x27;t be produced for the capture.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.3. Call notify with CAMERA3_MSG_SHUTTER with the capture timestamp</span></span><br><span class="line"><span class="comment">     *         before any buffers/metadata are returned with</span></span><br><span class="line"><span class="comment">     *         processCaptureResult.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.4. For captures that will produce some results, the HAL must not</span></span><br><span class="line"><span class="comment">     *         call CAMERA3_MSG_ERROR_REQUEST, since that indicates complete</span></span><br><span class="line"><span class="comment">     *         failure.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.5. Valid buffers/metadata must be passed to the framework as</span></span><br><span class="line"><span class="comment">     *         normal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.6. Failed buffers must be returned to the framework as described</span></span><br><span class="line"><span class="comment">     *         for case 2. But failed buffers do not have to follow the strict</span></span><br><span class="line"><span class="comment">     *         ordering valid buffers do, and may be out-of-order with respect</span></span><br><span class="line"><span class="comment">     *         to valid buffers. For example, if buffers A, B, C, D, E are sent,</span></span><br><span class="line"><span class="comment">     *         D and E are failed, then A, E, B, D, C is an acceptable return</span></span><br><span class="line"><span class="comment">     *         order.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.7. For fully-missing metadata, calling CAMERA3_MSG_ERROR_RESULT is</span></span><br><span class="line"><span class="comment">     *         sufficient, no need to call processCaptureResult with empty</span></span><br><span class="line"><span class="comment">     *         metadata or equivalent.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 4. If a flush() is invoked while a processCaptureRequest() invocation</span></span><br><span class="line"><span class="comment">     *    is active, that process call must return as soon as possible. In</span></span><br><span class="line"><span class="comment">     *    addition, if a processCaptureRequest() call is made after flush()</span></span><br><span class="line"><span class="comment">     *    has been invoked but before flush() has returned, the capture request</span></span><br><span class="line"><span class="comment">     *    provided by the late processCaptureRequest call must be treated</span></span><br><span class="line"><span class="comment">     *    like a pending request in case #2 above.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * flush() must only return when there are no more outstanding buffers or</span></span><br><span class="line"><span class="comment">     * requests left in the HAL. The framework may call configure_streams (as</span></span><br><span class="line"><span class="comment">     * the HAL state is now quiesced) or may issue new requests.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that it&#x27;s sufficient to only support fully-succeeded and</span></span><br><span class="line"><span class="comment">     * fully-failed result cases. However, it is highly desirable to support</span></span><br><span class="line"><span class="comment">     * the partial failure cases as well, as it could help improve the flush</span></span><br><span class="line"><span class="comment">     * call overall performance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL should return from this call in 100ms, and must return from this</span></span><br><span class="line"><span class="comment">     * call in 1000ms. And this call must not be blocked longer than pipeline</span></span><br><span class="line"><span class="comment">     * latency (see S7 for definition).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return status Status code for the operation, one of:</span></span><br><span class="line"><span class="comment">     *     OK:</span></span><br><span class="line"><span class="comment">     *         On a successful flush of the camera HAL.</span></span><br><span class="line"><span class="comment">     *     INTERNAL_ERROR:</span></span><br><span class="line"><span class="comment">     *         If the camera device has encountered a serious error. After this</span></span><br><span class="line"><span class="comment">     *         error is returned, only the close() method can be successfully</span></span><br><span class="line"><span class="comment">     *         called by the framework.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">flush</span>() <span class="built_in">generates</span> (Status status);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * close:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Shut down the camera device.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * After this call, all calls to this session instance must return</span></span><br><span class="line"><span class="comment">     * INTERNAL_ERROR.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method must always succeed, even if the device has encountered a</span></span><br><span class="line"><span class="comment">     * serious error.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">close</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该文件中定义了ICameraDeviceSession接口类，由CameraDeviceSession::TrampolineSessionInterface_3_2继承并实现，其主要接口如下：</p>
<ul>
<li>constructDefaultRequestSettings：用于创建默认的Request配置项。</li>
<li>configureStreams_3_5：用于配置数据流，其中包括了output buffer/Surface/图像格式大小等属性。</li>
<li>processCaptureRequest_3_4：下发request到Provider中，一个request对应着一次图像需求。</li>
<li>close: 关闭当前会话。</li>
</ul>
<h2 id="三-、Camera-Provider-主程序"><a href="#三-、Camera-Provider-主程序" class="headerlink" title="三 、Camera Provider 主程序"></a>三 、Camera Provider 主程序</h2><p>接下来进入到Provider内部去看看，整个进程是如何运转的，以下图为例进行分析:<br><img src="Image-2.png" alt="alt text"><br>在系统初始化的时候，系统会去运行<a href="mailto:&#x61;&#110;&#x64;&#x72;&#111;&#x69;&#x64;&#46;&#104;&#97;&#114;&#x64;&#119;&#x61;&#x72;&#101;&#46;&#99;&#97;&#x6d;&#101;&#x72;&#97;&#x2e;&#x70;&#x72;&#x6f;&#118;&#x69;&#100;&#101;&#114;&#x40;&#x32;&#46;&#52;&#45;&#115;&#101;&#x72;&#x76;&#105;&#99;&#101;&#95;&#x36;&#52;">&#x61;&#110;&#x64;&#x72;&#111;&#x69;&#x64;&#46;&#104;&#97;&#114;&#x64;&#119;&#x61;&#x72;&#101;&#46;&#99;&#97;&#x6d;&#101;&#x72;&#97;&#x2e;&#x70;&#x72;&#x6f;&#118;&#x69;&#100;&#101;&#114;&#x40;&#x32;&#46;&#52;&#45;&#115;&#101;&#x72;&#x76;&#105;&#99;&#101;&#95;&#x36;&#52;</a>程序启动Provider进程，并加入HW Service Manager中接受统一管理，在该过程中实例化了一个LegacyCameraProviderImpl_2_4对象，并在其构造函数中通过hw_get_module标准方法获取HAL的camera_module_t结构体,并将其存入CameraModule对象中，之后通过调用该camera_modult_t结构体的init方法初始化HAL Module，紧接着调用其get_number_of_camera方法获取当前HAL支持的Camera数量，最后通过调用其set_callbacks方法将LegcyCameraProviderImpl_2_4（LegcyCameraProviderImpl_2_4继承了camera_modult_callback_t）作为参数传入CamX-CHI中，接受来自CamX-CHI中的数据以及事件，当这一系列动作完成了之后，Camera Provider进程便一直便存在于系统中，监听着来自Camera Service的调用。</p>
<p><img src="Image-3.png" alt="alt text"><br>接下来以上图为例简单介绍下Provider中几个重要流程：</p>
<ul>
<li>Camera Service通过调用ICameraProvider的getCameraDeviceInterface_v3_x接口获取ICameraDevice，在此过程中，Provider会去实例化一个CameraDevice对象，并且将之前存有camera_modult_t结构体的CameraModule对象传入CameraDevice中，这样就可以在CameraDevice内部通过CameraModule访问到camera_module_t的相关资源，然后将CameraDevice内部类TrampolineDeviceInterface_3_2（该类继承并实现了ICameraDevice接口）返回给Camera Service。</li>
<li>Camera Service通过之前获取的ICameraDevice，调用其open方法来打开Camera设备，接着在Provider中会去调用CameraDevice对象的open方法，在该方法内部会去调用camera_module_t结构体的open方法，从而获取到HAL部分的camera3_device_t结构体，紧接着Provider会实例化一个CameraDeviceSession对象，并且将刚才获取到的camera3_device_t结构体以参数的方式传入CameraDeviceSession中，在CameraDeviceSession的构造方法中又会调用CameraDeviceSession的initialize方法，在该方法内部又会去调用camera3_device_t结构体的ops内的initialize方法开始HAL部分的初始化工作，最后CameraDeviceSession对象被作为camera3_callback_ops的实现传入HAL，接收来自HAL的数据或者具体事件，当一切动作都完成后，Provider会将CameraDeviceSession::TrampolineSessionInterface_3_2（该类继承并实现了ICameraDeviceSession接口）对象通过HIDL回调的方法返回给Camera Service中。</li>
<li>Camera Service通过调用ICameraDevcieSession的configureStreams_3_5接口进行数据流的配置，在Provider中，最终会通过调用之前获取的camera3_device_t结构体内ops的configure_streams方法下发到HAL中进行处理。</li>
<li>Camera Service通过调用ICameraDevcieSession的processCaptureRequest_3_4接口下发request请求到Provider中，在Provider中，最终依然会通过调用获取的camera3_device_t结构体内ops中的process_capture_request方法将此次请求下发到HAL中进行处理。</li>
</ul>
<p>从整个流程不难看出，这几个接口最终对应的是HAL3的接口，并且Provider并没有经过太多复杂的额外的处理。</p>
<h2 id="四、Camera-HAL3-接口"><a href="#四、Camera-HAL3-接口" class="headerlink" title="四、Camera HAL3 接口"></a>四、Camera HAL3 接口</h2><p>HAL硬件抽象层(Hardware Abstraction Layer)，是谷歌开发的用于屏蔽底层硬件抽象出来的一个软件层， 每一个平台厂商可以将不开源的的代码封装在这一层，仅仅提供二进制文件。<br>该层定义了自己的一套通用标准接口，平台厂商务必按照以下规则定义自己的Module:</p>
<ul>
<li>每一个硬件都通过hw_module_t来描述，具有固定的名字HMI</li>
<li>每一个硬件都必须实现hw_module_t里面的open方法，用于打开硬件设备，并返回对应的操作接口集合</li>
<li>硬件的操作接口集合使用hw_device_t 来描述，并可以通过自定义一个更大的包含hw_device_t的结构体来拓展硬件操作集合</li>
</ul>
<p>其中代表模块的是hw_module_t，对应的设备是通过hw_device_t来描述，这两者的定义如下：<br>hw_module_t/hw_device_t源码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2008 The Android Open Source Project</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ANDROID_INCLUDE_HARDWARE_HARDWARE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_INCLUDE_HARDWARE_HARDWARE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/cdefs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cutils/native_handle.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;system/graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__BEGIN_DECLS</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Value for the hw_module_t.tag field</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_TAG_CONSTANT(A,B,C,D) (((A) &lt;&lt; 24) | ((B) &lt;&lt; 16) | ((C) &lt;&lt; 8) | (D))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_MODULE_TAG MAKE_TAG_CONSTANT(<span class="meta-string">&#x27;H&#x27;</span>, <span class="meta-string">&#x27;W&#x27;</span>, <span class="meta-string">&#x27;M&#x27;</span>, <span class="meta-string">&#x27;T&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_DEVICE_TAG MAKE_TAG_CONSTANT(<span class="meta-string">&#x27;H&#x27;</span>, <span class="meta-string">&#x27;W&#x27;</span>, <span class="meta-string">&#x27;D&#x27;</span>, <span class="meta-string">&#x27;T&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_MAKE_API_VERSION(maj,min) \</span></span><br><span class="line"><span class="meta">            ((((maj) &amp; 0xff) &lt;&lt; 8) | ((min) &amp; 0xff))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_MAKE_API_VERSION_2(maj,min,hdr) \</span></span><br><span class="line"><span class="meta">            ((((maj) &amp; 0xff) &lt;&lt; 24) | (((min) &amp; 0xff) &lt;&lt; 16) | ((hdr) &amp; 0xffff))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_API_VERSION_2_MAJ_MIN_MASK 0xffff0000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_API_VERSION_2_HEADER_MASK  0x0000ffff</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The current HAL API version.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All module implementations must set the hw_module_t.hal_api_version field</span></span><br><span class="line"><span class="comment"> * to this value when declaring the module with HAL_MODULE_INFO_SYM.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that previous implementations have always set this field to 0.</span></span><br><span class="line"><span class="comment"> * Therefore, libhardware HAL API will always consider versions 0.0 and 1.0</span></span><br><span class="line"><span class="comment"> * to be 100% binary compatible.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_HAL_API_VERSION HARDWARE_MAKE_API_VERSION(1, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper macros for module implementors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The derived modules should provide convenience macros for supported</span></span><br><span class="line"><span class="comment"> * versions so that implementations can explicitly specify module/device</span></span><br><span class="line"><span class="comment"> * versions at definition time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use this macro to set the hw_module_t.module_api_version field.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_MODULE_API_VERSION(maj,min) HARDWARE_MAKE_API_VERSION(maj,min)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_MODULE_API_VERSION_2(maj,min,hdr) HARDWARE_MAKE_API_VERSION_2(maj,min,hdr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Use this macro to set the hw_device_t.version field</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_DEVICE_API_VERSION(maj,min) HARDWARE_MAKE_API_VERSION(maj,min)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_DEVICE_API_VERSION_2(maj,min,hdr) HARDWARE_MAKE_API_VERSION_2(maj,min,hdr)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hw_device_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Every hardware module must have a data structure named HAL_MODULE_INFO_SYM</span></span><br><span class="line"><span class="comment"> * and the fields of this data structure must begin with hw_module_t</span></span><br><span class="line"><span class="comment"> * followed by module specific information.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span> &#123;</span></span><br><span class="line">    <span class="comment">/** tag must be initialized to HARDWARE_MODULE_TAG */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The API version of the implemented module. The module owner is</span></span><br><span class="line"><span class="comment">     * responsible for updating the version when a module interface has</span></span><br><span class="line"><span class="comment">     * changed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The derived modules such as gralloc and audio own and manage this field.</span></span><br><span class="line"><span class="comment">     * The module user must interpret the version field to decide whether or</span></span><br><span class="line"><span class="comment">     * not to inter-operate with the supplied module implementation.</span></span><br><span class="line"><span class="comment">     * For example, SurfaceFlinger is responsible for making sure that</span></span><br><span class="line"><span class="comment">     * it knows how to manage different versions of the gralloc-module API,</span></span><br><span class="line"><span class="comment">     * and AudioFlinger must know how to do the same for audio-module API.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The module API version should include a major and a minor component.</span></span><br><span class="line"><span class="comment">     * For example, version 1.0 could be represented as 0x0100. This format</span></span><br><span class="line"><span class="comment">     * implies that versions 0x0100-0x01ff are all API-compatible.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * In the future, libhardware will expose a hw_get_module_version()</span></span><br><span class="line"><span class="comment">     * (or equivalent) function that will take minimum/maximum supported</span></span><br><span class="line"><span class="comment">     * versions as arguments and would be able to reject modules with</span></span><br><span class="line"><span class="comment">     * versions outside of the supplied range.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> module_api_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> version_major module_api_version</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * version_major/version_minor defines are supplied here for temporary</span></span><br><span class="line"><span class="comment">     * source code compatibility. They will be removed in the next version.</span></span><br><span class="line"><span class="comment">     * ALL clients must convert to the new version format.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The API version of the HAL module interface. This is meant to</span></span><br><span class="line"><span class="comment">     * version the hw_module_t, hw_module_methods_t, and hw_device_t</span></span><br><span class="line"><span class="comment">     * structures and definitions.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL interface owns this field. Module users/implementations</span></span><br><span class="line"><span class="comment">     * must NOT rely on this value for version information.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Presently, 0 is the only valid value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> hal_api_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> version_minor hal_api_version</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Identifier of module */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Name of this module */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Author/owner/implementor of the module */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *author;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Modules methods */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span>* <span class="title">methods</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** module&#x27;s dso */</span></span><br><span class="line">    <span class="keyword">void</span>* dso;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint64_t</span> reserved[<span class="number">32</span><span class="number">-7</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/** padding to 128 bytes, reserved for future use */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved[<span class="number">32</span><span class="number">-7</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">hw_module_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span> &#123;</span></span><br><span class="line">    <span class="comment">/** Open a specific device */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*open)(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* id,</span><br><span class="line">            struct <span class="keyword">hw_device_t</span>** device);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">hw_module_methods_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Every device data structure must begin with hw_device_t</span></span><br><span class="line"><span class="comment"> * followed by module specific public methods and attributes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_device_t</span> &#123;</span></span><br><span class="line">    <span class="comment">/** tag must be initialized to HARDWARE_DEVICE_TAG */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Version of the module-specific device API. This value is used by</span></span><br><span class="line"><span class="comment">     * the derived-module user to manage different device implementations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The module user is responsible for checking the module_api_version</span></span><br><span class="line"><span class="comment">     * and device version fields to ensure that the user is capable of</span></span><br><span class="line"><span class="comment">     * communicating with the specific module implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * One module can support multiple devices with different versions. This</span></span><br><span class="line"><span class="comment">     * can be useful when a device interface changes in an incompatible way</span></span><br><span class="line"><span class="comment">     * but it is still necessary to support older implementations at the same</span></span><br><span class="line"><span class="comment">     * time. One such example is the Camera 2.0 API.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This field is interpreted by the module user and is ignored by the</span></span><br><span class="line"><span class="comment">     * HAL interface itself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** reference to the module this device belongs to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span>* <span class="title">module</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** padding reserved for future use */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint64_t</span> reserved[<span class="number">12</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved[<span class="number">12</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Close this device */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*close)(struct <span class="keyword">hw_device_t</span>* device);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">hw_device_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TO_HW_DEVICE_T_OPEN(x) reinterpret_cast<span class="meta-string">&lt;struct hw_device_t**&gt;</span>(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TO_HW_DEVICE_T_OPEN(x) (struct hw_device_t**)(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Name of the hal_module_info</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_MODULE_INFO_SYM         HMI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Name of the hal_module_info as a string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_MODULE_INFO_SYM_AS_STR  <span class="meta-string">&quot;HMI&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the module info associated with a module by id.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return: 0 == success, &lt;0 == error and *module == NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw_get_module</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *id, <span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> **<span class="keyword">module</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the module info associated with a module instance by class &#x27;class_id&#x27;</span></span><br><span class="line"><span class="comment"> * and instance &#x27;inst&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Some modules types necessitate multiple instances. For example audio supports</span></span><br><span class="line"><span class="comment"> * multiple concurrent interfaces and thus &#x27;audio&#x27; is the module class</span></span><br><span class="line"><span class="comment"> * and &#x27;primary&#x27; or &#x27;a2dp&#x27; are module interfaces. This implies that the files</span></span><br><span class="line"><span class="comment"> * providing these modules would be named audio.primary.&lt;variant&gt;.so and</span></span><br><span class="line"><span class="comment"> * audio.a2dp.&lt;variant&gt;.so</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return: 0 == success, &lt;0 == error and *module == NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw_get_module_by_class</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *class_id, <span class="keyword">const</span> <span class="keyword">char</span> *inst,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> **<span class="keyword">module</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">__END_DECLS</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">/* ANDROID_INCLUDE_HARDWARE_HARDWARE_H */</span></span></span><br></pre></td></tr></table></figure>
<p>从上面的定义可以看出，主要是通过hw_module_t 代表了模块，通过其open方法用来打开一个设备，而该设备是用hw_device_t来表示，其中除了用来关闭设备的close方法外，并无其它方法，由此可见谷歌定义的HAL接口，并不能满足绝大部分HAL模块的需要，所以谷歌想出了一个比较好的解决方式，那便是将这两个基本结构嵌入到更大的结构体内部，同时在更大的结构内部定义了各自模块特有的方法，用于实现模块的功能，这样，一来对上保持了HAL的统一规范，二来也扩展了模块的功能。</p>
<p>基于上面的方式，谷歌便针对Camera 提出了HAL3接口，其中主要包括了用于代表一系列操作主体的结构体以及具体操作函数，接下来我们分别进行详细介绍：</p>
<h3 id="1-核心结构体解析"><a href="#1-核心结构体解析" class="headerlink" title="1. 核心结构体解析"></a>1. 核心结构体解析</h3><p>HAL3中主要定义了camera_module_t/camera3_device_t/camera3_stream_configuration/camera3_stream以及camera3_stream_buffer几个主要结构体。</p>
<p>其中camera_module_t以及camera3_device_t代码定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera_module</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Common methods of the camera module.  This *must* be the first member of</span></span><br><span class="line"><span class="comment">     * camera_module as users of this structure will cast a hw_module_t to</span></span><br><span class="line"><span class="comment">     * camera_module pointer in contexts where it&#x27;s known the hw_module_t</span></span><br><span class="line"><span class="comment">     * references a camera_module.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The return values for common.methods-&gt;open for camera_module are:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0:           On a successful open of the camera device.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENODEV:     The camera device cannot be opened due to an internal</span></span><br><span class="line"><span class="comment">     *              error.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL:     The input arguments are invalid, i.e. the id is invalid,</span></span><br><span class="line"><span class="comment">     *              and/or the module is invalid.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EBUSY:      The camera device was already opened for this camera id</span></span><br><span class="line"><span class="comment">     *              (by using this method or open_legacy),</span></span><br><span class="line"><span class="comment">     *              regardless of the device HAL version it was opened as.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EUSERS:     The maximal number of camera devices that can be</span></span><br><span class="line"><span class="comment">     *              opened concurrently were opened already, either by</span></span><br><span class="line"><span class="comment">     *              this method or the open_legacy method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * All other return values from common.methods-&gt;open will be treated as</span></span><br><span class="line"><span class="comment">     * -ENODEV.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">hw_module_t</span> common;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get_number_of_cameras:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Returns the number of camera devices accessible through the camera</span></span><br><span class="line"><span class="comment">     * module.  The camera devices are numbered 0 through N-1, where N is the</span></span><br><span class="line"><span class="comment">     * value returned by this call. The name of the camera device for open() is</span></span><br><span class="line"><span class="comment">     * simply the number converted to a string. That is, &quot;0&quot; for camera ID 0,</span></span><br><span class="line"><span class="comment">     * &quot;1&quot; for camera ID 1.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information (based on camera_module_t.common.module_api_version):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_2_3 or lower:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   The value here must be static, and cannot change after the first call</span></span><br><span class="line"><span class="comment">     *   to this method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_2_4 or higher:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   The value here must be static, and must count only built-in cameras,</span></span><br><span class="line"><span class="comment">     *   which have CAMERA_FACING_BACK or CAMERA_FACING_FRONT camera facing values</span></span><br><span class="line"><span class="comment">     *   (camera_info.facing). The HAL must not include the external cameras</span></span><br><span class="line"><span class="comment">     *   (camera_info.facing == CAMERA_FACING_EXTERNAL) into the return value</span></span><br><span class="line"><span class="comment">     *   of this call. Frameworks will use camera_device_status_change callback</span></span><br><span class="line"><span class="comment">     *   to manage number of external cameras.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*get_number_of_cameras)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get_camera_info:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return the static camera information for a given camera device. This</span></span><br><span class="line"><span class="comment">     * information may not change for a camera device.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0:           On a successful operation</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENODEV:     The information cannot be provided due to an internal</span></span><br><span class="line"><span class="comment">     *              error.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL:     The input arguments are invalid, i.e. the id is invalid,</span></span><br><span class="line"><span class="comment">     *              and/or the module is invalid.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information (based on camera_module_t.common.module_api_version):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_2_4 or higher:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   When a camera is disconnected, its camera id becomes invalid. Calling this</span></span><br><span class="line"><span class="comment">     *   this method with this invalid camera id will get -EINVAL and NULL camera</span></span><br><span class="line"><span class="comment">     *   static metadata (camera_info.static_camera_characteristics).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*get_camera_info)(<span class="keyword">int</span> camera_id, struct camera_info *info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set_callbacks:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Provide callback function pointers to the HAL module to inform framework</span></span><br><span class="line"><span class="comment">     * of asynchronous camera module events. The framework will call this</span></span><br><span class="line"><span class="comment">     * function once after initial camera HAL module load, after the</span></span><br><span class="line"><span class="comment">     * get_number_of_cameras() method is called for the first time, and before</span></span><br><span class="line"><span class="comment">     * any other calls to the module.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information (based on camera_module_t.common.module_api_version):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  CAMERA_MODULE_API_VERSION_1_0, CAMERA_MODULE_API_VERSION_2_0:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    Not provided by HAL module. Framework may not call this function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  CAMERA_MODULE_API_VERSION_2_1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    Valid to be called by the framework.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0:           On a successful operation</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENODEV:     The operation cannot be completed due to an internal</span></span><br><span class="line"><span class="comment">     *              error.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL:     The input arguments are invalid, i.e. the callbacks are</span></span><br><span class="line"><span class="comment">     *              null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*set_callbacks)(<span class="keyword">const</span> <span class="keyword">camera_module_callbacks_t</span> *callbacks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get_vendor_tag_ops:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Get methods to query for vendor extension metadata tag information. The</span></span><br><span class="line"><span class="comment">     * HAL should fill in all the vendor tag operation methods, or leave ops</span></span><br><span class="line"><span class="comment">     * unchanged if no vendor tags are defined.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The vendor_tag_ops structure used here is defined in:</span></span><br><span class="line"><span class="comment">     * system/media/camera/include/system/vendor_tags.h</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information (based on camera_module_t.common.module_api_version):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  CAMERA_MODULE_API_VERSION_1_x/2_0/2_1:</span></span><br><span class="line"><span class="comment">     *    Not provided by HAL module. Framework may not call this function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  CAMERA_MODULE_API_VERSION_2_2:</span></span><br><span class="line"><span class="comment">     *    Valid to be called by the framework.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*get_vendor_tag_ops)(<span class="keyword">vendor_tag_ops_t</span>* ops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * open_legacy:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Open a specific legacy camera HAL device if multiple device HAL API</span></span><br><span class="line"><span class="comment">     * versions are supported by this camera HAL module. For example, if the</span></span><br><span class="line"><span class="comment">     * camera module supports both CAMERA_DEVICE_API_VERSION_1_0 and</span></span><br><span class="line"><span class="comment">     * CAMERA_DEVICE_API_VERSION_3_2 device API for the same camera id,</span></span><br><span class="line"><span class="comment">     * framework can call this function to open the camera device as</span></span><br><span class="line"><span class="comment">     * CAMERA_DEVICE_API_VERSION_1_0 device.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This is an optional method. A Camera HAL module does not need to support</span></span><br><span class="line"><span class="comment">     * more than one device HAL version per device, and such modules may return</span></span><br><span class="line"><span class="comment">     * -ENOSYS for all calls to this method. For all older HAL device API</span></span><br><span class="line"><span class="comment">     * versions that are not supported, it may return -EOPNOTSUPP. When above</span></span><br><span class="line"><span class="comment">     * cases occur, The normal open() method (common.methods-&gt;open) will be</span></span><br><span class="line"><span class="comment">     * used by the framework instead.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information (based on camera_module_t.common.module_api_version):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  CAMERA_MODULE_API_VERSION_1_x/2_0/2_1/2_2:</span></span><br><span class="line"><span class="comment">     *    Not provided by HAL module. Framework will not call this function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  CAMERA_MODULE_API_VERSION_2_3:</span></span><br><span class="line"><span class="comment">     *    Valid to be called by the framework.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0:           On a successful open of the camera device.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENOSYS      This method is not supported.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EOPNOTSUPP: The requested HAL version is not supported by this method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL:     The input arguments are invalid, i.e. the id is invalid,</span></span><br><span class="line"><span class="comment">     *              and/or the module is invalid.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EBUSY:      The camera device was already opened for this camera id</span></span><br><span class="line"><span class="comment">     *              (by using this method or common.methods-&gt;open method),</span></span><br><span class="line"><span class="comment">     *              regardless of the device HAL version it was opened as.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EUSERS:     The maximal number of camera devices that can be</span></span><br><span class="line"><span class="comment">     *              opened concurrently were opened already, either by</span></span><br><span class="line"><span class="comment">     *              this method or common.methods-&gt;open method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*open_legacy)(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* id,</span><br><span class="line">            <span class="keyword">uint32_t</span> halVersion, struct <span class="keyword">hw_device_t</span>** device);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set_torch_mode:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Turn on or off the torch mode of the flash unit associated with a given</span></span><br><span class="line"><span class="comment">     * camera ID. If the operation is successful, HAL must notify the framework</span></span><br><span class="line"><span class="comment">     * torch state by invoking</span></span><br><span class="line"><span class="comment">     * camera_module_callbacks.torch_mode_status_change() with the new state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The camera device has a higher priority accessing the flash unit. When</span></span><br><span class="line"><span class="comment">     * there are any resource conflicts, such as open() is called to open a</span></span><br><span class="line"><span class="comment">     * camera device, HAL module must notify the framework through</span></span><br><span class="line"><span class="comment">     * camera_module_callbacks.torch_mode_status_change() that the</span></span><br><span class="line"><span class="comment">     * torch mode has been turned off and the torch mode state has become</span></span><br><span class="line"><span class="comment">     * TORCH_MODE_STATUS_NOT_AVAILABLE. When resources to turn on torch mode</span></span><br><span class="line"><span class="comment">     * become available again, HAL module must notify the framework through</span></span><br><span class="line"><span class="comment">     * camera_module_callbacks.torch_mode_status_change() that the torch mode</span></span><br><span class="line"><span class="comment">     * state has become TORCH_MODE_STATUS_AVAILABLE_OFF for set_torch_mode() to</span></span><br><span class="line"><span class="comment">     * be called.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When the framework calls set_torch_mode() to turn on the torch mode of a</span></span><br><span class="line"><span class="comment">     * flash unit, if HAL cannot keep multiple torch modes on simultaneously,</span></span><br><span class="line"><span class="comment">     * HAL should turn off the torch mode that was turned on by</span></span><br><span class="line"><span class="comment">     * a previous set_torch_mode() call and notify the framework that the torch</span></span><br><span class="line"><span class="comment">     * mode state of that flash unit has become TORCH_MODE_STATUS_AVAILABLE_OFF.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information (based on camera_module_t.common.module_api_version):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_1_x/2_0/2_1/2_2/2_3:</span></span><br><span class="line"><span class="comment">     *   Not provided by HAL module. Framework will not call this function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_2_4:</span></span><br><span class="line"><span class="comment">     *   Valid to be called by the framework.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0:           On a successful operation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENOSYS:     The camera device does not support this operation. It is</span></span><br><span class="line"><span class="comment">     *              returned if and only if android.flash.info.available is</span></span><br><span class="line"><span class="comment">     *              false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EBUSY:      The camera device is already in use.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EUSERS:     The resources needed to turn on the torch mode are not</span></span><br><span class="line"><span class="comment">     *              available, typically because other camera devices are</span></span><br><span class="line"><span class="comment">     *              holding the resources to make using the flash unit not</span></span><br><span class="line"><span class="comment">     *              possible.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL:     camera_id is invalid.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*set_torch_mode)(<span class="keyword">const</span> <span class="keyword">char</span>* camera_id, <span class="keyword">bool</span> enabled);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * init:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method is called by the camera service before any other methods</span></span><br><span class="line"><span class="comment">     * are invoked, right after the camera HAL library has been successfully</span></span><br><span class="line"><span class="comment">     * loaded. It may be left as NULL by the HAL module, if no initialization</span></span><br><span class="line"><span class="comment">     * in needed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It can be used by HAL implementations to perform initialization and</span></span><br><span class="line"><span class="comment">     * other one-time operations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information (based on camera_module_t.common.module_api_version):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_1_x/2_0/2_1/2_2/2_3:</span></span><br><span class="line"><span class="comment">     *   Not provided by HAL module. Framework will not call this function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_2_4:</span></span><br><span class="line"><span class="comment">     *   If not NULL, will always be called by the framework once after the HAL</span></span><br><span class="line"><span class="comment">     *   module is loaded, before any other HAL module method is called.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0:           On a successful operation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENODEV:     Initialization cannot be completed due to an internal</span></span><br><span class="line"><span class="comment">     *              error. The HAL must be assumed to be in a nonfunctional</span></span><br><span class="line"><span class="comment">     *              state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*init)();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get_physical_camera_info:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return the static metadata for a physical camera as a part of a logical</span></span><br><span class="line"><span class="comment">     * camera device. This function is only called for those physical camera</span></span><br><span class="line"><span class="comment">     * ID(s) that are not exposed independently. In other words, camera_id will</span></span><br><span class="line"><span class="comment">     * be greater or equal to the return value of get_number_of_cameras().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0:           On a successful operation</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENODEV:     The information cannot be provided due to an internal</span></span><br><span class="line"><span class="comment">     *              error.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL:     The input arguments are invalid, i.e. the id is invalid,</span></span><br><span class="line"><span class="comment">     *              and/or the module is invalid.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information (based on camera_module_t.common.module_api_version):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_1_x/2_0/2_1/2_2/2_3/2_4:</span></span><br><span class="line"><span class="comment">     *   Not provided by HAL module. Framework will not call this function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_2_5 or higher:</span></span><br><span class="line"><span class="comment">     *   If any of the camera devices accessible through this camera module is</span></span><br><span class="line"><span class="comment">     *   a logical multi-camera, and at least one of the physical cameras isn&#x27;t</span></span><br><span class="line"><span class="comment">     *   a stand-alone camera device, this function will be called by the camera</span></span><br><span class="line"><span class="comment">     *   framework. Calling this function with invalid physical_camera_id will</span></span><br><span class="line"><span class="comment">     *   get -EINVAL, and NULL static_metadata.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*get_physical_camera_info)(<span class="keyword">int</span> physical_camera_id,</span><br><span class="line">            <span class="keyword">camera_metadata_t</span> **static_metadata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * is_stream_combination_supported:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Check for device support of specific camera stream combination.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0:           In case the stream combination is supported.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL:     In case the stream combination is not supported.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENOSYS:     In case stream combination query is not supported.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information (based on camera_module_t.common.module_api_version):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_1_x/2_0/2_1/2_2/2_3/2_4:</span></span><br><span class="line"><span class="comment">     *   Not provided by HAL module. Framework will not call this function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_2_5 or higher:</span></span><br><span class="line"><span class="comment">     *   Valid to be called by the framework.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*is_stream_combination_supported)(<span class="keyword">int</span> camera_id,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera_stream_combination_t</span> *streams);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * notify_device_state_change:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Notify the camera module that the state of the overall device has</span></span><br><span class="line"><span class="comment">     * changed in some way that the HAL may want to know about.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, a physical shutter may have been uncovered or covered,</span></span><br><span class="line"><span class="comment">     * or a camera may have been covered or uncovered by an add-on keyboard</span></span><br><span class="line"><span class="comment">     * or other accessory.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The state is a bitfield of potential states, and some physical configurations</span></span><br><span class="line"><span class="comment">     * could plausibly correspond to multiple different combinations of state bits.</span></span><br><span class="line"><span class="comment">     * The HAL must ignore any state bits it is not actively using to determine</span></span><br><span class="line"><span class="comment">     * the appropriate camera configuration.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, on some devices the FOLDED state could mean that</span></span><br><span class="line"><span class="comment">     * backward-facing cameras are covered by the fold, so FOLDED by itself implies</span></span><br><span class="line"><span class="comment">     * BACK_COVERED. But other devices may support folding but not cover any cameras</span></span><br><span class="line"><span class="comment">     * when folded, so for those FOLDED would not imply any of the other flags.</span></span><br><span class="line"><span class="comment">     * Since these relationships are very device-specific, it is difficult to specify</span></span><br><span class="line"><span class="comment">     * a comprehensive policy.  But as a recommendation, it is suggested that if a flag</span></span><br><span class="line"><span class="comment">     * necessarily implies other flags are set as well, then those flags should be set.</span></span><br><span class="line"><span class="comment">     * So even though FOLDED would be enough to infer BACK_COVERED on some devices, the</span></span><br><span class="line"><span class="comment">     * BACK_COVERED flag should also be set for clarity.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method may be invoked by the HAL client at any time. It must not</span></span><br><span class="line"><span class="comment">     * cause any active camera device sessions to be closed, but may dynamically</span></span><br><span class="line"><span class="comment">     * change which physical camera a logical multi-camera is using for its</span></span><br><span class="line"><span class="comment">     * active and future output.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The method must be invoked by the HAL client at least once before the</span></span><br><span class="line"><span class="comment">     * client calls ICameraDevice::open on any camera device interfaces listed</span></span><br><span class="line"><span class="comment">     * by this provider, to establish the initial device state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that the deviceState is 64-bit bitmask, with system defined states in</span></span><br><span class="line"><span class="comment">     * lower 32-bit and vendor defined states in upper 32-bit.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*notify_device_state_change)(<span class="keyword">uint64_t</span> deviceState);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reserved for future use */</span></span><br><span class="line">    <span class="keyword">void</span>* reserved[<span class="number">2</span>];</span><br><span class="line">&#125; <span class="keyword">camera_module_t</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera3_device</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * common.version must equal CAMERA_DEVICE_API_VERSION_3_0 to identify this</span></span><br><span class="line"><span class="comment">     * device as implementing version 3.0 of the camera device HAL.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Camera open (common.module-&gt;common.methods-&gt;open) should return in 200ms, and must return</span></span><br><span class="line"><span class="comment">     * in 500ms.</span></span><br><span class="line"><span class="comment">     * Camera close (common.close) should return in 200ms, and must return in 500ms.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">hw_device_t</span> common;</span><br><span class="line">    <span class="keyword">camera3_device_ops_t</span> *ops;</span><br><span class="line">    <span class="keyword">void</span> *priv;</span><br><span class="line">&#125; <span class="keyword">camera3_device_t</span>;</span><br></pre></td></tr></table></figure>
<p>由定义不难发现，camera_module_t包含了hw_module_t，主要用于表示Camera模块，其中定义了诸如get_number_of_cameras以及set_callbacks等扩展方法，而camera3_device_t包含了hw_device_t，主要用来表示Camera设备，其中定义了camera3_device_ops操作方法集合，用来实现正常获取图像数据以及控制Camera的功能。</p>
<p>结构体camera3_stream_configuration代码定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera3_stream_configuration</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The total number of streams requested by the framework.  This includes</span></span><br><span class="line"><span class="comment">     * both input and output streams. The number of streams will be at least 1,</span></span><br><span class="line"><span class="comment">     * and there will be at least one output-capable stream.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> num_streams;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An array of camera stream pointers, defining the input/output</span></span><br><span class="line"><span class="comment">     * configuration for the camera HAL device.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * At most one input-capable stream may be defined (INPUT or BIDIRECTIONAL)</span></span><br><span class="line"><span class="comment">     * in a single configuration.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * At least one output-capable stream must be defined (OUTPUT or</span></span><br><span class="line"><span class="comment">     * BIDIRECTIONAL).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">camera3_stream_t</span> **streams;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_3:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The operation mode of streams in this configuration, one of the value</span></span><br><span class="line"><span class="comment">     * defined in camera3_stream_configuration_mode_t.  The HAL can use this</span></span><br><span class="line"><span class="comment">     * mode as an indicator to set the stream property (e.g.,</span></span><br><span class="line"><span class="comment">     * camera3_stream-&gt;max_buffers) appropriately. For example, if the</span></span><br><span class="line"><span class="comment">     * configuration is</span></span><br><span class="line"><span class="comment">     * CAMERA3_STREAM_CONFIGURATION_CONSTRAINED_HIGH_SPEED_MODE, the HAL may</span></span><br><span class="line"><span class="comment">     * want to set aside more buffers for batch mode operation (see</span></span><br><span class="line"><span class="comment">     * android.control.availableHighSpeedVideoConfigurations for batch mode</span></span><br><span class="line"><span class="comment">     * definition).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> operation_mode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_5:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The session metadata buffer contains the initial values of</span></span><br><span class="line"><span class="comment">     * ANDROID_REQUEST_AVAILABLE_SESSION_KEYS. This field is optional</span></span><br><span class="line"><span class="comment">     * and camera clients can choose to ignore it, in which case it will</span></span><br><span class="line"><span class="comment">     * be set to NULL. If parameters are present, then Hal should examine</span></span><br><span class="line"><span class="comment">     * the parameter values and configure its internal camera pipeline</span></span><br><span class="line"><span class="comment">     * accordingly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">camera_metadata_t</span> *session_parameters;</span><br><span class="line">&#125; <span class="keyword">camera3_stream_configuration_t</span>;</span><br></pre></td></tr></table></figure>
<p>该结构体主要用来代表配置的数据流列表，内部装有上层需要进行配置的数据流的指针，内部的定义简单介绍下：</p>
<ul>
<li>num_streams: 代表了来自上层的数据流的数量，其中包括了output以及input stream。</li>
<li>streams: 是streams的指针数组，包括了至少一条output stream以及至多一条input stream。</li>
<li>operation_mode: 当前数据流的操作模式，该模式在camera3_stream_configuration_mode_t中被定义，HAL通过这个参数可以针对streams做不同的设置。</li>
<li>session_parameters: 该参数可以作为缺省参数，直接设置为NULL即可，CAMERA_DEVICE_API_VERSION_3_5以上的版本才支持。</li>
</ul>
<p>结构体camera3_stream_t的代码定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * camera3_stream_t:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A handle to a single camera input or output stream. A stream is defined by</span></span><br><span class="line"><span class="comment"> * the framework by its buffer resolution and format, and additionally by the</span></span><br><span class="line"><span class="comment"> * HAL with the gralloc usage flags and the maximum in-flight buffer count.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The stream structures are owned by the framework, but pointers to a</span></span><br><span class="line"><span class="comment"> * camera3_stream passed into the HAL by configure_streams() are valid until the</span></span><br><span class="line"><span class="comment"> * end of the first subsequent configure_streams() call that _does not_ include</span></span><br><span class="line"><span class="comment"> * that camera3_stream as an argument, or until the end of the close() call.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All camera3_stream framework-controlled members are immutable once the</span></span><br><span class="line"><span class="comment"> * camera3_stream is passed into configure_streams().  The HAL may only change</span></span><br><span class="line"><span class="comment"> * the HAL-controlled parameters during a configure_streams() call, except for</span></span><br><span class="line"><span class="comment"> * the contents of the private pointer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If a configure_streams() call returns a non-fatal error, all active streams</span></span><br><span class="line"><span class="comment"> * remain valid as if configure_streams() had not been called.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The endpoint of the stream is not visible to the camera HAL device.</span></span><br><span class="line"><span class="comment"> * In DEVICE_API_VERSION_3_1, this was changed to share consumer usage flags</span></span><br><span class="line"><span class="comment"> * on streams where the camera is a producer (OUTPUT and BIDIRECTIONAL stream</span></span><br><span class="line"><span class="comment"> * types) see the usage field below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera3_stream</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*****</span></span><br><span class="line"><span class="comment">     * Set by framework before configure_streams()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The type of the stream, one of the camera3_stream_type_t values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> stream_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The width in pixels of the buffers in this stream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The height in pixels of the buffers in this stream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The pixel format for the buffers in this stream. Format is a value from</span></span><br><span class="line"><span class="comment">     * the HAL_PIXEL_FORMAT_* list in system/core/include/system/graphics.h, or</span></span><br><span class="line"><span class="comment">     * from device-specific headers.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED is used, then the platform</span></span><br><span class="line"><span class="comment">     * gralloc module will select a format based on the usage flags provided by</span></span><br><span class="line"><span class="comment">     * the camera device and the other endpoint of the stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;= CAMERA_DEVICE_API_VERSION_3_1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The camera HAL device must inspect the buffers handed to it in the</span></span><br><span class="line"><span class="comment">     * subsequent register_stream_buffers() call to obtain the</span></span><br><span class="line"><span class="comment">     * implementation-specific format details, if necessary.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * register_stream_buffers() won&#x27;t be called by the framework, so the HAL</span></span><br><span class="line"><span class="comment">     * should configure the ISP and sensor pipeline based purely on the sizes,</span></span><br><span class="line"><span class="comment">     * usage flags, and formats for the configured streams.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> format;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*****</span></span><br><span class="line"><span class="comment">     * Set by HAL during configure_streams().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The gralloc usage flags for this stream, as needed by the HAL. The usage</span></span><br><span class="line"><span class="comment">     * flags are defined in gralloc.h (GRALLOC_USAGE_*), or in device-specific</span></span><br><span class="line"><span class="comment">     * headers.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For output streams, these are the HAL&#x27;s producer usage flags. For input</span></span><br><span class="line"><span class="comment">     * streams, these are the HAL&#x27;s consumer usage flags. The usage flags from</span></span><br><span class="line"><span class="comment">     * the producer and the consumer will be combined together and then passed</span></span><br><span class="line"><span class="comment">     * to the platform gralloc HAL module for allocating the gralloc buffers for</span></span><br><span class="line"><span class="comment">     * each stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * == CAMERA_DEVICE_API_VERSION_3_0:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   No initial value guaranteed when passed via configure_streams().</span></span><br><span class="line"><span class="comment">     *   HAL may not use this field as input, and must write over this field</span></span><br><span class="line"><span class="comment">     *   with its usage flags.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   For stream_type OUTPUT and BIDIRECTIONAL, when passed via</span></span><br><span class="line"><span class="comment">     *   configure_streams(), the initial value of this is the consumer&#x27;s</span></span><br><span class="line"><span class="comment">     *   usage flags.  The HAL may use these consumer flags to decide stream</span></span><br><span class="line"><span class="comment">     *   configuration.</span></span><br><span class="line"><span class="comment">     *   For stream_type INPUT, when passed via configure_streams(), the initial</span></span><br><span class="line"><span class="comment">     *   value of this is 0.</span></span><br><span class="line"><span class="comment">     *   For all streams passed via configure_streams(), the HAL must write</span></span><br><span class="line"><span class="comment">     *   over this field with its usage flags.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   From Android O, the usage flag for an output stream may be bitwise</span></span><br><span class="line"><span class="comment">     *   combination of usage flags for multiple consumers, for the purpose of</span></span><br><span class="line"><span class="comment">     *   sharing one camera stream between those consumers. The HAL must fail</span></span><br><span class="line"><span class="comment">     *   configure_streams call with -EINVAL if the combined flags cannot be</span></span><br><span class="line"><span class="comment">     *   supported due to imcompatible buffer format, dataSpace, or other hardware</span></span><br><span class="line"><span class="comment">     *   limitations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> usage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum number of buffers the HAL device may need to have dequeued at</span></span><br><span class="line"><span class="comment">     * the same time. The HAL device may not have more buffers in-flight from</span></span><br><span class="line"><span class="comment">     * this stream than this value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> max_buffers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A handle to HAL-private information for the stream. Will not be inspected</span></span><br><span class="line"><span class="comment">     * by the framework code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> *priv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A field that describes the contents of the buffer. The format and buffer</span></span><br><span class="line"><span class="comment">     * dimensions define the memory layout and structure of the stream buffers,</span></span><br><span class="line"><span class="comment">     * while dataSpace defines the meaning of the data within the buffer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For most formats, dataSpace defines the color space of the image data.</span></span><br><span class="line"><span class="comment">     * In addition, for some formats, dataSpace indicates whether image- or</span></span><br><span class="line"><span class="comment">     * depth-based data is requested.  See system/core/include/system/graphics.h</span></span><br><span class="line"><span class="comment">     * for details of formats and valid dataSpace values for each format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt; CAMERA_DEVICE_API_VERSION_3_3:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   Not defined and should not be accessed. dataSpace should be assumed to</span></span><br><span class="line"><span class="comment">     *   be HAL_DATASPACE_UNKNOWN, and the appropriate color space, etc, should</span></span><br><span class="line"><span class="comment">     *   be determined from the usage flags and the format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * = CAMERA_DEVICE_API_VERSION_3_3:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   Always set by the camera service. HAL must use this dataSpace to</span></span><br><span class="line"><span class="comment">     *   configure the stream to the correct colorspace, or to select between</span></span><br><span class="line"><span class="comment">     *   color and depth outputs if supported. The dataspace values are the</span></span><br><span class="line"><span class="comment">     *   legacy definitions in graphics.h</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_4:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   Always set by the camera service. HAL must use this dataSpace to</span></span><br><span class="line"><span class="comment">     *   configure the stream to the correct colorspace, or to select between</span></span><br><span class="line"><span class="comment">     *   color and depth outputs if supported. The dataspace values are set</span></span><br><span class="line"><span class="comment">     *   using the V0 dataspace definitions in graphics.h</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">android_dataspace_t</span> data_space;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The required output rotation of the stream, one of</span></span><br><span class="line"><span class="comment">     * the camera3_stream_rotation_t values. This must be inspected by HAL along</span></span><br><span class="line"><span class="comment">     * with stream width and height. For example, if the rotation is 90 degree</span></span><br><span class="line"><span class="comment">     * and the stream width and height is 720 and 1280 respectively, camera service</span></span><br><span class="line"><span class="comment">     * will supply buffers of size 720x1280, and HAL should capture a 1280x720 image</span></span><br><span class="line"><span class="comment">     * and rotate the image by 90 degree counterclockwise. The rotation field is</span></span><br><span class="line"><span class="comment">     * no-op when the stream type is input. Camera HAL must ignore the rotation</span></span><br><span class="line"><span class="comment">     * field for an input stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;= CAMERA_DEVICE_API_VERSION_3_2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    Not defined and must not be accessed. HAL must not apply any rotation</span></span><br><span class="line"><span class="comment">     *    on output images.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_3:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    Always set by camera service. HAL must inspect this field during stream</span></span><br><span class="line"><span class="comment">     *    configuration and returns -EINVAL if HAL cannot perform such rotation.</span></span><br><span class="line"><span class="comment">     *    HAL must always support CAMERA3_STREAM_ROTATION_0, so a</span></span><br><span class="line"><span class="comment">     *    configure_streams() call must not fail for unsupported rotation if</span></span><br><span class="line"><span class="comment">     *    rotation field of all streams is CAMERA3_STREAM_ROTATION_0.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> rotation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The physical camera id this stream belongs to.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;= CAMERA_DEVICE_API_VERISON_3_4:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    Not defined and must not be accessed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERISON_3_5:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    Always set by camera service. If the camera device is not a logical</span></span><br><span class="line"><span class="comment">     *    multi camera, or if the camera is a logical multi camera but the stream</span></span><br><span class="line"><span class="comment">     *    is not a physical output stream, this field will point to a 0-length</span></span><br><span class="line"><span class="comment">     *    string.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    A logical multi camera is a camera device backed by multiple physical</span></span><br><span class="line"><span class="comment">     *    cameras that are also exposed to the application. And for a logical</span></span><br><span class="line"><span class="comment">     *    multi camera, a physical output stream is an output stream specifically</span></span><br><span class="line"><span class="comment">     *    requested on an underlying physical camera.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    For an input stream, this field is guaranteed to be a 0-length string.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* physical_camera_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reserved for future use */</span></span><br><span class="line">    <span class="keyword">void</span> *reserved[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">camera3_stream_t</span>;</span><br></pre></td></tr></table></figure>
<p>该结构体主要用来代表具体的数据流实体，在整个的配置过程中，需要在上层进行填充，当下发到HAL中后，HAL会针对其中的各项属性进行配置，这里便简单介绍下其内部的各个元素的意义：</p>
<ul>
<li>stream_type: 表示数据流的类型，类型在camera3_stream_type_t中被定义。</li>
<li>width： 表示当前数据流中的buffer的宽度。</li>
<li>height: 表示当前数据流中buffer的高度。</li>
<li>format: 表示当前数据流中buffer的格式，该格式是在system/core/include/system/graphics.h中被定义。</li>
<li>usage： 表示当前数据流的gralloc用法，其用法定义在gralloc.h中。</li>
<li>max_buffers： 指定了当前数据流中可能支持的最大数据buffer数量。</li>
<li>data_space: 指定了当前数据流buffer中存储的图像数据的颜色空间。</li>
<li>rotation：指定了当前数据流的输出buffer的旋转角度，其角度的定义在camera3_stream_rotation_t中，该参数由Camera Service进行设置，必须在HAL中进行设置，该参数对于input stream并没有效果。</li>
<li>physical_camera_id： 指定了当前数据流从属的物理camera Id。</li>
</ul>
<p>结构体camera3_stream_buffer_t定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * camera3_stream_buffer_t:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A single buffer from a camera3 stream. It includes a handle to its parent</span></span><br><span class="line"><span class="comment"> * stream, the handle to the gralloc buffer itself, and sync fences</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The buffer does not specify whether it is to be used for input or output;</span></span><br><span class="line"><span class="comment"> * that is determined by its parent stream type and how the buffer is passed to</span></span><br><span class="line"><span class="comment"> * the HAL device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera3_stream_buffer</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The handle of the stream this buffer is associated with</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">camera3_stream_t</span> *stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The native handle to the buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">buffer_handle_t</span> *buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Current state of the buffer, one of the camera3_buffer_status_t</span></span><br><span class="line"><span class="comment">     * values. The framework will not pass buffers to the HAL that are in an</span></span><br><span class="line"><span class="comment">     * error state. In case a buffer could not be filled by the HAL, it must</span></span><br><span class="line"><span class="comment">     * have its status set to CAMERA3_BUFFER_STATUS_ERROR when returned to the</span></span><br><span class="line"><span class="comment">     * framework with process_capture_result().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The acquire sync fence for this buffer. The HAL must wait on this fence</span></span><br><span class="line"><span class="comment">     * fd before attempting to read from or write to this buffer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework may be set to -1 to indicate that no waiting is necessary</span></span><br><span class="line"><span class="comment">     * for this buffer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When the HAL returns an output buffer to the framework with</span></span><br><span class="line"><span class="comment">     * process_capture_result(), the acquire_fence must be set to -1. If the HAL</span></span><br><span class="line"><span class="comment">     * never waits on the acquire_fence due to an error in filling a buffer,</span></span><br><span class="line"><span class="comment">     * when calling process_capture_result() the HAL must set the release_fence</span></span><br><span class="line"><span class="comment">     * of the buffer to be the acquire_fence passed to it by the framework. This</span></span><br><span class="line"><span class="comment">     * will allow the framework to wait on the fence before reusing the buffer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For input buffers, the HAL must not change the acquire_fence field during</span></span><br><span class="line"><span class="comment">     * the process_capture_request() call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When the HAL returns an input buffer to the framework with</span></span><br><span class="line"><span class="comment">     * process_capture_result(), the acquire_fence must be set to -1. If the HAL</span></span><br><span class="line"><span class="comment">     * never waits on input buffer acquire fence due to an error, the sync</span></span><br><span class="line"><span class="comment">     * fences should be handled similarly to the way they are handled for output</span></span><br><span class="line"><span class="comment">     * buffers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">int</span> acquire_fence;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The release sync fence for this buffer. The HAL must set this fence when</span></span><br><span class="line"><span class="comment">     * returning buffers to the framework, or write -1 to indicate that no</span></span><br><span class="line"><span class="comment">     * waiting is required for this buffer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For the output buffers, the fences must be set in the output_buffers</span></span><br><span class="line"><span class="comment">     * array passed to process_capture_result().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;= CAMERA_DEVICE_API_VERSION_3_1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For the input buffer, the release fence must be set by the</span></span><br><span class="line"><span class="comment">     * process_capture_request() call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For the input buffer, the fences must be set in the input_buffer</span></span><br><span class="line"><span class="comment">     * passed to process_capture_result().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * After signaling the release_fence for this buffer, the HAL</span></span><br><span class="line"><span class="comment">     * should not make any further attempts to access this buffer as the</span></span><br><span class="line"><span class="comment">     * ownership has been fully transferred back to the framework.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If a fence of -1 was specified then the ownership of this buffer</span></span><br><span class="line"><span class="comment">     * is transferred back immediately upon the call of process_capture_result.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> release_fence;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">camera3_stream_buffer_t</span>;</span><br></pre></td></tr></table></figure>
<p>该结构体主要用来代表具体的buffer对象，其中重要元素如下：</p>
<ul>
<li>stream: 代表了从属的数据流</li>
<li>buffer：buffer句柄</li>
</ul>
<h3 id="2-核心接口函数解析"><a href="#2-核心接口函数解析" class="headerlink" title="2. 核心接口函数解析"></a>2. 核心接口函数解析</h3><p>HAL3的核心接口都是在camera3_device_ops中被定义，代码定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera3_device_ops</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * One-time initialization to pass framework callback function pointers to</span></span><br><span class="line"><span class="comment">     * the HAL. Will be called once after a successful open() call, before any</span></span><br><span class="line"><span class="comment">     * other functions are called on the camera3_device_ops structure.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This should be a non-blocking call. The HAL should return from this call</span></span><br><span class="line"><span class="comment">     * in 5ms, and must return from this call in 10ms.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  0:     On successful initialization</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENODEV: If initialization fails. Only close() can be called successfully</span></span><br><span class="line"><span class="comment">     *          by the framework after this.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*initialize)(<span class="keyword">const</span> struct camera3_device *,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_callback_ops_t</span> *callback_ops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">     * Stream management</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * configure_streams:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_DEVICE_API_VERSION_3_0 only:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Reset the HAL camera device processing pipeline and set up new input and</span></span><br><span class="line"><span class="comment">     * output streams. This call replaces any existing stream configuration with</span></span><br><span class="line"><span class="comment">     * the streams defined in the stream_list. This method will be called at</span></span><br><span class="line"><span class="comment">     * least once after initialize() before a request is submitted with</span></span><br><span class="line"><span class="comment">     * process_capture_request().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The stream_list must contain at least one output-capable stream, and may</span></span><br><span class="line"><span class="comment">     * not contain more than one input-capable stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The stream_list may contain streams that are also in the currently-active</span></span><br><span class="line"><span class="comment">     * set of streams (from the previous call to configure_stream()). These</span></span><br><span class="line"><span class="comment">     * streams will already have valid values for usage, max_buffers, and the</span></span><br><span class="line"><span class="comment">     * private pointer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If such a stream has already had its buffers registered,</span></span><br><span class="line"><span class="comment">     * register_stream_buffers() will not be called again for the stream, and</span></span><br><span class="line"><span class="comment">     * buffers from the stream can be immediately included in input requests.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the HAL needs to change the stream configuration for an existing</span></span><br><span class="line"><span class="comment">     * stream due to the new configuration, it may rewrite the values of usage</span></span><br><span class="line"><span class="comment">     * and/or max_buffers during the configure call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework will detect such a change, and will then reallocate the</span></span><br><span class="line"><span class="comment">     * stream buffers, and call register_stream_buffers() again before using</span></span><br><span class="line"><span class="comment">     * buffers from that stream in a request.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If a currently-active stream is not included in stream_list, the HAL may</span></span><br><span class="line"><span class="comment">     * safely remove any references to that stream. It will not be reused in a</span></span><br><span class="line"><span class="comment">     * later configure() call by the framework, and all the gralloc buffers for</span></span><br><span class="line"><span class="comment">     * it will be freed after the configure_streams() call returns.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The stream_list structure is owned by the framework, and may not be</span></span><br><span class="line"><span class="comment">     * accessed once this call completes. The address of an individual</span></span><br><span class="line"><span class="comment">     * camera3_stream_t structure will remain valid for access by the HAL until</span></span><br><span class="line"><span class="comment">     * the end of the first configure_stream() call which no longer includes</span></span><br><span class="line"><span class="comment">     * that camera3_stream_t in the stream_list argument. The HAL may not change</span></span><br><span class="line"><span class="comment">     * values in the stream structure outside of the private pointer, except for</span></span><br><span class="line"><span class="comment">     * the usage and max_buffers members during the configure_streams() call</span></span><br><span class="line"><span class="comment">     * itself.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the stream is new, the usage, max_buffer, and private pointer fields</span></span><br><span class="line"><span class="comment">     * of the stream structure will all be set to 0. The HAL device must set</span></span><br><span class="line"><span class="comment">     * these fields before the configure_streams() call returns. These fields</span></span><br><span class="line"><span class="comment">     * are then used by the framework and the platform gralloc module to</span></span><br><span class="line"><span class="comment">     * allocate the gralloc buffers for each stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Before such a new stream can have its buffers included in a capture</span></span><br><span class="line"><span class="comment">     * request, the framework will call register_stream_buffers() with that</span></span><br><span class="line"><span class="comment">     * stream. However, the framework is not required to register buffers for</span></span><br><span class="line"><span class="comment">     * _all_ streams before submitting a request. This allows for quick startup</span></span><br><span class="line"><span class="comment">     * of (for example) a preview stream, with allocation for other streams</span></span><br><span class="line"><span class="comment">     * happening later or concurrently.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * CAMERA_DEVICE_API_VERSION_3_1 only:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Reset the HAL camera device processing pipeline and set up new input and</span></span><br><span class="line"><span class="comment">     * output streams. This call replaces any existing stream configuration with</span></span><br><span class="line"><span class="comment">     * the streams defined in the stream_list. This method will be called at</span></span><br><span class="line"><span class="comment">     * least once after initialize() before a request is submitted with</span></span><br><span class="line"><span class="comment">     * process_capture_request().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The stream_list must contain at least one output-capable stream, and may</span></span><br><span class="line"><span class="comment">     * not contain more than one input-capable stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The stream_list may contain streams that are also in the currently-active</span></span><br><span class="line"><span class="comment">     * set of streams (from the previous call to configure_stream()). These</span></span><br><span class="line"><span class="comment">     * streams will already have valid values for usage, max_buffers, and the</span></span><br><span class="line"><span class="comment">     * private pointer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If such a stream has already had its buffers registered,</span></span><br><span class="line"><span class="comment">     * register_stream_buffers() will not be called again for the stream, and</span></span><br><span class="line"><span class="comment">     * buffers from the stream can be immediately included in input requests.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the HAL needs to change the stream configuration for an existing</span></span><br><span class="line"><span class="comment">     * stream due to the new configuration, it may rewrite the values of usage</span></span><br><span class="line"><span class="comment">     * and/or max_buffers during the configure call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework will detect such a change, and will then reallocate the</span></span><br><span class="line"><span class="comment">     * stream buffers, and call register_stream_buffers() again before using</span></span><br><span class="line"><span class="comment">     * buffers from that stream in a request.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If a currently-active stream is not included in stream_list, the HAL may</span></span><br><span class="line"><span class="comment">     * safely remove any references to that stream. It will not be reused in a</span></span><br><span class="line"><span class="comment">     * later configure() call by the framework, and all the gralloc buffers for</span></span><br><span class="line"><span class="comment">     * it will be freed after the configure_streams() call returns.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The stream_list structure is owned by the framework, and may not be</span></span><br><span class="line"><span class="comment">     * accessed once this call completes. The address of an individual</span></span><br><span class="line"><span class="comment">     * camera3_stream_t structure will remain valid for access by the HAL until</span></span><br><span class="line"><span class="comment">     * the end of the first configure_stream() call which no longer includes</span></span><br><span class="line"><span class="comment">     * that camera3_stream_t in the stream_list argument. The HAL may not change</span></span><br><span class="line"><span class="comment">     * values in the stream structure outside of the private pointer, except for</span></span><br><span class="line"><span class="comment">     * the usage and max_buffers members during the configure_streams() call</span></span><br><span class="line"><span class="comment">     * itself.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the stream is new, max_buffer, and private pointer fields of the</span></span><br><span class="line"><span class="comment">     * stream structure will all be set to 0. The usage will be set to the</span></span><br><span class="line"><span class="comment">     * consumer usage flags. The HAL device must set these fields before the</span></span><br><span class="line"><span class="comment">     * configure_streams() call returns. These fields are then used by the</span></span><br><span class="line"><span class="comment">     * framework and the platform gralloc module to allocate the gralloc</span></span><br><span class="line"><span class="comment">     * buffers for each stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Before such a new stream can have its buffers included in a capture</span></span><br><span class="line"><span class="comment">     * request, the framework will call register_stream_buffers() with that</span></span><br><span class="line"><span class="comment">     * stream. However, the framework is not required to register buffers for</span></span><br><span class="line"><span class="comment">     * _all_ streams before submitting a request. This allows for quick startup</span></span><br><span class="line"><span class="comment">     * of (for example) a preview stream, with allocation for other streams</span></span><br><span class="line"><span class="comment">     * happening later or concurrently.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Reset the HAL camera device processing pipeline and set up new input and</span></span><br><span class="line"><span class="comment">     * output streams. This call replaces any existing stream configuration with</span></span><br><span class="line"><span class="comment">     * the streams defined in the stream_list. This method will be called at</span></span><br><span class="line"><span class="comment">     * least once after initialize() before a request is submitted with</span></span><br><span class="line"><span class="comment">     * process_capture_request().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The stream_list must contain at least one output-capable stream, and may</span></span><br><span class="line"><span class="comment">     * not contain more than one input-capable stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The stream_list may contain streams that are also in the currently-active</span></span><br><span class="line"><span class="comment">     * set of streams (from the previous call to configure_stream()). These</span></span><br><span class="line"><span class="comment">     * streams will already have valid values for usage, max_buffers, and the</span></span><br><span class="line"><span class="comment">     * private pointer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the HAL needs to change the stream configuration for an existing</span></span><br><span class="line"><span class="comment">     * stream due to the new configuration, it may rewrite the values of usage</span></span><br><span class="line"><span class="comment">     * and/or max_buffers during the configure call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework will detect such a change, and may then reallocate the</span></span><br><span class="line"><span class="comment">     * stream buffers before using buffers from that stream in a request.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If a currently-active stream is not included in stream_list, the HAL may</span></span><br><span class="line"><span class="comment">     * safely remove any references to that stream. It will not be reused in a</span></span><br><span class="line"><span class="comment">     * later configure() call by the framework, and all the gralloc buffers for</span></span><br><span class="line"><span class="comment">     * it will be freed after the configure_streams() call returns.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The stream_list structure is owned by the framework, and may not be</span></span><br><span class="line"><span class="comment">     * accessed once this call completes. The address of an individual</span></span><br><span class="line"><span class="comment">     * camera3_stream_t structure will remain valid for access by the HAL until</span></span><br><span class="line"><span class="comment">     * the end of the first configure_stream() call which no longer includes</span></span><br><span class="line"><span class="comment">     * that camera3_stream_t in the stream_list argument. The HAL may not change</span></span><br><span class="line"><span class="comment">     * values in the stream structure outside of the private pointer, except for</span></span><br><span class="line"><span class="comment">     * the usage and max_buffers members during the configure_streams() call</span></span><br><span class="line"><span class="comment">     * itself.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the stream is new, max_buffer, and private pointer fields of the</span></span><br><span class="line"><span class="comment">     * stream structure will all be set to 0. The usage will be set to the</span></span><br><span class="line"><span class="comment">     * consumer usage flags. The HAL device must set these fields before the</span></span><br><span class="line"><span class="comment">     * configure_streams() call returns. These fields are then used by the</span></span><br><span class="line"><span class="comment">     * framework and the platform gralloc module to allocate the gralloc</span></span><br><span class="line"><span class="comment">     * buffers for each stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Newly allocated buffers may be included in a capture request at any time</span></span><br><span class="line"><span class="comment">     * by the framework. Once a gralloc buffer is returned to the framework</span></span><br><span class="line"><span class="comment">     * with process_capture_result (and its respective release_fence has been</span></span><br><span class="line"><span class="comment">     * signaled) the framework may free or reuse it at any time.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Preconditions:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework will only call this method when no captures are being</span></span><br><span class="line"><span class="comment">     * processed. That is, all results have been returned to the framework, and</span></span><br><span class="line"><span class="comment">     * all in-flight input and output buffers have been returned and their</span></span><br><span class="line"><span class="comment">     * release sync fences have been signaled by the HAL. The framework will not</span></span><br><span class="line"><span class="comment">     * submit new requests for capture while the configure_streams() call is</span></span><br><span class="line"><span class="comment">     * underway.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Postconditions:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL device must configure itself to provide maximum possible output</span></span><br><span class="line"><span class="comment">     * frame rate given the sizes and formats of the output streams, as</span></span><br><span class="line"><span class="comment">     * documented in the camera device&#x27;s static metadata.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This call is expected to be heavyweight and possibly take several hundred</span></span><br><span class="line"><span class="comment">     * milliseconds to complete, since it may require resetting and</span></span><br><span class="line"><span class="comment">     * reconfiguring the image sensor and the camera processing pipeline.</span></span><br><span class="line"><span class="comment">     * Nevertheless, the HAL device should attempt to minimize the</span></span><br><span class="line"><span class="comment">     * reconfiguration delay to minimize the user-visible pauses during</span></span><br><span class="line"><span class="comment">     * application operational mode changes (such as switching from still</span></span><br><span class="line"><span class="comment">     * capture to video recording).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL should return from this call in 500ms, and must return from this</span></span><br><span class="line"><span class="comment">     * call in 1000ms.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  0:      On successful stream configuration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL: If the requested stream configuration is invalid. Some examples</span></span><br><span class="line"><span class="comment">     *          of invalid stream configurations include:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *          - Including more than 1 input-capable stream (INPUT or</span></span><br><span class="line"><span class="comment">     *            BIDIRECTIONAL)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *          - Not including any output-capable streams (OUTPUT or</span></span><br><span class="line"><span class="comment">     *            BIDIRECTIONAL)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *          - Including streams with unsupported formats, or an unsupported</span></span><br><span class="line"><span class="comment">     *            size for that format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *          - Including too many output streams of a certain format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *          - Unsupported rotation configuration (only applies to</span></span><br><span class="line"><span class="comment">     *            devices with version &gt;= CAMERA_DEVICE_API_VERSION_3_3)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *          - Stream sizes/formats don&#x27;t satisfy the</span></span><br><span class="line"><span class="comment">     *            camera3_stream_configuration_t-&gt;operation_mode requirements for non-NORMAL mode,</span></span><br><span class="line"><span class="comment">     *            or the requested operation_mode is not supported by the HAL.</span></span><br><span class="line"><span class="comment">     *            (only applies to devices with version &gt;= CAMERA_DEVICE_API_VERSION_3_3)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *          Note that the framework submitting an invalid stream</span></span><br><span class="line"><span class="comment">     *          configuration is not normal operation, since stream</span></span><br><span class="line"><span class="comment">     *          configurations are checked before configure. An invalid</span></span><br><span class="line"><span class="comment">     *          configuration means that a bug exists in the framework code, or</span></span><br><span class="line"><span class="comment">     *          there is a mismatch between the HAL&#x27;s static metadata and the</span></span><br><span class="line"><span class="comment">     *          requirements on streams.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENODEV: If there has been a fatal error and the device is no longer</span></span><br><span class="line"><span class="comment">     *          operational. Only close() can be called successfully by the</span></span><br><span class="line"><span class="comment">     *          framework after this error is returned.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*configure_streams)(<span class="keyword">const</span> struct camera3_device *,</span><br><span class="line">            <span class="keyword">camera3_stream_configuration_t</span> *stream_list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * register_stream_buffers:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * DEPRECATED. This will not be called and must be set to NULL.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;= CAMERA_DEVICE_API_VERSION_3_1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Register buffers for a given stream with the HAL device. This method is</span></span><br><span class="line"><span class="comment">     * called by the framework after a new stream is defined by</span></span><br><span class="line"><span class="comment">     * configure_streams, and before buffers from that stream are included in a</span></span><br><span class="line"><span class="comment">     * capture request. If the same stream is listed in a subsequent</span></span><br><span class="line"><span class="comment">     * configure_streams() call, register_stream_buffers will _not_ be called</span></span><br><span class="line"><span class="comment">     * again for that stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework does not need to register buffers for all configured</span></span><br><span class="line"><span class="comment">     * streams before it submits the first capture request. This allows quick</span></span><br><span class="line"><span class="comment">     * startup for preview (or similar use cases) while other streams are still</span></span><br><span class="line"><span class="comment">     * being allocated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method is intended to allow the HAL device to map or otherwise</span></span><br><span class="line"><span class="comment">     * prepare the buffers for later use. The buffers passed in will already be</span></span><br><span class="line"><span class="comment">     * locked for use. At the end of the call, all the buffers must be ready to</span></span><br><span class="line"><span class="comment">     * be returned to the stream.  The buffer_set argument is only valid for the</span></span><br><span class="line"><span class="comment">     * duration of this call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the stream format was set to HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED,</span></span><br><span class="line"><span class="comment">     * the camera HAL should inspect the passed-in buffers here to determine any</span></span><br><span class="line"><span class="comment">     * platform-private pixel format information.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This should be a non-blocking call. The HAL should return from this call</span></span><br><span class="line"><span class="comment">     * in 1ms, and must return from this call in 5ms.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  0:      On successful registration of the new stream buffers</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL: If the stream_buffer_set does not refer to a valid active</span></span><br><span class="line"><span class="comment">     *          stream, or if the buffers array is invalid.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENOMEM: If there was a failure in registering the buffers. The framework</span></span><br><span class="line"><span class="comment">     *          must consider all the stream buffers to be unregistered, and can</span></span><br><span class="line"><span class="comment">     *          try to register again later.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENODEV: If there is a fatal error, and the device is no longer</span></span><br><span class="line"><span class="comment">     *          operational. Only close() can be called successfully by the</span></span><br><span class="line"><span class="comment">     *          framework after this error is returned.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*register_stream_buffers)(<span class="keyword">const</span> struct camera3_device *,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_stream_buffer_set_t</span> *buffer_set);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">     * Request creation and submission</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * construct_default_request_settings:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Create capture settings for standard camera use cases.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The device must return a settings buffer that is configured to meet the</span></span><br><span class="line"><span class="comment">     * requested use case, which must be one of the CAMERA3_TEMPLATE_*</span></span><br><span class="line"><span class="comment">     * enums. All request control fields must be included.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL retains ownership of this structure, but the pointer to the</span></span><br><span class="line"><span class="comment">     * structure must be valid until the device is closed. The framework and the</span></span><br><span class="line"><span class="comment">     * HAL may not modify the buffer once it is returned by this call. The same</span></span><br><span class="line"><span class="comment">     * buffer may be returned for subsequent calls for the same template, or for</span></span><br><span class="line"><span class="comment">     * other templates.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This should be a non-blocking call. The HAL should return from this call</span></span><br><span class="line"><span class="comment">     * in 1ms, and must return from this call in 5ms.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   Valid metadata: On successful creation of a default settings</span></span><br><span class="line"><span class="comment">     *                   buffer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   NULL:           In case of a fatal error. After this is returned, only</span></span><br><span class="line"><span class="comment">     *                   the close() method can be called successfully by the</span></span><br><span class="line"><span class="comment">     *                   framework.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">camera_metadata_t</span>* (*construct_default_request_settings)(</span><br><span class="line">            <span class="keyword">const</span> struct camera3_device *,</span><br><span class="line">            <span class="keyword">int</span> type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * process_capture_request:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Send a new capture request to the HAL. The HAL should not return from</span></span><br><span class="line"><span class="comment">     * this call until it is ready to accept the next request to process. Only</span></span><br><span class="line"><span class="comment">     * one call to process_capture_request() will be made at a time by the</span></span><br><span class="line"><span class="comment">     * framework, and the calls will all be from the same thread. The next call</span></span><br><span class="line"><span class="comment">     * to process_capture_request() will be made as soon as a new request and</span></span><br><span class="line"><span class="comment">     * its associated buffers are available. In a normal preview scenario, this</span></span><br><span class="line"><span class="comment">     * means the function will be called again by the framework almost</span></span><br><span class="line"><span class="comment">     * instantly.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The actual request processing is asynchronous, with the results of</span></span><br><span class="line"><span class="comment">     * capture being returned by the HAL through the process_capture_result()</span></span><br><span class="line"><span class="comment">     * call. This call requires the result metadata to be available, but output</span></span><br><span class="line"><span class="comment">     * buffers may simply provide sync fences to wait on. Multiple requests are</span></span><br><span class="line"><span class="comment">     * expected to be in flight at once, to maintain full output frame rate.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework retains ownership of the request structure. It is only</span></span><br><span class="line"><span class="comment">     * guaranteed to be valid during this call. The HAL device must make copies</span></span><br><span class="line"><span class="comment">     * of the information it needs to retain for the capture processing. The HAL</span></span><br><span class="line"><span class="comment">     * is responsible for waiting on and closing the buffers&#x27; fences and</span></span><br><span class="line"><span class="comment">     * returning the buffer handles to the framework.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL must write the file descriptor for the input buffer&#x27;s release</span></span><br><span class="line"><span class="comment">     * sync fence into input_buffer-&gt;release_fence, if input_buffer is not</span></span><br><span class="line"><span class="comment">     * NULL. If the HAL returns -1 for the input buffer release sync fence, the</span></span><br><span class="line"><span class="comment">     * framework is free to immediately reuse the input buffer. Otherwise, the</span></span><br><span class="line"><span class="comment">     * framework will wait on the sync fence before refilling and reusing the</span></span><br><span class="line"><span class="comment">     * input buffer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The input/output buffers provided by the framework in each request</span></span><br><span class="line"><span class="comment">     * may be brand new (having never before seen by the HAL).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * Performance considerations:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Handling a new buffer should be extremely lightweight and there should be</span></span><br><span class="line"><span class="comment">     * no frame rate degradation or frame jitter introduced.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This call must return fast enough to ensure that the requested frame</span></span><br><span class="line"><span class="comment">     * rate can be sustained, especially for streaming cases (post-processing</span></span><br><span class="line"><span class="comment">     * quality settings set to FAST). The HAL should return this call in 1</span></span><br><span class="line"><span class="comment">     * frame interval, and must return from this call in 4 frame intervals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  0:      On a successful start to processing the capture request</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL: If the input is malformed (the settings are NULL when not</span></span><br><span class="line"><span class="comment">     *          allowed, invalid physical camera settings,</span></span><br><span class="line"><span class="comment">     *          there are 0 output buffers, etc) and capture processing</span></span><br><span class="line"><span class="comment">     *          cannot start. Failures during request processing should be</span></span><br><span class="line"><span class="comment">     *          handled by calling camera3_callback_ops_t.notify(). In case of</span></span><br><span class="line"><span class="comment">     *          this error, the framework will retain responsibility for the</span></span><br><span class="line"><span class="comment">     *          stream buffers&#x27; fences and the buffer handles; the HAL should</span></span><br><span class="line"><span class="comment">     *          not close the fences or return these buffers with</span></span><br><span class="line"><span class="comment">     *          process_capture_result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENODEV: If the camera device has encountered a serious error. After this</span></span><br><span class="line"><span class="comment">     *          error is returned, only the close() method can be successfully</span></span><br><span class="line"><span class="comment">     *          called by the framework.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*process_capture_request)(<span class="keyword">const</span> struct camera3_device *,</span><br><span class="line">            <span class="keyword">camera3_capture_request_t</span> *request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">     * Miscellaneous methods</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get_metadata_vendor_tag_ops:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Get methods to query for vendor extension metadata tag information. The</span></span><br><span class="line"><span class="comment">     * HAL should fill in all the vendor tag operation methods, or leave ops</span></span><br><span class="line"><span class="comment">     * unchanged if no vendor tags are defined.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The definition of vendor_tag_query_ops_t can be found in</span></span><br><span class="line"><span class="comment">     * system/media/camera/include/system/camera_metadata.h.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span></span><br><span class="line"><span class="comment">     *    DEPRECATED. This function has been deprecated and should be set to</span></span><br><span class="line"><span class="comment">     *    NULL by the HAL.  Please implement get_vendor_tag_ops in camera_common.h</span></span><br><span class="line"><span class="comment">     *    instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*get_metadata_vendor_tag_ops)(<span class="keyword">const</span> struct camera3_device*,</span><br><span class="line">            <span class="keyword">vendor_tag_query_ops_t</span>* ops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dump:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Print out debugging state for the camera device. This will be called by</span></span><br><span class="line"><span class="comment">     * the framework when the camera service is asked for a debug dump, which</span></span><br><span class="line"><span class="comment">     * happens when using the dumpsys tool, or when capturing a bugreport.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The passed-in file descriptor can be used to write debugging text using</span></span><br><span class="line"><span class="comment">     * dprintf() or write(). The text should be in ASCII encoding only.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This must be a non-blocking call. The HAL should return from this call</span></span><br><span class="line"><span class="comment">     * in 1ms, must return from this call in 10ms. This call must avoid</span></span><br><span class="line"><span class="comment">     * deadlocks, as it may be called at any point during camera operation.</span></span><br><span class="line"><span class="comment">     * Any synchronization primitives used (such as mutex locks or semaphores)</span></span><br><span class="line"><span class="comment">     * should be acquired with a timeout.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*dump)(<span class="keyword">const</span> struct camera3_device *, <span class="keyword">int</span> fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * flush:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Flush all currently in-process captures and all buffers in the pipeline</span></span><br><span class="line"><span class="comment">     * on the given device. The framework will use this to dump all state as</span></span><br><span class="line"><span class="comment">     * quickly as possible in order to prepare for a configure_streams() call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * No buffers are required to be successfully returned, so every buffer</span></span><br><span class="line"><span class="comment">     * held at the time of flush() (whether successfully filled or not) may be</span></span><br><span class="line"><span class="comment">     * returned with CAMERA3_BUFFER_STATUS_ERROR. Note the HAL is still allowed</span></span><br><span class="line"><span class="comment">     * to return valid (CAMERA3_BUFFER_STATUS_OK) buffers during this call,</span></span><br><span class="line"><span class="comment">     * provided they are successfully filled.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * All requests currently in the HAL are expected to be returned as soon as</span></span><br><span class="line"><span class="comment">     * possible.  Not-in-process requests should return errors immediately. Any</span></span><br><span class="line"><span class="comment">     * interruptible hardware blocks should be stopped, and any uninterruptible</span></span><br><span class="line"><span class="comment">     * blocks should be waited on.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * flush() may be called concurrently to process_capture_request(), with the expectation that</span></span><br><span class="line"><span class="comment">     * process_capture_request will return quickly and the request submitted in that</span></span><br><span class="line"><span class="comment">     * process_capture_request call is treated like all other in-flight requests.  Due to</span></span><br><span class="line"><span class="comment">     * concurrency issues, it is possible that from the HAL&#x27;s point of view, a</span></span><br><span class="line"><span class="comment">     * process_capture_request() call may be started after flush has been invoked but has not</span></span><br><span class="line"><span class="comment">     * returned yet. If such a call happens before flush() returns, the HAL should treat the new</span></span><br><span class="line"><span class="comment">     * capture request like other in-flight pending requests (see #4 below).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * More specifically, the HAL must follow below requirements for various cases:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. For captures that are too late for the HAL to cancel/stop, and will be</span></span><br><span class="line"><span class="comment">     *    completed normally by the HAL; i.e. the HAL can send shutter/notify and</span></span><br><span class="line"><span class="comment">     *    process_capture_result and buffers as normal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. For pending requests that have not done any processing, the HAL must call notify</span></span><br><span class="line"><span class="comment">     *    CAMERA3_MSG_ERROR_REQUEST, and return all the output buffers with</span></span><br><span class="line"><span class="comment">     *    process_capture_result in the error state (CAMERA3_BUFFER_STATUS_ERROR).</span></span><br><span class="line"><span class="comment">     *    The HAL must not place the release fence into an error state, instead,</span></span><br><span class="line"><span class="comment">     *    the release fences must be set to the acquire fences passed by the framework,</span></span><br><span class="line"><span class="comment">     *    or -1 if they have been waited on by the HAL already. This is also the path</span></span><br><span class="line"><span class="comment">     *    to follow for any captures for which the HAL already called notify() with</span></span><br><span class="line"><span class="comment">     *    CAMERA3_MSG_SHUTTER but won&#x27;t be producing any metadata/valid buffers for.</span></span><br><span class="line"><span class="comment">     *    After CAMERA3_MSG_ERROR_REQUEST, for a given frame, only process_capture_results with</span></span><br><span class="line"><span class="comment">     *    buffers in CAMERA3_BUFFER_STATUS_ERROR are allowed. No further notifys or</span></span><br><span class="line"><span class="comment">     *    process_capture_result with non-null metadata is allowed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. For partially completed pending requests that will not have all the output</span></span><br><span class="line"><span class="comment">     *    buffers or perhaps missing metadata, the HAL should follow below:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.1. Call notify with CAMERA3_MSG_ERROR_RESULT if some of the expected result</span></span><br><span class="line"><span class="comment">     *    metadata (i.e. one or more partial metadata) won&#x27;t be available for the capture.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.2. Call notify with CAMERA3_MSG_ERROR_BUFFER for every buffer that won&#x27;t</span></span><br><span class="line"><span class="comment">     *         be produced for the capture.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.3  Call notify with CAMERA3_MSG_SHUTTER with the capture timestamp before</span></span><br><span class="line"><span class="comment">     *         any buffers/metadata are returned with process_capture_result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.4 For captures that will produce some results, the HAL must not call</span></span><br><span class="line"><span class="comment">     *        CAMERA3_MSG_ERROR_REQUEST, since that indicates complete failure.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.5. Valid buffers/metadata should be passed to the framework as normal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.6. Failed buffers should be returned to the framework as described for case 2.</span></span><br><span class="line"><span class="comment">     *         But failed buffers do not have to follow the strict ordering valid buffers do,</span></span><br><span class="line"><span class="comment">     *         and may be out-of-order with respect to valid buffers. For example, if buffers</span></span><br><span class="line"><span class="comment">     *         A, B, C, D, E are sent, D and E are failed, then A, E, B, D, C is an acceptable</span></span><br><span class="line"><span class="comment">     *         return order.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.7. For fully-missing metadata, calling CAMERA3_MSG_ERROR_RESULT is sufficient, no</span></span><br><span class="line"><span class="comment">     *         need to call process_capture_result with NULL metadata or equivalent.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 4. If a flush() is invoked while a process_capture_request() invocation is active, that</span></span><br><span class="line"><span class="comment">     *    process call should return as soon as possible. In addition, if a process_capture_request()</span></span><br><span class="line"><span class="comment">     *    call is made after flush() has been invoked but before flush() has returned, the</span></span><br><span class="line"><span class="comment">     *    capture request provided by the late process_capture_request call should be treated like</span></span><br><span class="line"><span class="comment">     *    a pending request in case #2 above.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * flush() should only return when there are no more outstanding buffers or</span></span><br><span class="line"><span class="comment">     * requests left in the HAL. The framework may call configure_streams (as</span></span><br><span class="line"><span class="comment">     * the HAL state is now quiesced) or may issue new requests.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that it&#x27;s sufficient to only support fully-succeeded and fully-failed result cases.</span></span><br><span class="line"><span class="comment">     * However, it is highly desirable to support the partial failure cases as well, as it</span></span><br><span class="line"><span class="comment">     * could help improve the flush call overall performance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL should return from this call in 100ms, and must return from this</span></span><br><span class="line"><span class="comment">     * call in 1000ms. And this call must not be blocked longer than pipeline</span></span><br><span class="line"><span class="comment">     * latency (see S7 for definition).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   only available if device version &gt;= CAMERA_DEVICE_API_VERSION_3_1.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  0:      On a successful flush of the camera HAL.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL: If the input is malformed (the device is not valid).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENODEV: If the camera device has encountered a serious error. After this</span></span><br><span class="line"><span class="comment">     *          error is returned, only the close() method can be successfully</span></span><br><span class="line"><span class="comment">     *          called by the framework.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*flush)(<span class="keyword">const</span> struct camera3_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * signal_stream_flush:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;= CAMERA_DEVICE_API_VERISON_3_5:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    Not defined and must be NULL</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERISON_3_6:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Signaling HAL camera service is about to perform configure_streams() call</span></span><br><span class="line"><span class="comment">     * and HAL must return all buffers of designated streams. HAL must finish</span></span><br><span class="line"><span class="comment">     * inflight requests normally and return all buffers belonging to the</span></span><br><span class="line"><span class="comment">     * designated streams through process_capture_result() or</span></span><br><span class="line"><span class="comment">     * return_stream_buffers() API in a timely manner, or camera service will run</span></span><br><span class="line"><span class="comment">     * into a fatal error.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that this call serves as an optional hint and camera service may</span></span><br><span class="line"><span class="comment">     * skip calling this if all buffers are already returned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*signal_stream_flush)(<span class="keyword">const</span> struct camera3_device*,</span><br><span class="line">            <span class="keyword">uint32_t</span> num_streams,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_stream_t</span>* <span class="keyword">const</span>* streams);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * is_reconfiguration_required:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;= CAMERA_DEVICE_API_VERISON_3_5:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    Not defined and must be NULL</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERISON_3_6:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Check whether complete stream reconfiguration is required for possible new session</span></span><br><span class="line"><span class="comment">     * parameter values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method must be called by the camera framework in case the client changes</span></span><br><span class="line"><span class="comment">     * the value of any advertised session parameters. Depending on the specific values</span></span><br><span class="line"><span class="comment">     * the HAL can decide whether a complete stream reconfiguration is required. In case</span></span><br><span class="line"><span class="comment">     * the HAL returns -ENVAL, the camera framework must skip the internal reconfiguration.</span></span><br><span class="line"><span class="comment">     * In case Hal returns 0, the framework must reconfigure the streams and pass the</span></span><br><span class="line"><span class="comment">     * new session parameter values accordingly.</span></span><br><span class="line"><span class="comment">     * This call may be done by the framework some time before the request with new parameters</span></span><br><span class="line"><span class="comment">     * is submitted to the HAL, and the request may be cancelled before it ever gets submitted.</span></span><br><span class="line"><span class="comment">     * Therefore, the HAL must not use this query as an indication to change its behavior in any</span></span><br><span class="line"><span class="comment">     * way.</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Preconditions:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework can call this method at any time after active</span></span><br><span class="line"><span class="comment">     * session configuration. There must be no impact on the performance of</span></span><br><span class="line"><span class="comment">     * pending camera requests in any way. In particular there must not be</span></span><br><span class="line"><span class="comment">     * any glitches or delays during normal camera streaming.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     * HW and SW camera settings must not be changed and there must not be</span></span><br><span class="line"><span class="comment">     * a user-visible impact on camera performance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param oldSessionParams The currently applied session parameters.</span></span><br><span class="line"><span class="comment">     * @param newSessionParams The new session parameters set by client.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return Status Status code for the operation, one of:</span></span><br><span class="line"><span class="comment">     * 0:                    In case the stream reconfiguration is required</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL:              In case the stream reconfiguration is not required.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENOSYS:              In case the camera device does not support the</span></span><br><span class="line"><span class="comment">     *                       reconfiguration query.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*is_reconfiguration_required)(<span class="keyword">const</span> struct camera3_device*,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera_metadata_t</span>* old_session_params,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera_metadata_t</span>* new_session_params);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reserved for future use */</span></span><br><span class="line">    <span class="keyword">void</span> *reserved[<span class="number">6</span>];</span><br><span class="line">&#125; <span class="keyword">camera3_device_ops_t</span>;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看见，该结构体定义了一系列的函数指针，用来指向平台厂商实际的实现方法，接下来就其中几个方法简单介绍下：<br>a) initialize<br>该方法必须在camera_moudel_t中的open方法之后，其它camera3_device_ops中方法之前被调用，主要用来将上层实现的回调方法注册到HAL中，并且根据需要在该方法中加入自定义的一些初始化操作，另外，谷歌针对该方法在性能方面也有严格的限制，该方法需要在5ms内返回，最长不能超过10ms。<br>b) configure_streams<br>该方法在完成initialize方法之后，在调用process_capture_request方法之前被调用，主要用于重设当前正在运行的Pipeline以及设置新的输入输出流，其中它会将stream_list中的新的数据流替换之前配置的数据流。在调用该方法之前必须确保没有新的request下发并且当前request的动作已经完成，否则会引起无法预测的错误。一旦HAL调用了该方法，则必须在内部配置好满足当前数据流配置的帧率，确保这个流程的运行的顺畅性。<br>其中包含了两个参数，分别是camera3_device以及stream_list(camera3_stream_configuration_t ),其中第二个参数是上层传入的数据流配置列表，该列表中必须包含至少一个output stream，同时至多包含一个input stream。<br>另外，谷歌针对该方法有着严格的性能要求，平台厂商在实现该方法的时候，需要在500ms内返回，最长不能超过1000ms。<br>c) construct_default_request_settings<br>该方法主要用于构建一系列默认的Camera Usecase的capture 设置项，通过camera_metadata_t来进行描述，其中返回值是一个camera_metadata_t指针，其指向的内存地址是由HAL来进行维护的，同样地，该方法需要在1ms内返回，最长不能超过5ms。<br>d) process_capture_request<br>该方法用于下发单次新的capture request到HAL中， 上层必须保证该方法的调用都是在一个线程中完成，而且该方法是异步的，同时其结果并不是通过返回值给到上层，而是通过HAL调用另一个接口process_capture_result()来将结果返回给上层的，在使用的过程中，通过in-flight机制，保证短时间内下发足够多的request，从而满足帧率要求。<br>该方法的性能依然受到谷歌的严格要求，规定其需要在一帧图像处理完的时长内返回，最长不超过4帧图像处理完成的时长，比如当前预览帧率是30帧，则该方法的操作耗时最长不能超过120ms，否则便会引起明显的帧抖动，从而影响用户体验。<br>e) dump<br>该方法用于打印当前Camera设备的状态，一般是由上层通过dumpsys工具输出debug dump信息或者主动抓取bugreport的时候被调用，该方法必须是非阻塞实现，同时需要保证在1ms内返回，最长不能超过10ms。<br>f) flush<br>当上层需要执行新的configure_streams的时候，需要调用该方法去尽可能快地清除掉当前已经在处理中的或者即将处理的任务，为配置数据流提供一个相对稳定的环境，其具体工作如下：</p>
<ul>
<li>所有的还在流转的request会尽可能快的返回</li>
<li>并未开始进行流转的request会直接返回，并携带错误信息</li>
<li>任何可以打断的硬件操作会立即被停止</li>
<li>任何无法进行打断的硬件操作会在当前状态下进行休眠</li>
</ul>
<p>flush会在所有的buffer都得以释放，所有request都成功返回后才真正返回，该方法需要在100ms内返回，最长不能超过1000ms。</p>
<p>上面的一系列方法是上层直接对下控制Camera Hal，而一旦Camera Hal产生了数据或者事件的时候，可以通过camera3_callback_ops中定义的回调方法将数据或者事件返回至上层，该结构体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera3_callback_ops</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * process_capture_result:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Send results from a completed capture to the framework.</span></span><br><span class="line"><span class="comment">     * process_capture_result() may be invoked multiple times by the HAL in</span></span><br><span class="line"><span class="comment">     * response to a single capture request. This allows, for example, the</span></span><br><span class="line"><span class="comment">     * metadata and low-resolution buffers to be returned in one call, and</span></span><br><span class="line"><span class="comment">     * post-processed JPEG buffers in a later call, once it is available. Each</span></span><br><span class="line"><span class="comment">     * call must include the frame number of the request it is returning</span></span><br><span class="line"><span class="comment">     * metadata or buffers for.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A component (buffer or metadata) of the complete result may only be</span></span><br><span class="line"><span class="comment">     * included in one process_capture_result call. A buffer for each stream,</span></span><br><span class="line"><span class="comment">     * and the result metadata, must be returned by the HAL for each request in</span></span><br><span class="line"><span class="comment">     * one of the process_capture_result calls, even in case of errors producing</span></span><br><span class="line"><span class="comment">     * some of the output. A call to process_capture_result() with neither</span></span><br><span class="line"><span class="comment">     * output buffers or result metadata is not allowed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The order of returning metadata and buffers for a single result does not</span></span><br><span class="line"><span class="comment">     * matter, but buffers for a given stream must be returned in FIFO order. So</span></span><br><span class="line"><span class="comment">     * the buffer for request 5 for stream A must always be returned before the</span></span><br><span class="line"><span class="comment">     * buffer for request 6 for stream A. This also applies to the result</span></span><br><span class="line"><span class="comment">     * metadata; the metadata for request 5 must be returned before the metadata</span></span><br><span class="line"><span class="comment">     * for request 6.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * However, different streams are independent of each other, so it is</span></span><br><span class="line"><span class="comment">     * acceptable and expected that the buffer for request 5 for stream A may be</span></span><br><span class="line"><span class="comment">     * returned after the buffer for request 6 for stream B is. And it is</span></span><br><span class="line"><span class="comment">     * acceptable that the result metadata for request 6 for stream B is</span></span><br><span class="line"><span class="comment">     * returned before the buffer for request 5 for stream A is.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL retains ownership of result structure, which only needs to be</span></span><br><span class="line"><span class="comment">     * valid to access during this call. The framework will copy whatever it</span></span><br><span class="line"><span class="comment">     * needs before this call returns.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The output buffers do not need to be filled yet; the framework will wait</span></span><br><span class="line"><span class="comment">     * on the stream buffer release sync fence before reading the buffer</span></span><br><span class="line"><span class="comment">     * data. Therefore, this method should be called by the HAL as soon as</span></span><br><span class="line"><span class="comment">     * possible, even if some or all of the output buffers are still in</span></span><br><span class="line"><span class="comment">     * being filled. The HAL must include valid release sync fences into each</span></span><br><span class="line"><span class="comment">     * output_buffers stream buffer entry, or -1 if that stream buffer is</span></span><br><span class="line"><span class="comment">     * already filled.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the result buffer cannot be constructed for a request, the HAL should</span></span><br><span class="line"><span class="comment">     * return an empty metadata buffer, but still provide the output buffers and</span></span><br><span class="line"><span class="comment">     * their sync fences. In addition, notify() must be called with an</span></span><br><span class="line"><span class="comment">     * ERROR_RESULT message.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If an output buffer cannot be filled, its status field must be set to</span></span><br><span class="line"><span class="comment">     * STATUS_ERROR. In addition, notify() must be called with a ERROR_BUFFER</span></span><br><span class="line"><span class="comment">     * message.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the entire capture has failed, then this method still needs to be</span></span><br><span class="line"><span class="comment">     * called to return the output buffers to the framework. All the buffer</span></span><br><span class="line"><span class="comment">     * statuses should be STATUS_ERROR, and the result metadata should be an</span></span><br><span class="line"><span class="comment">     * empty buffer. In addition, notify() must be called with a ERROR_REQUEST</span></span><br><span class="line"><span class="comment">     * message. In this case, individual ERROR_RESULT/ERROR_BUFFER messages</span></span><br><span class="line"><span class="comment">     * should not be sent.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This is a non-blocking call. The framework will return this call in 5ms.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The pipeline latency (see S7 for definition) should be less than or equal to</span></span><br><span class="line"><span class="comment">     * 4 frame intervals, and must be less than or equal to 8 frame intervals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*process_capture_result)(<span class="keyword">const</span> struct camera3_callback_ops *,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_capture_result_t</span> *result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * notify:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Asynchronous notification callback from the HAL, fired for various</span></span><br><span class="line"><span class="comment">     * reasons. Only for information independent of frame capture, or that</span></span><br><span class="line"><span class="comment">     * require specific timing. The ownership of the message structure remains</span></span><br><span class="line"><span class="comment">     * with the HAL, and the msg only needs to be valid for the duration of this</span></span><br><span class="line"><span class="comment">     * call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Multiple threads may call notify() simultaneously.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;= CAMERA_DEVICE_API_VERSION_3_1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The notification for the start of exposure for a given request must be</span></span><br><span class="line"><span class="comment">     * sent by the HAL before the first call to process_capture_result() for</span></span><br><span class="line"><span class="comment">     * that request is made.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Buffers delivered to the framework will not be dispatched to the</span></span><br><span class="line"><span class="comment">     * application layer until a start of exposure timestamp (or input image&#x27;s</span></span><br><span class="line"><span class="comment">     * start of exposure timestamp for a reprocess request) has been received</span></span><br><span class="line"><span class="comment">     * via a SHUTTER notify() call. It is highly recommended to dispatch this</span></span><br><span class="line"><span class="comment">     * call as early as possible.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This is a non-blocking call. The framework will return this call in 5ms.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*notify)(<span class="keyword">const</span> struct camera3_callback_ops *,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_notify_msg_t</span> *msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * request_stream_buffers:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;= CAMERA_DEVICE_API_VERISON_3_5:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    DO NOT USE: not defined and must be NULL.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERISON_3_6:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Synchronous callback for HAL to ask for output buffer from camera service.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This call may be serialized in camera service so it is strongly</span></span><br><span class="line"><span class="comment">     * recommended to only call this method from one thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When camera device advertises</span></span><br><span class="line"><span class="comment">     * (android.info.supportedBufferManagementVersion ==</span></span><br><span class="line"><span class="comment">     * ANDROID_INFO_SUPPORTED_BUFFER_MANAGEMENT_VERSION_HIDL_DEVICE_3_5), HAL</span></span><br><span class="line"><span class="comment">     * can use this method to request buffers from camera service.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Caller is responsible for allocating enough memory for returned_buf_reqs</span></span><br><span class="line"><span class="comment">     * argument (num_buffer_reqs * sizeof(camera3_stream_buffer_ret_t)) bytes</span></span><br><span class="line"><span class="comment">     * and also the memory for the output_buffers field in each</span></span><br><span class="line"><span class="comment">     * camera3_stream_buffer_ret_t</span></span><br><span class="line"><span class="comment">     * (num_buffers_requested * sizeof(camera3_stream_buffer_t)) bytes</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     * This is a blocking call that takes more time with more buffers requested.</span></span><br><span class="line"><span class="comment">     * HAL should not request large amount of buffers on a latency critical code</span></span><br><span class="line"><span class="comment">     * path. It is highly recommended to use a dedicated thread to perform</span></span><br><span class="line"><span class="comment">     * all requestStreamBuffer calls, and adjust the thread priority and/or</span></span><br><span class="line"><span class="comment">     * timing of making the call in order for buffers to arrive before HAL is</span></span><br><span class="line"><span class="comment">     * ready to fill the buffer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">camera3_buffer_request_status_t</span> (*request_stream_buffers)(</span><br><span class="line">            <span class="keyword">const</span> struct camera3_callback_ops *,</span><br><span class="line">            <span class="keyword">uint32_t</span> num_buffer_reqs,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_buffer_request_t</span> *buffer_reqs,</span><br><span class="line">            <span class="comment">/*out*/</span><span class="keyword">uint32_t</span> *num_returned_buf_reqs,</span><br><span class="line">            <span class="comment">/*out*/</span><span class="keyword">camera3_stream_buffer_ret_t</span> *returned_buf_reqs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * return_stream_buffers:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;= CAMERA_DEVICE_API_VERISON_3_5:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    DO NOT USE: not defined and must be NULL.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERISON_3_6:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Synchronous callback for HAL to return output buffers to camera service.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If this method is called during a configure_streams() call, it will be</span></span><br><span class="line"><span class="comment">     * blocked until camera service finishes the ongoing configure_streams() call.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*return_stream_buffers)(</span><br><span class="line">            <span class="keyword">const</span> struct camera3_callback_ops *,</span><br><span class="line">            <span class="keyword">uint32_t</span> num_buffers,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_stream_buffer_t</span>* <span class="keyword">const</span>* buffers);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">camera3_callback_ops_t</span>;</span><br></pre></td></tr></table></figure>
<p>其中常用的回调方法主要有两个：用于返回数据的process_capture_result以及用于返回事件的notify，接下来分别介绍下：<br>a) process_capture_result<br>该方法用于返回HAL部分产生的metadata和image buffers，它与request是多对一的关系，同一个request，可能会对应到几个result，比如可以通过调用一次该方法用于返回metadata以及低分辨率的图像数据，再调用一次该方法用于返回jpeg格式的拍照数据，而这两次调用时对应于同一个process_capture_request动作。<br>同一个request的metadata以及image buffers的先后顺序无关紧要，但是同一个数据流的不同Request之间的Result必须严格按照request的下发先后顺序进行依次返回的，如若不然，会导致图像数据显示出现顺序错乱的情况。<br>该方法是非阻塞的，而且并且必须要在5ms内返回。<br>b) notify<br>该方法用于异步返回HAL事件到上层，必须非阻塞实现，而且要在5ms内返回。<br>谷歌为了将系统框架和平台厂商的自定义部分相分离，在Android上推出了Treble项目，该项目直接将平台厂商的实现部分放入vendor分区中进行管理，进而与system分区保持隔离，这样便可以在相互独立的空间中进行各自的迭代升级，而互不干扰，而在相机框架体系中，便将Camera HAL Module从Camera Service中解耦出来，放入独立进程Camera Provider中进行管理，而为了更好的进行跨进程访问，谷歌针对Provider提出了HIDL机制用于Camera Servic对于Camera Provier的访问，而HIDL接口的实现是在Camera Provider中实现，针对Camera HAL Module的控制又是通过谷歌制定的Camera HAL3接口来完成，所以由此看来，Provider的职责也比较简单，通过HIDL机制保持与Camera Service的通信，通过HAL3接口控制着Camera HAL Module。</p>
]]></content>
      <categories>
        <category>1. Android Camera</category>
      </categories>
      <tags>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Android相机体系结构之八：相机驱动层–高通KMD框架详解</title>
    <url>/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>1. Android Camera</category>
      </categories>
      <tags>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Android相机体系结构之六：相机硬件抽象层实现</title>
    <url>/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-6/</url>
    <content><![CDATA[<h2 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h2><p>回顾高通平台Camera HAL历史，其实不难发现之前高通采用的是QCamera &amp; MM-Camera架构，但是为了更精细化控制底层硬件(Sensor/ISP等关键硬件)，同时方便手机厂商自定义一些功能，现在提出了CamX-CHI架构，由于在CamX-CHI中完全看不到之前老架构的影子，所以它完全是一个全新的架构，它将一些高度统一的功能性接口抽离出来放到CamX中，将可定制化的部分放在CHI中供不同厂商进行修改，实现各自独有的特色功能，这样设计的好处显而易见，那便是即便开发者对于CamX并不是很了解，但是依然可以很方便的加入自定义的功能，从而降低了开发者在高通平台的开发门槛。<br>接下来我们以最直观的目录结构入手对该架构做一个简单的认识，以下便是CamX-CHI基本目录结构：<br><img src="Image.png" alt="alt text"></p>
<span id="more"></span>
<p>该部分代码主要位于 vendor/qcom/proprietary/ 目录下</p>
<p>其中 camx 代表了通用功能性接口的代码实现集合（CamX），chi-cdk代表了可定制化需求的代码实现集合（CHI），从图中不难看出camx部分对上作为HAL3接口的实现，对下<br>通过v4l2框架与Kernel保持通讯，中间通过互相dlopen so库并获取对方操作接口的方式保持着与CHI的交互。</p>
<p>camx/中有如下几个主要目录：</p>
<ul>
<li>core/ ： 用于存放camx的核心实现模块，其中还包含了主要用于实现hal3接口的hal/目录，以及负责与CHI进行交互的chi/目录</li>
<li>csl/： 用于存放主要负责camx与camera driver的通讯模块，为camx提供了统一的Camera driver控制接口</li>
<li>hwl/: 用于存放自身具有独立运算能力的硬件node，该部分node受csl管理</li>
<li>swl/: 用于存放自身并不具有独立运算能力，必须依靠CPU才能实现的node</li>
</ul>
<p>chi-cdk/中有如下几个主要目录：</p>
<ul>
<li>chioverride/: 用于存放CHI实现的核心模块，负责与camx进行交互并且实现了CHI的总体框架以及具体的业务处理。</li>
<li>bin/: 用于存放平台相关的配置项</li>
<li>topology/: 用于存放用户自定的Usecase xml配置文件</li>
<li>node/: 用于存放用户自定义功能的node</li>
<li>module/: 用于存放不同sensor的配置文件，该部分在初始化sensor的时候需要用到</li>
<li>tuning/: 用于存放不同场景下的效果参数的配置文件</li>
<li>sensor/: 用于存放不同sensor的自有信息以及寄存器配置参数</li>
<li>actuator/: 用于存放不同对焦模块的配置信息</li>
<li>ois/： 用于存放防抖模块的配置信息</li>
<li>flash/： 存放着闪光灯模块的配置信息</li>
<li>eeprom/: 存放着eeprom外部存储模块的配置信息</li>
<li>fd/: 存放了人脸识别模块的配置信息</li>
</ul>
<h2 id="二、基本组件概念"><a href="#二、基本组件概念" class="headerlink" title="二、基本组件概念"></a>二、基本组件概念</h2><h3 id="1-Usecase"><a href="#1-Usecase" class="headerlink" title="1. Usecase"></a>1. Usecase</h3><p>作为CamX-CHI中最大的抽象概念，其中包含了多条实现特定功能的Pipeline，具体实现是在CHI中通过Usecase类完成的，该类主要负责了其中的业务处理以及资源的管理。</p>
<p>Usecase类，提供了一系列通用接口，作为现有的所有Usecase的基类，其中，AdvancedCameraUsecase又继承于CameraUsecaseBase，相机中绝大部分场景会通过实例化AdvancedCameraUsecase来完成，它包括了几个主要接口：</p>
<ul>
<li>Create(): 该方法是静态方法，用于创建一个AdvancedCameraUsecase实例，在其构造方法中会去获取XML中的相应的Usecase配置信息。</li>
<li>ExecuteCaptureRequest(): 该方法用于下发一次Rrequest请求。</li>
<li>ProcessResultCb(): 该方法会在创建Session的过程中，作为回调方法注册到其中，一旦Session数据处理完成的时候便会调用该方法将结果发送到AdvancedCameraUsecase中。</li>
<li>ProcessDriverPartialCaptureResult(): 该方法会在创建Session的过程中，作为回调方法注册到其中，一旦Session中产生了partial meta data的时候，便会调用该方法将其发送至AdvancedCameraUsecase中。</li>
<li>ProcessMessageCb(): 该方法会在创建Session的过程中，作为回调方法注册到其中，一旦Session产生任何事件，便会调用该方法通知到AdvancedCameraUsecase中。</li>
<li>ExecuteFlush(): 该方法用于刷新AdvancedCameraUsecase。</li>
<li>Destroy(): 该方法用于安全销毁AdvancedCameraUsecase。</li>
</ul>
<p>Usecase的可定制化部分被抽象出来放在了common_usecase.xml文件中，这里简单介绍其中的几个主要的标签含义：</p>
<ul>
<li>UsecaseName: 代表了该Usecase的名字，后期根据这个名字找到这个Usecase的定义。</li>
<li>Targets: 用于表示用于输出的数据流的集合，其中包括了数据流的格式，输出Size的范围等。</li>
<li>Pipeline: 用于定义该Usecase可以是使用的所有Pipeline，这里必须至少定义一条Pipeline。</li>
</ul>
<h3 id="2-Feature"><a href="#2-Feature" class="headerlink" title="2. Feature"></a>2. Feature</h3><p>代表了一个特定的功能，该功能需要多条Pipeline组合起来实现，受Usecase统一管理，在CHI中通过Feature类进行实现，在XML中没有对应的定义，具体的Feature选取工作是在Usecase中完成的，通过在创建Feature的时候，传入Usecase的实例的方式，来和Usecase进行相互访问各自的资源。</p>
<p>以下是现有的Feature，其中Feature作为基类存在，定义了一系列通用方法。<br><img src="Image-1.png" alt="alt text"></p>
<p>几个常用的Feature:</p>
<ul>
<li>FeatureHDR: 用于实现HDR功能，它负责管理内部的一条或者几条pipeline的资源以及它们的流转，最终输出具有HDR效果的图像。</li>
<li>FeatureMFNR: 用于实现MFNR功能，内部分为几个大的流程，分别包括Prefiltering、Blending、Postfilter以及最终的OfflineNoiseReproces(这一个是可选择使能的)，每一个小功能中包含了各自的pipeline。</li>
<li>FeatureASD: 用于AI功能的实现，在预览的时候，接收每一帧数据，并且进行分析当前场景的AI识别输出结果，并其通过诸如到metadata方式给到上层，进行后续的处理。</li>
</ul>
<h3 id="3-Session"><a href="#3-Session" class="headerlink" title="3. Session"></a>3. Session</h3><p>用于管理pipeline的抽象控制单元，一个Session中至少拥有一个pipeine，并且控制着所有的硬件资源，管控着每一个内部pipeline的request的流转以及数据的输入输出，它没有可定制化的部分，所以在CHI中的XML文件中并没有将Session作为一个独立的单元进行定义。<br>Session的实现主要通过CamX中的Session类，其主要接口如下：</p>
<ul>
<li>Initialize(): 根据传入的参数SessionCreateData进行Session的初始化工作。</li>
<li>NotifyResult(): 内部的Pipeline通过该接口将结果发送到Session中。</li>
<li>ProcessCaptureRequest(): 该方法用于用户决定发送一个Request到Session中的时候调用。</li>
<li>StreamOn(): 通过传入的Pipeline句柄，开始硬件的数据传输。</li>
<li>StreamOff(): 通过传入的Pipeline句柄，停止硬件的数据传输。</li>
</ul>
<h3 id="4-Pipeline"><a href="#4-Pipeline" class="headerlink" title="4. Pipeline"></a>4. Pipeline</h3><p>作为提供单一特定功能的所有资源的集合，维护着所有硬件资源以及数据的流转，每一个Pipeline包括了其中的Node/Link，在CamX中通过Pipeline类进行实现，负责整条Pipeline的软硬件资源的维护以及业务逻辑的处理，接下来我们简单看下该类的几个主要接口：</p>
<ul>
<li>Create(): 该方法是一个静态方法，根据传入的PipelineCreateInputData信息来实例化一个Pipeline对象。</li>
<li>StreamOn(): 通知Pipeline开始硬件的数据传输</li>
<li>StreamOff(): 通知Pipeline停止硬件的数据传输</li>
<li>FinalizePipeline(): 用于完成Pipeline的设置工作</li>
<li>OpenRequest(): open一个CSL用于流转的Request</li>
<li>ProcessRequest(): 开始下发Request</li>
<li>NotifyNodeMetadataDone(): 该方法是Pipeline提供给Node，当Node内部生成了metadata,便会调用该方法来通知metadata已经完成，最后当所有Node都通知Pipeline metadata已经完成，Pipeline 便会调用ProcessMetadataRequestIdDone通知Session。</li>
<li>NotifyNodePartialMetadataDone(): 该方法是Pipeline提供给Node，当Node内部生成了partial metadata,便会调用该方法来通知metadata已经完成，最后当所有Node都通知Pipeline metadata已经完成，Pipeline 便会调用ProcessPartialMetadataRequestIdDone通知Session。</li>
<li>SinkPortFenceSignaled(): 用来通知Session 某个sink port的fence处于被触发的状态。</li>
<li>NonSinkPortFenceSignaled(): 用来通知Session 某个non sink port的fence处于被触发的状态。</li>
</ul>
<p>Pipeline中的Node以及连接方式都在XML中被定义，其主要包含了以下几个标签定义：</p>
<ul>
<li>PipelineName: 用来定义该条Pipeline的名称</li>
<li>NodeList: 该标签中定义了该条Pipeline的所有的Node</li>
<li>PortLinkages: 该标签定义了Node上不同端口之间的连接关系</li>
</ul>
<h3 id="5-Node"><a href="#5-Node" class="headerlink" title="5. Node"></a>5. Node</h3><p>作为单个具有独立处理功能的抽象模块，可以是硬件单元也可以是软件单元，关于Node的具体实现是CamX中的Node类来完成的，其中CamX-CHI中主要分为两个大类，一个是高通自己实现的Node包括硬件Node，一个是CHI中提供给用户进行实现的Node，其主要方法如下：</p>
<ul>
<li>Create(): 该方法是静态方法，用于实例化一个Node对象。</li>
<li>ExecuteProcessRequest(): 该方法用于针对hwl node下发request的操作。</li>
<li>ProcessRequestIdDone(): 一旦该Node当前request已经处理完成，便会通过调用该方法通知Pipeline。</li>
<li>ProcessMetadataDone(): 一旦该Node的当前request的metadata已经生成，便会通过调用该方法通知到Pipeline。</li>
<li>ProcessPartialMetadataDone(): 一旦该Node的当前request的partial metadata已经生成，便会通过调用该方法通知到Pipeline。</li>
<li>CreateImageBufferManager(): 创建ImageBufferManager</li>
</ul>
<p>其可定制化的部分作为标签在XML中进行定义：</p>
<ul>
<li>NodeName： 用来定义该Node的名称</li>
<li>NodeId: 用来指定该Node的ID，其中IPE NodeId为65538，IFE NodeId为65536，用户自定义的NodeId为255。</li>
<li>NodeInstance: 用于定义该Node的当前实例的名称。</li>
<li>NodeInstanceId: 用于指定该Node实例的Id。</li>
</ul>
<h3 id="6-Link"><a href="#6-Link" class="headerlink" title="6. Link"></a>6. Link</h3><p>用于定义不同Port的连接，一个Port可以根据需要建立多条与其它从属于不同Node的Port的连接,它通过标签来进行定义，其中包括了作为输入端口，作为输出端口。<br>一个Link中包含了一个SrcPort和一个DstPort,分别代表了输入端口和输出端口，然后BufferProperties用于表示两个端口之间的buffer配置。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><ol start="7">
<li>Port<br>作为Node的输入输出的端口，在XML文件中，标签用来定义一个输入端口，标签用来定义输出端口，每一个Node都可以根据需要使用一个或者多个输入输出端口，使用OutputPort以及InputPort结构体来进行在代码中定义。<br>Port</li>
</ol>
<ul>
<li>PortId: 该端口的Id: 该端口的名称</li>
<li>NodeName: 该端口从属的Node名称</li>
<li>NodeId: 该端口从属的Node的Id</li>
<li>NodeInstance: 该端口从属的Node的实例名称</li>
<li>NodeInstanceId: 该端口从属的Node的实例的Id</li>
</ul>
<h3 id="三、组件结构关系"><a href="#三、组件结构关系" class="headerlink" title="三、组件结构关系"></a>三、组件结构关系</h3><p>通过之前的介绍，我们对于几个基本组件有了一个比较清晰地认识，但是任何一个框架体系并不是仅靠组件胡乱堆砌而成的，相反，它们都必须基于各自的定位，按照各自所独有的行为模式，同时按照约定俗称的一系列规则组合起来，共同完成整个框架某一特定的功能。所以这里不得不产生一个疑问，在该框架中它们到底是如何组织起来的呢？它们之间的关系又是如何的呢？ 接下来我们以下图入手开始进行分析：<br><img src="Image-2.png" alt="alt text"><br>由上图可以看到，几者是通过包含关系组合起来的，Usecase 包含Feature，而Feature包含了Session，Session有维护了内部的Pipeline的流转，而每一条pipeline中有通过Link将所有Node都连接了起来，接下我们就这几种关系详细讲解下：</p>
<p>首先，一个Usecase代表了某个特定的图像采集场景，比如人像场景，后置拍照场景等等，在初始化的时候通过根据上层传入的一些具体信息来进行创建，这个过程中，一方面实例化了特定的Usecase，这个实例是用来管理整个场景的所有资源，同时也负责了其中的业务处理逻辑，另一方面，获取了定义在XML中的特定Usecase，获取了用于实现某些特定功能的pipeline。</p>
<p>其次，在Usecase中，Feature是一个可选项，如果当前用户选择了HDR模式或者需要在Zoom下进行拍照等特殊功能的话，在Usecase创建过程中，便会根据需要创建一个或者多个Feature，一般一个Feature对应着一个特定的功能，如果场景中并不需要任何特定的功能，则也完全可以不使用也不创建任何Feature。</p>
<p>然后，每一个Usecase或者Feature都可以包含一个或者多个Session，每一个Session都是直接管理并负责了内部的Pipeline的数据流转，其中每一次的Request都是Usecase或者Featuret通过Session下发到内部的Pipeline进行处理，数据处理完成之后也是通过Session的方法将结果给到CHI中，之后是直接给到上层还是将数据封装下再次下发到另一个Session中进行后处理，这都交由CHI来决定。</p>
<p>其中，Session和Pipeline是一对多的关系，通常一个Session只包含了一条Pipeline，用于某个特定图像处理功能的实现，但是也不绝对，比如FeatureMFNR中包含的Session就包括了三条pipeline，又比如后置人像预览，也是用一个Session包含了两条分别用于主副双摄预览的Pipeline，主要是要看当前功能需要的pipeline数量以及它们之间是否存在一定关联。</p>
<p>同时，根据上面关于Pipeline的定义，它内部包含了一定数量的Node，并且实现的功能越复杂，所包含的Node也就越多，同时Node之间的连接也就越错综复杂，比如后置人像预览虚化效果的实现就是将拿到的主副双摄的图像通过RBOfflinePreview这一条Pipeline将两帧图像合成一帧具有虚化效果的图像，从而完成了虚化功能。</p>
<p>最后Pipeline中的Node的连接方式是通过XML文件中的Link来进行描述的，每一个Link定义了一个输入端和输出端分别对应着不同Node上面的输入输出端口，通过这种方式就将其中的一个Node的输出端与另外一个Node的输入端，一个一个串联起来，等到图像数据从Pipeline的起始端开始输入的时候，便可以按照这种定义好的轨迹在一个一个Node之间进行流转，而在流转的过程中每经过一个Node都会在内部对数据进行处理，这样等到数据从起始端一直流转到最后一个Node的输出端的时候，数据就经过了很多次处理，这些处理效果最后叠加在一起便是该Pipeline所要实现的功能，比如降噪、虚化等等。</p>
<h2 id="四、关键流程详解"><a href="#四、关键流程详解" class="headerlink" title="四、关键流程详解"></a>四、关键流程详解</h2><h3 id="1-Camera-Provider-启动初始化"><a href="#1-Camera-Provider-启动初始化" class="headerlink" title="1. Camera Provider 启动初始化"></a>1. Camera Provider 启动初始化</h3><p>当系统启动的时候，Camera Provider主程序会被运行，在整个程序初始化的过程中会通过获取到的camera_module_t调用其get_number_of_camera接口获取底层支持的camera数量，由于是第一次获取，所以在CamX-CHI中会伴随着很多初始化动作，具体操作见下图：<br><img src="Image-3.png" alt="alt text"><br>主要流程如下：</p>
<ol>
<li>通过HAL3Module::GetInstance()静态方法实例化了HAL3Module对象，在其构造方法里面通过HwEnvironment::GetInstance()静态方法又实例化了HwEnvironment对象，在其构造方法中，实例化了SettingsManager对象，然后又在它构造方法中通过OverrideSettingsFile对象获取了位于/vendor/etc/camera/camoverridesettings.txt文件中的平台相关的配置信息（通过这种Override机制方便平台厂商加入自定义配置），该配置文件中，可以加入平台特定的配置项，比如可以通过设置multiCameraEnable的值来表示当前平台是否支持多摄，或者通过设置overrideLogLevels设置项来配置CamX-CHI部分的Log输出等级等等。</li>
<li>同时在HwEnvironment构造方法中会调用其Initialize方法，在该方法中实例化了CSLModeManager对象，并通过CSLModeManager提供的接口，获取了所有底层支持的硬件设备信息，其中包括了Camera Request Manager、CAPS模块（该驱动模块主要用于CSL获取Camera平台驱动信息，以及IPE/BPS模块的电源控制）以及Sensor/IPE/Flash等硬件模块，并且通过调用CSLHwInternalProbeSensorHW方法获取了当前设备安装的Sensor模组信息，并且将获取的信息暂存起来，等待后续阶段使用，总得来说在HwEnvironment初始化的过程中,通过探测方法获取了所有底层的硬件驱动模块，并将其信息存储下来供后续阶段使用。</li>
<li>之后通过调用HwEnvironment对象中的ProbeChiCompoents方法在/vendor/lib64/camera/components路径下找寻各个Node生成的So库，并获取Node提供的标准对外接口，这些Node不但包括CHI部分用户自定义的模块，还包括了CamX部分实现的硬件模块，并最后都将其都存入ExternalComponentInfo对象中，等待后续阶段使用。</li>
</ol>
<p>另外在初始化阶段还有一个比较重要的操作就是CamX 与CHI是通过互相dlopen对方的So库，获取了对方的入口方法，最后通过彼此的入口方法获取了对方操作方法集合，之后再通过这些操作方法与对方进行通讯，其主要流程见下图：<br><img src="Image-4.png" alt="alt text"><br>从上图不难看出，在HAL3Module构造方法中会去通过dlopen方法加载com.qti.chi.override.so库，并通过dlsym映射出CHI部分的入口方法chi_hal_override_entry，并调用该方法将HAL3Module对像中的成员变量m_ChiAppCallbacks(CHIAppCallbacks)传入CHI中，其中包含了很多函数指针，这些函数指针分别对应着CHI部分的操作方法集中的方法，一旦进入到CHI中，就会将CHI本地的操作方法集合中的函数地址依次赋值给m_ChiAppCallbacks，这样CamX后续就可以通过这个成员变量调用到CHI中方法，从而保持了与CHI的通讯。</p>
<p>同样地，CHI中的ExtensionModule在初始化的时候，其构造方法中也会通过调用dlopen方法加载camera.qcom.so库，并将其入口方法ChiEntry通过dlsym映射出来，之后调用该方法，将g_chiContextOps（ChiContextOps，该结构体中定义了很多指针函数）作为参数传入CamX中，一旦进入CamX中，便会将本地的操作方法地址依次赋值给g_chiContextOps中的每一个函数指针，这样CHI之后就可以通过g_chiContextOps访问到CamX方法。</p>
<h3 id="2-打开相机设备-初始化相机设备"><a href="#2-打开相机设备-初始化相机设备" class="headerlink" title="2. 打开相机设备/初始化相机设备"></a>2. 打开相机设备/初始化相机设备</h3><p>一旦用户打开了相机应用，App中便会去调用CameraManager的openCamera方法，该方法之后会最终调用到Camera Service中的CameraService::connectDevice方法，然后通过ICameraDevice::open()这一个HIDL接口通知Provider，然后在Provider内部又通过调用之前获取的camera_module_t中methods的open方法来获取一个Camera 设备，对应于HAL中的Lcamera3_device_t结构体，紧接着，在Provider中会继续调用获取到的camera3_device_t的initialize方法进行初始化动作。接下来我们便来详细分析下CamX-CHI对于open以及initialize的具体实现流程：</p>
<p>a) open<br>该方法是camera_module_t的标准方法，主要用来获取camera3_device_t设备结构体的，CamX-CHI对其进行了实现，open方法中完成的工作主要以下几个：</p>
<ol>
<li>将当前camera id传入CHI中进行remap操作，当然这个remap操作逻辑完全是根据CHI中用户需求来的，用户可以根据自己的需要在CHI中加入自定义remap逻辑。</li>
<li>实例化HALDevice对象，其构造函数中调用Initialize方法，该方法会填充CamX中自定义的Camera3Device结构体。</li>
<li>将m_HALCallbacks.process_capture_result指向了本地方法ProcessCaptureResult以及m_HALCallbacks.notify_result指向了本地方法Notify（之后会在配置数据流的过程中，将m_HALCallbacks注册到CHI中， 一旦当CHI数据处理完成之后，便会通过这两个回调方法将数据或者事件回传给CamX）。</li>
<li>最后将HALDevice 中的Camera3Device成员变量作为返回值给到Provider中的CameraCaptureSession中。</li>
</ol>
<p>Camera3Device 其实重定义了camera3_device_t，其中HwDevice对应于camera3_device_t中的hw_device_t，Camera3DeviceOps对应于camera3_device_ops_t，而在HALDevice的初始化过程中，会将CamX实现的HAL3接口的结构体g_camera3DeviceOps赋值给Camera3DeviceOps中。</p>
<p>b) initialize<br>该方法在调用open后紧接着被调用，主要用于将上层的回调接口传入HAL中，一旦有数据或者事件产生，CamX便会通过这些回调接口将数据或者事件上传至调用者，其内部的实现较为简单。</p>
<p>initialize方法中有两个参数，分别是之前通过open方法获取的camera3_device_t结构体和实现了camera3_callback_ops_t的CameraDevice，很显然camera3_device_t结构体并不是重点，所以该方法的主要工作是将camera3_callback_ops_t与CamX关联上，一旦数据准备完成便通过这里camera3_callback_ops_t中回调方法将数据回传到Camera Provider中的CameraDevice中，基本流程可以总结为以下几点：</p>
<ol>
<li>实例化了一个Camera3CbOpsRedirect对象并将其加入了g_HAL3Entry.m_cbOpsList队列中，这样方便之后需要的时候能够顺利拿到该对象。</li>
<li>将本地的process_capture_result以及notify方法地址分别赋值给Camera3CbOpsRedirect.cbOps中的process_capture_result以及notify函数指针。</li>
<li>将上层传入的回调方法结构体指针pCamera3CbOpsAPI赋值给Camera3CbOpsRedirect.pCbOpsAPI，并将Camera3CbOpsRedirect.cbOps赋值给pCamera3CbOpsAPI，通过JumpTableHal3的initialize方法将pCamera3CbOpsAPI传给HALDevice中的m_pCamera3CbOps成员变量，这样HALDevice中的m_pCamera3CbOps就指向了CamX中本地方法process_capture_result以及notify。</li>
</ol>
<p>经过这样的一番操作之后，一旦CHI有数据传入便会首先进入到本地方法ProcessCaptureResult，然后在该方法中获取到HALDevice的成员变量m_pCamera3CbOps，进而调用m_pCamera3CbOps中的process_capture_resutlt方法，即camxhal3entry.cpp中定义的process_capture_result方法，然后这个方法中会去调用JumpTableHAL3.process_capture_result方法，该方法最终会去调用Camera3CbOpsRedirect.pCbOpsAPI中的process_capture_result方法，这样就调到从Provider传入的回调方法，将数据顺利给到了CameraCaptureSession中。</p>
<h3 id="3-配置相机设备数据流"><a href="#3-配置相机设备数据流" class="headerlink" title="3. 配置相机设备数据流"></a>3. 配置相机设备数据流</h3><p>在打开相机应用过程中，App在获取并打开相机设备之后，会调用CameraDevice.createCaptureSession来获取CameraDeviceSession，并且通过Camera api v2标准接口，通知Camera Service，调用其CameraDeviceClient.endConfigure方法，在该方法内部又会去通过HIDL接口ICameraDeviceSession::configureStreams_3_4通知Provider开始处理此次配置需求，在Provider内部，会去通过在调用open流程中获取的camera3_device_t结构体的configure_streams方法来将数据流的配置传入CamX-CHI中，之后由CamX-CHI完成对数据流的配置工作，接下来我们来详细分析下CamX-CHI对于该标准HAL3接口 configure_streams的具体实现：<br>配置数据流是整个CamX-CHI流程比较重要的一环，其中主要包括两个阶段：</p>
<ol>
<li>选择UsecaseId</li>
<li>根据选择的UsecaseId创建Usecase</li>
</ol>
<p>接下来我们就这两个阶段分别进行详细介绍:<br><strong>① 选择UsecaseId</strong><br>不同的UsecaseId分别对应的不同的应用场景，该阶段是通过调用UsecaseSelector::GetMatchingUsecase()方法来实现的，该函数中通过传入的operation_mode、num_streams配置数据流数量以及当前使用的Sensor个数来选择相应的UsecaseId，比如当numPhysicalCameras值大于1同时配置的数据流数量num_streams大于1时选择的就是UsecaseId::MultiCamera，表示当前采用的是双摄场景。</p>
<p><strong>② 创建Usecase</strong><br>根据之前选择的UsecaseId，通过UsecaseFactory来创建相应的Usecase，<br>其中Class Usecase是所有Usecase的基类，其中定义并实现了一些通用接口，CameraUsecaseBase继承于Usecase，并扩展了部分功能。AdvancedCameraUsecase又继承于CameraUsecaseBase，作为主要负责大部分场景的Usecase实现类，另外对于多摄场景，现提供了继承于AdvancedCameraUsecase的UsecaseMultiCamera来负责实现。</p>
<p>除了双摄场景，其它大部分场景使用的都是AdvancedCameraUsecase类来管理各项资源的，接下来我们重点梳理下AdvancedCameraUsecase::Create()方法。<br>在AdvancedCameraUsecase::Create方法中做了很多初始化操作，其中包括了以下几个阶段：</p>
<ol>
<li>获取XML文件中Usecase配置信息</li>
<li>创建Feature</li>
<li>保存数据流，重建Usecase的配置信息</li>
<li>调用父类CameraUsecaseBase的initialize方法，进行一些常规初始化工作</li>
</ol>
<p>接下来我们就这几个阶段逐一进行分析：</p>
<ol>
<li><p>获取XML文件中Usecase配置信息<br>这一部分主要通过调用CameraUsecaseBase::GetXMLUsecaseByName方法进行实现。<br>该方法的主要操作是从PerNumTargetUsecases数组中找到匹配到给定的usecaseName的Usecase，并作为返回值返回给调用者，其中这里我们以”UsecaseZSL“为例进行分析，PerNumTargetUsecases的定义是在g_pipeline.h中，该文件是在编译过程中通过usecaseconverter.pl脚本将定义在个平台目录下的common_usecase.xml中的内容转换生成g_pipeline.h。</p>
</li>
<li><p>创建Feature<br>如果当前场景选取了Feature，则调用FeatureSetup来完成创建工作。<br>该方法主要是通过诸如operation_mode、camera数量以及UsecaseId等信息来决定需要选择哪些Feature,具体逻辑比较清晰，一旦决定需要使用哪一个Feature之后，便调用相应的Feature的Create()方法进行初始化操作。</p>
</li>
<li><p>保存数据流，重建Usecase的配置信息<br>从Camera Service 传入的数据流，需要将其存储下来，供后续使用，同时高通针对Usecase也加入了Override机制，根据需要可以选择性地扩展Usecase，这两个步骤的实现主要是通过SelectUsecaseConfig方法来实现。<br>其中主要是调用以下两个方法来实现的：</p>
</li>
</ol>
<ul>
<li>ConfigureStream： 该方法将从上层配置的数据流指针存入AdvancedCameraUsecase中，其中包括了用于预览的m_pPreviewStream以及用于拍照的m_pSnapshotStream。</li>
<li>BuildUsecase： 这个方法用来重新在原有的Usecase上面加入了Feature中所需要的pipeline，并创建了一个新的Usecase，并将其存入AdvancedCameraUsecase中的m_pChiUsecase成员变量中，紧接着通过SetPipelineToSessionMapping方法将pipeline与Session进行关联。</li>
</ul>
<ol start="4">
<li>调用父类CameraUsecaseBase的initialize方法，进行一些常规初始化工作<br>该方法中的操作主要有以下三个：</li>
</ol>
<ul>
<li>设置Session回调</li>
<li>创建Pipeline</li>
<li>创建Session</li>
</ul>
<p><strong>设置Session回调</strong><br>该方法有两个参数，第二个是缺省的，第一个是ChiCallBacks，该参数是作为创建的每一条Session的回调方法，当Session中的pipeline全部跑完之后，会回调该方法将数据投递到CHI中。<br>创建Pipeline<br>根据之前获取的pipeline信息开始创建每一条pipeline，通过调用CreatePipeline()方法实现。</p>
<p><strong>创建Session</strong><br>创建Session，通过CreateSession()方法实现，此时会将AdvancedCameraUsecase端的回调函数注册到Session中，一旦Session中数据处理完成，便会调用回调将数据回传给AdvancedCameraUsecase。</p>
<p>综上，整个configure_stream过程，基本可以概括为以下几点：</p>
<ol>
<li>根据operation_mode、camera 个数以及stream的配置信息选取了对应的UsecaseId</li>
<li>根据所选取的UsecaseId，使用UsecaseFactory简单工厂类创建了用于管理整个场景下所有资源的AdvancedCameraUsecase对象。</li>
<li>创建AdvancedCameraUsecase对象是通过调用其Create()方法完成，该方法中获取了common_usecase.xml定义的关于Usecase的配置信息，之后又根据需要创建了Feature并选取了Feature所需的pipeline，并通过Override机制将Feature中所需要的Pipeline加入重建后的Usecase中。</li>
<li>最后通过调用CameraUsecaseBaese的initialize方法依次创建了各个pipeline以及Session，并且将AdvancedCameraUsecase的成员方法注册到Session，用于Session将数据返回给Usecase中</li>
</ol>
<h3 id="4-处理拍照请求"><a href="#4-处理拍照请求" class="headerlink" title="4. 处理拍照请求"></a>4. 处理拍照请求</h3><p>当用户打开相机应用进行预览或者点击一次拍照操作的时候，便触发了一次拍照请求，该动作首先通过CameraDeviceSession的capture或者setRepeatingRequest方法将请求通过Camera api v2接口下发到Camera Service中，然后在Camera Service内部将此次请求发送到CameraDevice::RequestThread线程中进行处理，一旦进入到该线程之后，便会最终通过HIDL接口ICameraCaptureSession:processCaptureRequest_3_4将请求发送至Provider中，之后当Provider收到请求之后，会调用camera3_device_t结构体的process_capture_request开始了HAL针对此次Request的处理，而该处理是由CamX-CHI来负责实现，现在我们就来看下CamX-CHI是如何实现该方法的：</p>
<p>首先CamX中会将此次request转发到HALDevice中，再通过HALDevice对象调用之前初始化的时候获取的CHI部分的回调接口m_ChiAppCallbacks.chi_override_process_request方法（chi_override_process_request方法的定义位于chxextensioninterface.cpp中）将request发送到CHI部分。</p>
<p>在chi_override_process_request方法中会去获取ExtensionModule对象，并将request发送到ExtensionModule对象中，该对象中存储了之前创建的Usecase对象，然后经过层层调用，最终会调用AdvancedCameraUsecase的ExecuteCaptureRequest方法，该方法负责处理此次Request，具体流程如下：</p>
<p>在AdvancedCameraUsecase的ExecuteCaptureRequest中会有两个主要的分支来分别处理：</p>
<ul>
<li>如果当前并没有任何Feature需要实现，此时便会走默认流程，根据上面的流程图所示，这里会调用CameraUsecaseBase::ExecuteCaptureRequest方法，在该方法中，首先会将request取出，重新封装成CHICAPTUREREQUEST，然后调用CheckAndActivatePipeline方法唤醒pipeline,这一操作到最后会调到Session的StreamOn方法，在唤醒了pipeline之后，继续往下执行，再将封装后的Request发送到CamX中，最终调用到相应的Session::ProcessCaptureRequest方法，此时Request就进入到了Session内部进行流转了。</li>
<li>如果当前场景需要实现某个Feature，则直接调用Feature的ExecuteProcessRequest方法将此次request送入Feature中处理，最后依然会调用到Session::StreamOn以及Session::ProcessCaptureRequest方法来分别完成唤醒pipeline以及下发request的到Session的操作。</li>
</ul>
<p>该流程最终都会调用到两个比较关键的方法Session::StreamOn以及Session::ProcessCaptureRequest，接下来针对这两个方法重点介绍下：</p>
<h4 id="Session-StreamOn"><a href="#Session-StreamOn" class="headerlink" title="Session::StreamOn"></a>Session::StreamOn</h4><p>从方法名称基本可以知道该方法主要用于开始硬件的数据输出，具体点儿就是进行配置Sensor寄存器，让其开始出图，并且将当前的Session的状态告知每一Node，让它们在自己内部也做好处理数据的准备，所以之后的相关Request的流转都是以该方法为前提进行的，所以该方法重要性可见一斑，其操作流程见下图：</p>
<p>Session的StreamOn方法中主要做了如下两个工作：</p>
<ul>
<li>调用FinalizeDeferPipeline()方法，如果当前pipeline并未初始化，则会调用pipeline的FinalizePipeline方法，这里方法里面会去针对每一个从属于当前pipeline的Node依次做FinalizeInitialization、CreateBufferManager、NotifyPipelineCreated以及PrepareNodeStreamOn操作，FinalizeInitialization用于完成Node的初始化动作，NotifyPipelineCreated用于通知Node当前Pipeline的状态，此时Node内部可以根据自身的需要作相应的操作，PrepareNodeStreamOn方法的主要是完成Sensor以及IFE等Node的控制硬件模块出图前的配置，其中包括了曝光的参数的设置，CreateBufferManagers方法涉及到CamX-CHI中的一个非常重要的Buffer管理机制，用于Node的ImageBufferManager的创建，而该类用于管理Node中的output port的buffer申请/流转/释放等操作。</li>
<li>调用Pipeline的StreamOn方法，里面会进一步通知CSL部分开启数据流，并且调用每一个Node的OnNodeStreamOn方法，该方法会去调用ImageBufferManager的Activate(),该方法里面会去真正分配用于装载图像数据的buffer，之后会去调用CHI部分实现的用户自定义的Nod的pOnStreamOn方法，用户可以在该方法中做一些自定义的操作。</li>
</ul>
<h4 id="Session-ProcessCaptureRequest"><a href="#Session-ProcessCaptureRequest" class="headerlink" title="Session::ProcessCaptureRequest"></a>Session::ProcessCaptureRequest</h4><p>针对每一次的Request的流转，都是以该方法为入口开始的，具体流程见下图：<br><img src="Image-5.png" alt="alt text"><br>上述流程可以总结为以下几个步骤：</p>
<ol>
<li>通过调用Session的ProcessCaptureRequest方法进入到Session，然后调用Pipeline中的ProcessRequest方法通知Pipeline开始处理此次Request。</li>
<li>在Pipeline中，会先去调用内部的每一个Node的SetupRequest方法分别设置该Node的Output Port以及Input Port，之后通过调用DRQ(DeferredRequestQueue)的AddDeferredNode方法将所有的Node加入到DRQ中，其中DRQ中有两个队列分别是用于保存没有依赖项的Node的m_readyNodes以及保存处于等待依赖关系满足的Node的m_deferredNodes，当调用DRQ的DispatchReadyNodes方法后，会开始从m_readyNodes队列中取出Node调用其ProcessRequest开始进入Node内部处理本次request，在处理过程中会更新meta data数据，并更新至DRQ中，当该Node处理完成之后，会将处于m_deferredNodes中的已无依赖关系的Node移到m_readyNodes中，并再次调用DispatchReadyNodes方法从m_readyNodes取出Node进行处理。</li>
<li>与此过程中，当Node的数据处理完成之后会通过CSLFenceCallback通知到Pipeline，此时Pipeline会判断当前Node的Output port 是否是Sink Port(输出到CHI)，如果不是，则会更新依赖项到DRQ中，并且将不存在依赖项的Node移到m_readyNodes队列中，然后调用DispatchReadyNdoes继续进入到DRQ中流转，如果是Sink Port，则表示此Node是整个Pipeline的最末端，调用sinkPortFenceSignaled将数据给到Session中，最后通过调用Session中的NotifyResult将结果发送到CHI中。</li>
</ol>
<h4 id="DeferredRequestQueue"><a href="#DeferredRequestQueue" class="headerlink" title="DeferredRequestQueue"></a>DeferredRequestQueue</h4><p>上述流程里面中涉及到DeferredRequestQueue这个概念，这里简单介绍下：<br>DeferredRequestQueue继承于IPropertyPoolObserver，实现了OnPropertyUpdate/OnMetadataUpdate/OnPropertyFailure/OnMetadataFailure接口，这几个接口用于接收Meta Data以及Property的更新，另外，DRQ主要包含了以下几个主要方法:</p>
<ul>
<li>Create()<br>该方法用于创建DRQ，其中创建了用于存储依赖信息的m_pDependencyMap，并将自己注册到MetadataPool中，一旦有meta data或者property更新便会通过类中实现的几个接口通知到DRQ。</li>
<li>DispatchReadyNodes()<br>该方法主要用于将处于m_readyNodes队列的Node取出，将其投递到m_hDeferredWorker线程中进行处理。</li>
<li>AddDeferredNode()<br>该方法主要用于添加依赖项到m_pDependencyMap中。</li>
<li>FenceSignaledCallback()<br>当Node内部针对某次request处理完成之后，会通过一系列回调通知到DRQ，而其调用的方法便是该方法，在该方法中，会首先调用UpdateDependency更新依赖项，然后调用DispatchReadyNodes触发开始对处于ready状态的Node开始进行处理</li>
<li>OnPropertyUpdate()<br>该方法是定义于IPropertyPoolObserver接口，DRQ实现了它，主要用于接收Property更新的通知，并在内部调用UpdateDependency更新依赖项。</li>
<li>OnMetadataUpdate()<br>该方法是定义于IPropertyPoolObserver接口，DRQ实现了它，主要用于接收Meta data更新的通知，并在内部调用UpdateDependency更新依赖项。</li>
<li>UpdateDependency()<br>该方法用于更新Node的依赖项信息，并且将没有依赖的Node从m_deferredNodes队列中移到m_readyNodes，这样该Node就可以在之后的某次DispatchReadyNodes调用之后投入运行。</li>
<li>DeferredWorkerWrapper()<br>该方法是m_hDeferredWorker线程的处理函数，主要用于处理需要下发request的Node，同时再次更新依赖项，最后会再次调用DispatchReadyNodes开始处理。</li>
</ul>
<p>其中需要注意的是，Pipeline首次针对每一个Node通过调用AddDeferredNode方法加入到DRQ中，此时所有的Node都会加入到m_readyNodes中，然后通过调用dispatchReadyNodes方法，触发DRQ开始进行整个内部处理流程，基本流程可以参见下图，接下来就以该图进行深入梳理下：<br><img src="Image-6.png" alt="alt text"></p>
<ol>
<li>当调用了DRQ的dispatchReadyNodes方法后，会从m_readyNodes链表里面依次取出Dependency，将其投递到DeferredWorkerWrapper线程中，在该线程会从Dependency取出Node调用其ProcessRequest方法开始在Node内部处理本次request，处理完成之后如果当前Node依然存在依赖项，则调用AddDeferredNode方法将Node再次加入到m_deferredNodes链表中，并且加入新的依赖项，存入m_pDependencyMap hash表中。</li>
<li>在Node处理request的过程中，会持续更新meta data以及property，此时会通过调用MetadataSlot的PublishMetadata方法更新到MetadataPool中，此时MetadataPool会调用之前在DRQ初始化时候注册的几个回调方法OnPropertyUpdate以及OnMetadataUpdate方法通知DRQ，此时有新的meta data 和property更新，接下来会在这两个方法中调用UpdateDependency方法，去更新meta data 和property到m_pDependencyMap中，并且将没有任何依赖项的Node从m_deferredNodes取出加入到m_readyNodes，等待处理。</li>
<li>与此同时，Node的处理结果也会通过ProcessFenceCallback方法通知pipeline，并且调用pipeline的NonSinkPortFenceSignaled方法，在该方法内部又会去调用DRQ的FenceSignaledCallback方法，而该方法又会调用UpdateDependency更新依赖，并将依赖项都满足的Node从m_deferredNodes取出加入到m_readyNodes，然后调用dispatchReadyNodes继续进行处理。</li>
</ol>
<h3 id="5-上传拍照结果"><a href="#5-上传拍照结果" class="headerlink" title="5. 上传拍照结果"></a>5. 上传拍照结果</h3><p>在用户开启了相机应用，相机框架收到某次Request请求之后会开始对其进行处理，一旦有图像数据产生便会通过层层回调最终返回到应用层进行显示，这里我们针对CamX-CHI部分对于拍照结果的上传流程进行一个简单的梳理：<br>每一个Request对应了三个Result，分别是partial metadata、metadata以及image data，对于每一个Result，上传过程可以大致分为以下两个阶段：</p>
<ul>
<li>Session内部完成图像数据的处理，将结果发送至Usecase中</li>
<li>Usecase接收到来自Session的数据，并将其上传至Provider<br>首先来看下Session内部完成图像数据的处理后是如何将结果发送至Usecase的：<br><img src="Image-7.png" alt="alt text"><br>在整个requets流转的过程中，一旦Node中有Partial Meta Data产生，便会调用Node的ProcessPartialMetadataDone方法去通知从属的Pipeline，其内部又调用了pipeline的NotifyNodePartialMetadataDone方法。每次调用Pipeline的NotifyNodePartialMetadataDone方法都会去将pPerRequestInfo→numNodesPartialMetadataDone加一并且判断当前值是否等于pipeline中的Node数量，一旦相等，便说明当前所有的Node都完成了partial meta data的更新动作，此时，便会调用ProcessPartialMetadataRequestIdDone方法，里面会去取出partial meta data，并且重新封装成ResultsData结构体，将其作为参数通过Session的NotifyResult方法传入Session中，之后在Session中经过层层调用最终会调用到内部成员变量m_chiCallBacks的ChiProcessPartialCaptureResult方法，该方法正是创建Session的时候，传入Session中的Usecase的方法（AdvancedCameraUsecase::ProcessDriverPartialCaptureResultCb），通过该方法就将meta data返回到了CHI中。</li>
</ul>
<p>同样地，Meta data的逻辑和Partial Meta Data很相似，每个Node在处理request的过程中，会调用ProcessMetadataDone方法将数据发送到Pipeline中，一旦所有的Node的meta data否发送完成了，pipeline会调用NotifyNodeMetadataDone方法，将最终的结果发送至Session中，最后经过层层调用，会调用Session 中成员变量m_chiCallBacks的ChiProcessCaptureResult方法，将结果发送到CHI中Usecase中。</p>
<p>图像数据的流转和前两个meta data的流转有点儿差异，一旦Node内部图像数据处理完成后便会调用其ProcessFenceCallback方法，在该方法中会去检查当前输出是否是SInk Buffer，如果是则会调用Pipeline的SinkPortFenceSignaled方法将数据发送到Pipeline中，在该方法中Pipeline又会将数据发送至Session中，最后经过层层调用，会调用Session 中成员变量m_chiCallBacks的ChiProcessCaptureResult方法，将结果发送到CHI中Usecase中。</p>
<p>接下来我们来看下一旦Usecase接收到Session的数据，是如何发送至Provider的：<br>我们以常用的AdvancedCameraUsecase为例进行代码的梳理：<br><img src="Image-8.png" alt="alt text"><br>如上图所示，整个result的流转逻辑还是比较清晰的，CamX通过回调方法将结果回传给CHI中，而在CHI中，首先判断是否需要发送到具体的Feature的， 如果需要，则调用相应Feature的ProcessDriverPartialCaptureResult或者ProcessResult方法将结果发送到具体的Feature中，一旦处理完成，便会调用调用CameraUsecaseBase的ProcessAndReturnPartialMetadataFinishedResults以及ProcessAndReturnFinishedResults方法将结果发送到Usecase中，如果当前不需要发送到Feature进行处理，就在AdvancedCameraUsecase中调用CameraUsecaseBase的SessionCbPartialCaptureResult以及SessionCbCaptureResult方法，然后通过Usecase::ReturnFrameResult方法将结果发送到ExtensionModule中，之后调用ExtensionModule中存储的CamX中的回调函数process_capture_result将结果发送到CamX中的HALDevice中，之后HALDevice又通过之前存储的上层传入的回调方法，将结果最终发送到CameraDeviceSession中。</p>
<p>通过以上的梳理，可以发现，整个CamX-CHI框架设计的很不错，目录结构清晰明确，框架简单高效，流程控制逻辑分明，比如针对某一图像请求，整个流程经过Usecase、Feature、Session、Pipeline并且给到具体的Node中进行处理，最终输出结果。另外，相比较之前的QCamera &amp; Mm-Camera框架的针对某个算法的扩展需要在整个流程代码中嵌入自定义的修改做法而言，CamX-CHI通过将自定义实现的放入CHI中，提高了其扩展性，降低了开发门槛，使得平台厂商在并不是很熟悉CamX框架的情况下也可以通过小规模的修改成功添加新功能。但是人无完人，框架也是一样，该框架异步化处理太多，加大了定位问题以及解决问题的难度，给开发者带来了不小的压力。另外，框架对于内存的要求较高，所以在一些低端机型尤其是低内存机型上，整个框架的运行效率可能会受到一定的限制，进而导致相机效率低于预期。</p>
]]></content>
      <categories>
        <category>1. Android Camera</category>
      </categories>
      <tags>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
      </tags>
  </entry>
  <entry>
    <title>如何备份博客？</title>
    <url>/2018/03/14/How-to-backup-blog/</url>
    <content><![CDATA[<p>为整个博客目录建立GitHub仓库</p>
<span id="more"></span>
<hr>
<h3 id="为整个目录建立GitHub仓库"><a href="#为整个目录建立GitHub仓库" class="headerlink" title="为整个目录建立GitHub仓库"></a>为整个目录建立GitHub仓库</h3><p>前面文章<a href="https://shenweikun.github.io/2018/02/07/2018-02-07-hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">hexo+github搭建个人博客</a>中，提到使如下命令初始化一个hexo博客，此时会生成一个myblog目录，后面对博客网站的所有操作都是在此目录下完成的，所以我们可以直接为这整个目录建立GitHub仓库，并将所有数据传到GitHub上备份</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hexo init myblog</span><br></pre></td></tr></table></figure>

<p>如何建立可以参考文章<a href="https://www.cnblogs.com/zhixi/p/9584624.html">在github上创建自己的代码仓库</a></p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解Android相机体系结构之七：相机驱动层–V4L2框架解析</title>
    <url>/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-7/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>1. Android Camera</category>
      </categories>
      <tags>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
      </tags>
  </entry>
  <entry>
    <title>如何更换主题？</title>
    <url>/2018/03/14/How-to-change-theme/</url>
    <content><![CDATA[<p>在hexo初始化完成之后，会默认有一个主题，但是往往不是很喜欢，想要更换一个漂亮的主题。这里主要介绍一下我目前使用的这款主题jacman.</p>
<span id="more"></span>  
<hr>
<h4 id="如何使用jacman"><a href="#如何使用jacman" class="headerlink" title="如何使用jacman"></a>如何使用jacman</h4><p>关于如何使用jacman，以下这个链接写得比较详细，就不再赘述：<br><a href="http://jacman.wuchong.me/2014/11/20/how-to-use-jacman/">如何使用 Jacman 主题</a>  </p>
<hr>
<h4 id="其他主题"><a href="#其他主题" class="headerlink" title="其他主题"></a>其他主题</h4><p>hexo官网上也提供了不少好看的主题：<br><a href="https://hexo.io/themes/">官方主题链接</a></p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解Android相机体系结构之九：相机硬件层</title>
    <url>/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-9/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>1. Android Camera</category>
      </categories>
      <tags>
        <tag>Android Camera</tag>
        <tag>Camera系统</tag>
      </tags>
  </entry>
  <entry>
    <title>如何可视化编辑markdown?</title>
    <url>/2018/03/14/How-to-edit-MarkDown-visually/</url>
    <content><![CDATA[<p>使用 Hexo Admin 插件</p>
<span id="more"></span>
<hr>
<h3 id="使用-Hexo-Admin-插件"><a href="#使用-Hexo-Admin-插件" class="headerlink" title="使用 Hexo Admin 插件"></a>使用 Hexo Admin 插件</h3><p>Hexo Admin 是一个本地在线式文章管理器，可以用直观可视化的方式新建、编辑博客文章、page页面，添加标签、分类等，并且支持剪贴板粘贴图片（自动在source_images_目录中创建文件）<br><img src="How-to-edit-MarkDown-visually.png"></p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ol>
<li>在Hexo网站目录下，安装 Hexo Admin 插件<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-admin</span><br></pre></td></tr></table></figure></li>
<li>启动本地服务器并打开管理界面，即可使用<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hexo server -d</span><br><span class="line">open http:<span class="comment">//localhost:4000/admin/</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><a href="https://www.jianshu.com/p/925fa86ccc95">参考文章：使用Hexo写博客</a></p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
  </entry>
  <entry>
    <title>怎么把hexo的相关信息修改为自己？</title>
    <url>/2018/03/13/How-to-modify-hexo-config/</url>
    <content><![CDATA[<p>使用hexo搭建网站，网站的大部分配置信息都可以在_config.yml文件中进行修改。本编主要介绍_config.yml中的内容。</p>
<span id="more"></span>  
<hr>
<h3 id="config-yml介绍"><a href="#config-yml介绍" class="headerlink" title="_config.yml介绍"></a>_config.yml介绍</h3><ol>
<li>网站配置文件在位置： myblog/_config.yml （即创建网站文件夹的根目录下）</li>
<li><a href="https://hexo.io/docs/configuration.html">官方配置说明</a> </li>
<li>注意细节： 配置文件中每个属性的冒号（：）后面应该添加空格</li>
<li>以下用我的配置文件内容为例子进行说明 </li>
</ol>
<h4 id="网站基本信息配置"><a href="#网站基本信息配置" class="headerlink" title="网站基本信息配置"></a>网站基本信息配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line"># 博客的标题</span><br><span class="line">title: 空白的博客</span><br><span class="line"># 副标题</span><br><span class="line">subtitle: 需要效率的事情交给机器人就好了，我们真正擅长的是浪费时间。</span><br><span class="line"># 网站的描述，主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。</span><br><span class="line">description: 记录生活与职业中的点滴</span><br><span class="line"># 网站的作者</span><br><span class="line">author: yourname</span><br><span class="line"># 语言，默认是英文的，我这里修改为中文zh-CN</span><br><span class="line">language: zh-CN</span><br><span class="line"># 时区，一般留空，默认使用您电脑的时区。时区列表：America/New_York, Japan, 和 UTC 。</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure>

<h4 id="网址信息配置"><a href="#网址信息配置" class="headerlink" title="网址信息配置"></a>网址信息配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="line"># 修改成你自己的网址，你可以通过此网址来访问你的网站</span><br><span class="line">url: https://yourname.github.io/</span><br><span class="line">root: /</span><br><span class="line"># 文章链接地址格式 。即文章存放的目录。</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure>

<h4 id="目录配置"><a href="#目录配置" class="headerlink" title="目录配置"></a>目录配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Directory</span><br><span class="line"># 资源文件夹，这个文件夹用来存放内容。</span><br><span class="line">source_dir: source</span><br><span class="line"># 公共文件夹，这个文件夹用于存放生成的站点文件。</span><br><span class="line">public_dir: public</span><br><span class="line"># 标签文件夹，实际位于source/tags</span><br><span class="line">tag_dir: tags</span><br><span class="line"># 归档文件夹</span><br><span class="line">archive_dir: archives</span><br><span class="line"># 分类文件夹</span><br><span class="line">category_dir: categories</span><br><span class="line"># Include code 文件夹</span><br><span class="line">code_dir: downloads/code</span><br><span class="line"># 国际化（i18n）文件夹</span><br><span class="line">i18n_dir: :lang</span><br><span class="line"># 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</span><br><span class="line">skip_render:</span><br></pre></td></tr></table></figure>

<h4 id="写作配置"><a href="#写作配置" class="headerlink" title="写作配置"></a>写作配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Writing</span><br><span class="line"># 新文章的文件名称</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line"># 预设布局  </span><br><span class="line">default_layout: post</span><br><span class="line"># 是否将标题转换成标题形式（首字母大写）   </span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line"># 在新标签中打开链接 </span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line"># 把文件名称转换为 (1) 小写或 (2) 大写  </span><br><span class="line">filename_case: 0</span><br><span class="line"># 是否渲染草稿</span><br><span class="line">render_drafts: false</span><br><span class="line"># 启动 Asset 文件夹（创建文章的时候会创建同名文件夹，文件夹可以用于存放图片，建议启动）</span><br><span class="line">post_asset_folder: true</span><br><span class="line"># 把链接改为与根目录的相对位址 </span><br><span class="line">relative_link: false</span><br><span class="line"># 显示未来的文章</span><br><span class="line">future: true</span><br><span class="line"># 代码块的设置</span><br><span class="line">highlight:</span><br><span class="line">  enable: true #使能</span><br><span class="line">  line_number: true #显示行号</span><br><span class="line">  auto_detect: false #自动检测语言</span><br><span class="line">  tab_replace:</span><br></pre></td></tr></table></figure>

<h4 id="主页设置"><a href="#主页设置" class="headerlink" title="主页设置"></a>主页设置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><span class="line"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class="line"># order_by: Posts order. (Order by date descending by default)</span><br><span class="line">index_generator:</span><br><span class="line">  path: &#x27;&#x27;</span><br><span class="line">  per_page: 10 </span><br><span class="line">  order_by: -date</span><br></pre></td></tr></table></figure>

<h4 id="分类-amp-标签"><a href="#分类-amp-标签" class="headerlink" title="分类&amp;标签"></a>分类&amp;标签</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Category &amp; Tag</span><br><span class="line"># 默认分类</span><br><span class="line">default_category: uncategorized</span><br><span class="line"># 分类别名</span><br><span class="line">category_map:</span><br><span class="line">	编程: programming</span><br><span class="line">	生活: life</span><br><span class="line">	其他: other</span><br><span class="line"># 标签别名</span><br><span class="line">tag_map:</span><br></pre></td></tr></table></figure>

<h4 id="日期和时间格式"><a href="#日期和时间格式" class="headerlink" title="日期和时间格式"></a>日期和时间格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br></pre></td></tr></table></figure>

<h4 id="分页设置"><a href="#分页设置" class="headerlink" title="分页设置"></a>分页设置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10 #每页</span><br><span class="line">pagination_dir: page</span><br></pre></td></tr></table></figure>

<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: jacman  #这里是配置主题，位于myblog/themes/目录下</span><br><span class="line">stylus:</span><br><span class="line">  compress: true</span><br><span class="line"># 部署部分的设置，我这里与我的git相绑定，你们可以改成自己的git地址</span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<h4 id="可视化插件相关"><a href="#可视化插件相关" class="headerlink" title="可视化插件相关"></a>可视化插件相关</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin:</span><br><span class="line">   username: yourname</span><br><span class="line">#   password_hash: </span><br><span class="line">   secret: hey hexo</span><br><span class="line">   deployCommand: &#x27;./admin_script/hexo-generate.sh&#x27;</span><br><span class="line">#  expire: 60*1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>建站</category>
      </categories>
  </entry>
  <entry>
    <title>文章汇总</title>
    <url>/2021/10/25/hello-world/</url>
    <content><![CDATA[<p>从事 Android Camera 开发已有8年，与相机软件相关的各个模块基本上都有涉足，诸如传感器移植、算法集成、性能/内存优化以及稳定性等等方面。那些零零碎碎的知识点一直未曾进行全面完整的归纳与总结，于此开始进行回顾并记录下来，力求能够做到温故而知新。</p>
<span id="more"></span>
<h2 id="技术博文汇总"><a href="#技术博文汇总" class="headerlink" title="技术博文汇总"></a>技术博文汇总</h2><hr>
<h3 id="Camera基础概念篇"><a href="#Camera基础概念篇" class="headerlink" title="Camera基础概念篇"></a>Camera基础概念篇</h3><p><a href="https://shenweikun.github.io/2021/10/25/2021-10-25-Camera-concept/">Camera概念篇-岗位职能划分</a><br><a href="https://shenweikun.github.io/2021/10/25/2021-10-25-Camera-concept-Camera-HW/">Camera概念篇-相机原理</a><br><a href="https://shenweikun.github.io/2021/10/24/2021-10-24-Camera-concept-sensorIntroduction/">Camera概念篇-Sensor介绍</a><br><a href="https://shenweikun.github.io/2021/10/25/2021-10-24-Camera-concept-illuminant/">Camera概念篇-标准光源</a><br><a href="https://shenweikun.github.io/2021/10/25/2021-10-25-Camera-concept-Image/">Camera概念篇-图像</a><br><a href="https://shenweikun.github.io/2021/10/25/2021-10-25-Camera-concept-Color-Correction-Matrix/">Camera概念篇-色彩校正矩阵</a></p>
<hr>
<h3 id="Camera系统架构篇"><a href="#Camera系统架构篇" class="headerlink" title="Camera系统架构篇"></a>Camera系统架构篇</h3><p><a href="https://shenweikun.github.io/2021/10/24/2021-10-24-a-Camera-system-architecture/">Android Camera架构概述</a><br><a href="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-1/">深入理解Android相机体系结构之一：相机简史</a><br><a href="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-2/">深入理解Android相机体系结构之二：安卓相机架构概览</a><br><a href="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-3/">深入理解Android相机体系结构之三：相机应用层</a><br><a href="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-4/">深入理解Android相机体系结构之四：相机服务层</a><br><a href="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-5/">深入理解Android相机体系结构之五：相机硬件抽象层</a><br><a href="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-6/">深入理解Android相机体系结构之六：相机硬件抽象层实现</a><br><a href="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-7/">深入理解Android相机体系结构之七：相机驱动层–V4L2框架解析</a><br><a href="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-8/">深入理解Android相机体系结构之八：相机驱动层–高通KMD框架详解</a><br><a href="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-9/">深入理解Android相机体系结构之九：相机硬件层</a><br><a href="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-10/">深入理解Android相机体系结构之十：安卓相机架构总结</a><br><a href="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-11/">深入理解Android相机体系结构之十一：手机相机的未来与发展</a></p>
<hr>
<h3 id="Camera进阶篇"><a href="#Camera进阶篇" class="headerlink" title="Camera进阶篇"></a>Camera进阶篇</h3><h4 id="MTK-Camera"><a href="#MTK-Camera" class="headerlink" title="MTK Camera"></a>MTK Camera</h4><p><a href="https://shenweikun.github.io/2024/11/18/2024-11-20-MTKcam-ISP7-Camsys-Hw-Lib/">ISP7-Camsys Hw-Lib</a><br><a href="https://shenweikun.github.io/2024/11/19/2024-11-20-MTKcam-ISP7-CamCtrl/">ISP7-CamCtrl</a><br><a href="https://shenweikun.github.io/2024/11/19/2024-11-20-MTKcam-ISP7-P1-Node/">ISP7-P1 node</a><br><a href="https://shenweikun.github.io/2024/11/19/2024-11-20-MTKcam-ISP7-enable-fast-launch/">ISP7-enable fastlaunch</a></p>
<h4 id="Qcom-Camera"><a href="#Qcom-Camera" class="headerlink" title="Qcom Camera"></a>Qcom Camera</h4><h4 id="Camera-feature"><a href="#Camera-feature" class="headerlink" title="Camera feature"></a>Camera feature</h4><h4 id="Camera优化"><a href="#Camera优化" class="headerlink" title="Camera优化"></a>Camera优化</h4><h5 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h5><p><a href="https://shenweikun.github.io/2024/11/20/2024-11-20-memory-libmemunreachable/">Memory libmemunreachable</a></p>
<h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><p><a href="https://shenweikun.github.io/2024/11/19/2024-11-20-MTKcam-ISP7-enable-fast-launch/">ISP7-enable fastlaunch</a></p>
<hr>
<h3 id="其它知识点"><a href="#其它知识点" class="headerlink" title="其它知识点"></a>其它知识点</h3><p><a href="https://shenweikun.github.io/2021/10/17/2021-10-17-CTS-Introduction/">Camera CTS介绍</a><br><a href="https://shenweikun.github.io/2021/10/24/2021-10-24-BufferQueue/">BufferQueue详解</a></p>
<hr>
<h3 id="语言学习"><a href="#语言学习" class="headerlink" title="语言学习"></a>语言学习</h3><p><a href="https://shenweikun.github.io/2024/10/30/2024-10-30-CPP-Basics-C-to-Cpp/">C++从入门到进阶之一-从C到C++</a><br><a href="https://shenweikun.github.io/2024/11/17/2024-11-17-CPP-Basics-C-and-ObjectOrientation/">C++从入门到进阶之二-C++和面向对象</a><br><a href="https://shenweikun.github.io/2024/11/18/2024-11-18-CPP-Basics-about-STL/">C++从入门到进阶之三-STL等高阶话题</a><br><a href="https://shenweikun.github.io/2024/11/18/2024-11-19-CPP-Basics-C-Programming-Optimization/">C++从入门到进阶之四-C++编程优化</a><br><a href="https://shenweikun.github.io/2024/11/18/2024-11-20-CPP-Basics-C-Design-Patterns/">C++从入门到进阶之五-C++的设计模式</a><br><a href="https://shenweikun.github.io/2021/10/10/2021-10-10The-difference-between-C-and-C-static/">C和C++中static的区别</a></p>
<hr>
<h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p><a href="https://shenweikun.github.io/2018/02/07/2018-02-07-hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">hexo+github搭建个人博客</a><br><a href="https://shenweikun.github.io/2018/03/13/How-to-modify-hexo-config/">怎么把hexo的相关信息修改为自己？</a><br><a href="https://shenweikun.github.io/2018/03/14/How-to-change-theme/">如何更换主题？</a><br><a href="https://shenweikun.github.io/2018/03/14/How-to-backup-blog/">如何备份博客？</a><br><a href="https://shenweikun.github.io/2018/03/14/How-to-edit-MarkDown-visually/">如何可视化编辑markdown?</a></p>
]]></content>
  </entry>
</search>
