<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shenweikun.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="记录生活与职业中的点滴">
<meta property="og:type" content="website">
<meta property="og:title" content="Weikun&#39;s Notes">
<meta property="og:url" content="https://shenweikun.github.io/page/2/index.html">
<meta property="og:site_name" content="Weikun&#39;s Notes">
<meta property="og:description" content="记录生活与职业中的点滴">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="空白">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://shenweikun.github.io/page/2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Weikun's Notes</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Weikun's Notes</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">怀揣代码中的唏嘘，记录生活中的点滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">空白</p>
  <div class="site-description" itemprop="description">记录生活与职业中的点滴</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="空白">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weikun's Notes">
      <meta itemprop="description" content="记录生活与职业中的点滴">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Weikun's Notes">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-2/" class="post-title-link" itemprop="url">深入理解Android相机体系结构之二：安卓相机架构概览</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-11-21 00:25:39 / 修改时间：01:54:29" itemprop="dateCreated datePublished" datetime="2024-11-21T00:25:39+08:00">2024-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/1-Android-Camera/" itemprop="url" rel="index"><span itemprop="name">1. Android Camera</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Android系统利用分层思想，将各层的接口定义与实现分离开来，以接口作为各层的脉络连接整体框架，将具体实现的主导权交由各自有具体实现需求的平台厂商或者Android 开发者，这样既做到把控全局，也给予了众多开发者足够大的创作空间，这体现出了一个优秀的开源系统应有的胸怀和远见。其中，谷歌根据职能的不同将Camera框架一共划分成了五层，分别是App、Service、Provider、Driver以及Hardware，下面的Camera的整体架构图很清晰地显示出了其五层架构以及相互的关联接口。<br>   <img src="image1.png"></p>
<h2 id="Camera-App"><a href="#Camera-App" class="headerlink" title="Camera App"></a>Camera App</h2><p>应用层处于整个框架的顶端，承担着于用户直接进行交互的责任，承接来自用户直接或者间接的比如预览/拍照/录像等一系列具体需求，一旦接收到用户相关UI操作，便会通过Camera Api v2标准接口将需求发送至Camera Framework部分，并且等待Camera Framework回传处理结果，其中包括了图像数据以及整体相机系统状态参数，之后将结果以一定方式反馈给用户，达到记录显示种种美好瞬间的目的。</p>
<h2 id="Camera-Framework"><a href="#Camera-Framework" class="headerlink" title="Camera Framework"></a>Camera Framework</h2><p>该层主要位于Camera App与Camera Service之间，以jar包的形式运行在App进程中，它封装了Camera Api v2接口的实现细节，暴露接口给App进行调用，进而接收来自App的请求，同时维护着请求在内部流转的业务逻辑，最终通过调用Camera AIDL跨进程接口将请求发送至Camera Service中进行处理，紧接着，等待Camera Service结果的回传，进而将最终结果发送至App。</p>
<h2 id="Camera-Service"><a href="#Camera-Service" class="headerlink" title="Camera Service"></a>Camera Service</h2><p>该层位于Camera Framework与Camera Provider之间，作为一个独立进程存在于Android系统中，在系统启动初期会运行起来，它封装了Camera AIDL跨进程接口，提供给Framework进行调用，进而接收来自Framework的图像请求，同时内部维护着关于请求在该层的处理逻辑，最终通过调用Camera HIDL跨进程接口将请求再次下发到Camera Provider中，并且等待结果的回传，进而将结果上传至Framework中。</p>
<h2 id="Camera-Provider"><a href="#Camera-Provider" class="headerlink" title="Camera Provider"></a>Camera Provider</h2><p>该层位于Camera Service与Camera Driver之间，作为一个独立的进程存在于Android系统中，同时在系统启动初期被运行，提供Camera HIDL跨进程接口供Camera Service进行调用，封装了该接口的实现细节，接收来自Service的图像请求，并且内部加载了Camera HAL Module，该Module由OEM/ODM实现，遵循谷歌制定的标准Camera HAL3接口，进而通过该接口控制通过谷歌标准HAL3接口控制Camera HAL部分，最后等待Camera HAL的结果回传，紧接着Provider将结果通过Camera HIDL接口将结果发送至Camera Service。</p>
<h2 id="CamX-CHI-Camera-HAL"><a href="#CamX-CHI-Camera-HAL" class="headerlink" title="CamX-CHI(Camera HAL)"></a>CamX-CHI(Camera HAL)</h2><p>该部分是高通对谷歌Camera HAL3接口的实现，以so库的形式被加载至Camera Provider中，之前采用的是QCamera &amp; MM-Camera架构，但是为了更好灵活性和可扩展性，而今高通又提出了CamX-CHI架构，该架构提供HAL3接口给Provider进行调用，接收来自Provider的请求，而内部对HAL3接口进行了实现，并且通过V4L2标准框架控制着相机驱动层，将请求下发至驱动部分，并且等待结果回传，进而上报给Camera Provider。<br>CamX-CHI架构由CamX和CHI两个部分组成，CamX负责一些基础服务代码的实现，不经常改动，CHI负责实现一些可扩展性和定制化的需求，方便OEM/ODM添加自己的扩展功能。CamX主要包括实现HAL3入口的hal模块，实现与V4L2驱动交互的csl模块，实现硬件node的hwl和实现软件node的swl。CHI通过抽象出Usecase、Featrue、Session、Pipeline、Node的概念，使厂商可以通过实现Node接口来接入自己的算法，并通过XML文件灵活配置Usecase、Pipeline、Node的结构关系。</p>
<h2 id="Camera-Driver"><a href="#Camera-Driver" class="headerlink" title="Camera Driver"></a>Camera Driver</h2><p>Linux为视频采集设备制定了标准的V4L2接口，并在内核中实现了其基础框架V4L2 Core。用户空间进程可以通过V4L2接口调用相关设备功能，而不用考虑其实现细节。V4L2提出了总设备和子设备的概念，并通过media controller机制向用户空间暴露自己的硬件拓扑结构。视频采集设备驱动厂商按照V4L2 Core的要求开发自己的驱动程序，只需要实现相应的结构体和函数接口并调用注册函数注册自己就行。<br>在高通平台上，高通对相机驱动部分进行了实现，利用了V4L2框架的可扩展特性，设计出了一套独特的KMD框架。在该框架内部主要包含了三个部分，CRM、Camera Sync以及一系列子设备，首先，作为框架顶层管理者，CRM创建了一个V4L2主设备用来管理所有的子设备，并且暴露设备节点video0给用户空间，同时内部维护着整个底层驱动业务逻辑。其次，Camera Sync创建了一个V4L2主设备，同时暴露了设备节点video1给用户空间，主要用于向用户空间反馈图像数据处理状态。最后，子设备模块被抽象成v4l2_subdev设备，同样也暴露设备节点v4l2-subdev给用户空间进行更精细化的控制。另外，在整个框架初始化的过程中，通过media controller机制，保持了在用户空间进行枚举底层硬件设备的能力。</p>
<h2 id="Camera-Hardware"><a href="#Camera-Hardware" class="headerlink" title="Camera Hardware"></a>Camera Hardware</h2><p>相机硬件处在整个相机体系的最底层，是相机系统的物理实现部分，该部分包括镜头、感光器、ISP三个最重要的模块，还有对焦马达、闪光灯、滤光片、光圈等辅助模块。镜头的作用是汇聚光线，利用光的折射性把射入的光线汇聚到感光器上。感光器的作用是负责光电转换，通过内部感光元件将接收到的光信号转换为电子信号进而通过数电转换模块转为数字信号，并最后传给ISP。ISP负责对数字图像进行一些算法处理，如白平衡、降噪、去马赛克等。</p>
<p>通过上面的介绍，我们可以发现，谷歌通过以上五级分层，形成了整个相机框架体系，其中层与层之间通过行业协会、开源社区或者谷歌制订的标准接口进行连接，上层通过调用标准接口下发请求到下层，下层负责对标准接口进行实现，最终将请求再次封装并调用下一层级的对外接口下发到下层。所以总得来说，谷歌使用标准接口作为骨架搭建整体框架，而其具体实现交由各层自己负责，从整体上来看，职责划分明确，界限分明，这样的设计，一来利用标准接口，保持了整个框架业务正常流转，二来极大地降低了各层耦合度，保持了各层的相互独立，最终让整个框架处于一个稳定同时高效的运行状态。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="空白">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weikun's Notes">
      <meta itemprop="description" content="记录生活与职业中的点滴">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Weikun's Notes">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-1/" class="post-title-link" itemprop="url">深入理解Android相机体系结构之一：相机简史</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-11-21 00:25:33 / 修改时间：01:54:26" itemprop="dateCreated datePublished" datetime="2024-11-21T00:25:33+08:00">2024-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/1-Android-Camera/" itemprop="url" rel="index"><span itemprop="name">1. Android Camera</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>几千年来，人类主要通过文字以及绘画的方式记录着对于客观世界的认知，为了更直观地呈现客观世界的图景，摄影技术应运而生。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://shenweikun.github.io/2024/11/20/2024-11-20-memory-libmemunreachable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="空白">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weikun's Notes">
      <meta itemprop="description" content="记录生活与职业中的点滴">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Weikun's Notes">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/20/2024-11-20-memory-libmemunreachable/" class="post-title-link" itemprop="url">Memory libmemunreachable</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-20 23:06:27" itemprop="dateCreated datePublished" datetime="2024-11-20T23:06:27+08:00">2024-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-21 01:53:39" itemprop="dateModified" datetime="2024-11-21T01:53:39+08:00">2024-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/5-Memory/" itemprop="url" rel="index"><span itemprop="name">5. Memory</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>libmemunreachable is a zero-overhead native memory leak detector. </p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/11/20/2024-11-20-memory-libmemunreachable/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://shenweikun.github.io/2024/11/19/2024-11-20-MTKcam-ISP7-enable-fast-launch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="空白">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weikun's Notes">
      <meta itemprop="description" content="记录生活与职业中的点滴">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Weikun's Notes">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/19/2024-11-20-MTKcam-ISP7-enable-fast-launch/" class="post-title-link" itemprop="url">MTKcam-ISP7-enable fast launch</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-19 02:14:21" itemprop="dateCreated datePublished" datetime="2024-11-19T02:14:21+08:00">2024-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-21 01:53:44" itemprop="dateModified" datetime="2024-11-21T01:53:44+08:00">2024-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/1-Android-Camera/" itemprop="url" rel="index"><span itemprop="name">1. Android Camera</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Breakdown"><a href="#Breakdown" class="headerlink" title="Breakdown"></a>Breakdown</h2><p>相机的冷/热启动，若从systrace上分析耗时，可以按照cameraservice进程来分5个阶段：</p>
<ol>
<li> <strong>S1: AppLaunch_dispatchPtr:Up –&gt; connectDevice</strong><br>点击APP按钮到连接相机，这部分主要是APP和framework的耗时；</li>
<li> <strong>S2: connectDevice</strong><br>连接相机的耗时，对应HAL层的open操作，主要包括遍历sensorlist，加载tuning算法库（并行化的，不需要等上下电），主要是HAL部分耗时</li>
<li> <strong>S3: connectDevice –&gt; endConfigure</strong><br>CameraDevice callback之后，就可以调用createcapturesession（endConfigure），因此这部分耗时主要来源于APP和framework</li>
<li> <strong>S4:endConfigure</strong><br>对应HAL层的configstream，需要等待sensor上电完成，以及3A初始化，耗时主要是HAL部分</li>
<li> <strong>S5: endConfigure –&gt; first full buffer call back</strong><br>流配置完成到回帧到APP，需要等待HAL pipeline创建完成，3A计算和吐帧，主要耗时是HAL部分</li>
</ol>
<h2 id="analysis"><a href="#analysis" class="headerlink" title="analysis"></a>analysis</h2><p>breakdown的结果是<strong>S5: endConfigure –&gt; first full buffer call back</strong>耗时长，流配置完成到回帧到APP，需要等待HAL pipeline创建完成，3A计算和吐帧，主要耗时是HAL部分;<br>在这个阶段MTK有一个fast lunch功能可以开启</p>
<h2 id="fast-launch功能介绍"><a href="#fast-launch功能介绍" class="headerlink" title="fast launch功能介绍"></a>fast launch功能介绍</h2><p>fast launch又叫Fast Preview，在了解fast launch功能之前，我们首先需要知道request在MTK P1 Node中是如何流转的，具体过程可以参考文档<a href="https://shenweikun.github.io/2024/11/19/2024-11-20-MTKcam-ISP7-P1-Node/">ISP7-P1 node</a>简介 ，里面有相关介绍。<br>开启fast launch主要时节省了3A相关的计算，使用<strong>默认的3A计算结果（一般会是上一次退出相机时的3A计算结果）</strong>直接作用在driver，随后等待driver出帧。</p>
<h2 id="SysTrace分析"><a href="#SysTrace分析" class="headerlink" title="SysTrace分析"></a>SysTrace分析</h2><h3 id="Normal-Request："><a href="#Normal-Request：" class="headerlink" title="Normal Request："></a>Normal Request：</h3><p>cameraservice通过sendRequestsBatch下发quest，正常需要等待P1Node.queue走完之后才会返回：<br>   <img src="image1.png"><br>   <img src="image2.png"><br>并且会调用tryEnQ 并进入S_Enque状态，此时需要等待3A相关的计算：<br>   <img src="image3.png"></p>
<h3 id="fast-launch-Request："><a href="#fast-launch-Request：" class="headerlink" title="fast launch Request："></a>fast launch Request：</h3><p>   <img src="image4.png"><br>这里有3个sendRequestsBatch执行时间特别短，原因就是开启了fast launch功能。我们看来下这些request在HAL中是怎么走的：<br>   <img src="image5.png"><br>request下发到HAL之后并没有等待queue。queue动作在另一个线程中完成：<br>   <img src="image6.png"><br>另外，第一个queue函数执行很长，主要是在等res寄存器的写入。<br>   <img src="image7.png"><br>这里做的实际上是调用preEnQ，进入S_PreQue状态，这里便是核心区别。用preEnQ，进入S_PreQue状态，此时采用<strong>默认的3A计算结果（一般会是上一次退出相机时的3A计算结果）</strong>直接作用在driver，随后调用setupSubmission ，让 P1Node 将对应的 buffer 给 acquire 出来，并将buffer address给到Camctrl, 等待driver 吐帧。随后的流程和Normal Request一致。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>通过设置：<br>adb shell setprop vendor.debug.camera.pass1initrequestnum 4 //可以开启功能4-1=3帧，理论优化耗时3*33=99ms<br>或者直接在代码里面修改</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://shenweikun.github.io/2024/11/19/2024-11-20-MTKcam-ISP7-P1-Node/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="空白">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weikun's Notes">
      <meta itemprop="description" content="记录生活与职业中的点滴">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Weikun's Notes">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/19/2024-11-20-MTKcam-ISP7-P1-Node/" class="post-title-link" itemprop="url">MTKcam-ISP7-P1 Node</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-19 01:57:30" itemprop="dateCreated datePublished" datetime="2024-11-19T01:57:30+08:00">2024-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-21 01:53:46" itemprop="dateModified" datetime="2024-11-21T01:53:46+08:00">2024-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/1-Android-Camera/" itemprop="url" rel="index"><span itemprop="name">1. Android Camera</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="P1Node-Architecture-Overview"><a href="#P1Node-Architecture-Overview" class="headerlink" title="P1Node Architecture Overview"></a>P1Node Architecture Overview</h2><p>   <img src="image1.png"><br>如上图所示，在旧版的ISP6中，P1Node会直接与HAL3A，NormalPipe，HalIsp进行交互，但是在新的ISP7架构中，引入了CamCtrl作为协调者，统一协调Camsys Hw-Lib，P1Node与CAMCtrl进行交互。关于Camsys Hw-Lib的介绍可以看文档： <a href="https://shenweikun.github.io/2024/11/18/2024-11-20-MTKcam-ISP7-Camsys-Hw-Lib/">ISP7-Camsys Hw-Lib</a><br>由此，P1 Node的工作变得更加清晰简单。</p>
<h2 id="P1Node-Basic-Flow"><a href="#P1Node-Basic-Flow" class="headerlink" title="P1Node Basic Flow"></a>P1Node Basic Flow</h2><p>   <img src="image2.png"><br>如图是P1Node处理request的Basic Flow：</p>
<ol>
<li>首先P1Node会先实作一些callback，可让CamCtrl回调，主要实作是requestsubmission和setupsubmission。CamCtrl 透过 requestSubmission 去通知 P1Node 送 request 下来,此时 P1Node 会通知 Pipeline 送 request 下来,之后 Pipeline 就会调用 P1Node 的 queue 丢 request 下来,接着P1Node 会 call 到 CamCtrl 的 tryEnQ 将 request 送下来。</li>
<li>接下来 CamCtrl 会调用 setupSubmission,主要是告之 P1Node 已经送了 request 下来,CamCtrl 这边也拿到了对应的设定,让 P1Node 将对应的 buffer 给 acquire 出来,并通知 P1Node 设定 buffer 的address 给 CamCtrl。</li>
<li>P1Node 有一个 deque thread,这个 thread 会 call CamCtrl 的 tryDeQ,tryDeQ 是 blocking code,所以只有当真正 driver 那边有吐 data,CamCtrl 的 tryDeQ 才会放开,这个时候 P1Node 就可以拿到result 的数据。</li>
<li>P1Node 还有一个 deliver thread,deliver thread 会透过 pipeline 的接口进行 dispatch。</li>
</ol>
<h3 id="Nornal-Request："><a href="#Nornal-Request：" class="headerlink" title="Nornal Request："></a>Nornal Request：</h3><p>   <img src="image3.png"><br>上面是描述Normal Request的例子：</p>
<ol>
<li>假设MW透过P1Node的queue接口送request下来，P1Node 会先执行 parseFrame 产生 <strong>S_Queue</strong>，在S_Queue 的时候主要是去 call CamCtrl 的 tryEnQ(图中 S_Queue 后面的 hwOps_try_enque()表达的是它会 call try enque,其他的状态后面表示被相应的事件来 trigger)。</li>
<li>tryEnQ 主要是先告知 CamCtrl 有 request 进来,并将一些 setting 预先告知 CamCtrl。</li>
<li>tryEnQ 之后 state machine 就会进入 <strong>S_Enque</strong>,并等待下一个 event trigger,这个 event 会是setupSubmission,setupSubmission 被 trigger 的时候 S_Enque 相关 function 会被执行,这个过程会跟MW 要 buffer,做完之后 state machine 就会停留在 <strong>S_Deque</strong>。</li>
<li>S_Deque 状态会等 Deque thread trigger,当 deque thread 已经 deque 到东西,这个时候 S_Deque 的stage 就会做事情去产生 metadata,并切到下一个 state <strong>S_Deliver</strong> 等待被 trigger。</li>
<li>当Deliver thread 知道有可以 Deliver 的 frame 进入之后就会 call pipeline 的接口做 deliver。</li>
</ol>
<h3 id="Reprocess："><a href="#Reprocess：" class="headerlink" title="Reprocess："></a>Reprocess：</h3><p>   <img src="image4.png"></p>
<h3 id="FastPreview-fast-launch"><a href="#FastPreview-fast-launch" class="headerlink" title="FastPreview(fast launch):"></a>FastPreview(fast launch):</h3><p>   <img src="image5.png"><br>FastPreview的流程如上图(if preqCnt != -1)的流程，原本正常的流程request需要tryEnQ 并进入S_Enque状态，此时需要等待3A相关的计算。<br>为了加速启动，当((if preqCnt != -1)成立时，会调用preEnQ，进入S_PreQue状态，此时采用<strong>默认的3A计算结果（一般会是上一次退出相机时的3A计算结果）</strong>直接作用在driver，随后调用setupSubmission ，让 P1Node 将对应的 buffer 给 acquire 出来，并将buffer address给到Camctrl, 等待driver 吐帧。随后的流程和Normal Request一致。</p>
<h3 id="Drop-Case："><a href="#Drop-Case：" class="headerlink" title="Drop Case："></a>Drop Case：</h3><p>drop case应用在上层下发flush的场景，通过dropSubmission实现drop：<br>   <img src="image6.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://shenweikun.github.io/2024/11/19/2024-11-20-MTKcam-ISP7-CamCtrl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="空白">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weikun's Notes">
      <meta itemprop="description" content="记录生活与职业中的点滴">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Weikun's Notes">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/19/2024-11-20-MTKcam-ISP7-CamCtrl/" class="post-title-link" itemprop="url">MTKcam-ISP7-CamCtrl</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-19 01:46:48" itemprop="dateCreated datePublished" datetime="2024-11-19T01:46:48+08:00">2024-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-21 01:53:40" itemprop="dateModified" datetime="2024-11-21T01:53:40+08:00">2024-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/1-Android-Camera/" itemprop="url" rel="index"><span itemprop="name">1. Android Camera</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="CamCtrl简介："><a href="#CamCtrl简介：" class="headerlink" title="CamCtrl简介："></a>CamCtrl简介：</h2><p>文件目录：vendor/mediatek/proprietary/hardware/mtkcam-core/hw/camsys/cam_ctrl/<br>CamCtrl是P1Node/PipeMgr/3A HAL/ISP HAL的协调者。其主要有两个作用：</p>
<ul>
<li>搜集从P1 Node过来的request Info，然后queue给driver（使用PipeMgr并通过SensorPipe接口丢给MTK drivers):<br>request Info包含：</li>
<li>Image Info. (from P1Node)，例如上层传下来的buffer size，format等</li>
<li>Setting (from 3A-HAL)，例如需要给到driver的gain值，曝光等</li>
<li>Tuning (from ISP-HAL)，例如从tuning参数中获取的信息等</li>
<li>从driver中做deque(使用PipeMgr并通过SensorPipe接口),并将结果传递给用户：<ul>
<li>Image buffer(to P1Node)</li>
<li>STT buffer(to 3A HAL)，如AAO，AFO等统计信息</li>
</ul>
</li>
</ul>
<p>更多可以参考：<a href="https://shenweikun.github.io/2024/11/18/2024-11-20-MTKcam-ISP7-Camsys-Hw-Lib/">ISP7-Camsys Hw-Lib</a></p>
<h2 id="CamCtrl基本流程"><a href="#CamCtrl基本流程" class="headerlink" title="CamCtrl基本流程:"></a>CamCtrl基本流程:</h2><p>   <img src="image1.png"><br>如上图，描述的是CamCtrl与其它模块相互交互时使用的function。不同颜色的线代表不同的线程，其中requestregulator thread是混色的，代表包含多个线程(实现同一功能)。同一颜色的不同标号代表一串事件的先后顺序。</p>
<h3 id="request-thread"><a href="#request-thread" class="headerlink" title="request thread:"></a>request thread:</h3><ol>
<li>当Pipeline model Queue一个request到P1 Node时，P1 Node会调用的Camtrl的tryEnQ()往Camtrl塞request</li>
<li>随后CamCtrl会调用到3A-HAL的setControl()，把当前request带下来的metadata数据设置到3A-HAL中，让3A-HAL去做一些预处理。</li>
<li>同时，CamCtrl还会调用到RequestRegulator中的enrollRequest()函数，通知RequestRegulator，CamCtrl收到了一帧request，并且已将其相关的metadata参数设置到了3A-HAL。此信息将用于控制request的节奏。</li>
</ol>
<h3 id="requestRegulator-thread"><a href="#requestRegulator-thread" class="headerlink" title="requestRegulator thread:"></a>requestRegulator thread:</h3><ol>
<li>RequestRegulator有一个线程会通过CamCtrl去调用到Sensor-Pipe的wait-SOF()，去等待sof信号。</li>
<li>当RequestRegulator收到sof信号后，会通过CamCtrl的cueFrameStart()去triggerFrameStart（我理解是触发接收下一个request）。</li>
<li>CamCtrl调用RequestRegulator的available()去确认request的节奏，CamCtrl是否可以接收下一个request。</li>
<li>若能接收下一个quest，CamCtrl会调用到P1 Node的requestSubmission()，告诉P1 Node可以继续tryEnQ()塞request下来了。</li>
<li>于此同时,CamCtrl会通过P1 Node的setupSubmission(),去获取上一个request的image buffer。</li>
</ol>
<h3 id="deque-thread"><a href="#deque-thread" class="headerlink" title="deque thread:"></a>deque thread:</h3><ol>
<li>P1 Node会调用CamCtrl的tryDeQ()。tryDeQ()是blocking code，所以只有当真正的driver那边吐出data，CamCtrl的tryDeQ才会被完成，这个时候P1 Node就可以拿到result的数据。</li>
<li>CamCtrl的tryDeQ()实际会去调用Sensor-Pipe的deque()，然后等待driver deque数据出来。这个数据包括Image buffer和STT buffer。</li>
<li>当Sensor-Pipe deque出数据之后，首先CamCtrl会调用3A-HAL 的setSttBuffer()，将统计数据设置到3A-HAL</li>
<li>CamCtrl调用3A-HAL的getResult()，去获取3A的result meta。</li>
<li>CamCtrl调用ISP-HAL的getResultByFrameID()，去获取ISP的result meta。</li>
</ol>
<h3 id="CamCtrl-thread-3A-thread"><a href="#CamCtrl-thread-3A-thread" class="headerlink" title="CamCtrl thread/3A thread:"></a>CamCtrl thread/3A thread:</h3><ol>
<li>当deque thread的第3步，CamCtrl通过setSttBuffer将统计数据给到3A-HAL后，若3A-HAL使用完，会调用notifySettingReadyEvent()告诉CamCtrl有一个request的结果计算完成了。</li>
<li>CamCtrl调用3A-HAL的getSetting()，拿到3A-HAL的计算结果。</li>
<li>CamCtrl调用ISP-HAL的getCamSysMetaTuning()，拿到ISP-HAL的计算结果。</li>
<li>前面2(getSetting())，3(getCamSysMetaTuning())，结合requestRegulator thread中的5(setupSubmission())，这里就获取到了3份数据（3A-HAL的计算结果，ISP-HAL的计算结果，Image Buffer），此时所有数据准备就绪，就可以通过CamCtrl去调用RequestRegulator的informReady()，通知RequestRegulator已经CamCtrl已经准备好了，可以enque了。</li>
<li>RequestRegulator调用CamCtrl的hintForEnQ(),去通知CamCtrl做enque。</li>
<li>CamCtrl去做enque。</li>
<li>当CamCtrl做完enque之后，CamCtrl会调用RequestRegulator的informCount，去告诉RequestRegulator，我已经往driver做enque了。之所以要告诉RequestRegulator，是因为RequestRegulator要控制enque的节奏，避免driver中累积太多的request。</li>
</ol>
<p>参考：[ISP7]CAMSYS_HW-Lib_P1Node_CamCtrl.pdf</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://shenweikun.github.io/2024/11/18/2024-11-20-MTKcam-ISP7-Camsys-Hw-Lib/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="空白">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weikun's Notes">
      <meta itemprop="description" content="记录生活与职业中的点滴">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Weikun's Notes">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/18/2024-11-20-MTKcam-ISP7-Camsys-Hw-Lib/" class="post-title-link" itemprop="url">MTKcam-ISP7-Camsys Hw-Lib</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-18 03:00:31" itemprop="dateCreated datePublished" datetime="2024-11-18T03:00:31+08:00">2024-11-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-21 01:53:42" itemprop="dateModified" datetime="2024-11-21T01:53:42+08:00">2024-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/1-Android-Camera/" itemprop="url" rel="index"><span itemprop="name">1. Android Camera</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="High-Level-view"><a href="#High-Level-view" class="headerlink" title="High-Level view"></a>High-Level view</h2><p><img src="High-Level-view.png"><br>CAMSYS_HW-Lib所在位置如上图红框所示，包含<strong>CamCtrl</strong>，<strong>PipeMgr</strong>，<strong>CamCoordinator</strong>，<strong>RequestRegulator</strong>四个模块，向上通过CamCtrl沟通P1Node，向下通过PipeMgr对接drivers，访问硬件，同时CamCtrl还可以沟通IHALIsp Adapter和3A control flows。<br><img src="image1.png"></p>
<h3 id="CamCtrl"><a href="#CamCtrl" class="headerlink" title="CamCtrl:"></a>CamCtrl:</h3><p>文件目录：vendor/mediatek/proprietary/hardware/mtkcam-core/hw/camsys/cam_ctrl/<br>CamCtrl是P1Node/PipeMgr/3A HAL/ISP HAL的协调者。其主要有两个作用：</p>
<ul>
<li>搜集从P1 Node过来的request Info，然后queue给driver（使用PipeMgr并通过SensorPipe接口丢给MTK drivers):<br>request Info包含：</li>
<li>Image Info. (from P1Node)，例如上层传下来的buffer size，format等</li>
<li>Setting (from 3A-HAL)，例如需要给到driver的gain值，曝光等</li>
<li>Tuning (from ISP-HAL)，例如从tuning参数中获取的信息等</li>
<li>从driver中做deque(使用PipeMgr并通过SensorPipe接口),并将结果传递给用户：<ul>
<li>Image buffer(to P1Node)</li>
<li>STT buffer(to 3A HAL)，如AAO，AFO等统计信息</li>
</ul>
</li>
</ul>
<h3 id="PipeMgr-SensorPipe"><a href="#PipeMgr-SensorPipe" class="headerlink" title="PipeMgr/SensorPipe:"></a>PipeMgr/SensorPipe:</h3><p>文件目录：vendor/mediatek/proprietary/hardware/mtkcam-core/hw/camsys/pipe_mgr/<br>pipeMgr的作用：</p>
<ul>
<li>简化和封装V4L2-FW操作</li>
<li>抽象化CamCtrl</li>
<li>构建sensor map，映射driver中的设备文件<br>pipe_mgr兼容isp6，pipe_mgr目录下有isp6s和isp7两个目录。主要有如下几个类：<br><img src="image2.png"><br>PipeCapability类没在代码中找到定义。PiPeMgr和sensorPipe互为友元，PiPeMgr和RawPipe互为友元。剩下三个是PipeMgr的友元，可以访问PipeMgr的数据。</li>
</ul>
<h3 id="CamCoordinator"><a href="#CamCoordinator" class="headerlink" title="CamCoordinator:"></a>CamCoordinator:</h3><p>文件目录：vendor/mediatek/proprietary/hardware/mtkcam-core/hw/camsys/cam_coordinator/<br>CamCoordinator作用：</p>
<ul>
<li>Negotiate and Configure the CAMSYS topology</li>
<li>Align MW-Frame and CAMSYS Request in multiple-sensor sources</li>
</ul>
<h3 id="RequestRegulator"><a href="#RequestRegulator" class="headerlink" title="RequestRegulator:"></a>RequestRegulator:</h3><p>文件目录：vendor/mediatek/proprietary/hardware/mtkcam-core/hw/camsys/request_regulator/<br>RequestRegulator的作用：</p>
<ul>
<li>防止request累积，因为enque给driver的request都需要被消费，不会被drop，所以当P1处理较慢就会形成堆积。</li>
<li>监控和调整request消耗</li>
<li>为Cam Ctrl提供不同的策略选择<br>  <img src="image3.png"><br>主要有ContSttRegulator，ImageRequestRegulator，SttRegulator三个类对IRequestRegulator接口的实现。</li>
</ul>
<h2 id="Instance-view"><a href="#Instance-view" class="headerlink" title="Instance view"></a>Instance view</h2><p>如下是从instance view的视角来看Camsys-HW-Lib各个模块间的关系:<br>   <img src="image4.png"><br>1.此图是一个multicam的例子，可以看到左右两边是对称的<br>2. PipeMgr针对不同的sensor有开出两个SensorPipe接口，不同Sensor的CamCtrl会使用的不同的SensorPipe接口实例<br>3.其他的如：P1Node、HalISP、Hal3A、RequestRegulator也都是每个实例服务对应的单颗sensor<br>4.而像CamCoordinator、PipeMgr、V4L2 Framework因为需要统筹整个系统的资源，所以是Topology的View<br>从这个图也可以看出，<strong>CamCtrl</strong>和<strong>P1Node</strong>等可以有多个实例，<strong>CamCoordinator</strong>和<strong>RequestRegulator</strong>只有单个实例，用于统筹<strong>CamCtrl和P1Node</strong>等模块</p>
<h2 id="The-role-conception-of-module-layer"><a href="#The-role-conception-of-module-layer" class="headerlink" title="The role/conception of module-layer"></a>The role/conception of module-layer</h2><p>下图描述了从PipelineModel→ P1Node→ CamCtrl→ PipeMgr→ V4L2各层级作用和扮演的角色。<br>   <img src="image5.png"></p>
<h2 id="Data-Processing"><a href="#Data-Processing" class="headerlink" title="Data Processing"></a>Data Processing</h2><p>   <img src="image6.png"><br>例如：pipelineModel会送一个request给P1Node，P1Node会送给CamCtrl，到了CamCtrl之后，它会跟P1Node拿image、跟ISP_HAL拿tuning、跟HAL3A拿setting，都准备好后就一整包使用同一个<strong>request-FD</strong>打包好后送给PipeMgr，之后再透过PipeMgr往V4L2 FrameWork进行设置，进而控制底层driver的行为。<br>ISP7 之前 P1Node 会跟 Hal3A、P1Driver、HalISP 都有交互,目前在 ISP7 上对 P1Node 有做解耦操作,P1Node 会跟 MW 对接,处理 feature 相关的部分,而跟其他模块交互的动作就交给了 CamCtrl,使 P1Node 的工作变得单纯,也使得 CamCtrl 可以不用关注 feature 相关的部分。</p>
<p>参考文章：<br>[ISP7]CAMSYS_HW-Lib_P1Node_CamCtrl.pdf</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://shenweikun.github.io/2024/11/18/2024-11-20-CPP-Basics-C-Design-Patterns/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="空白">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weikun's Notes">
      <meta itemprop="description" content="记录生活与职业中的点滴">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Weikun's Notes">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/18/2024-11-20-CPP-Basics-C-Design-Patterns/" class="post-title-link" itemprop="url">C++从入门到进阶之五-C++的设计模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-18 02:11:50" itemprop="dateCreated datePublished" datetime="2024-11-18T02:11:50+08:00">2024-11-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-21 01:53:37" itemprop="dateModified" datetime="2024-11-21T01:53:37+08:00">2024-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/4-C-C/" itemprop="url" rel="index"><span itemprop="name">4. C/C++</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://shenweikun.github.io/2024/11/18/2024-11-19-CPP-Basics-C-Programming-Optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="空白">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weikun's Notes">
      <meta itemprop="description" content="记录生活与职业中的点滴">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Weikun's Notes">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/18/2024-11-19-CPP-Basics-C-Programming-Optimization/" class="post-title-link" itemprop="url">C++从入门到进阶之四-C++编程优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-18 02:11:08" itemprop="dateCreated datePublished" datetime="2024-11-18T02:11:08+08:00">2024-11-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-21 01:53:33" itemprop="dateModified" datetime="2024-11-21T01:53:33+08:00">2024-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/4-C-C/" itemprop="url" rel="index"><span itemprop="name">4. C/C++</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="C-编程功底和常用规则"><a href="#C-编程功底和常用规则" class="headerlink" title="C++编程功底和常用规则"></a>C++编程功底和常用规则</h2><p>待完成…</p>
<h2 id="C-并发编程"><a href="#C-并发编程" class="headerlink" title="C++并发编程"></a>C++并发编程</h2><h3 id="并发编程相关基础概念"><a href="#并发编程相关基础概念" class="headerlink" title="并发编程相关基础概念"></a>并发编程相关基础概念</h3><p>待完成…</p>
<h3 id="pthread使用讲解和实战"><a href="#pthread使用讲解和实战" class="headerlink" title="pthread使用讲解和实战"></a>pthread使用讲解和实战</h3><p>1、简介<br>POSIX线程（英语：POSIX Threads，常被缩写为Pthreads）是POSIX的线程标准，定义了创建和操纵线程的一套API。<br>实现POSIX 线程标准的库常被称作Pthreads，一般用于Unix-likePOSIX 系统，如Linux、Solaris。</p>
<p>2、pthread的使用<br>需求：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建线程并运行，验证线程函数会被调度运行</span></span><br><span class="line"><span class="comment">// 2. 向子线程传参并接收</span></span><br><span class="line"><span class="comment">// 3. 使用pthread_join来回收线程，验证主线阻塞等待子线程完成后再执行</span></span><br><span class="line"><span class="comment">// 4. 线程函数使用ptread_exit主动结束</span></span><br><span class="line"><span class="comment">// 5. 子线程向主线程返回值，主线程通过 pthread_join 来接收</span></span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">testFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = *(<span class="keyword">int</span> *)arg;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[cnt];   <span class="comment">// 注意：这里是分配在堆上的,因为这个会return p， 若分配在栈上，这个函数执行完毕之后就被销毁了，无法被return</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;call testFunc , arg: &quot;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        p[i] = i + <span class="number">2</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; p[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//return p;       // 正常返回</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(p);  <span class="comment">//使用 pthread_exit 主动结束当前线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arg = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> *retValue;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, testFunc, &amp;arg);  <span class="comment">// arg 会作为参数传给 testFunc</span></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pthread_create success!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">pthread_join</span>(tid, (<span class="keyword">void</span>**)&amp;retValue);   <span class="comment">// pthread_join 会阻塞，等待子线程执行完成， 接收 testFunc 的返回值</span></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pthread_join success!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; arg; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;retValue[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; retValue[i] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> retValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pthread_create success!</span><br><span class="line">call testFunc , arg: <span class="number">3</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">p[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">p[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line">pthread_join success!</span><br><span class="line">retValue[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">retValue[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">retValue[<span class="number">2</span>] = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="pthread线程分离"><a href="#pthread线程分离" class="headerlink" title="pthread线程分离"></a>pthread线程分离</h3><p>1、 线程的状态</p>
<ol>
<li>   线程有两种状态： <strong>JOINABLE</strong> 和 <strong>DETACHED</strong> ，默认是 JOINABLE</li>
<li>   <strong>JOINABLE 的线程必须在创建它的线程中使用 pthread_join 回收，否则会有资源未释放</strong></li>
<li>   <strong>DETACHED 的线程可以在终止时释放资源，这样创建它的线程就不用通过 pthread_join 来等待回收</strong></li>
<li>   <strong>线程转为 DETACHED 有两种方法</strong>:<br>第一种是线程函数内部自己调用 pthread_detach(pthread_self());<br>第二种是使用线程属性 pthread_attr</li>
</ol>
<p>2、线程函数内部自己调用 pthread_detach(pthread_self());</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">testFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());   <span class="comment">// 注意：将线程状态改为 DETACHED</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = *(<span class="keyword">int</span> *)arg;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[cnt];   <span class="comment">// 注意：这里是分配在堆上的,因为这个会return p， 若分配在栈上，这个函数执行完毕之后就被销毁了，无法被return</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;call testFunc , arg: &quot;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        p[i] = i + <span class="number">2</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; p[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return p;       // 正常返回</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(p);  <span class="comment">//使用 pthread_exit 主动结束当前线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arg = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> *retValue;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, testFunc, &amp;arg);  <span class="comment">// arg 会作为参数传给 testFunc</span></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pthread_create success!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 DETACHED 线程中， pthread_join 其实是不需要的，这里是做实验保留</span></span><br><span class="line">    ret = <span class="built_in">pthread_join</span>(tid, (<span class="keyword">void</span>**)&amp;retValue);   <span class="comment">// pthread_join 会阻塞，等待子线程执行完成， 接收 testFunc 的返回值</span></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pthread_join success!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; arg; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;retValue[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; retValue[i] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> retValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 会跑到这里，因为子线程中已经把线程状态修改成 DETACHED 了，不需要使用  pthread_join 来阻塞等待资源释放</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pthread_join fail!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;start to pthread_exit main …&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 退出主线程，主线程退出后，子线程依旧可以继续执行。因为 pthread_exit 是针对线程的，不是针对进程</span></span><br><span class="line">    <span class="comment">// 若不加这个，随着 return 0的调用，进程就终止了，子线程 testFunc 也会被终止</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pthread_create success!</span><br><span class="line">pthread_join fail!</span><br><span class="line">start to pthread_exit main …</span><br><span class="line">call testFunc , arg: <span class="number">3</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">p[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">p[<span class="number">2</span>] = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>3、使用线程属性 pthread_attr<br>(1) pthread_attr_t attr; //声明一个参数<br>(2) pthread_attr_init(&amp;attr); //对参数进行初始化<br>(3) pthread_attr_setdetachstate(&amp;attr， PTHREAD_CREATE_JOINABLE); //设置线程为可连接的<br>(4) pthread_attr_setdetachstate(&amp;attr， PTHREAD_CREATE_DETACHED); //设置线程为可分离的<br>(5) pthread_attr_destroy(&amp;attr); //销毁属性，防止内存泄露<br>(6) 实战：使用 int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); //设置线程为状态<br>(7) int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">testFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = *(<span class="keyword">int</span> *)arg;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[cnt];   <span class="comment">// 注意：这里是分配在堆上的,因为这个会return p， 若分配在栈上，这个函数执行完毕之后就被销毁了，无法被return</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;call testFunc , arg: &quot;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        p[i] = i + <span class="number">2</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; p[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return p;       // 正常返回</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(p);  <span class="comment">//使用 pthread_exit 主动结束当前线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arg = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> *retValue;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="keyword">int</span> detachstate;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line">    <span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, testFunc, &amp;arg);  <span class="comment">// arg 会作为参数传给 testFunc</span></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pthread_create success!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">pthread_attr_getdetachstate</span>(&amp;attr, &amp;detachstate);</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( detachstate == PTHREAD_CREATE_DETACHED )</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;detachstate == PTHREAD_CREATE_DETACHED&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( detachstate == PTHREAD_CREATE_JOINABLE )</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;detachstate == PTHREAD_CREATE_JOINABLE&quot;</span> &lt;&lt; endl;</span><br><span class="line">            ret = <span class="built_in">pthread_join</span>(tid, (<span class="keyword">void</span>**)&amp;retValue); <span class="comment">// pthread_join 会阻塞，等待子线程执行完成， 接收 testFunc 的返回值</span></span><br><span class="line">            <span class="keyword">if</span> (!ret)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;pthread_join success!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; arg; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;retValue[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; retValue[i] &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span> retValue;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 会跑到这里，因为子线程中已经把线程状态修改成 DETACHED 了，不需要使用  pthread_join 来阻塞等待资源释放</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;pthread_join fail!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_attr_destroy</span>(&amp;attr);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;start to pthread_exit main …&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 退出主线程，主线程退出后，子线程依旧可以继续执行。因为 pthread_exit 是针对线程的，不是针对进程</span></span><br><span class="line">    <span class="comment">// 若不加这个，随着 return 0的调用，进程就终止了，子线程 testFunc 也会被终止</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、关于多线程编程的几个值得注意的点：</p>
<ol>
<li>   <strong>main 所在的线程称之为“初始线程”，从main返回的时候，整个进程就被终止了</strong></li>
<li>   <strong>在任意线程内调用 exit 函数都会让该线程所在的进程整个退出。所以主动退出线程的时候一定要使用 pthread_exit ，而不是 exit</strong></li>
<li>   <strong>当主线程调用 pthread_exit 函数仅仅只是终止主线程，其它线程仍将继续存在</strong></li>
</ol>
<h3 id="线程同步-互斥锁"><a href="#线程同步-互斥锁" class="headerlink" title="线程同步_互斥锁"></a>线程同步_互斥锁</h3><p>1、 <strong>互斥锁: 对共享数据进行锁定，保证同一时刻只能有一个线程去操作。</strong><br>2、注意: <strong>互斥锁是多个线程一起去抢，抢到锁的线程先执行，没有抢到锁的线程需要等待，等互斥锁使用完释放后，其它等待的线程再去抢这个锁。</strong><br>3、互斥锁的使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 互斥锁 mutex</span></span><br><span class="line">(<span class="number">1</span>) 互斥锁静态初始化：<span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">(<span class="number">2</span>) 互斥锁动态初始化： <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">(<span class="number">3</span>) 上锁和解锁： <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">(<span class="number">4</span>) 互斥锁销毁： <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p>实战：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> g_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">testFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;g_mutex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">200</span>*<span class="number">1000</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;g_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">200</span>*<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;g_mutex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">5</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">200</span>*<span class="number">1000</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;g_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;g_mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    ret1 = <span class="built_in">pthread_create</span>(&amp;tid1, <span class="literal">NULL</span>, testFunc, <span class="literal">NULL</span>);</span><br><span class="line">    ret2 = <span class="built_in">pthread_create</span>(&amp;tid2, <span class="literal">NULL</span>, testFunc, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    ret1 = <span class="built_in">pthread_join</span>(tid1, <span class="literal">NULL</span>);   <span class="comment">// pthread_join 会阻塞，等待子线程执行完成， 接收 testFunc 的返回值</span></span><br><span class="line">    <span class="keyword">if</span> (!ret1)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pthread_join tid1 success!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ret2 = <span class="built_in">pthread_join</span>(tid2, <span class="literal">NULL</span>);   <span class="comment">// pthread_join 会阻塞，等待子线程执行完成， 接收 testFunc 的返回值</span></span><br><span class="line">    <span class="keyword">if</span> (!ret2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pthread_join tid2 success!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;g_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">139925917001472</span> <span class="number">0</span></span><br><span class="line"><span class="number">139925917001472</span> <span class="number">1</span></span><br><span class="line"><span class="number">139925917001472</span> <span class="number">2</span></span><br><span class="line"><span class="number">139925917001472</span> <span class="number">3</span></span><br><span class="line"><span class="number">139925917001472</span> <span class="number">4</span></span><br><span class="line"><span class="number">139925908608768</span> <span class="number">0</span></span><br><span class="line"><span class="number">139925908608768</span> <span class="number">1</span></span><br><span class="line"><span class="number">139925908608768</span> <span class="number">2</span></span><br><span class="line"><span class="number">139925908608768</span> <span class="number">3</span></span><br><span class="line"><span class="number">139925908608768</span> <span class="number">4</span></span><br><span class="line"><span class="number">139925917001472</span> <span class="number">5</span></span><br><span class="line"><span class="number">139925917001472</span> <span class="number">6</span></span><br><span class="line"><span class="number">139925917001472</span> <span class="number">7</span></span><br><span class="line"><span class="number">139925917001472</span> <span class="number">8</span></span><br><span class="line"><span class="number">139925917001472</span> <span class="number">9</span></span><br><span class="line">pthread_join tid1 success!</span><br><span class="line"><span class="number">139925908608768</span> <span class="number">5</span></span><br><span class="line"><span class="number">139925908608768</span> <span class="number">6</span></span><br><span class="line"><span class="number">139925908608768</span> <span class="number">7</span></span><br><span class="line"><span class="number">139925908608768</span> <span class="number">8</span></span><br><span class="line"><span class="number">139925908608768</span> <span class="number">9</span></span><br><span class="line">pthread_join tid2 success!</span><br></pre></td></tr></table></figure>

<h3 id="线程同步-读写锁"><a href="#线程同步-读写锁" class="headerlink" title="线程同步_读写锁"></a>线程同步_读写锁</h3><p>1、 读写锁概念</p>
<ol>
<li>   <strong>读写锁（Readers-Writer Lock）顾名思义是一把锁分为两部分：读锁和写锁。</strong></li>
<li>   <strong>其中读锁允许多个线程同时获得，因为读操作本身是线程安全的，而写锁则是互斥锁，不允许多个线程同时获得写锁，并且写操作和读操作也是互斥的。</strong></li>
<li>   总结来说，读写锁的特点是：<strong>读读不互斥、读写互斥、写写互斥</strong></li>
</ol>
<p>2、 读写锁的使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_rwlock_init</span>(&amp;g_rwlock, <span class="literal">NULL</span>); <span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="built_in">pthread_rwlock_wrlock</span>(&amp;g_rwlock);     <span class="comment">// 写锁</span></span><br><span class="line"><span class="built_in">pthread_rwlock_rdlock</span>(&amp;g_rwlock);     <span class="comment">// 读锁</span></span><br><span class="line"><span class="built_in">pthread_rwlock_tryrdlock</span>(&amp;g_rwlock);  <span class="comment">// 非阻塞读锁</span></span><br><span class="line"><span class="built_in">pthread_rwlock_trywrlock</span>(&amp;g_rwlock);  <span class="comment">// 非阻塞写锁</span></span><br><span class="line"><span class="built_in">pthread_rwlock_unlock</span>(&amp;g_rwlock);     <span class="comment">// 将读锁或写锁解锁</span></span><br><span class="line"><span class="built_in">pthread_rwlock_destroy</span>(&amp;g_rwlock);    <span class="comment">// 销毁</span></span><br></pre></td></tr></table></figure>
<p>实战：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> g_rwlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">testFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_rwlock_wrlock</span>(&amp;g_rwlock);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">200</span>*<span class="number">1000</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_rwlock_unlock</span>(&amp;g_rwlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_rwlock_init</span>(&amp;g_rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    ret1 = <span class="built_in">pthread_create</span>(&amp;tid1, <span class="literal">NULL</span>, testFunc, <span class="literal">NULL</span>);</span><br><span class="line">    ret2 = <span class="built_in">pthread_create</span>(&amp;tid2, <span class="literal">NULL</span>, testFunc, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    ret1 = <span class="built_in">pthread_join</span>(tid1, <span class="literal">NULL</span>);   <span class="comment">// pthread_join 会阻塞，等待子线程执行完成， 接收 testFunc 的返回值</span></span><br><span class="line">    <span class="keyword">if</span> (!ret1)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pthread_join tid1 success!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ret2 = <span class="built_in">pthread_join</span>(tid2, <span class="literal">NULL</span>);   <span class="comment">// pthread_join 会阻塞，等待子线程执行完成， 接收 testFunc 的返回值</span></span><br><span class="line">    <span class="keyword">if</span> (!ret2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pthread_join tid2 success!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_rwlock_destroy</span>(&amp;g_rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">140108497356544</span> <span class="number">0</span></span><br><span class="line"><span class="number">140108497356544</span> <span class="number">1</span></span><br><span class="line"><span class="number">140108497356544</span> <span class="number">2</span></span><br><span class="line"><span class="number">140108497356544</span> <span class="number">3</span></span><br><span class="line"><span class="number">140108497356544</span> <span class="number">4</span></span><br><span class="line"><span class="number">140108497356544</span> <span class="number">5</span></span><br><span class="line"><span class="number">140108497356544</span> <span class="number">6</span></span><br><span class="line"><span class="number">140108497356544</span> <span class="number">7</span></span><br><span class="line"><span class="number">140108497356544</span> <span class="number">8</span></span><br><span class="line"><span class="number">140108497356544</span> <span class="number">9</span></span><br><span class="line">pthread_join tid1 success!</span><br><span class="line"><span class="number">140108488963840</span> <span class="number">0</span></span><br><span class="line"><span class="number">140108488963840</span> <span class="number">1</span></span><br><span class="line"><span class="number">140108488963840</span> <span class="number">2</span></span><br><span class="line"><span class="number">140108488963840</span> <span class="number">3</span></span><br><span class="line"><span class="number">140108488963840</span> <span class="number">4</span></span><br><span class="line"><span class="number">140108488963840</span> <span class="number">5</span></span><br><span class="line"><span class="number">140108488963840</span> <span class="number">6</span></span><br><span class="line"><span class="number">140108488963840</span> <span class="number">7</span></span><br><span class="line"><span class="number">140108488963840</span> <span class="number">8</span></span><br><span class="line"><span class="number">140108488963840</span> <span class="number">9</span></span><br><span class="line">pthread_join tid2 success!</span><br></pre></td></tr></table></figure>

<h3 id="线程同步-条件变量"><a href="#线程同步-条件变量" class="headerlink" title="线程同步_条件变量"></a>线程同步_条件变量</h3><p>1、条件变量概念<br>条件变量（condition variable）是为了等待某个条件成立而设计，提供一种线程间通知机制，在条件成立之前，等待线程进入睡眠状态，当某个条件成立时，信号端发射signal/broadcast来“唤醒”等待线程。<br>具体参考：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bigosprite/p/11068687.html">https://www.cnblogs.com/bigosprite/p/11068687.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/chengonghao/article/details/51779279">https://blog.csdn.net/chengonghao/article/details/51779279</a></p>
<p>2、条件变量的使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSUMERS_COUNT 2        </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRODUCERS_COUNT 1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">pthread_mutex_t</span> g_mutex ;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> g_cond ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">pthread_t</span> g_thread[CONSUMERS_COUNT + PRODUCERS_COUNT] ;</span><br><span class="line"><span class="keyword">int</span> share_variable = <span class="number">0</span> ;<span class="comment">// this is the share variable, shared by consumer and producer</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer</span><span class="params">( <span class="keyword">void</span>* arg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> num = *(<span class="keyword">int</span> *)arg;</span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">1</span> ) </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">/******* critical section begin *******/</span></span><br><span class="line">      <span class="built_in">pthread_mutex_lock</span>( &amp;g_mutex ) ;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// if share_variable == 0, means consumer shell stop here</span></span><br><span class="line">      <span class="keyword">while</span> ( share_variable == <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">printf</span>( <span class="string">&quot;consumer %d begin wait a condition...\n&quot;</span>, num ) ;</span><br><span class="line">         <span class="comment">// put a thread blocked ont a condition variable( here is g_cond),</span></span><br><span class="line">         <span class="comment">// and unlock the mutex( here is g_mutex )</span></span><br><span class="line">         <span class="built_in">pthread_cond_wait</span>( &amp;g_cond, &amp;g_mutex ) ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// here means n != 0 and consumer can goes on</span></span><br><span class="line">      <span class="comment">// consumer consumed shared variable, so the number of shared variable shell minus</span></span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">&quot;consumer %d end wait a condition...\n&quot;</span>, num ) ;</span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">&quot;consumer %d begin consume product\n&quot;</span>, num ) ;</span><br><span class="line">      --share_variable ;</span><br><span class="line"> </span><br><span class="line">      <span class="built_in">pthread_mutex_unlock</span>( &amp;g_mutex ) ;</span><br><span class="line">      <span class="comment">/******** critial section end *********/</span></span><br><span class="line">      <span class="built_in">sleep</span>( <span class="number">1</span> ) ;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span> ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">( <span class="keyword">void</span>* arg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> num = *(<span class="keyword">int</span> *)arg;</span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">/******* critical section begin *******/</span></span><br><span class="line">      <span class="built_in">pthread_mutex_lock</span>( &amp;g_mutex ) ;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// produce a shared variable</span></span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">&quot;--- producer %d begin produce product...\n&quot;</span>, num ) ;</span><br><span class="line">      ++share_variable ;</span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">&quot;--- producer %d end produce product...\n&quot;</span>, num ) ;</span><br><span class="line">      <span class="comment">// unblock threads blocked on a condition variable( here is g_cond )</span></span><br><span class="line">      <span class="built_in">pthread_cond_signal</span>( &amp;g_cond ) ;</span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">&quot;--- producer %d notified consumer by condition variable...\n&quot;</span>, num ) ;</span><br><span class="line">      <span class="built_in">pthread_mutex_unlock</span>( &amp;g_mutex ) ;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/******** critial section end *********/</span></span><br><span class="line">      <span class="built_in">sleep</span>( <span class="number">5</span> ) ;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// initiate mutex</span></span><br><span class="line">   <span class="built_in">pthread_mutex_init</span>( &amp;g_mutex, <span class="literal">NULL</span> ) ;</span><br><span class="line">   <span class="comment">// initiate condition</span></span><br><span class="line">   <span class="built_in">pthread_cond_init</span>( &amp;g_cond, <span class="literal">NULL</span> ) ;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// initiate consumer threads</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONSUMERS_COUNT; ++ i )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">pthread_create</span>( &amp;g_thread[i], <span class="literal">NULL</span>, consumer, &amp;i ) ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">sleep</span>( <span class="number">1</span> ) ;</span><br><span class="line">   <span class="comment">// initiate producer threads</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = CONSUMERS_COUNT; i &lt; CONSUMERS_COUNT + PRODUCERS_COUNT; ++ i )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">pthread_create</span>( &amp;g_thread[i], <span class="literal">NULL</span>, producer, &amp;i ) ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONSUMERS_COUNT + PRODUCERS_COUNT; ++ i ) </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">pthread_join</span>( g_thread[i], <span class="literal">NULL</span> ) ;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">pthread_mutex_destroy</span>( &amp;g_mutex ) ;</span><br><span class="line">   <span class="built_in">pthread_cond_destroy</span>( &amp;g_cond ) ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">consumer <span class="number">2</span> begin wait a condition...</span><br><span class="line">consumer <span class="number">2</span> begin wait a condition...</span><br><span class="line">--- producer <span class="number">3</span> begin produce product...</span><br><span class="line">--- producer <span class="number">3</span> end produce product...</span><br><span class="line">--- producer <span class="number">3</span> notified consumer by condition variable...</span><br><span class="line">consumer <span class="number">2</span> end wait a condition...</span><br><span class="line">consumer <span class="number">2</span> begin consume product</span><br><span class="line">consumer <span class="number">2</span> begin wait a condition...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--- producer <span class="number">3</span> begin produce product...</span><br><span class="line">--- producer <span class="number">3</span> end produce product...</span><br><span class="line">--- producer <span class="number">3</span> notified consumer by condition variable...</span><br><span class="line">consumer <span class="number">2</span> end wait a condition...</span><br><span class="line">consumer <span class="number">2</span> begin consume product</span><br><span class="line">consumer <span class="number">2</span> begin wait a condition...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--- producer <span class="number">3</span> begin produce product...</span><br><span class="line">--- producer <span class="number">3</span> end produce product...</span><br><span class="line">--- producer <span class="number">3</span> notified consumer by condition variable...</span><br><span class="line">consumer <span class="number">2</span> end wait a condition...</span><br><span class="line">consumer <span class="number">2</span> begin consume product</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">consumer <span class="number">2</span> begin wait a condition...</span><br><span class="line"></span><br><span class="line">--- producer <span class="number">3</span> begin produce product...</span><br><span class="line">--- producer <span class="number">3</span> end produce product...</span><br><span class="line">--- producer <span class="number">3</span> notified consumer by condition variable...</span><br><span class="line">consumer <span class="number">2</span> end wait a condition...</span><br><span class="line">consumer <span class="number">2</span> begin consume product</span><br><span class="line">consumer <span class="number">2</span> begin wait a condition...</span><br></pre></td></tr></table></figure>

<h3 id="std-thread基本使用"><a href="#std-thread基本使用" class="headerlink" title="std::thread基本使用"></a>std::thread基本使用</h3><p>1、基本概念</p>
<ol>
<li>   std::thread 在 <thread> 头文件中声明，因此使用 std::thread 时需要包含 <thread> 头文件。</li>
<li>   std::thread内部实际上也是对pthread做了一层封装<br>学习参考：// <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/thread">https://zh.cppreference.com/w/cpp/thread</a></li>
</ol>
<p>2、代码实践</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread 1 executing\n&quot;</span>;</span><br><span class="line">        ++n;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>&amp; n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread 2 executing\n&quot;</span>;</span><br><span class="line">        ++n;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread 3 executing\n&quot;</span>;</span><br><span class="line">            ++n;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">baz</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread 4 executing\n&quot;</span>;</span><br><span class="line">            ++n;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    foo f;</span><br><span class="line">    baz b;</span><br><span class="line">    std::thread t1; <span class="comment">// t1 不是线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(f1, n + <span class="number">1</span>)</span></span>; <span class="comment">// 按值传递</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(f2, std::ref(n))</span></span>; <span class="comment">// 按引用传递</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t4</span><span class="params">(std::move(t3))</span></span>; <span class="comment">// t4 现在运行 f2() 。 t3 不再是线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t5</span><span class="params">(&amp;foo::bar, &amp;f)</span></span>; <span class="comment">// 按引用传递,t5 在对象 f 上运行 foo::bar()</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t6</span><span class="params">(b)</span></span>; <span class="comment">// t6 在对象 b 的副本上运行 baz::operator()</span></span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">    t5.<span class="built_in">join</span>();</span><br><span class="line">    t6.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final value of n is &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final value of f.n (foo::n) is &quot;</span> &lt;&lt; f.n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final value of b.n (baz::n) is &quot;</span> &lt;&lt; b.n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span> executing</span><br><span class="line">Thread <span class="number">3</span> executing</span><br><span class="line">Thread <span class="number">4</span> executing</span><br><span class="line">Thread <span class="number">2</span> executing</span><br><span class="line">Thread <span class="number">1</span> executing</span><br><span class="line">Thread <span class="number">3</span> executing</span><br><span class="line">Thread <span class="number">4</span> executing</span><br><span class="line">Thread <span class="number">2</span> executing</span><br><span class="line">Thread <span class="number">1</span> executing</span><br><span class="line">Thread <span class="number">3</span> executing</span><br><span class="line">Thread <span class="number">4</span> executing</span><br><span class="line">Thread <span class="number">2</span> executing</span><br><span class="line">Thread <span class="number">1</span> executing</span><br><span class="line">Thread <span class="number">3</span> executing</span><br><span class="line">Thread <span class="number">4</span> executing</span><br><span class="line">Thread <span class="number">2</span> executing</span><br><span class="line">Thread <span class="number">1</span> executing</span><br><span class="line">Thread <span class="number">3</span> executing</span><br><span class="line">Thread <span class="number">2</span> executing</span><br><span class="line">Thread <span class="number">4</span> executing</span><br><span class="line">Final value of n is <span class="number">5</span></span><br><span class="line">Final value of f.<span class="built_in">n</span> (foo::n) is <span class="number">5</span></span><br><span class="line">Final value of b.<span class="built_in">n</span> (baz::n) is <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="thread线程同步"><a href="#thread线程同步" class="headerlink" title="thread线程同步"></a>thread线程同步</h3><p>参考：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/thread/lock_guard">https://zh.cppreference.com/w/cpp/thread/lock_guard</a></p>
<h3 id="thread的异步机制future"><a href="#thread的异步机制future" class="headerlink" title="thread的异步机制future"></a>thread的异步机制future</h3><p>类模板 std::future 提供访问异步操作结果的机制<br>学习参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/c_base_jin/article/details/89761718">C++11之std::future对象使用说明</a></p>
<p>代码实践：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板 std::future 提供访问异步操作结果的机制</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;future&lt;<span class="keyword">int</span>&gt;&gt; vfutures;  <span class="comment">// 定义一个容器，里面存放 future&lt;int&gt; 类型的变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vfutures.<span class="built_in">emplace_back</span>(     <span class="comment">// 于容器所提供的位置原位构造 future&lt;int&gt; 类型元素</span></span><br><span class="line">            <span class="built_in">async</span>(std::launch::async,   <span class="comment">// std::async 的第一个传参 std::launch policy</span></span><br><span class="line">            [](<span class="keyword">int</span> sleepTime)&#123;          <span class="comment">// std::async 的第二个传参 Function&amp;&amp; f，即可调用的对象</span></span><br><span class="line">                <span class="built_in">usleep</span>(sleepTime*<span class="number">1000</span>);</span><br><span class="line">                cout &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; sleepTime = &quot;</span> &lt;&lt; sleepTime &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> sleepTime;</span><br><span class="line">            &#125;, </span><br><span class="line">            i)   <span class="comment">// std::async 的第三个传参 Args&amp;&amp;... args，即可调用对象的参数</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; fut : vfutures)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> ret = fut.<span class="built_in">get</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;fut.get() ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    vfutures.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">139759526287104</span> sleepTime = <span class="number">0</span></span><br><span class="line">fut.<span class="built_in">get</span>() ret = <span class="number">0</span></span><br><span class="line"><span class="number">139759517894400</span> sleepTime = <span class="number">1</span></span><br><span class="line">fut.<span class="built_in">get</span>() ret = <span class="number">1</span></span><br><span class="line"><span class="number">139759509501696</span> sleepTime = <span class="number">2</span></span><br><span class="line">fut.<span class="built_in">get</span>() ret = <span class="number">2</span></span><br><span class="line"><span class="number">139759501108992</span> sleepTime = <span class="number">3</span></span><br><span class="line">fut.<span class="built_in">get</span>() ret = <span class="number">3</span></span><br><span class="line"><span class="number">139759376660224</span> sleepTime = <span class="number">4</span></span><br><span class="line">fut.<span class="built_in">get</span>() ret = <span class="number">4</span></span><br><span class="line"><span class="number">139759492716288</span> sleepTime = <span class="number">5</span></span><br><span class="line">fut.<span class="built_in">get</span>() ret = <span class="number">5</span></span><br><span class="line"><span class="number">139759484323584</span> sleepTime = <span class="number">6</span></span><br><span class="line">fut.<span class="built_in">get</span>() ret = <span class="number">6</span></span><br><span class="line"><span class="number">139759475930880</span> sleepTime = <span class="number">7</span></span><br><span class="line">fut.<span class="built_in">get</span>() ret = <span class="number">7</span></span><br><span class="line"><span class="number">139759467538176</span> sleepTime = <span class="number">8</span></span><br><span class="line">fut.<span class="built_in">get</span>() ret = <span class="number">8</span></span><br><span class="line"><span class="number">139759459145472</span> sleepTime = <span class="number">9</span></span><br><span class="line">fut.<span class="built_in">get</span>() ret = <span class="number">9</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://shenweikun.github.io/2024/11/18/2024-11-18-CPP-Basics-about-STL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="空白">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weikun's Notes">
      <meta itemprop="description" content="记录生活与职业中的点滴">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Weikun's Notes">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/18/2024-11-18-CPP-Basics-about-STL/" class="post-title-link" itemprop="url">C++从入门到进阶之三-STL等高阶话题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-18 02:09:47" itemprop="dateCreated datePublished" datetime="2024-11-18T02:09:47+08:00">2024-11-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-21 01:53:29" itemprop="dateModified" datetime="2024-11-21T01:53:29+08:00">2024-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/4-C-C/" itemprop="url" rel="index"><span itemprop="name">4. C/C++</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>78k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:11</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="C-模板编程入门"><a href="#C-模板编程入门" class="headerlink" title="C++模板编程入门"></a>C++模板编程入门</h2><h3 id="一个案例引入模板"><a href="#一个案例引入模板" class="headerlink" title="一个案例引入模板"></a>一个案例引入模板</h3><p>1、模板和泛型编程系类文章介绍<br>(1)模板编程是C++的一种高级特性，很常用，很有用，可以说是 C++的精髓，是C++被广泛使用的关键<br>(2)泛型在C++、java、C#等多种语言中都有，是现代编程语言典型特性<br>(3)本章开始不像以前以理论知识讲解为主，而是以写代码和实践为主，在实践中学为主。因为开始变得抽象起来了 </p>
<p>2、案例和传统解决方案<br>(1)问题：swap函数交换2个数<br>(2)传统解法：定义重载函数，用引用（或指针）来实现<br>(3)代码实战</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(<span class="keyword">double</span>&amp; a, <span class="keyword">double</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> tmp;</span><br><span class="line"></span><br><span class="line">    tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">3.3</span>, d = <span class="number">4.4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myswap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myswap</span>(c, d);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、传统方案的缺点<br>(1)<strong>要为每个数据类型提供一个重载函数，麻烦</strong><br>(2)<strong>所有重载函数除了类型外其他完全一致，重复而浪费</strong></p>
<p>4、解决办法思考与模板引入<br>(1)用到什么类型再实现相应重载。虽然可行但无法类库化，无法分工<br>(2)函数编写时进一步抽象化，调用时再给定具体类型，由<strong>编译器在编译时再绑定形成代码，这就是模板</strong><br>(3)代码实践，用函数模板来实现swap</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;<span class="comment">//定义一个抽象类型X，在函数被调用时确定具体类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(X&amp; a, X&amp; b)</span><span class="comment">//使用swap作为函数名会与某个库函数名冲突</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X tmp;</span><br><span class="line"></span><br><span class="line">    tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">3.3</span>, d = <span class="number">4.4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myswap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myswap</span>(c, d);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板的理解和几个细节"><a href="#模板的理解和几个细节" class="headerlink" title="模板的理解和几个细节"></a>模板的理解和几个细节</h3><p>1、模板是一种编译时的多态<br>(1)模板是关键是编写函数代码原型时不给定具体类型，每次调用时再给定具体类型<br>(2)模板特性由编译器提供，编译时根据调用时的实参具体类型推导匹配的原型中模板的本次具体类型<br>(3)<strong>模板在最终生成的可执行程序中是不可见的</strong><br>(4)<strong>模板是编译时的多态，也可以叫“静态”多态</strong><br>(5)<strong>模板是一种语法糖，是编译器提供给我们的减少编程劳动量的一种语法特性</strong> </p>
<p>2、模板有什么用<br>(1)让我们编写与类型无关的函数<br>(2)模板是一种抽象的维度，让我们能够写出抽象度更高的代码<br>(3)用模板来写库函数更好，因为这样的模板库可以在调用库函数时再指定各种数据类型<br>(4)模板没那么简单，抽象是拿复杂度换劳动量，所以学起来难，学会了用处大</p>
<p>3、模板的几个小细节<br>(1)函数模板定义时typename和class效果是一样的，视个人习惯而使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">X</span>&gt;</span></span><br><span class="line"><span class="comment">// 两个都可以，效果相同</span></span><br></pre></td></tr></table></figure>
<p>(2)函数模板中可以有多个typename，使用时按名称匹配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br></pre></td></tr></table></figure>

<h3 id="函数模板和类模板"><a href="#函数模板和类模板" class="headerlink" title="函数模板和类模板"></a>函数模板和类模板</h3><p>1、模板分2种<br>(1)<strong>函数模板</strong>。模板类型在函数参数列表中使用<br>(2)<strong>类模板</strong>。模板类型在类中（定义类成员变量，或类成员函数的参数列表）使用</p>
<p>2、类模板举例<br>单模板参数的类模板定义与使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(<span class="keyword">int</span> myage);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T x)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; People&lt;T&gt;::<span class="built_in">People</span>(<span class="keyword">int</span> myage)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = myage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> People&lt;T&gt;::<span class="built_in">print</span>(T x)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上边的部分为类模板的定义</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//类模板的使用</span></span><br><span class="line">    <span class="function">People&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">p2</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">4444</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(<span class="number">5.55</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多模板参数的类模板"><a href="#多模板参数的类模板" class="headerlink" title="多模板参数的类模板"></a>多模板参数的类模板</h3><p>1、同类型多参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(<span class="keyword">int</span> myage);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T x, T y)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; People&lt;T&gt;::<span class="built_in">People</span>(<span class="keyword">int</span> myage)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = myage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> People&lt;T&gt;::<span class="built_in">print</span>(T x, T y)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">p2</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">4444</span>, <span class="number">0000</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(<span class="number">5.55</span>, <span class="number">1.122</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、不同类型多参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(<span class="keyword">int</span> myage);</span><br><span class="line">    ~<span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T1 x, T2 y)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; People&lt;T1, T2&gt;::<span class="built_in">People</span>(<span class="keyword">int</span> myage)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = myage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="keyword">void</span> People&lt;T1, T2&gt;::<span class="built_in">print</span>(T1 x, T2 y)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; <span class="string">&quot;, x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">int</span>, string&gt; <span class="title">p1</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">5</span>, <span class="string">&quot;linux&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、成员函数在类内部的模板类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(<span class="keyword">int</span> myage)&#123;</span><br><span class="line">        age = myage;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T1 x, T2 y)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">int</span>, string&gt; <span class="title">p1</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">2</span>, <span class="string">&quot;linux&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板友元函数"><a href="#模板友元函数" class="headerlink" title="模板友元函数"></a>模板友元函数</h3><p>1、友元函数参数中不带模板的情况<br>(1)友元函数声明在class内，定义实现写在class外<br>(2)友元函数参数中类的直接给出具体类型，譬如<br>(3)这种友元函数实际是削弱了模板参数在使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//friend void friend_function(People&lt;int&gt;&amp; s);//方式一：友元函数定义在类的外部</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function</span><span class="params">(People&lt;<span class="keyword">int</span>&gt;&amp; s)</span><span class="comment">//方式二：友元函数定义在类的内部</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt;s.age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//方式一：友元函数定 义在类的外部</span></span><br><span class="line"><span class="comment">void friend_function(People&lt;int&gt;&amp; s)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;age = &quot; &lt;&lt;s.age &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>; </span><br><span class="line">    <span class="built_in">friend_function</span>(a);<span class="comment">//由于友元函数的类型被指定为int，若是定义的类不是int则无法使用该类的对象传参</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、友元函数参数中带模板参数方法1<br>(1)友元函数声明和定义都写在class内部<br>(2)虽然写在class内，但仍然是友元，而不是member function<br>(3)友元可以适配类的各种模板参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(People&lt;T&gt;&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span></span>;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;wwwwedsfs&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、友元函数参数中带模板参数方法2<br>(1)友元函数声明在class内，定义在class外<br>(2)声明时函数名加后缀，而定义时不用加<br>(3)需要class和friend function的2个前置声明<br>(4)调用friend function时可加&lt;实参类型&gt;后缀，也可以不加，但是加就必须加对了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前置声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;T&gt;&amp; s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> friend_function1&lt;T&gt;(<span class="keyword">const</span> People&lt;T&gt;&amp; s);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;T&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span></span>;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;wwwwedsfs&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、友元函数参数中带模板参数方法3</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span>;<span class="comment">//重定义一个U,不与T重名</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span></span>;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;wwwwedsfs&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板运算符重载函数"><a href="#模板运算符重载函数" class="headerlink" title="模板运算符重载函数"></a>模板运算符重载函数</h3><p>1、实现+和+=的运算符重载函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+号如果返回引用,一种是返回*<span class="keyword">this</span>,另一种是返回新建的对象的引用</span><br><span class="line"></span><br><span class="line">前者导致加数也被改</span><br><span class="line">后者导致返回垃圾</span><br><span class="line"></span><br><span class="line">所以只能返回对象</span><br><span class="line"></span><br><span class="line">--------------------------------------------</span><br><span class="line">=号返回引用,</span><br><span class="line">保证了效率,</span><br><span class="line">支持了连续的=号操作</span><br><span class="line"></span><br><span class="line">若返回对象,</span><br><span class="line">效率低下,</span><br><span class="line">并不支持连续=号操作</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;<span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;<span class="comment">//自定义构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span>;<span class="comment">//友元函数，重定义一个U,不与T冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//运算符重载函数</span></span><br><span class="line">    People&lt;T&gt; <span class="keyword">operator</span>+(People&lt;T&gt;&amp; other);</span><br><span class="line">    People&lt;T&gt;&amp; <span class="keyword">operator</span>+=(People&lt;T&gt;&amp; other);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; People&lt;T&gt; People&lt;T&gt;::<span class="keyword">operator</span>+(People&lt;T&gt;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    People&lt;T&gt; tmp;</span><br><span class="line"></span><br><span class="line">    tmp.age = <span class="keyword">this</span>-&gt;age + other.age; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; People&lt;T&gt;&amp; People&lt;T&gt;::<span class="keyword">operator</span>+=(People&lt;T&gt;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age += other.age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span>, <span class="title">c1</span><span class="params">(<span class="number">2.222</span>)</span>, c2</span>;</span><br><span class="line">    c2 = c + c1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line">    c2 += c;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;wwwwedsfs&quot;</span>)</span>, <span class="title">b1</span><span class="params">(<span class="string">&quot;ooosdfsdfsdqw&quot;</span>)</span>, b2</span>;</span><br><span class="line">    b2 = b + b1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line">    b2 += b;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板运算符友元函数重载实现"><a href="#模板运算符友元函数重载实现" class="headerlink" title="模板运算符友元函数重载实现"></a>模板运算符友元函数重载实现</h3><p>1、+作为友元运算符重载<br>(1)友元函数在class内实现，ok，但是因为是友元实现的，所以参数要有2个<br>(2)友元函数在class外实现，不ok，编译无法通过<br>(3)友元函数的第三种实现，ok<br>上述三种情况下的代码实现 在《2、+=作为友元运算符重载》中 给出了</p>
<p>2、+=作为友元运算符重载<br>(1)友元函数在class内实现，ok，但必须带2个参数，带1个不行 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;<span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;<span class="comment">//自定义构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span>;<span class="comment">//友元函数，重定义一个U,不与T冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//运算符重载函数</span></span><br><span class="line">    <span class="keyword">friend</span> People&lt;T&gt; <span class="keyword">operator</span>+(People&lt;T&gt;&amp; a, People&lt;T&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        People&lt;T&gt; tmp;</span><br><span class="line"></span><br><span class="line">        tmp.age = a.age + b.age;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> People&lt;T&gt;&amp; <span class="keyword">operator</span>+=(People&lt;T&gt;&amp; a, People&lt;T&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        a.age += b.age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span>, <span class="title">c1</span><span class="params">(<span class="number">2.222</span>)</span>, c2</span>;</span><br><span class="line">    c2 = c + c1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line">    c2 += c;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span>, <span class="title">b1</span><span class="params">(<span class="string">&quot;linux&quot;</span>)</span>, b2</span>;</span><br><span class="line">    b2 = b + b1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line">    b2 += b;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)友元函数在class外实现，ok</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; People&lt;T&gt;&amp; <span class="keyword">operator</span>+=(People&lt;T&gt; &amp;a, People&lt;T&gt; &amp;b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;<span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;<span class="comment">//自定义构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span>;<span class="comment">//友元函数，重定义一个U,不与T冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//运算符重载函数</span></span><br><span class="line">    <span class="keyword">friend</span> People&lt;T&gt; <span class="keyword">operator</span>+(People&lt;T&gt;&amp; a, People&lt;T&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        People&lt;T&gt; tmp;</span><br><span class="line"></span><br><span class="line">        tmp.age = a.age + b.age;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tmp;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> People&lt;T&gt;&amp; <span class="keyword">operator</span>+=&lt;T&gt;(People&lt;T&gt;&amp; a, People&lt;T&gt;&amp; b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; People&lt;T&gt;&amp; <span class="keyword">operator</span>+=(People&lt;T&gt; &amp;a, People&lt;T&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">        a.age += b.age;</span><br><span class="line">        <span class="keyword">return</span> a;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span>, <span class="title">c1</span><span class="params">(<span class="number">2.222</span>)</span>, c2</span>;</span><br><span class="line">    c2 = c + c1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line">    c2 += c;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;wwwwedsfs&quot;</span>)</span>, <span class="title">b1</span><span class="params">(<span class="string">&quot;ooosdfsdfsdqw&quot;</span>)</span>, b2</span>;</span><br><span class="line">    b2 = b + b1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line">    b2 += b;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3)友元函数的第三种实现，ok</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;<span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;<span class="comment">//自定义构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span>;<span class="comment">//友元函数，重定义一个U,不与T冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//运算符重载函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> People&lt;U&gt; <span class="keyword">operator</span>+(People&lt;U&gt;&amp; a, People&lt;U&gt;&amp; b);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> People&lt;U&gt;&amp; <span class="keyword">operator</span>+=(People&lt;U&gt;&amp; a, People&lt;U&gt;&amp; b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; People&lt;U&gt; <span class="keyword">operator</span>+(People&lt;U&gt;&amp; a, People&lt;U&gt;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    People&lt;T&gt; tmp;</span><br><span class="line"></span><br><span class="line">    tmp.age = a.age + b.age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; People&lt;U&gt;&amp; <span class="keyword">operator</span>+=(People&lt;U&gt;&amp; a, People&lt;U&gt;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    a.age += b.age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span>, <span class="title">c1</span><span class="params">(<span class="number">2.222</span>)</span>, c2</span>;</span><br><span class="line">    c2 = c + c1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line">    c2 += c;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span>, <span class="title">b1</span><span class="params">(<span class="string">&quot;linux&quot;</span>)</span>, b2</span>;</span><br><span class="line">    b2 = b + b1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line">    b2 += b;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板类的继承"><a href="#模板类的继承" class="headerlink" title="模板类的继承"></a>模板类的继承</h3><p>1、模板类继承的多种情况（常见的）<br>类模板：不确定的类，类中用到了模板<br>模板类：确定的类，类中用到了模板</p>
<p>(1)类模板 继承 类模板<br>(2)类模板 继承 模板类<br>(3)类模板 继承 普通类<br>(4)普通类 继承 模板类</p>
<p>2、类模板继承类模板<br>(1)单模板参数，类模板继承类模板<br>(2)代码实战中学习</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    T x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">People</span>(T myx):<span class="built_in">x</span>(myx)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> People&lt;T&gt;::<span class="built_in">print</span>(<span class="keyword">void</span>)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">man</span>:</span><span class="keyword">public</span> People&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">man</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">man</span>(T myy):<span class="built_in">y</span>(myy)&#123;&#125;;</span><br><span class="line">    <span class="built_in">man</span>(T a, T b):People&lt;T&gt;(a),<span class="built_in">y</span>(b)&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">man</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> man&lt;T&gt;::<span class="built_in">print</span>(<span class="keyword">void</span>)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// (1)类模板 继承 类模板</span></span><br><span class="line">    <span class="function">People&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">man&lt;<span class="keyword">int</span>&gt; <span class="title">m</span><span class="params">(<span class="number">4</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">print</span>();</span><br><span class="line">    m.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)总结：在继承时，相当于用子类的模板参数T去实例填充了父类的模板参数T<br>(4)作用：用于构建模板化的类体系，写模板化的大框架</p>
<p>3、多模板参数<br>(1)2个或2个以上模板参数的情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    T1 x1; <span class="comment">//double</span></span><br><span class="line">    T2 x2;  <span class="comment">//int</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">People</span>(T1 myx1, T2 myx2):<span class="built_in">x1</span>(myx1),<span class="built_in">x2</span>(myx2)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U1, <span class="keyword">typename</span> U2&gt; <span class="class"><span class="keyword">class</span> <span class="title">man</span>:</span>People&lt;U1 ,U2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    U1 y1;  <span class="comment">// int               这里就决定了U1是int ，U2是double， 因此People&lt;U2 ,U1&gt;为People(double, int)，按照符号来决定</span></span><br><span class="line">    U2 y2;  <span class="comment">// double</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">man</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">man</span>( U1 myx1, U2 myx2, U1 myy1, U2 myy2):People&lt;U1, U2&gt;(myx1, myx2),<span class="built_in">y1</span>(myy1),<span class="built_in">y2</span>(myy2)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">man</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U1, <span class="keyword">typename</span> U2&gt; <span class="keyword">void</span> man&lt;U1, U2&gt;::<span class="built_in">print</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this-&gt;x1 = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x1 &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this-&gt;x2 = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x2 &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this-&gt;y1 = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;y1 &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this-&gt;y2 = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;y2 &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双模板参数</span></span><br><span class="line">    <span class="function">man&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; <span class="title">m</span><span class="params">(<span class="number">4</span>, <span class="number">3.3</span>, <span class="number">5</span>, <span class="number">6.6</span>)</span></span>;</span><br><span class="line">    m.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：多个模板参数是按照顺序对应的</p>
<p>4、类模板 继承 模板类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T attribute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(T my_attitude):<span class="built_in">attribute</span>(my_attitude)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> People&lt;T&gt;::<span class="built_in">print</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;attribute = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;attribute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span> <span class="keyword">public</span> People&lt;<span class="keyword">double</span>&gt;<span class="comment">//在这里将People类确定为double</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    U P_attribute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Man</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">Man</span>(<span class="keyword">double</span> a, U b):People&lt;<span class="keyword">double</span>&gt;(a),<span class="built_in">P_attribute</span>(b)&#123;&#125;;<span class="comment">//这里的a的类型也由此确定了</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Man_print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">void</span> Man&lt;U&gt;::<span class="built_in">Man_print</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P_attribute = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;P_attribute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Man&lt;string&gt; <span class="title">s</span><span class="params">(<span class="number">6.666</span>,<span class="string">&quot;asdasd&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">print</span>();</span><br><span class="line">    s.<span class="built_in">Man_print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、类模板 继承 普通类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> attribute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(<span class="keyword">double</span> my_attitude):<span class="built_in">attribute</span>(my_attitude)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">People::print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;attribute = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;attribute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span> <span class="keyword">public</span> People<span class="comment">//</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    U P_attribute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Man</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">Man</span>(<span class="keyword">double</span> a, U b):<span class="built_in">People</span>(a),<span class="built_in">P_attribute</span>(b)&#123;&#125;;<span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Man_print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">void</span> Man&lt;U&gt;::<span class="built_in">Man_print</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P_attribute = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;P_attribute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Man&lt;string&gt; <span class="title">s</span><span class="params">(<span class="number">6.666</span>,<span class="string">&quot;asdasd&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">print</span>();</span><br><span class="line">    s.<span class="built_in">Man_print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、普通类 继承 模板类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T attribute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(T my_attitude):<span class="built_in">attribute</span>(my_attitude)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> People&lt;T&gt;::<span class="built_in">print</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;attribute = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;attribute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span> <span class="keyword">public</span> People&lt;<span class="keyword">double</span>&gt;<span class="comment">//在这里将People类确定为double</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string P_attribute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Man</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">Man</span>(<span class="keyword">double</span> a, string b):People&lt;<span class="keyword">double</span>&gt;(a),<span class="built_in">P_attribute</span>(b)&#123;&#125;;<span class="comment">//这里的a的类型也由此确定了</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Man_print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Man::Man_print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P_attribute = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;P_attribute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Man <span class="title">s</span><span class="params">(<span class="number">6.666</span>,<span class="string">&quot;asdasdsdfsdfoo&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">print</span>();</span><br><span class="line">    s.<span class="built_in">Man_print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非类型模板参数和模板类型推导"><a href="#非类型模板参数和模板类型推导" class="headerlink" title="非类型模板参数和模板类型推导"></a>非类型模板参数和模板类型推导</h3><p>1、非类型模版参数<br>详解阅读：参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/lanchunhui/article/details/49634077">https://blog.csdn.net/lanchunhui/article/details/49634077</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> MAXSIZE&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T elems[MAXSIZE];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">         Stack&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; int10Stack;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非类型模板参数是有类型限制的。一般而言，它可以是常整数（包括enum枚举类型）或者指向外部链接对象的指针。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、模板的本质<br>参数化：将其作为参数一样，通过传参确定<br>(1)类型参数化<br>(2)值参数化<br>(3)类型和值都参数化<br>(4)本质：延迟绑定</p>
<p>3、类型推导的隐式类型转换<br>(1)在决定模板参数类型前，编译器执行隐式类型转换，有时候实际类型和看起来会不同<br>(2)编译器用值类型实例化函数模板，而不是用相应的引用类型<br>(3)编译器用指针类型实例化函数模板，而不是相应的数组类型<br>(4)去除const修饰，绝不会用const类型实例化函数模板，总是用相应的非const类型<br>(5)对于指针来说，指针和 const 指针是不同的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">2</span>）</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;</span><br><span class="line">People&lt;b&gt;<span class="comment">//实例化时会将int&amp; 转换为 int</span></span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(a)</span></span>;                <span class="comment">// 数组做实参，实际实参不是数组而是指针</span></span><br><span class="line">People&lt;a&gt;</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">People&lt;a&gt;<span class="comment">//实例化时会去除const</span></span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1;</span><br><span class="line"><span class="keyword">int</span> *p2;</span><br></pre></td></tr></table></figure>

<p>4、模板和库<br>(1)模板无法单独编译，也就不能通过lib连接静态库的形式隐藏实现<br>(2)模板通常会把声明和定义写在头文件里，所以c++的模板总是开源的<br>(3)说明typename的一种用法，这种用法里typename不等同于class<br>详解阅读：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cthon/p/9201649.html">https://www.cnblogs.com/cthon/p/9201649.html</a></p>
<h2 id="STL的容器类和迭代器"><a href="#STL的容器类和迭代器" class="headerlink" title="STL的容器类和迭代器"></a>STL的容器类和迭代器</h2><h3 id="STL的容器类介绍"><a href="#STL的容器类介绍" class="headerlink" title="STL的容器类介绍"></a>STL的容器类介绍</h3><p>1、何为容器<br>(1)顾名思义，容器就是盛放东西的东西，这里被盛放的一般是数据对象，用来盛放的是容器类<br>(2)计算机中一切皆是数据，<strong>数据存储只能在内存中，而容器类是用做容器的内存的管理方法</strong><br>(3)容器类的内核就是：<strong>数据结构 (数据在内存中的排放、存储方法)+ 算法(数据的运算、处理，如排序)</strong><br>  数据结构 -&gt; 类的成员变量<br>  算法     -&gt; 类的成员方法<br>(4)C语言语法内置的数组和结构体，就是语言源生支持的容器（但并未提供相应的算法，不过通过库函数补充了部分算法）<br>(5)C++容器通过类库方式提供，容器类库被模板技术泛化后，就是STL容器了。STL一般指标准模板库。 标准模板库（Standard Template Library，STL） </p>
<p>2、STL有哪些容器类<br>(1)<strong>序列容器</strong>。<br>元素在容器中的位置同元素的值无关，即容器不是排序的（类似于C数组）。包括array、vector、deque、list、forward_list等几个。<br>(2)<strong>排序容器</strong>。<br>数据插入时即自动按照值从小到大排列好。包括set、multiset、map、mutilmap等。<br>(3)<strong>哈希容器</strong>。<br>哈希容器中的元素是未排序的，元素的位置由哈希函数确定，即遵守一定规则的&lt;key,value&gt;对式存储。包括unordered_set、unordered_map、hash_set、hash_multiset、hash_map、hash_multimap等 </p>
<p>3、容器类如何学习<br>(1)<strong>容器类就是STL的核心</strong>，STL其他技术点都围绕容器类开展<br>(2)可见<strong>STL的本质其实就是一套模板技术泛化类型的C++基本数据结构和算法类库</strong><br>(3)本部分文章会集中细致讲几个STL序列容器array、vector等，其他容器类似情况就简略讲过了<br>(4)第一层为学会使用stl容器，第二层为能合理使用stl容器，第三层为理解stl背后设计，第四层为自己能写新的stl容器。 </p>
<h3 id="序列容器之array"><a href="#序列容器之array" class="headerlink" title="序列容器之array"></a>序列容器之array</h3><p>1、array的特性<br>(1)<strong>array是定长、同类型多元素、内存中连续排布的一种容器</strong><br>(2)array其实就是C语言数组的C++ template封装，定义于头文件array</p>
<p>2、array的学习方法<br>(1)参考文档：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/array">https://zh.cppreference.com/w/cpp/container/array</a><br>(2)挨个理解文档相关所有元素<br>隐式声明与显示声明：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/snandy/archive/2011/03/04/1970777.html">https://www.cnblogs.com/snandy/archive/2011/03/04/1970777.html</a> </p>
<p>3、array的构造和初始化<br>(1)和C数组兼容的初始化方式<br>(2)需要C++11或以上标准来支持</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linux中使用g++编译时需加上：-std=c++<span class="number">11</span>选项</span><br><span class="line">低版本的ubuntu需要，高版本的ubuntu安装的g++并不需要</span><br></pre></td></tr></table></figure>

<p>4、array的元素访问<br>(1)at方法<br>(2)operator[]实现的C数组式访问<br>(3)front和back方法返回第1个和最后1个元素<br>(4)data返回真实存储内存中首元素首地址的值<br>如果array的元素访问越界了，那么编译时没问题，但是运行时会抛出异常</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1)array是定长、同类型多元素、内存中连续排布的一种容器</span></span><br><span class="line"><span class="comment">// (2)array其实就是C语言数组的C++ template封装，定义于头文件array</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;array&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a1;             <span class="comment">// 定义但是未初始化</span></span><br><span class="line">    <span class="comment">//array&lt;int, 3&gt; a2(1, 3, 5);    // 编译报错，因为这里相当于调用构造函数去初始化，C++不可能提供那么多个构造函数</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a2&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;    <span class="comment">// 定义并初始化 ，聚合初始化</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a3 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;; <span class="comment">// 初始化赋值</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a4 = a3;        <span class="comment">// 拷贝构造</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[0] = &quot;</span> &lt;&lt; a2[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[1] = &quot;</span> &lt;&lt; a2[<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[2] = &quot;</span> &lt;&lt; a2[<span class="number">2</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    a2[<span class="number">0</span>] = <span class="number">11</span>;                  <span class="comment">// 访问指定的元素，但是没有进行越界检查</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[0] = &quot;</span> &lt;&lt; a2[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    a2.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="number">33</span>;               <span class="comment">// 访问指定的元素，同时进行越界检查</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[1] = &quot;</span> &lt;&lt; a2.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//a2.at(3) = 33; //编译报错，越界了，编译没问题，运行时抛出异常 //terminate called after throwing an instance of &#x27;std::out_of_range&#x27;</span></span><br><span class="line"></span><br><span class="line">    a2[<span class="number">4</span>] = <span class="number">11</span>;                   <span class="comment">// 这里已经越界访问了，但是不一定会报错，因为这赋值是不会进行越界检查的</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[4] = &quot;</span> &lt;&lt; a2[<span class="number">4</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2.front = &quot;</span> &lt;&lt; a2.<span class="built_in">front</span>() &lt;&lt;endl;  <span class="comment">// 访问第一个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2.back = &quot;</span> &lt;&lt; a2.<span class="built_in">back</span>() &lt;&lt; endl;   <span class="comment">// 访问最后一个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2.size = &quot;</span> &lt;&lt; a2.<span class="built_in">size</span>() &lt;&lt; endl;   <span class="comment">// 返回容纳的元素数</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、array的容量设置和获取<br>(1)容量设置只能在定义时一次设定，且必须设定，设定后再不能改<br>(2)empty：若容器为空则为 true ，否则为 false<br>(3)size：容器中的元素数量。<br>(4)max_size：返回根据系统或库实现限制的容器可保有的元素最大数量</p>
<p>6、操作<br>(1)fill：以指定值填充容器<br>(2)swap：交换内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array &lt;<span class="keyword">int</span>, 3&gt; a1&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    array &lt;<span class="keyword">int</span>, 3&gt; a2&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[0] = &quot;</span> &lt;&lt; a1[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[1] = &quot;</span> &lt;&lt; a1[<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[2] = &quot;</span> &lt;&lt; a1[<span class="number">2</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[0] = &quot;</span> &lt;&lt; a2[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[1] = &quot;</span> &lt;&lt; a2[<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[2] = &quot;</span> &lt;&lt; a2[<span class="number">2</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x  = get&lt;<span class="number">0</span>&gt;(a1);  <span class="comment">// 获取第0个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt;endl;  </span><br><span class="line"></span><br><span class="line">    a1.<span class="built_in">swap</span>(a2); <span class="comment">//等价于 std::swap(a1, a2);</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[0] = &quot;</span> &lt;&lt; a1[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[1] = &quot;</span> &lt;&lt; a1[<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[2] = &quot;</span> &lt;&lt; a1[<span class="number">2</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[0] = &quot;</span> &lt;&lt; a2[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[1] = &quot;</span> &lt;&lt; a2[<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[2] = &quot;</span> &lt;&lt; a2[<span class="number">2</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    a1.<span class="built_in">fill</span>(<span class="number">0</span>);   <span class="comment">// 将 array 填充 0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[0] = &quot;</span> &lt;&lt; a1[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[1] = &quot;</span> &lt;&lt; a1[<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[2] = &quot;</span> &lt;&lt; a1[<span class="number">2</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    array &lt;string, 1&gt; a3&#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a3.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、非成员函数<br>(1)operator重载函数<br>(2)get<br>(3)swap<br>(4)to_array (C++20 起)，低版本编译器并不支持</p>
<p>8、辅助类tuple_size、tuple_element<br>tuple_size提供作为编译时常量表达式访问 std::array 中元素数量的方法。<br>tuple_element使用类 tuple 接口，提供 array 元素类型的编译时带下标访问</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[tuple_size&lt;T&gt;::value];<span class="comment">// 能用于编译时</span></span><br><span class="line">        cout &lt;&lt; tuple_size&lt;T&gt;::value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        array&lt;<span class="keyword">int</span>, 3&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        array&lt;string, 4&gt; b = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">         定义 a 并获取位于位置 <span class="number">0</span> 的元素类型,类型为<span class="keyword">int</span></span><br><span class="line">        <span class="keyword">using</span> T = tuple_element&lt;<span class="number">0</span>, <span class="keyword">decltype</span>(a)&gt;::type; <span class="comment">//这里的using作用类似于C中的typedef，给数据类型起别名</span></span><br><span class="line">        T c = <span class="number">6</span>;</span><br><span class="line">        cout &lt;&lt; is_same&lt;T, <span class="keyword">int</span>&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//判断T是否为int，是否都是int类型</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">test</span>(a);</span><br><span class="line">        <span class="built_in">test</span>(b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器的引入"><a href="#迭代器的引入" class="headerlink" title="迭代器的引入"></a>迭代器的引入</h3><p>1、迭代器是干嘛的<br>(1)迭代器就是能 <strong>通过移动 来 遍历处理 的 一种机制</strong><br>(2)C语言中遍历数组元素，用指针*p++方式，指针变量就是遍历迭代器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*        </span></span><br><span class="line"><span class="comment">        for (p=第1个元素; p!=最后一个元素; p++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">                *p就是每一个元素</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>(3)思考：结构体元素能够通过指针运算来遍历？<br>答：不能。因为结构体中元素的类型一般是不同的，无法得知访问下一个元素，地址的偏移量是多少</p>
<p>2、关于迭代器的分析<br>(1)每种容器理论上都可以被遍历，不存在不能被遍历的容器<br>(2)每种容器的遍历实现都可能不同，要结合容器和元素的特点来具体实现<br>(3)<strong>迭代器内部原理肯定是通过指针操作（地址运算）来实现</strong><br>(4)迭代器就是C++为我们设计的一个高层次的“指针”，高层指针是面向容器中的元素的，实现对容器中元素的遍历。其工作时最终会映射到底层指针(即我们C语言中使用指针的方法) </p>
<p>3、C++实际是这么设计迭代器的<br>(1)<strong>所有的迭代器有一个共同基类（接口），规定了迭代器的基本行为规范接口</strong><br>(2)<strong>每个容器类中均包含了一个专属化迭代器成员变量</strong>，这个专属化迭代器专门针对该容器的特点实现了迭代器应该有的所有接口<br>(3)需要遍历某STL容器时，只需要直接调出该容器的这个迭代器成员变量直接用即可，固定名字为iterator </p>
<p>4、典型的迭代器用法<br>(1)代码实战，用迭代器来实现遍历array</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt;::iterator iter;  <span class="comment">//这是一个可读可写的迭代器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">        *iter = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt;::const_iterator citer;  <span class="comment">//这是一个只读的迭代器</span></span><br><span class="line">    <span class="keyword">for</span> ( citer = a.<span class="built_in">cbegin</span>(); citer != a.<span class="built_in">cend</span>(); citer++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; *citer &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//*citer = 3;  //报错 error: assignment of read-only location ‘* citer’</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际写代码中，一般不会像前面这样写，会利用auto</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a1 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = a1.<span class="built_in">begin</span>(); iter != a1.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = a1.<span class="built_in">rbegin</span>(); iter != a1.<span class="built_in">rend</span>(); iter++)   <span class="comment">// 逆向迭代器</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)begin()和end()方法是得到容器遍历的开始和结尾的套路化方法</p>
<h3 id="迭代器的几个细节问题"><a href="#迭代器的几个细节问题" class="headerlink" title="迭代器的几个细节问题"></a>迭代器的几个细节问题</h3><p>1、const与非const<br>(1)begin和end返回可读可写的迭代器，而cbegin和cend返回const的只读迭代器<br>(2)代码验证迭代器的读写权限</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt;::iterator iter;<span class="comment">//可读可写</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt;::const_iterator citer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; iter &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">        *iter = <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(citer = a.<span class="built_in">cbegin</span>(); citer != a.<span class="built_in">cend</span>(); citer++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;citer = &quot;</span> &lt;&lt; citer &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*citer = &quot;</span> &lt;&lt; *citer &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; iter &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">        *iter = <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> citer = a.<span class="built_in">cbegin</span>(); citer != a.<span class="built_in">cend</span>(); citer++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;citer = &quot;</span> &lt;&lt; citer &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*citer = &quot;</span> &lt;&lt; *citer &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、begin和end的半开半闭区间<br>(1)begin返回第0个元素的迭代器（类似于C数组的首元素首地址指针）<br>(2)end指向的不是末尾元素的迭代器，而是末尾元素的（实际不存在的）下一个元素的迭代器<br>(3)前闭后开区间，经常记做[begin end)，这样设计是为了写循环遍历时方便 </p>
<p>3、正向和逆向迭代器<br>(1)rbegin和rend返回逆向迭代器<br>(2)逆向迭代器的begin是最末尾元素，而end是第0个元素去（实际不存在的）前面1个元素的迭代器<br>(3)逆向迭代器++是向前移动，而–是向后移动</p>
<p>4、迭代器越界会怎么样<br>(1)<strong>和数组越界类似，编译时不审查，运行时会崩溃</strong><br>(2)<strong>不管是正向还是逆向迭代器，++不到end，–不到begin，就不会越界</strong></p>
<h3 id="STL的不同类型迭代器"><a href="#STL的不同类型迭代器" class="headerlink" title="STL的不同类型迭代器"></a>STL的不同类型迭代器</h3><p>1、C++17前共有5种迭代器<br>(1)InputIterator，输入迭代器。只能从容器内读出而不能向容器内写入，只能单次读出（读出过一次后不保证再次操作仍然可以，想想流输入输出），只能++走不能–走（就是单向的），不能保证第二次遍历容器时，顺序不变。输入迭代器适用于单通只读型算法。<br>(2)OutputIterator，输出迭代器。用于将信息传输给容器（修改容器中元素的值），但是不能读取。（显示器就是只能写不能读的设备，可用输出容器来表示它）只能++走不能–走（就是单向的），输出迭代器适用于单通只写型算法。<br>(3)ForwardIterator，前向迭代器。只能++走不能–走（就是单向的）<br>(4)BidirectionalIterator，双向迭代器。既能++也可以–，双向移动。<br>(5)RandomAccessIterator，随机访问迭代器。能双向移动，并且可以单次跨越多个元素移动。 </p>
<p>2、C++17新增1种迭代器<br>(1)contiguousIterator,连续迭代器。所指向的逻辑相邻元素也在内存中物理上相邻。</p>
<p>3、STL的6种迭代器总结<br>(1)每种迭代器更应该被看作是具有某些预定义特征（或者满足某接口要求）的一个迭代器的实现。</p>
<p>(2)这些迭代器彼此之间有功能重叠，譬如随机访问迭代器可由双向迭代器扩展而来，详见文档：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/iterator">https://zh.cppreference.com/w/cpp/iterator</a></p>
<p>(3)为何定义多种迭代器？<br>  是为了适配容器特性和泛型算法，后面会看到array的迭代器既是一个双向迭代器，也是一个随机访问迭代器。</p>
<p>4、C++20的新迭代器<br>(1)C++20中重新实现了基于concept的新的迭代器体系<br>(2)原有的模板都被加了前缀Legecy，但很长时间仍然可用，甚至还是主流<br>(3)基于concept的新迭代器主要在类型约束和模板特化方面做了优化<br>(4)C++20目前还刚开始，可以先不管，先学好原有的，后面再扩展去学C++20新特性 </p>
<h3 id="序列容器之Vector"><a href="#序列容器之Vector" class="headerlink" title="序列容器之Vector"></a>序列容器之Vector</h3><p>参考学习文档:<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/vector">https://zh.cppreference.com/w/cpp/container/vector</a><br>1、Vector的特征<br>(1)Vector和Array相同点是：都是数组、都是contiguousIterator、容器内元素种类都相同<br>(2)Vector和Array不同点是：<strong>Array是固定数组；Vector是动态数组，可以按需扩展数组大小</strong><br>(3)<strong>vector 的存储是自动管理的，按需扩张收缩。</strong><br>(4)<strong>vector 通常占用多于静态数组的空间，因为要分配更多内存以管理将来的增长</strong><br>(5)vector 所用的内存分配方式不在每次插入元素时，而<strong>只在额外内存耗尽时重分配</strong>。 </p>
<p>使用例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = v.<span class="built_in">cbegin</span>(); iter != v.<span class="built_in">cend</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.size = &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.max_size = &quot;</span> &lt;&lt; v.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.capacity = &quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.size = &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.max_size = &quot;</span> &lt;&lt; v.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;push_back v.capacity  = &quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.size = &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.max_size = &quot;</span> &lt;&lt; v.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;push_back v.capacity = &quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : v)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">*iter = <span class="number">1</span></span><br><span class="line">*iter = <span class="number">3</span></span><br><span class="line">*iter = <span class="number">5</span></span><br><span class="line">v.size = <span class="number">3</span></span><br><span class="line">v.max_size = <span class="number">4611686018427387903</span></span><br><span class="line">v.capacity = <span class="number">3</span></span><br><span class="line">v.size = <span class="number">4</span></span><br><span class="line">v.max_size = <span class="number">4611686018427387903</span></span><br><span class="line">push_back v.capacity  = <span class="number">6</span></span><br><span class="line">v.size = <span class="number">5</span></span><br><span class="line">v.max_size = <span class="number">4611686018427387903</span></span><br><span class="line">push_back v.capacity = <span class="number">6</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">i = <span class="number">3</span></span><br><span class="line">i = <span class="number">5</span></span><br><span class="line">i = <span class="number">7</span></span><br><span class="line">i = <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h3 id="序列容器之list"><a href="#序列容器之list" class="headerlink" title="序列容器之list"></a>序列容器之list</h3><p>参考学习：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/list">https://zh.cppreference.com/w/cpp/container/list</a><br>(1) list 通常实现为双向链表。<br>(2) 可以高效地进行插入删除元素，但是随机访问却比较慢。<br>(3) list不支持随机存取，要访问第n个元素，必须先遍历前n-1个元素才能访问第n个元素。因此，list没有下标[ ]操作，也没有at()接口。</p>
<p>使用例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; l = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;; </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l.size = &quot;</span> &lt;&lt; l.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l.max_size = &quot;</span> &lt;&lt; l.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;is or not empty :&quot;</span> &lt;&lt; l.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : l)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    l.<span class="built_in">assign</span>(<span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    l.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">    l.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">    l.<span class="built_in">insert</span>(l.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">    l.<span class="built_in">sort</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = l.<span class="built_in">begin</span>(); iter != l.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l.size = <span class="number">6</span></span><br><span class="line">l.max_size = <span class="number">768614336404564650</span></span><br><span class="line">is <span class="keyword">or</span> <span class="keyword">not</span> empty :<span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">9</span> </span><br></pre></td></tr></table></figure>

<h3 id="序列容器之deque"><a href="#序列容器之deque" class="headerlink" title="序列容器之deque"></a>序列容器之deque</h3><p>(1) deque容器为一个给定类型的元素进行线性处理，像向量一样，它能够快速地随机访问任一个元素，并且能够高效地插入和删除容器的尾部元素。<br>(2) 它又与vector不同，deque支持高效插入和删除容器的头部元素，因此也叫做双端队列。<br>参考学习：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010710458/article/details/79540505">https://blog.csdn.net/u010710458/article/details/79540505</a><br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/deque">https://zh.cppreference.com/w/cpp/container/deque</a></p>
<p>使用例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建容纳整数的 deque</span></span><br><span class="line">    std::deque&lt;<span class="keyword">int</span>&gt; d = &#123;<span class="number">7</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">8</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 从 deque 的首尾添加整数</span></span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">13</span>);</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">25</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 迭代并打印 deque 的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : d) &#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>

<h3 id="序列容器选择"><a href="#序列容器选择" class="headerlink" title="序列容器选择"></a>序列容器选择</h3><p>如何选择这四个容器中哪一个，应根据你的需要而定，具体可以遵循下面的原则：</p>
<ol>
<li>   <strong>如果你需要高效的随即存取，而不在乎插入和删除的效率，使用array或vector，前者是固定大小的数组，后者是可变大小的数组</strong></li>
<li>   <strong>如果你需要大量的插入和删除，而不关心随即存取，则应使用list</strong></li>
<li>   <strong>如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque</strong></li>
</ol>
<p>注意：C++提供的容器还有很多，适用于各种场景，但是使用方法都大同小异，这里不再赘述。有需要查询<a target="_blank" rel="noopener" href="https://zh.cppreference.com/">C++ 参考手册</a>即可。</p>
<h2 id="STL的泛型算法使用详解"><a href="#STL的泛型算法使用详解" class="headerlink" title="STL的泛型算法使用详解"></a>STL的泛型算法使用详解</h2><h3 id="什么是泛型算法"><a href="#什么是泛型算法" class="headerlink" title="什么是泛型算法"></a>什么是泛型算法</h3><p>1、从容器说起<br>(1)容器是数据结构，是对数据的封装<br>(2)各容器都提供了少量处理元素操作的方法，譬如sort，但没有提供更多<br>(3)同样的操作譬如sort，在不同容器中底层处理肯定会不同<br>(4)<strong>泛型算法是独立于容器类的一些操作方法，可以用于多种容器，所以叫“泛型”算法</strong><br>(5)泛型算法实际上是<strong>更高层次的抽象</strong>，所以设计和实现的难度很大，这也是<strong>STL的核心技术</strong></p>
<p>2、泛型算法使用基础<br>(1)泛型算法学习参考：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm">https://zh.cppreference.com/w/cpp/algorithm</a><br>  泛型算法在元素范围上操作，即其操作的是元素的值。注意范围定义为 [first, last) ，其中 last 指代要查询或修改的最后元素的后一个元素。<br>(2)泛型算法所在头文件 </p>
<h3 id="泛型算法使用实战"><a href="#泛型算法使用实战" class="headerlink" title="泛型算法使用实战"></a>泛型算法使用实战</h3><p>1、泛型算法和容器迭代器的适配<br><strong>(1)算法中对迭代器有要求<br>(2)容器中包含的迭代器有特性<br>(3)2者兼容才可合使用，否则不可使用</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; class RandomIt &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">( RandomIt first, RandomIt last )</span></span>;(C++<span class="number">20</span> 前)</span><br><span class="line"></span><br><span class="line">类型要求:</span><br><span class="line">-RandomIt 必须满足值可交换 (ValueSwappable) 和 老式随机访问迭代器 (LegacyRandomAccessIterator) 的要求。</span><br><span class="line">-解引用 RandomIt 结果的类型必须满足可移动赋值 (MoveAssignable) 和可移动构造 (MoveConstructible) 的要求。</span><br></pre></td></tr></table></figure>

<p>2、泛型算法使用举例<br>下面的这个sort函数并非这几个容器自带的算法，而是泛型算法sort：<br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/sort">https://zh.cppreference.com/w/cpp/algorithm/sort</a><br>(1)使用sort为array默认排序<br>(2)使用sort为list默认排序<br>(3)使用sort为list由大到小排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>();)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter++ &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="keyword">int</span>, 5&gt; a1&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a2&#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; a3&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a1.<span class="built_in">begin</span>(), a1.<span class="built_in">end</span>());<span class="comment">//默认从小到大的顺序排列</span></span><br><span class="line">    <span class="built_in">sort</span>(a2.<span class="built_in">begin</span>(), a2.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());<span class="comment">//按从大到小的顺序排列</span></span><br><span class="line">    a3.<span class="built_in">sort</span>();<span class="comment">//list的迭代器不支持随机访问，故而不可使用泛型算法，可使用其自带的sort方法</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(a1);</span><br><span class="line">    <span class="built_in">print</span>(a2);</span><br><span class="line">    <span class="built_in">print</span>(a3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="谓词predicate和函数对象引入"><a href="#谓词predicate和函数对象引入" class="headerlink" title="谓词predicate和函数对象引入"></a>谓词predicate和函数对象引入</h3><p>1、何为谓词<br>(1)谓词就是可以<strong>做谓语的词，就是“动词、动作”性质语义的词</strong><br>(2)<strong>C/C++中的函数function就是典型的谓词语义</strong><br>(3)C++ STL中的谓词类似这样：<strong>bool func(T&amp; a); 或者 bool func(T&amp;a, T&amp; b);返回值是bool类型</strong><br>(4)常见的谓词：<strong>函数,函数指针,lambda表达式,函数对象,库定义的函数对象</strong></p>
<p>2、函数对象引入<br>(1)函数对象 function object， 也叫仿函数 functor<br>(2)函数对象在语法上不是函数，而是个类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a2.<span class="built_in">begin</span>(), a2.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">greater就是个函数对象。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; class RandomIt, class Compare &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">( RandomIt first, RandomIt last, Compare comp )</span></span>;</span><br></pre></td></tr></table></figure>
<p>(3)函数对象在<strong>调用形式上看起来像个函数</strong></p>
<p>3、函数对象案例实践<br>(1)写一个函数，判断传参是否大于0<br>(2)用函数对象实现，对比、分析、体会</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsGreater_function</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a&gt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsGreater_class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//我们通过()的运算符重载函数实现同样的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(U a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a&gt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用函数实现</span></span><br><span class="line">    <span class="keyword">bool</span> b = <span class="built_in">IsGreater_function</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    b = <span class="built_in">IsGreater_function</span>(<span class="number">-5</span>);</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用函数对象实现</span></span><br><span class="line">    IsGreater_class&lt;<span class="keyword">int</span>&gt; is_greater;</span><br><span class="line">    b = <span class="built_in">is_greater</span>(<span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    b = <span class="built_in">is_greater</span>(<span class="number">-6</span>); </span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数对象的一些细节"><a href="#函数对象的一些细节" class="headerlink" title="函数对象的一些细节"></a>函数对象的一些细节</h3><p>1、自定义函数对象用于STL算法库</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的函数对象，通过字符串的个数进行比较</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mygreater</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> string s1, <span class="keyword">const</span> string s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (s1.<span class="built_in">size</span>() &gt; s2.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>();)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter++ &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;string, 3&gt; a = &#123;<span class="string">&quot;linux&quot;</span>, <span class="string">&quot;android&quot;</span>, <span class="string">&quot;harmonyos&quot;</span>&#125;; </span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());<span class="comment">//默认是根据字符串首字母的字典序进行比较的，排序按照从小到大</span></span><br><span class="line">    <span class="built_in">print</span>(a);</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), greater&lt;string&gt;());<span class="comment">//使用泛型算法提供的函数对象greater</span></span><br><span class="line">    <span class="built_in">print</span>(a);</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">mygreater</span>());<span class="comment">//使用自定义的函数对象mygreater</span></span><br><span class="line">    <span class="built_in">print</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、函数对象的优势<br>(1)<strong>函数对象可以使用template技术实现多类型支持，这比函数的重载技术更有优势</strong><br>(2)函数对象可以有<strong>自己的状态</strong>。我们可以在类中定义状态变量（类私有成员变量），这样一个函数对象在多次的调用中可以共享这个状态。比如我们可以用这个状态表示函数被调用的次数。<br>参考学习：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/gis-user/p/5086218.html">https://www.cnblogs.com/gis-user/p/5086218.html</a> </p>
<h3 id="STL典型泛型算法解读"><a href="#STL典型泛型算法解读" class="headerlink" title="STL典型泛型算法解读"></a>STL典型泛型算法解读</h3><p>我们随机打开一个来分析学习：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/all_any_none_of">https://zh.cppreference.com/w/cpp/algorithm/all_any_none_of</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; class InputIt, class UnaryPredicate &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">all_of</span><span class="params">( InputIt first, InputIt last, UnaryPredicate p )</span></span>;</span><br><span class="line"></span><br><span class="line">UnaryPredicate：一元谓词，表示该谓词只接收一个参数</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Divisible</span> <span class="title">By</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> d;</span><br><span class="line">        <span class="built_in">DivisibleBy</span>(<span class="keyword">int</span> n) : <span class="built_in">d</span>(n) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n % d == <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">any_of</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), <span class="built_in">DivisibleBy</span>(<span class="number">7</span>))) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;At least one number is divisible by 7\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">any_of</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), <span class="built_in">DivisibleBy</span>(<span class="number">7</span>))中的<span class="number">7</span>对应DivisibleBy成员变量</span><br><span class="line">d，这里的<span class="built_in">DivisibleBy</span>(<span class="number">7</span>)既与构造函数有关（进行初始化），也与运算符重载函数有关（作</span><br><span class="line">为函数对象），<span class="built_in">DivisibleBy</span>(<span class="keyword">int</span> n)中的n是在迭代器遍历时内部传参的。</span><br></pre></td></tr></table></figure>

<h3 id="CPP之lamba表达式"><a href="#CPP之lamba表达式" class="headerlink" title="CPP之lamba表达式"></a>CPP之lamba表达式</h3><p>1、实践体会lamba表达式<br>(1)lambda表达式使用举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::<span class="built_in">all_of</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), [](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>; &#125;))</span><br><span class="line">&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;All numbers are even\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lamba表达式:[](int i)&#123; return i % 2 == 0; &#125;</span></span><br></pre></td></tr></table></figure>
<p>(2)使用函数对象实现类似于lambda表达式的效果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IsEven</span>//若使用<span class="keyword">class</span>关键字，则需将重载函数作为<span class="title">public</span>成员，<span class="keyword">class</span>和<span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span>                         <span class="comment">//关键字默认权限不一样</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if (all_of(v.begin(), v.end(), [](int i) -&gt;bool &#123;return i % 2 == 0;&#125;))//方式一：使用lamba表达式</span></span><br><span class="line">    <span class="comment">//IsEven()不传参，这个()对应使用构造函数进行初始化的参数，i是内部传参，迭代器遍历时容器中的元素</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">all_of</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">IsEven</span>()))<span class="comment">//方式二：使用函数对象</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;All numbers are even\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot; Not all numbers are  even\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、lambda表达式总结<br>(1)lambda表达式就是<strong>一个匿名函数，相当于一次使用的、直接原地展开调用的函数</strong><br>(2)lambda表达式也叫<strong>闭包，就是在别的地方无法调用的封包</strong><br>(3)lambda表达式其实<strong>就是一个函数对象，在内部创建了一个重载()操作符的类</strong></p>
<p>3、lambda表达式格式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)完整格式<span class="number">5</span>部分：[参数捕获] (操作符重载函数参数) <span class="keyword">mutable</span>或exception声明 -&gt;返回值类型 &#123;函数体&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)最简单的lambda表达式：[]()&#123;&#125;，调用执行时为[]()&#123;&#125;();</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)带传参的lambda表达式：[](<span class="keyword">int</span> i)&#123;<span class="comment">//i在这里可以用&#125;</span></span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)使用<span class="keyword">auto</span>将lambda表达式定义为一个变量，再以变量方式调用</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>)使用-&gt;<span class="keyword">int</span>这种方式让lambda表达式函数返回相应类型的值</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例如下：</span><br><span class="line">        (<span class="number">2</span>) []()&#123;&#125;();</span><br><span class="line">        </span><br><span class="line">        (<span class="number">3</span>) []()&#123;cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;&#125;();</span><br><span class="line">                [](<span class="keyword">int</span> i)&#123;cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; i &lt;&lt; endl;&#125;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        (<span class="number">4</span>)、(<span class="number">5</span>) <span class="keyword">auto</span> func = [](<span class="keyword">int</span> i) -&gt;<span class="keyword">bool</span> &#123;cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; i &lt;&lt; endl; <span class="keyword">return</span> <span class="literal">false</span>;&#125;;</span><br><span class="line">        <span class="keyword">bool</span> x = <span class="built_in">func</span>(<span class="number">4</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="lambda表达式之参数捕获"><a href="#lambda表达式之参数捕获" class="headerlink" title="lambda表达式之参数捕获"></a>lambda表达式之参数捕获</h3><p>1、什么是参数捕获<br>(1)实验：在lambda表达式外面定义int a，在表达式内部试图访问<br>(2)解决：在[]中增加捕获说明即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">test</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">test</span>(<span class="keyword">int</span> t)&#123;<span class="keyword">this</span>-&gt;sum = t;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt;endl;</span><br><span class="line">        [&amp;]()&#123;sum++;cout&lt;&lt;<span class="string">&quot;lamba4: sum = &quot;</span> &lt;&lt; sum &lt;&lt;endl;&#125;();</span><br><span class="line">        [<span class="keyword">this</span>]()&#123;<span class="keyword">this</span>-&gt;sum++;cout&lt;&lt;<span class="string">&quot;lamba5: this-&gt;sum = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;sum &lt;&lt; endl;&#125;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    string b = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    [a]()&#123;cout &lt;&lt; <span class="string">&quot;lamba1: a = &quot;</span> &lt;&lt; a &lt;&lt; endl;&#125;();</span><br><span class="line">    [&amp;a]()&#123;a++; cout &lt;&lt; <span class="string">&quot;lamba2: a = &quot;</span> &lt;&lt; a &lt;&lt; endl;&#125;();</span><br><span class="line">    <span class="keyword">auto</span> func = [=](<span class="keyword">int</span> i)&#123;cout &lt;&lt; <span class="string">&quot;lamba3: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;&#125;;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">test <span class="title">s</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    s.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)总结：<strong>所谓参数捕获，就是让lambda表达式内部可以捕获并使用外部的变量</strong></p>
<p>2、lambda表达式的捕获列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)[] 空，完全不捕获</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)[=] 等号，以值传参方式捕获（复制了一份传进来，这样表达式内修改了变量，但表达式外值</span><br><span class="line">仍未变，与引用传参的效果不同），捕获范围是表达式所在作用范围（包括所在类的<span class="keyword">this</span>）</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)[&amp;] &amp;号，以引用传参方式捕获，捕获范围是表达式所在作用范围（包括所在类的<span class="keyword">this</span>）</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)[<span class="keyword">this</span>] 只捕获lambda表达式所在类的<span class="keyword">this</span>可访问的那些</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>)[a] 仅以值方式捕获a，其他全部不捕获</span><br><span class="line"></span><br><span class="line">(<span class="number">6</span>)[&amp;a] 仅以引用方式捕获a，其他全部不捕获</span><br><span class="line"></span><br><span class="line">(<span class="number">7</span>)[a, &amp;b] 仅以值方式捕获a，以引用方式捕获b，其余完全不捕获</span><br><span class="line"></span><br><span class="line">(<span class="number">8</span>)[=, &amp;a, &amp;b] 仅以引用方式捕获a和b，其余以值方式捕获</span><br><span class="line"></span><br><span class="line">(<span class="number">9</span>)[&amp;, a, b] 仅以值方式捕获a和b，其余以引用方式捕获</span><br></pre></td></tr></table></figure>

<p>3、lambda表达式总结<br>(1)lambda表达式提供<strong>一种单次使用的函数简写方式</strong><br>(2)<strong>通过捕获列表，在lambda表达式内部也可以访问外部的变量，相当于函数传参</strong></p>
<h3 id="CPP函数适配器"><a href="#CPP函数适配器" class="headerlink" title="CPP函数适配器"></a>CPP函数适配器</h3><p>1、什么是函数适配器<br>(1)<strong>适配器，adapter，用来在不适配的2端间对接的连接器</strong><br>(2)<strong>函数适配器是在不同传参个数的函数间进行适配的技术</strong><br>示例理解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func1</span>(<span class="keyword">int</span> a)</span><br><span class="line"><span class="built_in">func2</span>(<span class="keyword">int</span> a, <span class="keyword">char</span> b)<span class="comment">//可通过手动填充一个参数b进行适配</span></span><br><span class="line"><span class="built_in">func3</span>(<span class="keyword">int</span> a)&#123;<span class="built_in">func2</span>(a, <span class="string">&#x27;A&#x27;</span>);&#125;<span class="comment">//func3则是一个函数适配器，适配了func1与func2</span></span><br></pre></td></tr></table></figure>
<p>(3)几个概念：1元函数、2元函数、1元谓词、2元谓词<br>1元：具有一个参数<br>2元：具有两个参数<br>谓词：返回值是bool类型</p>
<p>2、C++的函数适配器<br>(1)早期C++98时，常用bind1st bind2nd<br>bind1st：预先填充第一个，释放第二个，bind2nd与其刚好相反<br>(2)C++11开始，引入加强版：std::bind</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::<span class="built_in">none_of</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), std::<span class="built_in">bind</span>(std::modulus&lt;<span class="keyword">int</span>&gt;(),                                                 std::placeholders::_1, <span class="number">2</span>)))</span><br><span class="line"><span class="comment">//std::placeholders::_1:表示释放谁，2：表示要填充的值，即将二元谓词的第一个元释放出来，第二个元预先填充，形成一个新的一元谓词</span></span><br><span class="line">&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;None of them are odd\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; class InputIt, class UnaryPredicate &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">all_of</span><span class="params">( InputIt first, InputIt last, UnaryPredicate p )</span></span>;<span class="comment">//UnaryPredicate表示一元谓词</span></span><br><span class="line"></span><br><span class="line">std::modulus::<span class="built_in"><span class="keyword">operator</span></span>()<span class="comment">//二元谓词</span></span><br><span class="line"><span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> T&amp; rhs )</span> <span class="keyword">const</span></span>;</span><br><span class="line">(C++<span class="number">14</span> 前)</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> T&amp; rhs )</span> <span class="keyword">const</span></span>;</span><br><span class="line">(C++<span class="number">14</span> 起)</span><br><span class="line">返回 lhs 除以 rhs 的余数。</span><br><span class="line"></span><br><span class="line">一元谓词和二元谓词并不适配，故需要函数适配器bind</span><br></pre></td></tr></table></figure>

<p>3、bind的学习<br>参考学习：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013654125/article/details/100140328">https://blog.csdn.net/u013654125/article/details/100140328</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestFunc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> c, <span class="keyword">float</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;f = &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> bindFunc1 = <span class="built_in">bind</span>(TestFunc, placeholders::_1, <span class="string">&#x27;A&#x27;</span>, <span class="number">100.1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bindFunc1</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=================================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> bindFunc2 = <span class="built_in">bind</span>(TestFunc, placeholders::_1, placeholders::_2, <span class="number">100.1</span>);</span><br><span class="line">    <span class="built_in">bindFunc2</span>(<span class="number">10</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=================================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> bindFunc3 = <span class="built_in">bind</span>(TestFunc, placeholders::_2, placeholders::_3, placeholders::_1);</span><br><span class="line">    <span class="built_in">bindFunc3</span>(<span class="number">100.1</span>, <span class="number">30</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=================================&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> bindFunc4 = <span class="built_in">bind</span>(TestFunc, <span class="number">10</span>, placeholders::_2, placeholders::_1);</span><br><span class="line">    <span class="built_in">bindFunc4</span>(<span class="number">100.1</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="STL典型泛型算法解读-1"><a href="#STL典型泛型算法解读-1" class="headerlink" title="STL典型泛型算法解读"></a>STL典型泛型算法解读</h3><p>1、for_each、transform、范围 for 循环(C++11)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参考学习：</span><br><span class="line">https:<span class="comment">//zh.cppreference.com/w/cpp/algorithm/for_each</span></span><br><span class="line">https:<span class="comment">//zh.cppreference.com/w/cpp/algorithm/transform</span></span><br><span class="line">https:<span class="comment">//zh.cppreference.com/w/cpp/language/range-for</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; sum += n; &#125;</span><br><span class="line">    <span class="keyword">int</span> sum&#123;<span class="number">0</span>&#125;;<span class="comment">//使用&#123;&#125;赋初值，若struct Sum类型变量被定义，sum初值为0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">for_each示例：</span><br><span class="line"></span><br><span class="line">可能源码：</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class InputIt, class UnaryFunction&gt;</span></span><br><span class="line"><span class="function">UnaryFunction <span class="title">for_each</span><span class="params">(InputIt first, InputIt last, UnaryFunction f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">        <span class="built_in">f</span>(*first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f; <span class="comment">// C++11 起隐式移动</span></span><br><span class="line">&#125;</span><br><span class="line">使用示例：</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">267</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> print = [](<span class="keyword">const</span> <span class="keyword">int</span>&amp; n) &#123; std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n; &#125;;</span><br><span class="line"> </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;before:&quot;</span>;</span><br><span class="line">std::for_each(nums.<span class="built_in">cbegin</span>(), nums.<span class="built_in">cend</span>(), print);<span class="comment">//实现遍历元素并打印</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">transform示例：</span><br><span class="line">可能源码:</span><br><span class="line"></span><br><span class="line">版本一</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class InputIt, class OutputIt, class UnaryOperation&gt;</span></span><br><span class="line"><span class="function">OutputIt <span class="title">transform</span><span class="params">(InputIt first1, InputIt last1, OutputIt d_first, </span></span></span><br><span class="line"><span class="params"><span class="function">                   UnaryOperation unary_op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (first1 != last1) &#123;</span><br><span class="line">        *d_first++ = <span class="built_in">unary_op</span>(*first1++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d_first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用示例：</span><br><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">transform</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s.<span class="built_in">begin</span>(),</span><br><span class="line">[](<span class="keyword">unsigned</span> <span class="keyword">char</span> c) -&gt; <span class="keyword">unsigned</span> <span class="keyword">char</span> &#123; <span class="keyword">return</span> std::<span class="built_in">toupper</span>(c); &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">范围 <span class="keyword">for</span> 循环示例：</span><br><span class="line"></span><br><span class="line">可能源码：</span><br><span class="line">属性(可选) <span class="keyword">for</span> ( 初始化语句(可选)范围变量声明 : 范围表达式 ) 循环语句                </span><br><span class="line"></span><br><span class="line">使用示例：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; i : v) <span class="comment">// 以 const 引用访问</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : v) <span class="comment">// 以值访问，i 的类型是 int</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; i : v) <span class="comment">// 以转发引用访问，i 的类型是 int&amp;</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cv = v;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; i : cv) <span class="comment">// 以转发引用访问，i 的类型是 const int&amp;</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;) <span class="comment">// 初始化器可以是花括号初始化器列表</span></span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : a) <span class="comment">// 初始化器可以是数组</span></span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> ([[maybe_unused]] <span class="keyword">int</span> n : a)  </span><br><span class="line">        std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 不必使用循环变量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n = v.<span class="built_in">size</span>(); <span class="keyword">auto</span> i : v) <span class="comment">// 初始化语句（C++20）</span></span><br><span class="line">        std::cout &lt;&lt; --n + i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">typedef</span> <span class="keyword">decltype</span>(v)::value_type <span class="keyword">elem_t</span>; <span class="keyword">elem_t</span> i : v)</span><br><span class="line">    <span class="comment">// typedef 声明作为初始化语句（C++20）</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">using</span> <span class="keyword">elem_t</span> = <span class="keyword">decltype</span>(v)::value_type; <span class="keyword">elem_t</span> i : v)</span><br><span class="line">    <span class="comment">// 别名声明作为初始化语句，同上（C++23）</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、再看几个泛型算法<br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm">https://zh.cppreference.com/w/cpp/algorithm</a><br>其他算法的学习方法与上边相同，打开上边的网址自主学习，授之以鱼不如授之以渔。</p>
<p>2、泛型算法总结<br>(1)<strong>理解 谓词 和 函数对象，是学习和使用泛型算法的基础</strong><br>(2)泛型算法很多，但是套路是类似的，学会的关键是理解并会用这种套路<br>(3)<strong>不建议试图死记硬背所有泛型算法，建议实战中去熟悉、去用起来并记住</strong><br>(4)能用现成泛型算法写代码就不要自己造轮子<br>(5)一个潜在问题警告：C++包的越来越多（层层封装），不要想当然，未经验证确认的代码都要有怀疑精神</p>
<h2 id="模板特化和类型萃取"><a href="#模板特化和类型萃取" class="headerlink" title="模板特化和类型萃取"></a>模板特化和类型萃取</h2><h3 id="从案例中理解什么是模板特化"><a href="#从案例中理解什么是模板特化" class="headerlink" title="从案例中理解什么是模板特化"></a>从案例中理解什么是模板特化</h3><p>1、通过一个案例理解模板特化<br>(1)案例前奏：写一个swap函数库，可以适用于各种数据类型。结论是模板比函数重载好用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;<span class="comment">//定义一个抽象类型X，在函数被调用时确定具体类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(X&amp; a, X&amp; b)</span><span class="comment">//使用swap作为函数名会与某个库函数名冲突</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X tmp;</span><br><span class="line"></span><br><span class="line">    tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">3.3</span>, d = <span class="number">4.4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myswap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myswap</span>(c, d);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)案例：写一个GreaterThan函数，可以对比各种数据类型的大小。<br>(3)特殊要求：int等比较数值大小，但string类型对比时，不比较字典序，而是以字符串长短来比较</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GreaterThan</span><span class="params">(T a, T b)</span><span class="comment">//模板泛化函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template GreaterThan&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GreaterThan</span><span class="params">(string a, string b)</span><span class="comment">//模板特化函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;special template GreaterThan&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GreaterThan</span><span class="params">(string a, string b)</span><span class="comment">//普通函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ordinary GreaterThan&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; GreaterThan&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; GreaterThan&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; GreaterThan&lt;<span class="keyword">double</span>&gt;(<span class="number">5.4</span>, <span class="number">5.3</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; GreaterThan&lt;<span class="keyword">double</span>&gt;(<span class="number">5.3</span>, <span class="number">5.4</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面所传的两个参数为const型，不可修改，GreaterThan()函数调用优先级为模板泛化函数最高</span></span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; GreaterThan&lt;string&gt;(<span class="string">&quot;linux&quot;</span>, <span class="string">&quot;harmony&quot;</span>) &lt;&lt; endl;<span class="comment">//执行special</span></span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; <span class="built_in">GreaterThan</span>(<span class="string">&quot;linux&quot;</span>, <span class="string">&quot;harmony&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当比较的两个参数为string类型时，上述三个函数优先级为：</span></span><br><span class="line">    <span class="comment">//普通函数 &gt; 模板特化函数 &gt; 模板泛化函数</span></span><br><span class="line">    string a = <span class="string">&quot;linux&quot;</span>, b = <span class="string">&quot;harmony&quot;</span>; </span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; GreaterThan&lt;string&gt;(a, b) &lt;&lt; endl;<span class="comment">//执行special</span></span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; <span class="built_in">GreaterThan</span>(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考学习：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/rickyk/p/3941176.html">C++普通函数与模板函数以及特化函数重载的优先级问题</a></p>
<p>2、模板特化总结<br>(1)<strong>模板特化有点类似于函数重载，而且都是编译链接时确定，而非运行时确定的。</strong><br>(2)特化，specialize，就是<strong>让模板参数T在某个具体类型时可以特殊化指定处理</strong><br>(3)特化的模板声明，前面一般是 template&lt;&gt;</p>
<h3 id="偏特化和全特化"><a href="#偏特化和全特化" class="headerlink" title="偏特化和全特化"></a>偏特化和全特化</h3><p>1、全特化与偏特化概念<br>(1)<strong>全特化，特化原模板的所有模板类型为具体类型</strong><br>(2)<strong>偏特化，又叫局部特化，特化原模板的部分类型，或部分特化原模板的类型</strong><br>(3)全特化比较简单，而偏特化更复杂，是之后讨论的重点。</p>
<p>2、函数模板的全特化<br>(1)代码实践，单个模板参数<br>  上边提供的那个程序中就实现了单个模板参数的全特化。<br>(2)代码实践，多个模板参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T1 a, T2 b)</span> <span class="comment">//模板泛化函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(T1 a, T2 b), a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">int</span> b)</span> <span class="comment">//函数模板的全特化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(double a, int b), a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> b = <span class="number">2.2</span>;</span><br><span class="line">    <span class="built_in">func</span>(a, b);</span><br><span class="line">    <span class="built_in">func</span>(b, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、类模板的全特化<br>(1)代码实践，单个模板参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T attribute;</span><br><span class="line">    <span class="built_in">people</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">people</span>(T attr)&#123;attribute = attr;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T a)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> people&lt;T&gt;::<span class="built_in">print</span>(T a)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template function print: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span><span class="keyword">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> attribute;</span><br><span class="line">    <span class="built_in">people</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">people</span>(<span class="keyword">int</span> attr)&#123;attribute = attr;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span></span>;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> people&lt;<span class="keyword">int</span>&gt;::<span class="built_in">print</span>(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;complete special template function print: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">people&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">people&lt;string&gt; <span class="title">p2</span><span class="params">(<span class="string">&quot;linux&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">10</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(<span class="string">&quot;linux&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)代码实践，多个模板参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 attribute;</span><br><span class="line">    <span class="built_in">people</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">people</span>(T1 attr)&#123;attribute = attr;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T2 a)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="keyword">void</span> people&lt;T1, T2&gt;::<span class="built_in">print</span>(T2 a)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template function print: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span><span class="keyword">int</span>, string&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> attribute;</span><br><span class="line">    <span class="built_in">people</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">people</span>(<span class="keyword">int</span> attr)&#123;attribute = attr;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(string a)</span></span>;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> people&lt;<span class="keyword">int</span>, string&gt;::<span class="built_in">print</span>(string a)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;complete special template function print: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">people&lt;<span class="keyword">int</span>, string&gt; <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">people&lt;string, <span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="string">&quot;linux&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="string">&quot;linux&quot;</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类模板的多种偏特化"><a href="#类模板的多种偏特化" class="headerlink" title="类模板的多种偏特化"></a>类模板的多种偏特化</h3><p>1、类模板的第一种偏特化<br>(1)特化多个模板参数中的一部分参数<br>(2)这种比较简单，代码实践演示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>//模板泛化类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T1 a, T2 b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="keyword">void</span> people&lt;T1, T2&gt;::<span class="built_in">print</span>(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span>string, <span class="keyword">int</span>&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(string a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:people&lt;string, int&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span><span class="keyword">int</span>, string&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a, string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:people&lt;int, string&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    people&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p1;</span><br><span class="line">    people&lt;string, string&gt; p2;</span><br><span class="line">    people&lt;<span class="keyword">int</span>, string&gt; p3;</span><br><span class="line">    people&lt;string, <span class="keyword">int</span>&gt; p4;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(<span class="string">&quot;two&quot;</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">    p3.<span class="built_in">print</span>(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">    p4.<span class="built_in">print</span>(<span class="string">&quot;four&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、类模板的第二种偏特化<br>(1)特化为T的指针类型<br>(2)这种特化理解起来稍微有点绕（可以将T理解为一个万能类型，而T则表示这个类型必须为指针，T包含T，所以T*是T的偏特化），实战演示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>//模板泛化类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T1 a, T2 b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="keyword">void</span> people&lt;T1, T2&gt;::<span class="built_in">print</span>(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span>T *, <span class="keyword">int</span>&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:peoplepeople&lt;T *, int&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span>T *, string&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T *a,  string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:peoplepeoplepeople&lt;T *, string&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    string c = <span class="string">&quot;two&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> d = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    people&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p1;</span><br><span class="line">    people&lt;<span class="keyword">char</span> *, <span class="keyword">int</span>&gt; p2;</span><br><span class="line">    people&lt;<span class="keyword">int</span> *, string&gt; p3;</span><br><span class="line">    people&lt;string *, <span class="keyword">int</span>&gt; p4;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(d, <span class="number">2</span>);</span><br><span class="line">    p3.<span class="built_in">print</span>(&amp;a, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">    p4.<span class="built_in">print</span>(<span class="string">&quot;four&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、类模板的第三种偏特化<br>(1)特化为T的其他类模板，譬如vector<br>(2)这种特化理解起来难度更大，实战演示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>//模板泛化类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T1 a, T2 b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="keyword">void</span> people&lt;T1, T2&gt;::<span class="built_in">print</span>(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span>vector&lt;T&gt;, <span class="keyword">int</span>&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:people&lt;vector&lt;T&gt;, int&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span>array&lt;T, 3&gt;, string&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(array&lt;T, <span class="number">3</span>&gt; a,  string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:people&lt;array&lt;T, 3&gt;, string&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span>T&amp; , string&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T&amp; a,  string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:people&lt;T&amp; , string&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; c;</span><br><span class="line"></span><br><span class="line">    people&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p1;</span><br><span class="line">    people&lt;<span class="keyword">int</span> &amp;, string&gt; p2;</span><br><span class="line">    people&lt;vector&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; p3;</span><br><span class="line">    people&lt;array&lt;<span class="keyword">int</span>, 3&gt;, string&gt; p4;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(a, <span class="string">&quot;int&amp;&quot;</span>);</span><br><span class="line">    p3.<span class="built_in">print</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    p4.<span class="built_in">print</span>(c, <span class="string">&quot;array&lt;int, 3&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、类模板的第四种偏特化<br>(1)特化为带const的版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;template class&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>&lt;</span><span class="keyword">const</span> T &amp;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;People&lt;const T &amp;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    People&lt;string&gt; p1;</span><br><span class="line">    People&lt;<span class="keyword">const</span> <span class="keyword">char</span> &amp;&gt; p2;</span><br><span class="line">    People&lt;<span class="keyword">const</span> <span class="keyword">int</span> &amp;&gt; p3;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">func</span>();</span><br><span class="line">    p2.<span class="built_in">func</span>();</span><br><span class="line">    p3.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数模板为什么不能偏特化"><a href="#函数模板为什么不能偏特化" class="headerlink" title="函数模板为什么不能偏特化"></a>函数模板为什么不能偏特化</h3><p>1、事实<br>(1)<strong>函数模板确实不支持偏特化，只能全特化，这是编译器决定的</strong>（若想求证，可自行写个程序测试一下，比较简单，下面是我的测试程序）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T a)</span><span class="comment">//模板泛化函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template:void func(T a) &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;  endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="comment">//全特化函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;complete template :void func(int a) &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;  endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> func&lt;T*&gt;(T a)<span class="comment">//偏特化函数，但函数没有偏特化，故编译不会通过</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;partial template:void func(T* a) &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;  endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用函数重载来实现T *的偏特化完全相同的效果</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func(T *a), a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="comment">//非模板函数，即普通函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ordinary:void func(int a) &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;  endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3.14</span>);    <span class="comment">//template</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">5</span>);       <span class="comment">//ordinary</span></span><br><span class="line">    func&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>);  <span class="comment">//complete template</span></span><br><span class="line">    <span class="comment">//func&lt;int *&gt;(5);//用于调用偏特化函数，但函数无偏特化</span></span><br><span class="line">    func&lt;<span class="keyword">int</span>&gt;(&amp;a);<span class="comment">//重载函数：func(T *a)</span></span><br><span class="line">    <span class="built_in">func</span>(&amp;a);     <span class="comment">//重载函数：func(T *a)</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="string">&quot;linux&quot;</span>);<span class="comment">//重载函数：func(T *a)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)怎么办？<br>  用模板函数重载即可</p>
<p>(3)总结：为什么函数模板不能偏特化？<br>  因为没必要支持，模板函数重载就能搞定</p>
<p>2、分析深度原因<br>(1)C++语言设计基本原则：<strong>后出现的语法尽量兼容且不破坏原有的语法规则</strong><br>(2)<strong>C++一开始就支持函数重载，所以模板函数自然沿用了支持函数重载</strong><br>(3)<strong>偏特化实现的效果，完全可以用模板函数重载实现，所以没必要让模板函数可以偏特化</strong><br>(4)再思考：类模板为什么可以偏特化？<br>  因为类不能重载 </p>
<h3 id="编译器匹配规则和特化的总结"><a href="#编译器匹配规则和特化的总结" class="headerlink" title="编译器匹配规则和特化的总结"></a>编译器匹配规则和特化的总结</h3><p>1、编译器匹配规则<br>(1)第1步先匹配非模版函数，也就是普通函数，如果匹配到就执行，匹配不到进入下一步<br>(2)第2步再匹配基础泛化版函数，如果匹配不到就报错了，匹配到进入下一步<br>(3)第3步再匹配完全特化版本，如果匹配到就执行，匹配不到就执行上一步匹配到的泛化版本<br>(4)一个小细节：函数模板的特化（当然是全特化）不参与函数重载 </p>
<p>2、特化与递归结合<br>(1)特化与递归结合，可以很巧妙的实现编译期的条件判断</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">int</span> i&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  print&lt;i<span class="number">-1</span>&gt;();</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//特例，终止递归。</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> print&lt;<span class="number">1</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  print&lt;<span class="number">100</span>&gt;();<span class="comment">//在编译期展开相当于100条输出语句</span></span><br><span class="line">  <span class="comment">//即调用void print()并传参100，print&lt;i-1&gt;();开始递归，i初值100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liuxuejiang158blog/article/details/17678573">https://blog.csdn.net/liuxuejiang158blog/article/details/17678573</a></p>
<p>3、特化的最后总结<br>(1)<strong>特化本质上是我们顶替了编译器的工作，我们帮编译器做了类型推导</strong><br>(2)模板特化和模板实例化这2个概念的对比<br>(3)<strong>全特化本质上是一个实例，而偏特化本质上还是一个模板，只是原来模板的一个子集，所以全特化的函数模板，本质上是实例（但不参与普通函数的重载），从而不会与函数模板产生二义性</strong></p>
<h3 id="类型萃取的目的和意义"><a href="#类型萃取的目的和意义" class="headerlink" title="类型萃取的目的和意义"></a>类型萃取的目的和意义</h3><p>1、类型萃取是用途<br>(1)典型应用就是：在模板函数中区分T是 源生类型POD 还是 自定义类型<br>(2)POD,Plain Old Data,简单理解就是C++从C继承而来的基本类型，如int、double等<br>(3)POD类型的本质是没有C++叠加的那些高级特征（构造析构，拷贝构造，移动语义，虚函数等） </p>
<p>2、为什么要区分POD类型和非POD类型<br>(1)典型案例就是copy时，POD类型直接memcpy(C语言的一个库函数)即可，而非POD类型需要用for循环结合“=”(默认提供的运算符重载后的=可以实现对象拷贝)，挨个对象拷贝<br>(2)非POD类型不能memcpy(涉及到了动态内存)，本质是因为需要深拷贝以避免出错<br>(3)代码演练:int数组和string数组的复制对比 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span><span class="comment">//c语言的那个string.h头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//C++的string头文件，与上边的那个不同</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mycopy</span><span class="params">(T* Dst, T* Src, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(Dst, Src, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0    </span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, b[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    string a[<span class="number">3</span>] = &#123;<span class="string">&quot;linux&quot;</span>, <span class="string">&quot;android&quot;</span>, <span class="string">&quot;harmonyos&quot;</span>&#125;;</span><br><span class="line">    string b[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    mycopy&lt;string&gt;(b, a, <span class="built_in"><span class="keyword">sizeof</span></span>(string)*<span class="number">3</span>);<span class="comment">//虽然可以执行，但会报错，这就是浅拷贝</span></span><br><span class="line">    a[<span class="number">1</span>] = <span class="string">&quot;ubuntu&quot;</span>;                       <span class="comment">//报错信息：free(): invalid size ，已放弃 (核心已转储)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//mycopy&lt;int&gt;(b, a, sizeof(int)*3);</span></span><br><span class="line">    <span class="comment">//a[0] = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; b[k] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型萃取实战演练"><a href="#类型萃取实战演练" class="headerlink" title="类型萃取实战演练"></a>类型萃取实战演练</h3><p>1、使用is_pod解决上面的问题<br>(1)std::is_pod介绍</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m1;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m2;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; std::is_pod&lt;A&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::is_pod&lt;B&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::is_pod&lt;C&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>(2)代码实战，使用is_pod来完善mycopy解决上节中的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mycopy</span><span class="params">(T* Dst, T* Src, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_pod&lt;T&gt;::value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(Dst, Src, <span class="built_in"><span class="keyword">sizeof</span></span>(T)*count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Dst[i] = Src[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a[<span class="number">3</span>] = &#123;<span class="string">&quot;linux&quot;</span>, <span class="string">&quot;android&quot;</span>, <span class="string">&quot;harmonyos&quot;</span>&#125;;</span><br><span class="line">    string b[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    mycopy&lt;string&gt;(b, a, <span class="number">3</span>);</span><br><span class="line">    a[<span class="number">1</span>] = <span class="string">&quot;ubuntu&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; b[k] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型萃取是如何实现的"><a href="#类型萃取是如何实现的" class="headerlink" title="类型萃取是如何实现的"></a>类型萃取是如何实现的</h3><p>1、一种可能的实现（方法一）<br>(1)把所有pod类型组成列表，在内部挨个判断，借助两个关键字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeid</span>用来返回一个变量（表达式）（对象）的类型，类似于C语言中的：<span class="built_in">typeof</span>() </span><br><span class="line">是GUN C提供的一种特性，它可以取得变量的类型，或者表达式的类型。</span><br></pre></td></tr></table></figure>
<p>(2)优点：可以实现，且能实现<type_traits>中所有的标准库萃取工具<br>(3)缺点：运行时</p>
<p>2、使用类模板的特化实现（方法二）<br>(1)代码实践演示<br>判断，占用运行时资源，效率低</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛化版本的my_is_pod</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_is_pod</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> my_is_pod&lt;T&gt;::value = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// int类型的特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_is_pod</span>&lt;</span><span class="keyword">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> my_is_pod&lt;<span class="keyword">int</span>&gt;::value = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// double类型的特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_is_pod</span>&lt;</span><span class="keyword">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> my_is_pod&lt;<span class="keyword">double</span>&gt;::value = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// short类型的特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_is_pod</span>&lt;</span><span class="keyword">short</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> my_is_pod&lt;<span class="keyword">short</span>&gt;::value = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string类型使用这样的方法还会报错，我试过，但没有去深入研究</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mycopy</span><span class="params">(T *dest, <span class="keyword">const</span> T *src, <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">// 我们需要一种技术，在这里可以去区分，T到底是pod还是非pod</span></span><br><span class="line">        <span class="keyword">if</span> (my_is_pod&lt;T&gt;::value)</span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;if&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">memcpy</span>(dest, src, cnt*<span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;else&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cnt; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                        dest[i] = src[i];                        <span class="comment">// 非pod类型使用operator=是可以复制的</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; boolalpha &lt;&lt; my_is_pod&lt;double&gt;::value &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">short</span> a[<span class="number">3</span>] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">short</span> b[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        mycopy&lt;<span class="keyword">short</span>&gt;(b, a, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">                cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*        </span></span><br><span class="line"><span class="comment">        string s1[3] = &#123;&quot;linux&quot;, &quot;android&quot;, &quot;harmonyos&quot;&#125;;</span></span><br><span class="line"><span class="comment">        string s2[3];</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        mycopy&lt;string&gt;(s2, s1, 3);                        // 非pod类型不能memcpy，因为会浅拷贝导致错误</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for (int i=0; i&lt;3; i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; &quot;s2[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; s2[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        s1[0] = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;last, s2[0] = &quot; &lt;&lt; s2[0] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">*/</span>        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)总结：特化实现萃取的关键，就是特化版本的优先级高于泛化版本<br>(3)思考：使用类模板特化，是否会增加代码量，影响程序效率？<br>  会增加代码量，不会影响效率，模板特化是在编译时判断的。</p>
<h3 id="类型萃取的另一种可能实现"><a href="#类型萃取的另一种可能实现" class="headerlink" title="类型萃取的另一种可能实现"></a>类型萃取的另一种可能实现</h3><p>1、不使用静态成员变量<br>2、改为使用成员函数<br>3、使用typedef增加一层中间层<br>(1)class/struct内使用typedef定义子类型的方法<br>(2)增加名为value_type的子类型中间层，实现pod判断</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FalseType</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">GetType</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrueType</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">GetType</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛化版本的my_is_pod</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_is_pod</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> FalseType value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_is_pod</span>&lt;</span><span class="keyword">short</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> TrueType value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; my_is_pod&lt;<span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>().<span class="built_in">GetType</span>() &lt;&lt; endl;<span class="comment">//value_type()的这个()表示构造函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器萃取与泛型算法"><a href="#迭代器萃取与泛型算法" class="headerlink" title="迭代器萃取与泛型算法"></a>迭代器萃取与泛型算法</h3><p>1、STL的核心<br>(1)STL，就是C++提供的一套标准实现的template化的library<br>(2)STL有很多内容，但是核心就是2个：<strong>泛型容器、泛型算法</strong><br>(3)为了实现<strong>泛型容器，引入了迭代器，迭代器是指针的泛化抽象</strong><br>(4)泛型算法可以接受多种容器，每种容器内可以存储多种数据载体，这就是泛型算法的2级泛化支持</p>
<p>2、泛型算法实现的难题和解法<br>(1)问题1：泛型算法无法预知自己处理的是什么容器<br>解决思路：<strong>将容器降级为迭代器来对接泛型算法。所以任何容器都必须内置一个迭代器</strong><br>(3)问题2：泛型算法无法预知容器内存储的元素类型，是否POD<br>解决思路：<strong>提供迭代器萃取器，在泛型算法内预先萃取并使用容器元素类型</strong></p>
<h3 id="迭代器萃取器的设计解读"><a href="#迭代器萃取器的设计解读" class="headerlink" title="迭代器萃取器的设计解读"></a>迭代器萃取器的设计解读</h3><p>(1)迭代器萃取器本质是一个类，叫iterator_traits，属于辅助迭代器的第三方类<br>(2)解读参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/virtual_func/article/details/48398451">https://blog.csdn.net/virtual_func/article/details/48398451</a></p>
<h3 id="迭代器萃取器的特化"><a href="#迭代器萃取器的特化" class="headerlink" title="迭代器萃取器的特化"></a>迭代器萃取器的特化</h3><p>1、萃取器的特化讲解<br>(1)参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/terence1212/article/details/52287762">https://blog.csdn.net/terence1212/article/details/52287762</a><br>(2)总结：本质是偏特化结合类型萃取技术</p>
<p>2、本章节文章总结<br>(1)主要讲了2项技术，一个 是特化，一个是萃取<br>(2)特化的核心价值是，<strong>让模板类/函数按一定优先级规则去匹配</strong><br>(3)萃取的核心价值是，让我们在<strong>写泛型算法时可以预先得知未来传参容器及容器内元素的型别特征</strong><br>(4)<strong>如果只是使用STL，实际上不需要关注特化和萃取</strong><br>(5)<strong>真正理解模板技术、特化、萃取等技术的使用和实现，你才会感受到C++的魅力，知道C++为什么效率高</strong><br>(6)<strong>从实用角度讲，不需要真的深度去研究这些。但是如果完全不懂甚至不知道这些技术的存在，那休想用好C++</strong></p>
<h2 id="STL其它容器讲解"><a href="#STL其它容器讲解" class="headerlink" title="STL其它容器讲解"></a>STL其它容器讲解</h2><h3 id="STL的三种容器适配器"><a href="#STL的三种容器适配器" class="headerlink" title="STL的三种容器适配器"></a>STL的三种容器适配器</h3><p>1、什么是容器适配器<br>(1)回顾：C++三种适配器：<strong>函数适配器、容器适配器、迭代器适配器</strong><br>(2)<strong>适配器，adapter，本质是添加一个中间层来转换以适配双方</strong><br>(3)<strong>容器适配器，是用已有容器来二次封装以构建新容器</strong><br>(4)<strong>STL提供三种容器适配器，分别是：stack、queue、priority_queue</strong><br>(5)stack:栈，先进后出，关心压栈和弹栈操作<br>(6)queue:队列，FIFO，关心入队和出队操作<br>(7)priority_queue:优先级队列，内部自排队式进，按优先级出，关心入队和出队操作 </p>
<p>2、为什么会有容器适配器<br>(1)<strong>顺序式容器是基本容器，偏重于“存储”特性，核心是元素如何在内存中管理</strong><br>(2)<strong>栈和队列是数据结构型容器，偏重于“数据操作”特性，核心是元素如何按需要进去出来</strong><br>(3)从层次讲：<strong>顺序式容器是底层实现，而栈和队列是上层应用</strong><br>(4)<strong>栈和队列底层完全可以由vector、list、array等顺序式容器封装形成，没必要完全从零构建</strong> </p>
<p>3、总结<br>(1)<strong>容器适配器很多时候用起来和容器完全一样，所以也可以叫容器</strong><br>(2)容器适配器内部实现和容器不同<br>(3)<strong>容器适配器直接内部没有迭代器，但是间接包含有</strong><br>(4)<strong>容器适配器不能访问内部间接迭代器，而且也没有必要访问</strong><br>(5)容器适配器怎么实现的可以不必关心，除非你自己需要去定义新的容器适配器 </p>
<h3 id="容器适配器之stack详解"><a href="#容器适配器之stack详解" class="headerlink" title="容器适配器之stack详解"></a>容器适配器之stack详解</h3><p>参考学习：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/stack">https://zh.cppreference.com/w/cpp/container/stack</a><br>  栈(这个容器)是无法进行遍历的，其内没有迭代器。只可以通过弹栈的方式来查看栈内的元素，当元素被依次弹出时，虽然看到了其中的元素，但最终栈将会变为一个空栈。<br>1、stack的构造<br>参考手册：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/stack/stack">https://zh.cppreference.com/w/cpp/container/stack/stack</a></p>
<p>2、stack的操作函数<br>(1)进栈push<br>(2)出栈pop</p>
<p>3、stack元素查询<br>(1)栈顶元素读取top<br>(2)栈内元素个数获取size<br>(3)栈元素是否空empty</p>
<p>4、栈和栈操作<br>(1)栈元素交换：2个swap<br>(2)栈元素对比：一众运算符重载 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    a.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    a.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    a.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    a.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.size() = &quot;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.top() = &quot;</span> &lt;&lt; a.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; <span class="string">&quot;a.empty() = &quot;</span> &lt;&lt; a.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a.top() = &quot;</span> &lt;&lt; a.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="容器适配器之queue和priority-queue详解"><a href="#容器适配器之queue和priority-queue详解" class="headerlink" title="容器适配器之queue和priority_queue详解"></a>容器适配器之queue和priority_queue详解</h3><p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/queue">https://zh.cppreference.com/w/cpp/container/queue</a><br>1、queue<br>(1)FIFO，先进先出<br>(2)访问元素用front访问队首，用back访问队尾<br>(3)push时只能push到back的后面，pop时只能从front处pop</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::queue&lt;<span class="keyword">int</span>&gt; c1;</span><br><span class="line">    c1.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c1.size = &quot;</span> &lt;&lt; c1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">queue&lt;<span class="keyword">int</span>&gt; <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c2.size = &quot;</span> &lt;&lt; c2.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; deq&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">queue&lt;<span class="keyword">int</span>&gt; <span class="title">c3</span><span class="params">(deq)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.size = &quot;</span> &lt;&lt; c3.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.front = &quot;</span> &lt;&lt; c3.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.back = &quot;</span> &lt;&lt; c3.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">    c3.<span class="built_in">push</span>(<span class="number">6</span>);</span><br><span class="line">    c3.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">    c3.<span class="built_in">emplace</span>(<span class="number">8</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.front = &quot;</span> &lt;&lt; c3.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.back = &quot;</span> &lt;&lt; c3.<span class="built_in">back</span>() &lt;&lt; endl;    </span><br><span class="line">    c3.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.front = &quot;</span> &lt;&lt; c3.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.back = &quot;</span> &lt;&lt; c3.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        queue&lt;string&gt; q1;</span><br><span class="line">        </span><br><span class="line">        q1.<span class="built_in">push</span>(<span class="built_in">string</span>(<span class="string">&quot;android&quot;</span>));</span><br><span class="line">        q1.<span class="built_in">push</span>(<span class="built_in">string</span>(<span class="string">&quot;linux&quot;</span>));</span><br><span class="line">        q1.<span class="built_in">push</span>(<span class="built_in">string</span>(<span class="string">&quot;harmonyos&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;q1.size = &quot;</span> &lt;&lt; q1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        string s1 = q1.<span class="built_in">front</span>();</span><br><span class="line">        string s2 = q1.<span class="built_in">back</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;s1 = &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;, s2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;q1.size = &quot;</span> &lt;&lt; q1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、priority_queue<br>(1)按照规则进时排队，从top出<br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/priority_queue">https://zh.cppreference.com/w/cpp/container/priority_queue</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_queue</span><span class="params">(T&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; q.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;)</span><br><span class="line">        q.<span class="built_in">push</span>(n);</span><br><span class="line">    <span class="built_in">print_queue</span>(q);</span><br><span class="line"></span><br><span class="line">    std::priority_queue&lt;<span class="keyword">int</span>, std::vector&lt;<span class="keyword">int</span>&gt;, std::greater&lt;<span class="keyword">int</span>&gt;&gt; q2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;)</span><br><span class="line">        q2.<span class="built_in">push</span>(n);</span><br><span class="line">    <span class="built_in">print_queue</span>(q2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">int</span> left, <span class="keyword">int</span> right)&#123;<span class="built_in"><span class="keyword">return</span></span> (left ^ <span class="number">1</span>) &lt; (right ^ <span class="number">1</span>);&#125;;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">q3</span>(cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;)</span><br><span class="line">        q3.<span class="built_in">push</span>(n);</span><br><span class="line">    <span class="built_in">print_queue</span>(q3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有序关联容器set"><a href="#有序关联容器set" class="headerlink" title="有序关联容器set"></a>有序关联容器set</h3><p>1、什么是有序关联容器<br>(1)顺序容器，<strong>容器中的元素是按它们在容器中的位置来顺序保存和访问的</strong><br>(2)顺序容器有<strong>array、vector、deque、list、forward_list、string</strong>等<br>(3)<strong>关联容器中的元素是按关键字来保存和访问的，关联的意思就是关键字（key）与存储值（value）的关联</strong><br>(4)主要的关联容器类型是<strong>map</strong>和<strong>set</strong><br>(5)<strong>关联容器支持高效的关键字查找和访问</strong><br>(6)有序关联容器：容器内元素按顺序排列，一般用树（譬如红黑树）来实现<br>(7)无序关联容器：容器内元素无顺序排列，一般用哈希表来实现，本质上是一种映射</p>
<p>2、set的基本使用<br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/set">https://zh.cppreference.com/w/cpp/container/set</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7192.html">http://c.biancheng.net/view/7192.html</a><br>(1)set的基本理解：<strong>就是一个用来装Key类型对象的筐子，数学上叫集合</strong><br>(2)set的构造函数<br>(3)<strong>插入数据可以用insert，插入时内部自动排序</strong><br>(4)查询set中元素个数用：empty、size，max_size是理论上的最大元素数<br>(5)清除全部元素用clear<br>(6)针对清除某个Key用erase，若erase的元素不存在则不报错<br>(7)<strong>使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;string&gt; s1;</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="string">&quot;cat&quot;</span>);<span class="comment">//这里有个转换的过程，&quot;key&quot;是c中的字符串，这里内部将其转换为了string类型</span></span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="string">&quot;monkey&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1.size = &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; boolalpha &lt;&lt; <span class="string">&quot;, empty = &quot;</span> &lt;&lt; s1.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    s1.<span class="built_in">erase</span>(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1.size = &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; boolalpha &lt;&lt; <span class="string">&quot;, empty = &quot;</span> &lt;&lt; s1.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">    s1.<span class="built_in">erase</span>(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    s1.<span class="built_in">erase</span>(<span class="string">&quot;monkey&quot;</span>);    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1.size = &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; boolalpha &lt;&lt; <span class="string">&quot;, empty = &quot;</span> &lt;&lt; s1.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set的遍历和原地构造"><a href="#set的遍历和原地构造" class="headerlink" title="set的遍历和原地构造"></a>set的遍历和原地构造</h3><p>1、set的三种遍历方法（set具有迭代器）<br>(1)使用ranged for<br>(2)使用迭代器写for循环<br>(3)使用std::for_each</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;string&gt; s1;</span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="string">&quot;house&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1.size() = &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 第一种遍历方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : s1)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种遍历方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = s1.<span class="built_in">cbegin</span>(); iter != s1.<span class="built_in">cend</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种遍历方式</span></span><br><span class="line">    <span class="keyword">auto</span> print = [](<span class="keyword">auto</span> s)&#123;cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;&#125;;</span><br><span class="line">    for_each(s1.<span class="built_in">cbegin</span>(), s1.<span class="built_in">cend</span>(), print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1.<span class="built_in">size</span>() = <span class="number">3</span></span><br><span class="line">cat dog house </span><br><span class="line">cat dog house </span><br><span class="line">cat dog house </span><br></pre></td></tr></table></figure>

<p>2、set的原地构造<br>在容器的指定位置直接构造元素，而不是先单独生成，再将其复制（或移动）到容器中。即构建一个临时对象直接使用，而不是将值复制过去再去构建一个对象<br>(1)set插入新元素一共有3个方法：insert、emplace、emplace_hint<br>(2)**一般来说，emplace比insert效率更高，详解参考(必读)**：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6834.html">http://c.biancheng.net/view/6834.html</a> </p>
<h3 id="移动构造和emplace-hint"><a href="#移动构造和emplace-hint" class="headerlink" title="移动构造和emplace_hint"></a>移动构造和emplace_hint</h3><p>1、移动构造函数<br>参考学习:<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7847.html">C++11移动构造函数详解</a><br>(1)移动构造函数特征：传参是一个右值引用的对象（对比copy构造函数）<br>(2)**右值引用的特征就是&amp;&amp;**，lvalue和rvalue相关的内容在之后的文章中会讲解<br><strong>(3)右值引用对应移动语义，对应移动构造函数；而左值引用对应复制语义，对应复制构造函数<br>(4)移动语义就是直接把右值的临时对象给左值，而不是复制右值给左值重新构造一份<br>(5)移动构造函数可以避免不必要的深拷贝，这在很多时候可以提升效率，当拷贝构造函数和移动构造函数同时存在时，insert() 会优先调用移动构造函数。</strong></p>
<p>2、emplace_hint<br>(1)emplace_hint使用得到会比emplace效率更高，主要原因是插入位置会影响内部自排队效率<br>因为set容器中的元素是经过排序的，你插入新的元素可能需要重新排序，而使用emplace_hint可以尽可能减少这个问题的影响。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nof_operations = <span class="number">100500</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_emplace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nof_operations; ++i) &#123;</span><br><span class="line">    set.<span class="built_in">emplace</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> set.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_emplace_hint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">  <span class="keyword">auto</span> it = set.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nof_operations; ++i) &#123;</span><br><span class="line">    set.<span class="built_in">emplace_hint</span>(it, i);</span><br><span class="line">    it = set.<span class="built_in">end</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> set.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_emplace_hint_wrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">  <span class="keyword">auto</span> it = set.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = nof_operations; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    set.<span class="built_in">emplace_hint</span>(it, i);</span><br><span class="line">    it = set.<span class="built_in">end</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> set.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_emplace_hint_corrected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">  <span class="keyword">auto</span> it = set.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = nof_operations; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    set.<span class="built_in">emplace_hint</span>(it, i);</span><br><span class="line">    it = set.<span class="built_in">begin</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> set.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_emplace_hint_closest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">  <span class="keyword">auto</span> it = set.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nof_operations; ++i) &#123;</span><br><span class="line">    it = set.<span class="built_in">emplace_hint</span>(it, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> set.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timeit</span><span class="params">(std::function&lt;<span class="keyword">int</span>()&gt; set_test, std::string what = <span class="string">&quot;&quot;</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">int</span> setsize = <span class="built_in">set_test</span>();</span><br><span class="line">  <span class="keyword">auto</span> stop = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">  std::chrono::duration&lt;<span class="keyword">double</span>, std::milli&gt; time = stop - start;</span><br><span class="line">  <span class="keyword">if</span> (what.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; setsize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">2</span>)</span><br><span class="line">              &lt;&lt; time.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;  ms for &quot;</span> &lt;&lt; what &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">timeit</span>(set_emplace); <span class="comment">// 栈加热</span></span><br><span class="line">   <span class="built_in">timeit</span>(set_emplace, <span class="string">&quot;plain emplace&quot;</span>);</span><br><span class="line">   <span class="built_in">timeit</span>(set_emplace_hint, <span class="string">&quot;emplace with correct hint&quot;</span>);</span><br><span class="line">   <span class="built_in">timeit</span>(set_emplace_hint_wrong, <span class="string">&quot;emplace with wrong hint&quot;</span>);</span><br><span class="line">   <span class="built_in">timeit</span>(set_emplace_hint_corrected, <span class="string">&quot;corrected emplace&quot;</span>);</span><br><span class="line">   <span class="built_in">timeit</span>(set_emplace_hint_closest, <span class="string">&quot;emplace using returned iterator&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可能的输出：</span><br><span class="line"><span class="number">18.96</span>  ms <span class="keyword">for</span> plain emplace</span><br><span class="line"><span class="number">7.95</span>  ms <span class="keyword">for</span> emplace with correct hint</span><br><span class="line"><span class="number">19.39</span>  ms <span class="keyword">for</span> emplace with wrong hint</span><br><span class="line"><span class="number">8.39</span>  ms <span class="keyword">for</span> corrected emplace</span><br><span class="line"><span class="number">7.90</span>  ms <span class="keyword">for</span> emplace <span class="keyword">using</span> returned iterator</span><br></pre></td></tr></table></figure>

<h3 id="set的其他方法"><a href="#set的其他方法" class="headerlink" title="set的其他方法"></a>set的其他方法</h3><p>参考学习：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/set">https://zh.cppreference.com/w/cpp/container/set</a><br>1、extract和merge</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::set&lt;<span class="keyword">int</span>&gt; cont&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> print = [](<span class="keyword">const</span> <span class="keyword">int</span>&amp; n) &#123; std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n; &#125;;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Start:&quot;</span>;</span><br><span class="line">    std::for_each(cont.<span class="built_in">begin</span>(), cont.<span class="built_in">end</span>(), print);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 释出结点柄并更改键</span></span><br><span class="line">    <span class="keyword">auto</span> nh = cont.<span class="built_in">extract</span>(<span class="number">1</span>);</span><br><span class="line">    nh.<span class="built_in">value</span>() = <span class="number">4</span>; </span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After extract and before insert:&quot;</span>;</span><br><span class="line">    std::for_each(cont.<span class="built_in">begin</span>(), cont.<span class="built_in">end</span>(), print);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 往回插入结点柄</span></span><br><span class="line">    cont.<span class="built_in">insert</span>(<span class="built_in">move</span>(nh));</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;End:&quot;</span>;</span><br><span class="line">    std::for_each(cont.<span class="built_in">begin</span>(), cont.<span class="built_in">end</span>(), print);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Start: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">After extract <span class="keyword">and</span> before insert: <span class="number">2</span> <span class="number">3</span></span><br><span class="line">End: <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 打印出容器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Os</span>, <span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line">Os&amp; <span class="keyword">operator</span>&lt;&lt;(Os&amp; os, <span class="keyword">const</span> std::set&lt;K&gt;&amp; v) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&#x27;[&#x27;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;] &#123;&quot;</span>;</span><br><span class="line">    <span class="keyword">bool</span> o&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : v)</span><br><span class="line">        os &lt;&lt; (o ? <span class="string">&quot;, &quot;</span> : (o = <span class="number">1</span>, <span class="string">&quot; &quot;</span>)) &lt;&lt; e;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">&quot; &#125;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::set&lt;<span class="keyword">char</span>&gt;</span><br><span class="line">        p&#123; <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;A&#x27;</span> &#125;, </span><br><span class="line">        q&#123; <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;C&#x27;</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p: &quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;q: &quot;</span> &lt;&lt; q;</span><br><span class="line"> </span><br><span class="line">    p.<span class="built_in">merge</span>(q);</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p.merge(q);\n&quot;</span> &lt;&lt; <span class="string">&quot;p: &quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;q: &quot;</span> &lt;&lt; q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">p: [<span class="number">3</span>] &#123; A, B, C &#125;</span><br><span class="line">q: [<span class="number">3</span>] &#123; C, D, E &#125;</span><br><span class="line">p.<span class="built_in">merge</span>(q);</span><br><span class="line">p: [<span class="number">5</span>] &#123; A, B, C, D, E &#125;</span><br><span class="line">q: [<span class="number">1</span>] &#123; C &#125;</span><br></pre></td></tr></table></figure>

<p>2、查找和观察器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(s1.<span class="built_in">key_comp</span>()).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(less&lt;<span class="keyword">int</span>&gt;).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有序关联容器map"><a href="#有序关联容器map" class="headerlink" title="有序关联容器map"></a>有序关联容器map</h3><p>1、map介绍<br>(1)<strong>map和set类似，但是map是(key, value)对，而set只有key（可以理解为key就是value）</strong><br>(2)map是映射的意思，此处是key到value的一对一映射。不要理解成地图（根据地图查位置）,一般用key去查value<br>(3)map的用法和特征与set非常类似，学会set了再学map就容易多了 </p>
<p>2、pair<br>(1)<strong>pair即对，也就是(key, value)对，本质是有2个元素的结构体</strong><br>(2)std::pair是STL的标准pair封装<br>(3)<strong>pair中2个元素类型可以不同，也就是说key和value的类型可以不同，也可以相同</strong><br>(4)<strong>pair中2个元素名字是固定的，key叫first，而value叫second</strong><br>(5)<strong>map中存的元素都是一个一个的pair，访问map的key和value要先从map找到pair，再去first和second</strong><br>参考学习：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/utility/pair">https://zh.cppreference.com/w/cpp/utility/pair</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7173.html">http://c.biancheng.net/view/7173.html</a></p>
<p>3、map的构造函数详解<br>(1)直接参考cppreference中构造函数页面的sample即可，链接如下：<br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/map/map">https://zh.cppreference.com/w/cpp/container/map/map</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Map&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_map</span><span class="params">(Map&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : m)</span><br><span class="line">        std::cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; p.second &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&#125;\n&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span><span class="keyword">double</span> x,y;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PointCmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Point&amp; lhs, <span class="keyword">const</span> Point&amp; rhs)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.x &lt; rhs.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//定义一个函数对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、默认构造函数</span></span><br><span class="line">    std::map&lt;std::string, <span class="keyword">int</span>&gt; map1;</span><br><span class="line">    map1[<span class="string">&quot;something&quot;</span>] = <span class="number">69</span>;<span class="comment">//向位图中添加元素</span></span><br><span class="line">    map1[<span class="string">&quot;anything&quot;</span>] = <span class="number">199</span>;</span><br><span class="line">    map1[<span class="string">&quot;everything&quot;</span>] = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;map1 = &quot;</span>;<span class="built_in">print_map</span>(map1); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、范围构造函数</span></span><br><span class="line">    <span class="function">std::map&lt;std::string, <span class="keyword">int</span>&gt; <span class="title">iter</span><span class="params">(map1.find(<span class="string">&quot;anything&quot;</span>),map1.end())</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\niter = &quot;</span>;<span class="built_in">print_map</span>(iter);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;map1 = &quot;</span>;<span class="built_in">print_map</span>(map1); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、复制（拷贝构造函数）</span></span><br><span class="line">    <span class="function">std::map&lt;std::string, <span class="keyword">int</span>&gt; <span class="title">copied</span><span class="params">(map1)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\ncopied = &quot;</span>;<span class="built_in">print_map</span>(copied);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;map1 = &quot;</span>;<span class="built_in">print_map</span>(map1); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、移动构造函数</span></span><br><span class="line">    <span class="function">std::map&lt;std::string, <span class="keyword">int</span>&gt; <span class="title">moved</span><span class="params">(std::move(map1))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nmoved = &quot;</span>;<span class="built_in">print_map</span>(moved);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;map1 = &quot;</span>;<span class="built_in">print_map</span>(map1); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、initializer_list 构造函数</span></span><br><span class="line">    std::map&lt;std::string, <span class="keyword">int</span>&gt; init&#123;</span><br><span class="line">        &#123;<span class="string">&quot;this&quot;</span>, <span class="number">100</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;can&quot;</span>, <span class="number">100</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;be&quot;</span>, <span class="number">100</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;const&quot;</span>, <span class="number">100</span>&#125;,        </span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\ninit = &quot;</span>;<span class="built_in">print_map</span>(init);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定制关键类选项 1 ：</span></span><br><span class="line">  <span class="comment">// 使用比较 struct</span></span><br><span class="line">  std::map&lt;Point, <span class="keyword">double</span>, PointCmp&gt; mag = &#123;</span><br><span class="line">      &#123; &#123;<span class="number">5</span>, <span class="number">-12</span>&#125;, <span class="number">13</span> &#125;,</span><br><span class="line">      &#123; &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,   <span class="number">5</span> &#125;,</span><br><span class="line">      &#123; &#123;<span class="number">-8</span>, <span class="number">-15</span>&#125;, <span class="number">17</span> &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> p : mag)</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;The magnitude of (&quot;</span> &lt;&lt; p.first.x</span><br><span class="line">                &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.first.y &lt;&lt; <span class="string">&quot;) is &quot;</span></span><br><span class="line">                &lt;&lt; p.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 定制关键类选项 2 ：</span></span><br><span class="line">    <span class="comment">// 使用比较 lambda</span></span><br><span class="line">    <span class="comment">// 此 lambda 按照其模比较点，注意其中模取自局部变量 mag</span></span><br><span class="line">    <span class="keyword">auto</span> cmpLambda = [&amp;mag](<span class="keyword">const</span> Point &amp;lhs, <span class="keyword">const</span> Point &amp;rhs) &#123; <span class="keyword">return</span> mag[lhs] &lt; mag[rhs]; &#125;;</span><br><span class="line">    <span class="comment">// 你亦可使用不依赖局部变量的 lambda ，像这样：</span></span><br><span class="line">    <span class="comment">// auto cmpLambda = [](const Point &amp;lhs, const Point &amp;rhs) &#123; return lhs.y &lt; rhs.y; &#125;;</span></span><br><span class="line">    <span class="function">std::map&lt;Point, <span class="keyword">double</span>, <span class="title">decltype</span><span class="params">(cmpLambda)</span>&gt;   <span class="title">magy</span><span class="params">(cmpLambda)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 各种插入元素的方式：</span></span><br><span class="line">    magy.<span class="built_in">insert</span>(std::pair&lt;Point, <span class="keyword">double</span>&gt;(&#123;<span class="number">5</span>, <span class="number">-12</span>&#125;, <span class="number">13</span>));</span><br><span class="line">    magy.<span class="built_in">insert</span>(&#123; &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, <span class="number">5</span>&#125;);</span><br><span class="line">    magy.<span class="built_in">insert</span>(&#123;Point&#123;<span class="number">-8.0</span>, <span class="number">-15.0</span>&#125;, <span class="number">17</span>&#125;);</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : magy)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The magnitude of (&quot;</span> &lt;&lt; p.first.x</span><br><span class="line">                &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.first.y &lt;&lt; <span class="string">&quot;) is &quot;</span></span><br><span class="line">                &lt;&lt; p.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、其他方法<br>(1)与set非常类似，详见：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/map">https://zh.cppreference.com/w/cpp/container/map</a><br>(2)<strong>extract是修改map的key值的唯一方法,map和set中的key是不可以重复的，但map的value可以重复，而由于set的key和value是一个东西，所以set的value也不可以重复。</strong><br>(3)map中的排序是根据key进行的，所以一般都不修改key，修改后需要再次排序 </p>
<h3 id="multi-set和multi-map"><a href="#multi-set和multi-map" class="headerlink" title="multi_set和multi_map"></a>multi_set和multi_map</h3><p>1、multi_版本的差异<br>(1)<strong>set和map中每个容器内所有元素的key都是unique(独一无二)的，不能重复</strong><br>(2)<strong>如果需要容器中同一个key有多个元素(也可理解为有多个相同的key)，则需要使用multi_版本的set和map</strong><br>(3)除此区别外，multi_版本和普通版本没有任何差异，所有方法也完全一样<br>(4)工作中用哪个，取决于实际需求。</p>
<p>2、multi_set实战演示<br>学习参考：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/multiset">https://zh.cppreference.com/w/cpp/container/multiset</a></p>
<p>3、multi_map实战演示<br>学习参考：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/multimap">https://zh.cppreference.com/w/cpp/container/multimap</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        multimap&lt;<span class="keyword">int</span>, string&gt; m1;</span><br><span class="line">        m1.<span class="built_in">insert</span>(&#123;<span class="number">0</span>, <span class="string">&quot;linux&quot;</span>&#125;);</span><br><span class="line">        m1.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, <span class="string">&quot;android&quot;</span>&#125;);</span><br><span class="line">        m1.<span class="built_in">insert</span>(&#123;<span class="number">2</span>, <span class="string">&quot;windows&quot;</span>&#125;);</span><br><span class="line">        m1.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, <span class="string">&quot;macos&quot;</span>&#125;);</span><br><span class="line">        m1.<span class="built_in">insert</span>(&#123;<span class="number">2</span>, <span class="string">&quot;harmonyos&quot;</span>&#125;);</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;size = &quot;</span> &lt;&lt; m1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> val : m1)</span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;&#123;&quot;</span> &lt;&lt; val.first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;&#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        multiset&lt;string&gt; s1;</span></span><br><span class="line"><span class="comment">        s1.insert(&quot;horse&quot;);                // 按照key去排序</span></span><br><span class="line"><span class="comment">        s1.insert(&quot;cat&quot;);</span></span><br><span class="line"><span class="comment">        s1.insert(&quot;cat&quot;);</span></span><br><span class="line"><span class="comment">        s1.insert(&quot;cat&quot;);</span></span><br><span class="line"><span class="comment">        s1.insert(&quot;dog&quot;);</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;size = &quot; &lt;&lt; s1.size() &lt;&lt; boolalpha &lt;&lt; &quot;, empty = &quot; &lt;&lt; s1.empty() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        for (auto val : s1)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h3><p>1、无序关联容器和有序关联容器的相同点<br>(1)也属于关联容器，<strong>有set和map两种，set只有key，map有(key, value)对</strong><br>(2)<strong>也有带不带multi_的版本</strong>，差异和上节讲的一样<br>(3)<strong>操作方法很多都是重合的，名字和作用也都一样</strong></p>
<p>2、无序关联容器和有序关联容器的差异点<br>(1)<strong>有序内部用红黑树实现，无序内部用哈希函数实现</strong><br>(2)<strong>有序插入元素时会内部自动排序，无序插入时不排序，按照哈希规则直接映射存放</strong></p>
<p>3、无序关联容器初步使用<br>(1)unordered_set和unordered_map<br>参考学习：<br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/unordered_set">https://zh.cppreference.com/w/cpp/container/unordered_set</a><br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/unordered_map">https://zh.cppreference.com/w/cpp/container/unordered_map</a></p>
<h3 id="哈希函数和桶"><a href="#哈希函数和桶" class="headerlink" title="哈希函数和桶"></a>哈希函数和桶</h3><p>1、什么是哈希函数(一类函数)<br>(1)哈希表是一种典型数据结构，又被称为是散列表，英文hashmap<br>(2)STL中的哈希表hashmap就是unordered_map<br>(3)哈希函数是可以用来实现哈希表的函数，是一类而不是一个<br>(4)哈希表的本质是k-v结构，也就是给定key可以找到一个位置来对应value</p>
<p>2、哈希冲突及其解决<br>参考学习：<a target="_blank" rel="noopener" href="https://blog.csdn.net/WX_East/article/details/56005664?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control">unorder_map的底层实现方法</a></p>
<h3 id="unordered-map中桶相关的方法"><a href="#unordered-map中桶相关的方法" class="headerlink" title="unordered_map中桶相关的方法"></a>unordered_map中桶相关的方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, string&gt; m1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                m1.<span class="built_in">insert</span>(&#123;i, <span class="string">&quot;abc&quot;</span>&#125;);</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;&#123;&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="string">&quot;abc&quot;</span> &lt;&lt; <span class="string">&quot;&#125;,     &quot;</span>;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;element size = &quot;</span> &lt;&lt; m1.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;, bucket size = &quot;</span> &lt;&lt; m1.<span class="built_in">bucket_count</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">空白</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">288k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:22</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"shenweikun/helloworld","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
