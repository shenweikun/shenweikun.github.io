<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shenweikun.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="曾经跟随过朱老师系统地学习过C&#x2F;C++编程语言，然而一直没有机会对所学内容进行有效的整理。近来，有了较多的空闲时间，于是决定利用这段时间将以往的笔记进行回顾并整理。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++从入门到进阶之一-从C到C++">
<meta property="og:url" content="https://shenweikun.github.io/2024/10/30/2024-10-30-CPP-Basics-C-to-Cpp/index.html">
<meta property="og:site_name" content="Weikun&#39;s Notes">
<meta property="og:description" content="曾经跟随过朱老师系统地学习过C&#x2F;C++编程语言，然而一直没有机会对所学内容进行有效的整理。近来，有了较多的空闲时间，于是决定利用这段时间将以往的笔记进行回顾并整理。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-29T17:07:50.000Z">
<meta property="article:modified_time" content="2024-11-20T17:52:06.642Z">
<meta property="article:author" content="空白">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://shenweikun.github.io/2024/10/30/2024-10-30-CPP-Basics-C-to-Cpp/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://shenweikun.github.io/2024/10/30/2024-10-30-CPP-Basics-C-to-Cpp/","path":"2024/10/30/2024-10-30-CPP-Basics-C-to-Cpp/","title":"C++从入门到进阶之一-从C到C++"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++从入门到进阶之一-从C到C++ | Weikun's Notes</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Weikun's Notes</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">怀揣代码中的唏嘘，记录生活中的点滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">C++基本编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E4%B8%BA%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">1.1.</span> <span class="nav-text">何为命名空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-number">1.1.1.</span> <span class="nav-text">命名空间的引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%90%8D%E7%A7%B0%E5%86%B2%E7%AA%81"><span class="nav-number">1.1.2.</span> <span class="nav-text">C语言如何解决名称冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.3.</span> <span class="nav-text">命名空间如何解决问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9A%84%E6%80%9D%E8%80%83"><span class="nav-number">1.1.4.</span> <span class="nav-text">关于语言特性的思考</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9D%E7%BA%A7%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.</span> <span class="nav-text">命名空间的初级定义和使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E9%BB%98%E8%AE%A4%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">1.3.</span> <span class="nav-text">C++默认命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E5%8C%BF%E5%90%8D%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%88%E6%B2%A1%E6%9C%89%E5%90%8D%E5%AD%97%E7%9A%84namespace%EF%BC%89"><span class="nav-number">1.4.</span> <span class="nav-text">C++匿名命名空间（没有名字的namespace）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">1.5.</span> <span class="nav-text">嵌套命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C%E4%B8%8EC-%E7%9A%84%E5%85%B3%E7%B3%BB%E5%8F%8AC-%E6%A0%87%E5%87%86%E5%BA%93%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.6.</span> <span class="nav-text">C与C++的关系及C++标准库介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iostream%E7%9A%84cout-cin%E4%BD%BF%E7%94%A8"><span class="nav-number">1.7.</span> <span class="nav-text">iostream的cout&#x2F;cin使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E7%94%A8fstream%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">1.8.</span> <span class="nav-text">C++用fstream读写文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E5%AD%97%E7%AC%A6%E4%B8%B2string%E7%B1%BB%E4%BD%BF%E7%94%A8"><span class="nav-number">1.9.</span> <span class="nav-text">C++字符串string类使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C%E4%B8%8EC-%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B"><span class="nav-number">1.10.</span> <span class="nav-text">C与C++混合编程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E6%96%B0%E5%A2%9E%E5%92%8C%E6%9C%89%E5%8F%98%E5%8C%96%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.</span> <span class="nav-text">C++新增和有变化的关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bool%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.1.</span> <span class="nav-text">bool关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E7%9A%84%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8Bchar"><span class="nav-number">2.2.</span> <span class="nav-text">C++的字符类型char</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E6%97%A0%E5%8F%98%E5%8C%96%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BB%A3%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.3.</span> <span class="nav-text">C++中无变化关键字和运算符代用关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E6%96%B0%E5%A2%9E%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%88reference%EF%BC%89%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.4.</span> <span class="nav-text">C++新增的引用（reference）介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%89%96%E6%9E%90"><span class="nav-number">2.5.</span> <span class="nav-text">引用的本质剖析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E7%9A%84enum%E6%9E%9A%E4%B8%BE"><span class="nav-number">2.6.</span> <span class="nav-text">C++的enum枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E7%9A%84%E5%85%B1%E7%94%A8%E4%BD%93union"><span class="nav-number">2.7.</span> <span class="nav-text">C++的共用体union</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inline%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.8.</span> <span class="nav-text">inline关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-11%E5%BC%95%E5%85%A5%E7%9A%84nullptr"><span class="nav-number">2.9.</span> <span class="nav-text">C++11引入的nullptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80"><span class="nav-number">2.10.</span> <span class="nav-text">使用静态断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="nav-number">2.11.</span> <span class="nav-text">C++内存对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#alignas%E5%92%8Ctypeid"><span class="nav-number">2.12.</span> <span class="nav-text">alignas和typeid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E7%9A%844%E7%A7%8Dcast%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.13.</span> <span class="nav-text">C++的4种cast转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="nav-number">2.14.</span> <span class="nav-text">C++的自动类型推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.15.</span> <span class="nav-text">C++类与面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%ADstatic%E5%92%8Cthis%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.16.</span> <span class="nav-text">C++中static和this关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B6%E4%BB%96%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.17.</span> <span class="nav-text">C++面向对象的其他关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E7%9A%84const%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8Aconst%E6%9C%89%E5%85%B3%E7%9A%84%E5%85%B6%E4%BB%96%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.18.</span> <span class="nav-text">C++的const关键字以及const有关的其他几个关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.19.</span> <span class="nav-text">模板编程的几个关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">2.20.</span> <span class="nav-text">C++的异常处理机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">C++的内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%A0%94%E7%A9%B6%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">3.1.</span> <span class="nav-text">为什么要研究内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E5%8F%AF%E7%94%A8%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="nav-number">3.2.</span> <span class="nav-text">C++可用内存区域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.</span> <span class="nav-text">new和malloc的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-number">3.4.</span> <span class="nav-text">智能指针的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">3.5.</span> <span class="nav-text">Java的垃圾回收机制</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">空白</p>
  <div class="site-description" itemprop="description">记录生活与职业中的点滴</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shenweikun.github.io/2024/10/30/2024-10-30-CPP-Basics-C-to-Cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="空白">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weikun's Notes">
      <meta itemprop="description" content="记录生活与职业中的点滴">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++从入门到进阶之一-从C到C++ | Weikun's Notes">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++从入门到进阶之一-从C到C++
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-30 01:07:50" itemprop="dateCreated datePublished" datetime="2024-10-30T01:07:50+08:00">2024-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-21 01:52:06" itemprop="dateModified" datetime="2024-11-21T01:52:06+08:00">2024-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/4-C-C/" itemprop="url" rel="index"><span itemprop="name">4. C/C++</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>37k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>33 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>曾经跟随过朱老师系统地学习过C/C++编程语言，然而一直没有机会对所学内容进行有效的整理。近来，有了较多的空闲时间，于是决定利用这段时间将以往的笔记进行回顾并整理。</p>
<span id="more"></span>
<h2 id="C-基本编程"><a href="#C-基本编程" class="headerlink" title="C++基本编程"></a>C++基本编程</h2><h3 id="何为命名空间"><a href="#何为命名空间" class="headerlink" title="何为命名空间"></a>何为命名空间</h3><h4 id="命名空间的引入"><a href="#命名空间的引入" class="headerlink" title="命名空间的引入"></a>命名空间的引入</h4><ol>
<li><strong>命名空间namespace，是C++引入解决全局变量和函数名（其是全局的）冲突的机制。</strong></li>
<li>C语言中没有namespace，但C++及之后的Java Python等都有。</li>
<li>namespace的关键点有2个：<br>第一、是如何解决名称冲突<br>第二、是如何合法访问变量</li>
</ol>
<h4 id="C语言如何解决名称冲突"><a href="#C语言如何解决名称冲突" class="headerlink" title="C语言如何解决名称冲突"></a>C语言如何解决名称冲突</h4><ol>
<li>大项目中会有很多C文件，全局变量和函数都是extern链接属性，因此名称冲突是客观存在的</li>
<li>一个项目是一个单体程序，项目中的全局变量和函数理应能够相互范围，因此名称冲突是客观存在的</li>
<li>C语言解决名称冲突的办法是：<br>第一、同一个C文件不要太大，由一个人写<br>第二、每个C文件（或几个C文件构成的一个模块）中所有的全局变量和函数前加统一的唯一前缀；<br>第三、不需要文件外访问的全局变量进而函数前面都加static</li>
<li>C语言的解决方案可行，在Linux内核中就是大量使用这种解决方案，C++早期就是这样做的，但是这种方式不够优雅。</li>
</ol>
<h4 id="命名空间如何解决问题"><a href="#命名空间如何解决问题" class="headerlink" title="命名空间如何解决问题"></a>命名空间如何解决问题</h4><ol>
<li>为实现命名空间机制，C++引入namespace关键字，定义格式为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> XX&#123; &#125;；</span><br></pre></td></tr></table></figure></li>
<li>一个特定名称的namespace的一对大括号内部定义的变量、函数、类等均属于该命名空间内</li>
<li>在命名空间内部相互引用时可以直接使用变量名、函数名等</li>
<li>跨命名空间相互引用时，必须同时指定被引用方的命名空间名和变量名函数名才可以找到</li>
<li>命名空间看起来就好像是一种前缀</li>
<li><strong>命名空间本质上其实是对全局变量和函数在一定范围内链接属性的更改和控制（在命名空间之内是extern，在命名空间之外是static的）</strong></li>
</ol>
<h4 id="关于语言特性的思考"><a href="#关于语言特性的思考" class="headerlink" title="关于语言特性的思考"></a>关于语言特性的思考</h4><ol>
<li><strong>语言特性是语言通过关键字或符号所支持第一种功能特性，如namespace、template、运算符重载、面向对象等</strong>。</li>
<li>语言特性必定对应解决某种问题，必定在某方面对程序员有帮助</li>
<li>语言特性越多或者设计越复杂，则语言本身就越难使用，但语言就越厉害</li>
<li>语言特性体现为某种语法，本质上靠编译工具链提供支持</li>
<li>C++11/14/17/20的版本变迁，无非就是新增或修正某些细节语言特性</li>
<li>就事论事讨论编程语言，其实难点都在掌握和熟练运用语言特性上</li>
</ol>
<h3 id="命名空间的初级定义和使用"><a href="#命名空间的初级定义和使用" class="headerlink" title="命名空间的初级定义和使用"></a>命名空间的初级定义和使用</h3><ol>
<li>同一文件内定义namespace</li>
</ol>
<p>正常情况，一个文件使用一个namespace，或者几个文件共同使用一个namespace</p>
<ol start="2">
<li>同一文件内使用namespace</li>
</ol>
<p><strong>:: (作用域解析符)</strong></p>
<p><strong>using关键字：最常用的作用就是导入命名空间</strong></p>
<ul>
<li><p>namespace的三种引用方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方式一</span><br><span class="line"></span><br><span class="line">ace::Mutex mutex; <span class="comment">//成本最低，用到那个，就去现场引用那个，没有额外的负担对编译器</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">方式二</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ace::Mutex; <span class="comment">//一次性只声明了指定命名空间里面的一个变量或函数，成本较低</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> NS1::func1 <span class="comment">//告诉编译器如果在默认的命名空间找不到func1可以到NS1中去找一下</span></span><br><span class="line"></span><br><span class="line">Mutex mutex;      <span class="comment">// 定义一个变量</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方式三</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ace; <span class="comment">//一次性声明指定命名空间里面的所有变量函数等，成本更高，但更方便</span></span><br><span class="line"></span><br><span class="line">Mutex mutex;</span><br></pre></td></tr></table></figure>

<p>  using这里有点像include关键字，就是把整个文件拿过来在这里原地展开，假设include的包含的那个文件有700行，include这行代码就相当于把那700行的代码全部搂过来了，这种做法还是有一定开销的，对编译器的压力就比较大。</p>
<p>  第二种只using进来一个符号，第三种把命名空间的所有符号全部都using进来了。</p>
<p>  从成本的角度来说，第一种到第二种到第三种的成本是依次递升，但是方便性是越来越好的。</p>
<p>  实际开发当中第一种和第三种用的比较多，第二种用的比较少。</p>
</li>
<li><p>不同文件间定义和使用namespace</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> NS2&#123;<span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">void</span>)</span></span>;&#125;; <span class="comment">//你有东西在另一个文件中，你要使用可以，但是你得先声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> NS2&#123;<span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">void</span>)</span></span>;&#125;; <span class="comment">//namespace这种思想与要使用跨文件使用变量或函数是类似的，声明的时候不可以有实体，有实体就变成定义了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> NS2; <span class="comment">//命名空间引用，using是消费型的，因此需要前面先声明NS2，实际开发中，前面的声明一般加在对应的头文件中</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="C-默认命名空间"><a href="#C-默认命名空间" class="headerlink" title="C++默认命名空间"></a>C++默认命名空间</h3><p>在C++语言，所有的代码都应处于某个命名空间中，在同一个namespace中直接引用（类似于C语言中的一个文件内的函数引用），在不同的namespace中，通过上面的方法进行引用（同一个文件）、跨文件引用。</p>
<p><strong>所有没有明确指定放在哪一个namespace中，都是在默认的namespace。</strong></p>
<p>(1)默认命名空间又叫全局命名空间</p>
<p>(2)默认命名空间引用其他命名空间方法（上节最后的内容：using namespace NS2; ）</p>
<p>(3)默认命名空间引用自己的方法</p>
<p>(4)其他命名空间引用默认命名空间中的方法::f();</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数的声明要放在引用它的命名空间之前，因为编译只会往前回顾，不会往后看的。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func5</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">   </span><br><span class="line"><span class="keyword">namespace</span> NS1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ::<span class="built_in">func5</span>();        </span><br><span class="line">       <span class="comment">/* 表示func5定义和声明在默认命名空间，因为命名空间的名字是空的，所以冒号的前面是空的，也可以省略双冒号，最好加上，不加的话给人的感觉func5()是NS1里面定义的函数*/</span></span><br><span class="line">       <span class="comment">//func1();   //如果是特定的命名空间内部访问自己的东西，前面什么都不用加</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在一个命名空间中调用不加前缀的函数（来自其他namespace，但未声明），默认会在自己的这个命名空间中进行寻找。</p>
<h3 id="C-匿名命名空间（没有名字的namespace）"><a href="#C-匿名命名空间（没有名字的namespace）" class="headerlink" title="C++匿名命名空间（没有名字的namespace）"></a>C++匿名命名空间（没有名字的namespace）</h3><ol>
<li>匿名命名空间的定义和使用</li>
</ol>
<ul>
<li><p>定义匿名命名空间和全局命名空间有些类似，他们都没有名字，但是全局命名空间不需要自己定义，而<strong>匿名命名空间需要自己去定义</strong>，方法就是namespace后面没有空间名，直接就是 {}</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;“来自匿名命名空间的<span class="built_in">func</span>().”&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>匿名命名空间中引用其他命名空间中的方法（与上小节讲的方法一样）</p>
</li>
<li><p>匿名命名空间中引用自己命名空间中的方法(确保先定义后使用)直接用，无需添加命名空间名前缀，只要确保先声明后使用的顺序就没有问题。</p>
</li>
<li><p>其他命名空间中引用匿名命名空间中的方法</p>
<p>  <strong>一般匿名命名空间定义于文件前面，类似于全局函数位置，之后的命名空间可以正常访问匿名命名空间中的内容</strong>，但是匿名命名空间的作用不在于此，而是在于跨文件访问的时候。因此其实对于单个文件内部，使用匿名命名空间与全局函数并无多大差别。</p>
</li>
</ul>
<ol start="2">
<li>匿名命名空间的价值</li>
</ol>
<ul>
<li>匿名命名空间中的符号纯（只在）文件内部使用，不需要被外部引用</li>
<li><strong>匿名命名空间效果类似于全局变量和函数加static</strong>，但是比C中的static使用范围广，C中static只能使用到函数和全局变量上，无法用到结构体以及枚举类型等等，但匿名的namespace可以。</li>
<li><strong>在文件内部没有什么作用好像没有一样</strong>的，其内的东西是全局的，但改变了文件的外部链接属性。</li>
<li>匿名命名空间的用法逻辑上符合整个命名空间的一贯原则</li>
</ul>
<h3 id="嵌套命名空间"><a href="#嵌套命名空间" class="headerlink" title="嵌套命名空间"></a>嵌套命名空间</h3><p>嵌套namespace的定义和使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> NS1</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">namespace</span> NS2</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;NS1::NS2::func1.&quot;</span> &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;NS1::func1.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;NS1::func2&quot;</span> &lt;&lt; endl;</span><br><span class="line">                NS2::<span class="built_in">func1</span>();</span><br><span class="line">                <span class="built_in">func1</span>();</span><br><span class="line">        &#125;</span><br><span class="line">                        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> NS1::NS2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        NS1::NS2::<span class="built_in">func1</span>();</span><br><span class="line">        <span class="built_in">func1</span>();</span><br><span class="line">        NS1::<span class="built_in">func2</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="C与C-的关系及C-标准库介绍"><a href="#C与C-的关系及C-标准库介绍" class="headerlink" title="C与C++的关系及C++标准库介绍"></a>C与C++的关系及C++标准库介绍</h3><ol>
<li>C++是C的超集</li>
</ol>
<ul>
<li><p>一个典型C程序（后缀名.c）可以完全被视为C++程序来编译，可使用g++来编译；</p>
</li>
<li><p>C程序可以通过__cplusplus符号是否预定义来判断当前是gcc还是g++编译 ，C++编译器中才有__cplusplus。</p>
<p>  __cplusplus的值是long int类型的，值表示当前编译程序的C++编译器的版本号。</p>
</li>
<li><p>一个典型C++程序（后缀名.cpp）只能当C++程序来编译，可见C++是C的超集</p>
</li>
<li><p>C++文件名的常用后缀：源文件（.cpp .cxx .cc .c .c++），头文件（.hpp .hxx .h）</p>
</li>
</ul>
<p>printf其实是属于std命名空间的，之所以未导入命名空间就可以用，是因为C++为了兼容C语言，但并不建议这么用，建议这样包含再使用该语句</p>
<ol start="2">
<li>C++完全接收并兼容了C库</li>
</ol>
<ul>
<li>典型C++程序中可以支持C的形式包含C库头文件，并直接使用C库API</li>
<li>C++更建议的头文件包含形式不是&lt;stdio.h&gt;这样，而是<iostream>（内部还是包含了：#include &lt;stdio.h&gt;）这样</li>
</ul>
<p><code>      </code>要点：C++的标准库的头文件是没有后缀名的</p>
<ul>
<li>ubuntu中gcc工具链的头文件在/usr/include中，可以实际看看</li>
</ul>
<ol start="3">
<li>C++标准库介绍</li>
</ol>
<ul>
<li>C标准库即为C++标准库的一部分，完全继承并以C++方式重写，位于std命名空间中</li>
<li>C++面向对象库，如string、iostream等，位于std命名空间中</li>
<li>C++ STL标准模板库，如vector、map等，位于std命名空间中</li>
</ul>
<ol start="4">
<li>C++标准库的地位和学习</li>
</ol>
<ul>
<li>C++比C在实际工作中更依赖于库，所以学好C++标准库很重要</li>
<li>C++标准库蕴含了C++的各种语言特性的典型用法，学标准库就顺便学好了C++</li>
<li>继承C标准库的部分兼容C的玩法</li>
<li>C++面向对象库难度不大，本次先讲iostream和string等初步用法</li>
<li>STL部分是重难点</li>
</ul>
<p><strong>summary</strong>：越高级的语言库占得比例越多，语言占得越少，比如python，学好其要学好它的库，学标准库就是在学C++；</p>
<h3 id="iostream的cout-cin使用"><a href="#iostream的cout-cin使用" class="headerlink" title="iostream的cout/cin使用"></a>iostream的cout/cin使用</h3><ol>
<li><p>基本使用</p>
<p> &lt;&lt; 流操作符，做输出， &gt;&gt; 做输入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please input an int number:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The int number is x= &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please input a float number:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; y;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;The float number is y= &quot;</span> &lt;&lt; y &lt;&lt;endl;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果如下（↙表示按下回车键）：</span><br><span class="line">Please input an <span class="keyword">int</span> number:</span><br><span class="line"><span class="number">8</span>↙</span><br><span class="line">The <span class="keyword">int</span> number is x= <span class="number">8</span></span><br><span class="line">Please input a <span class="keyword">float</span> number:</span><br><span class="line"><span class="number">7.4</span>↙</span><br><span class="line">The <span class="keyword">float</span> number is y= <span class="number">7.4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>流操作符&lt;&lt;本质上是<strong>左移运算符在iostream中的运算符重载</strong></p>
</li>
</ol>
<h3 id="C-用fstream读写文件"><a href="#C-用fstream读写文件" class="headerlink" title="C++用fstream读写文件"></a>C++用fstream读写文件</h3><ol>
<li>fstream介绍</li>
</ol>
<ul>
<li>fstream是C++标准库中面向对象库的一个，用于操作流式文件</li>
<li>fstream本质上是一个class，提供file操作的一众方法</li>
</ul>
<p>详解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xuleisdjn/article/details/79040688">https://blog.csdn.net/xuleisdjn/article/details/79040688</a></p>
<ol start="2">
<li>C++标准库查询参考</li>
</ol>
<p>man手册：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012675539/article/details/50257343">https://blog.csdn.net/u012675539/article/details/50257343</a></p>
<p>C++ 参考手册1:<a target="_blank" rel="noopener" href="http://www.cplusplus.com/reference/">http://www.cplusplus.com/reference/</a></p>
<p>C++ 参考手册2: <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5</a></p>
<ol start="3">
<li>fstream使用举例</li>
</ol>
<ul>
<li>打开/创建文件，并写入内容，保存关闭</li>
<li>打开文件，并读取内容显示，最后关闭。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        fstream fs;                <span class="comment">// 定义了一个fs对象用来做后续操作</span></span><br><span class="line">        <span class="keyword">char</span> str[] = <span class="string">&quot;i love c++&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span> rstr[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        fs.<span class="built_in">open</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fs.<span class="built_in">is_open</span>())</span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;open success&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;open fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文件写入</span></span><br><span class="line">        fs.<span class="built_in">write</span>(str, <span class="built_in"><span class="keyword">sizeof</span></span>(str));</span><br><span class="line">        fs &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文件读出</span></span><br><span class="line">        fs.<span class="built_in">read</span>(rstr, <span class="built_in"><span class="keyword">sizeof</span></span>(rstr));</span><br><span class="line">        fs &gt;&gt; rstr;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;read content: &quot;</span> &lt;&lt; rstr &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文件关闭</span></span><br><span class="line">        fs.<span class="built_in">close</span>();</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="C-字符串string类使用"><a href="#C-字符串string类使用" class="headerlink" title="C++字符串string类使用"></a>C++字符串string类使用</h3><ol>
<li><p>C++式字符串的使用</p>
<p> <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">参考手册文档</a></p>
</li>
<li><p>C++字符串和C字符串的对比</p>
</li>
</ol>
<ul>
<li>C语言严格说没有字符串的概念，C字符串其实就是字符数组或字符指针</li>
<li>C++和之后的java等都有字符串，本质是一个class</li>
<li>C++字符串的优势是标准库自带可用于字符串的各种处理算法和方法</li>
<li>C++实际开发中建议使用C++字符串而不是沿用C式字符串</li>
</ul>
<h3 id="C与C-混合编程"><a href="#C与C-混合编程" class="headerlink" title="C与C++混合编程"></a>C与C++混合编程</h3><p>1、为什么需要混合编程</p>
<p>(1)C有很多优秀成熟项目和库，丢了可惜，重写没必要，C++程序里要调用<br>(2)庞大项目划分后一部分适合用C，一部分适合用C++<br>(3)其他情况，如项目组一部分人习惯用C，一部分习惯用C++</p>
<p>2、为什么不同语言可以混合编程</p>
<p>(1)程序编译过程：源文件-&gt;目标（库）文件-&gt;可执行程序-&gt;镜像文件<br>(2)任何编程语言执行时都必须是可执行程序，所以都必须先被编译成目标文件<br>(3)混合编程的“混合”操作发生在链接这一步</p>
<p>3、C++和C混合编程的困难所在<br>(1)C++和C都是编译型语言，互相混合相对容易<br>(2)难点：C++支持函数名重载，而C不支持，因此编译器生成目标文件时，函数名在目标文件中的临时内部名称规则不同。导致链接时符号对不上 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">C语言函数：</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_char</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">编译后生成的中间名字：</span><br><span class="line">add_int</span><br><span class="line">add_char</span><br><span class="line"></span><br><span class="line">C++函数名重载机制：</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> , b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span>, b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, flaot b)</span></span>;</span><br><span class="line"></span><br><span class="line">编译后生成的中间名字：</span><br><span class="line">addii</span><br><span class="line">addcc</span><br><span class="line">addif </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(3)解决方案：使用extern “C”{}; 让C++在对接的局部向C妥协兼容</p>
<p>4、C与C++混合编程的可能情况分析<br>(1)同一个项目C/C++全部有源码，一次编译链接。<br>(2)同一个项目中C是库，C++是源码，C++调用C<br>(3)同一个项目中C++是库，C是源码，C调用C++</p>
<p>5、第一种情况<br>(1)可能性1：全部使用g++编译。不推荐<br>(2)可能性2：在C的头文件中加extern “C”声明</p>
<p>6、第二种情况<br>(1)这种是最典型的常见情况<br>(2)通用解决方案：在C的头文件中加extern “C”声明，在C++中直接包含头文件调用即可</p>
<p>7、C调用C++的麻烦<br>(1)g++和gcc的编译时符号差异<br>(2)c++支持很多c并不支持的特性，如函数重载<br>(3)解决方案：添加一层封装层，因为此时已形成 c++的库，已按照C++的标准编译了，所以无法修改源码添加extern “C”{},所以增加一个封装层，在封装层是上使用extern “C”,封装层使用C++</p>
<h2 id="C-新增和有变化的关键字"><a href="#C-新增和有变化的关键字" class="headerlink" title="C++新增和有变化的关键字"></a>C++新增和有变化的关键字</h2><h3 id="bool关键字"><a href="#bool关键字" class="headerlink" title="bool关键字"></a>bool关键字</h3><p>1、关键字学习<br>(1)研究编程语言从关键字出发不适合学习，但是适合查漏补缺<br>(2)C++全部关键字列表查阅<br>(3)C++关键字相对C有几种情况：新增关键字、新增语义、语义变化、完全无变化<br>(4)限于面向对象和STL没学，因此本篇文章不追求全面讲解关键字，重点是从一些核心关键字出发学习C++语法特性，体会C++与C的不同，熟悉C++。</p>
<p>2、C++的bool关键字<br>(1)bool类型也叫逻辑类型，是个2值enum，值为true或false（这2个也是C++关键字）<br>(2)C语言没有bool关键字，不源生支持bool类型，一般用typedef int bool;这样来自定义<br>(3)C++语言源生支持bool类型，一般占1字节（与平台相关），用法没什么差异<br>(4)bool内建和自定义至少有一个差别：函数重载机制认为bool是不同类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">bool</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">bool</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">C中，<span class="keyword">bool</span>和<span class="keyword">int</span>是一个类型，在C++中不是</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">在C++中，虽然布尔类型只表示<span class="literal">true</span>和<span class="literal">false</span>，看起来好像可以用一个位来存储布尔类型的变量，但其实，布尔类型在C++中是占用一个字节的。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> b </span>= <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>,b);</span><br><span class="line">b++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>,b);</span><br><span class="line">b = b - <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>,b);</span><br><span class="line"></span><br><span class="line">用C++编译器编译运行后得到的是：</span><br><span class="line">b = <span class="number">0</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">从上面我们也可以看到，布尔类型作为C++中的一种基础类型，是完全可以对布尔类型进行运算的，只不过最后遵循非<span class="number">0</span>值为真，<span class="number">0</span>值为假这条规则。</span><br></pre></td></tr></table></figure>
<p><strong>summary：</strong><br>在C语言中，没有bool这种类型，但是在C++中，把bool当做一种基本的数据类型，既然是数据类型，那么久可以对bool类型的变量进行运算，只不过最后遵循非0值为真，0值为假这条规则。同时，bool类型作为一种基本的数据类型，也可以用来定义常量，全局变量，指针还有数组.</p>
<h3 id="C-的字符类型char"><a href="#C-的字符类型char" class="headerlink" title="C++的字符类型char"></a>C++的字符类型char</h3><p>1、char<br>(1)字符类型，一般占1字节，表示字符（ASCI或unicode字符）<br>(2)从C++14开始char默认是unsigned还是signed取决于目标平台，如arm默认unsigned，而X64默认是signed，建议如果在意符号最好显式使用unsigned char或signed char<br>(3)char类型cout输出默认为字符，而int类型cout输出默认为数字<br>(4)1 == sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)<br>=还是&lt;取决于具体的平台</p>
<p>2、wchar_t<br>(1)宽字符，用于应对一个字符编码超过1字节的Unicode编码<br>(2)wchar_t和char的数组都能存下unicode码，区别是需要几个单元才能存一个字符<br>(3)wchar_t占几个字节取决于具体实现（一般不会是一个字节），可能是unsigned short也可能是int<br>(4)wchar_t要用wcin和wcout来输入输出，对应字符串为wstring</p>
<p>3、指定具体字节数的字符类型<br>(1)char8_t (C++20 起) char16_t (C++11 起) char32_t (C++11 起)<br>(2)这三个类型一个套路，最大特征就是明确指定占用字节数，且都是无符号的<br>(3)char8_t很大程度上等同于unsigned char<br>(4)关于char8_t可以参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/57402464/is-c20-char8-t-the-same-as-our-old-char">https://stackoverflow.com/questions/57402464/is-c20-char8-t-the-same-as-our-old-char</a><br>(5)C++20起，新增字符串类u8string, u16string, u32string</p>
<h3 id="C-中无变化关键字和运算符代用关键字"><a href="#C-中无变化关键字和运算符代用关键字" class="headerlink" title="C++中无变化关键字和运算符代用关键字"></a>C++中无变化关键字和运算符代用关键字</h3><p>1、C++中无明显变化的关键字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">while</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">switch</span></span><br><span class="line"><span class="keyword">case</span></span><br><span class="line"><span class="keyword">default</span></span><br><span class="line"><span class="keyword">goto</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">unsigned</span></span><br><span class="line"><span class="keyword">signed</span></span><br><span class="line"><span class="keyword">float</span></span><br><span class="line"><span class="keyword">double</span></span><br><span class="line"><span class="keyword">short</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="keyword">long</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="keyword">sizeof</span></span><br><span class="line"><span class="keyword">register</span></span><br><span class="line"><span class="keyword">volatile</span>  <span class="comment">//volatile是一个类型修饰符（type specifier），就像我们熟悉的const一样，它是被设计用来修饰被不同线程访问和修改的变量；volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。</span></span><br><span class="line"><span class="keyword">extern</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="keyword">asm</span>（内嵌汇编）</span><br></pre></td></tr></table></figure>

<p>2、C++中新增的运算符代用关键字<br>(1)逻辑运算代用关键字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span>                        &amp;&amp;</span><br><span class="line"><span class="keyword">or</span>                        ||                </span><br><span class="line"><span class="keyword">not</span>                        !（逻辑取反）</span><br></pre></td></tr></table></figure>
<p>(2)位运算代用关键字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bitand</span>                &amp;</span><br><span class="line"><span class="keyword">bitor</span>                |</span><br><span class="line"><span class="keyword">xor</span>                        ^</span><br><span class="line"><span class="keyword">and_eq</span>                &amp;=</span><br><span class="line"><span class="keyword">or_eq</span>                |=</span><br><span class="line"><span class="keyword">xor_eq</span>                ^=</span><br><span class="line"><span class="keyword">compl</span>                ~（按位取反）</span><br></pre></td></tr></table></figure>
<p>(3)不等判断运算符代用关键字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">not_eq</span>                !=</span><br></pre></td></tr></table></figure>
<p>(4)运算符代用关键字的优势：有些人认为这样便于理解和阅读</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> a = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">bool</span> b = <span class="number">-1</span>;</span><br><span class="line">        string str = <span class="string">&quot;hello world, my cplusplus.&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span> c[] = <span class="string">&quot;Always try to see the best in people.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a = %d.\n&quot;</span>, a);</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; b;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(bool) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">bool</span>) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">and</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a and b are ture.\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">not</span> a);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a\n&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;not b :&quot; &lt;&lt; not b &lt;&lt; endl;</span></span><br><span class="line">         <span class="comment">//cout &lt;&lt; &quot;not a :&quot; &lt;&lt; not a &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">while</span>((<span class="keyword">not</span> a) <span class="built_in"><span class="keyword">or</span></span> (<span class="keyword">not</span> b));</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(not a) or (not b).\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a not_eq b :&quot;</span> &lt;&lt; (a <span class="keyword">not_eq</span> b) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">while</span>(a <span class="keyword">not_eq</span> b);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ending!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-新增的引用（reference）介绍"><a href="#C-新增的引用（reference）介绍" class="headerlink" title="C++新增的引用（reference）介绍"></a>C++新增的引用（reference）介绍</h3><p>1、引用介绍<br>(1)引用的经典案例：实现swap函数实战<br>(2)引用定义和识别的关键：&amp;符号，注意这里和取地址一毛钱关系都没有<br>(3)引用符号（注意我没说变量，引用相当于别名）在定义时 必须 同时初始化，以后不能再另外赋值，只能使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">4</span>, y = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b1 = x;</span><br><span class="line"><span class="comment">//定义了一个引用符号b1，与x关联,关联后只能与x相关，不可与其他变量关联了，类似于linux的软链接</span></span><br><span class="line"></span><br><span class="line">b1 = y;<span class="comment">//相当于x = y;即x = 6;</span></span><br><span class="line">错误：<span class="keyword">int</span> &amp;b1; b1 = x;<span class="comment">//错误，必须定义的同时初始化</span></span><br></pre></td></tr></table></figure>

<p>2、<strong>引用和指针的对比</strong><br>(1)指针在C和C++中都有，且使用方法和实现本质完全相同；引用只有C++可用<br>(2)引用可以理解为功能弱化、安全性增强的低配版指针<br>(3)引用能做的事指针都能做，但指针能做的事儿引用不一定能做<br>(4)引用是它指向变量的“别名”，这个是从引用的使用效果角度讲的，对熟悉指针的人反而不好理解“别名”这个词<br>(5)引用比指针弱的地方就是一个引用定义时绑定了一个变量，后面没法改了<br>(6)引用比指针强的地方也是没法改，所以不存在”野指针”问题，更安全<br>(7)引用主要用在函数传参和返回值</p>
<h3 id="引用的本质剖析"><a href="#引用的本质剖析" class="headerlink" title="引用的本质剖析"></a>引用的本质剖析</h3><p>1、引用可以加const修饰<br>(1)const int &amp;b = a; 表示b是a的const别名，无法通过b修改a了<br>(2)<strong>主要用在函数形参中，告诉大家该函数内部不会修改实参的值</strong>。用在某些时候我们有一个非const类型的变量，但是我们在某个函数调用的过程中，不希望变量的值在函数内部被修改，这时候就可以用const引用来传参。</p>
<p>2、引用和sizeof运算符<br>(1)<strong>sizeof引用得到的不是引用本身的大小，而是引用指向的目标变量的大小</strong><br>(2)在struct或class中定义一个引用，再sizeof整个struct或class就会不一样<br>在这两个里边sizeof(引用)是八个字节，加之考虑结构体对齐，就可得知sizeof的结果</p>
<p>3、<strong>引用的本质是const指针</strong><br>(1)int &amp;b = a; 类似于 int * const b = &a; // 指针本身不能被修改，但是指针指向的内容是可修改的<br>(2)C++标准并没有规定引用是否占用内存空间，但是大多数编译器都把引用实现为const指针，所以大部分编译器中引用也是要占内存空间的<br>(3)<strong>引用是天然const的，所以定义时必须初始化指向变量，否则就没意义了（const修饰之后不可修改）</strong><br>(4)<strong>引用本质是指针，是地址，所以才能实现传址调用的效果</strong></p>
<p>总结：引用就是指针在定义时增加了把指针变量本身const化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *pa, <span class="keyword">int</span> *pb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap3</span><span class="params">(<span class="keyword">int</span> &amp;pa, <span class="keyword">int</span> &amp;pb)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *pa, <span class="keyword">int</span> *pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        temp = *pa;</span><br><span class="line">        *pa = *pb;</span><br><span class="line">        *pb = temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap3</span><span class="params">(<span class="keyword">int</span> &amp;pa, <span class="keyword">int</span> &amp;pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        temp = pa;</span><br><span class="line">        pa = pb;</span><br><span class="line">        pb = temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">test1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">int</span> &amp;a1 = a;         </span><br><span class="line">&#125;mytest1; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">test2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="keyword">char</span> &amp;b1 = b;</span><br><span class="line">        </span><br><span class="line">&#125;mytest2; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0        </span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">3</span>, y = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> &amp;x1 = x, &amp;y1 = y; </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">swap1</span>(x, y);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">swap2</span>(&amp;x, &amp;y);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">swap3</span>(x1, y1);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> z = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">1.11</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> &amp;t1 =t;   </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> &amp;z1 = z;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">double</span> &amp;d1 = d;</span><br><span class="line">                </span><br><span class="line">        <span class="comment">//t1 = 5;//error,不允许被修改</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(t1)&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(t1) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(z1)&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(z1) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(d1)&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(d1) &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//因为引用本质上相当于一个指针，在64为系统上为8字节，加之结构体对齐访问</span></span><br><span class="line">        <span class="comment">//故为两个结构体的大小均为16字节                                                                                </span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(mytest1)&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(mytest1) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(mytest2)&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(mytest2) &lt;&lt; endl;        </span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-的enum枚举"><a href="#C-的enum枚举" class="headerlink" title="C++的enum枚举"></a>C++的enum枚举</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C和C++98等老版本里的写法</span></span><br><span class="line"><span class="comment">//enum day &#123;MON, THU, WEN&#125;;</span></span><br><span class="line"><span class="comment">//enum day2 &#123;MON, xxxx, yyy&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define MON &quot;55&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C中习惯用typedef来重命名类型以避免每次类型使用都加enum</span></span><br><span class="line"><span class="comment">//typedef enum &#123;MON, xxx, xx&#125; day;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">day</span> <span class="title">d1</span>;</span>                <span class="comment">// 定义了一个day类型的变量，变量名是d1</span></span><br><span class="line">        day d1;             <span class="comment">// C++中定义时可以省掉前面的enum</span></span><br></pre></td></tr></table></figure>
<p>1、C++继承C的枚举用法<br>(1)典型枚举类型定义，枚举变量定义和使用<br>(2)枚举类型中的枚举值常量不能和其他外部常量名称冲突：举例1宏定义，举例2另一个枚举<br>即使枚举数据类型中的值实际存储为整数，也不能总是将整数值替换为符号名称。例如，不能使用下面的语句将数值赋值给 student，student是一个枚举变量： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student = <span class="number">1</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<p>但是，可以使用整数值而不是符号名称来测试枚举变量。例如，以下两个 if 语句是等效的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (student == Bill)</span><br><span class="line"><span class="keyword">if</span> (student == <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>2、C++11中扩展的枚举<br>(1)enum class enumType:valueType{one=xx, two, three};<br>对于其的预处理，会将其变成一个：定义一个命名空间，在其中定义一个枚举<br>(2)两种简写,eg:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">day</span>:</span><span class="keyword">unsigned</span> <span class="keyword">int</span>&#123;MON = <span class="number">44</span>, THU, WEN&#125;;</span><br><span class="line"><span class="comment">// 简化写法1</span></span><br><span class="line"><span class="comment">//enum class day&#123;MON, THU, WEN&#125;;</span></span><br><span class="line"><span class="comment">// 简化写法2</span></span><br><span class="line"><span class="comment">//enum day&#123;MON, THU, WEN&#125;;</span></span><br></pre></td></tr></table></figure>
<p>(3)解决2个枚举中的重名问题（不同的命名空间，互不影响），但是宏定义仍然不能重名</p>
<p>3、关于枚举的3个小细节<br>iostream中的输入输出流不接受枚举类型，必须进行强制类型转换。无法通过隐式转换，必须通过显示转换。C++/C都是强制类型转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d1 = day::MON;</span><br><span class="line">cout &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)d1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>(1)枚举类型和值类型的互相转换，枚举类型不可以使用++，只能间接使用，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d1 = (day)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)d1 + <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>(2)枚举类型的前置声明，有时使用在定义之前，所以必须要有 前置声明<br>eg:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">day</span>;</span><span class="comment">//只声明了day是一个enum变量，但不知道其内有哪些成员。使用其中的成员时仍会报错。</span></span><br></pre></td></tr></table></figure>
<p>(3)枚举类型超出范围访问是否会编译时或运行时报错，不会:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译时：g++ enum.cpp -std=c++11，低版本的并不支持某些语法格式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C语言所支持的语法</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">day1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        MON,</span><br><span class="line">        THU,</span><br><span class="line">        WEN</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">//C++所支持的语法</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">day2</span>:</span><span class="keyword">unsigned</span> <span class="keyword">int</span> &#123;</span><br><span class="line">        MON = <span class="number">44</span>,</span><br><span class="line">        THU = <span class="number">55</span>,</span><br><span class="line">        WEN        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 1</span></span><br><span class="line">        <span class="comment">//简化写法1</span></span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">day2</span>&#123;</span>MON, THU, WEN&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 0</span></span><br><span class="line">        <span class="comment">//简化写法2</span></span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">day2</span>&#123;</span>MON, THU, WEN&#125;;<span class="comment">//这种形式下不论使用C还是C++的风格都可以实习其中元素的访问</span></span><br><span class="line">                                                         <span class="comment">//但是使用这种方式会与day1冲突，其内的成员名一样，而使用前两种</span></span><br><span class="line">                                                         <span class="comment">//在一个命名空间中则不会产生干扰</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>        </span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">day1</span> <span class="title">day_c</span>;</span></span><br><span class="line">        day2 day_cplus;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"><span class="comment">//适用于C的语法        </span></span><br><span class="line">        day_c = MON;</span><br><span class="line">        cout &lt;&lt; day_c &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (day_c <span class="keyword">not_eq</span> THU)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//适用于C++的语法        </span></span><br><span class="line">        day_cplus = day2::MON;</span><br><span class="line">        cout &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)day_cplus &lt;&lt; endl;<span class="comment">//iostream中的输入输出流不接受枚举类型，必须进行强制类型转换。</span></span><br><span class="line">        day_cplus = day2::WEN;</span><br><span class="line">        cout &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)day_cplus &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (day2::MON <span class="keyword">not_eq</span> day2::WEN)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;very good.&quot;</span> &lt;&lt; endl; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//枚举类型不可直接使用++,枚举类型超出范围访问是否会编译时或运行时报错，不会</span></span><br><span class="line">        day_cplus = (day2)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)day_cplus + <span class="number">55</span>);</span><br><span class="line">        cout &lt;&lt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)day_cplus &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-的共用体union"><a href="#C-的共用体union" class="headerlink" title="C++的共用体union"></a>C++的共用体union</h3><p>1、C语言中union回顾<br>(1)union翻译成共用体更合适，而不是联合、联合体<br>(2)union中所有成员是多选一的关系，这是union和struct的最大差别<br>(3) 面试笔试常考，必须掌握</p>
<p>2、C++中union和C中不同<br>(1)C++中union类型定义后使用时可以省去union（和上节enum时一样）<br>(2)C++中union里成员除了普通的，还可以是对象，但是对象不能包含自定义构造函数、析构函数，简单说就是不能太复杂<br>(3)C++中经常用到匿名union，一般是内置在class内部做成员变量</p>
<p>3、总结</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//union在C++中没有突出变化，主要还是沿用C中使用</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">myu</span>                        // <span class="title">union</span>类型的定义</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">char</span> *p;</span><br><span class="line">        <span class="built_in"><span class="keyword">void</span></span> (*p1)(<span class="keyword">int</span>);                </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">p1</span>();                                <span class="comment">// 通过p1函数指针来调用函数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">myu</span> <span class="title">m1</span>;</span>                <span class="comment">// C中定义了一个myu类型的变量</span></span><br><span class="line">myu m1;                                <span class="comment">// C++中定义了一个myu类型的变量</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> //没有名字，节省了符号表  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">char</span> *p1;</span><br><span class="line">        <span class="keyword">int</span> *p2;</span><br><span class="line">&#125;m1;                                <span class="comment">// 直接定义了union变量m1</span></span><br></pre></td></tr></table></figure>

<h3 id="inline关键字"><a href="#inline关键字" class="headerlink" title="inline关键字"></a>inline关键字</h3><p>1、C中inline使用关键点强调<br>(1)inline是一种“用于实现的关键字”，而不是一种“用于声明的关键字”，所以关键字 inline 必须与函数定义体放在一起，而不是和声明放在一起<br>(2)如果希望在多个c文件中使用，则inline函数应该定义在h文件中（不需要额外声明）；如果只在一个c文件中使用，则inline函数可以定义在c文件或h文件中（<strong>若定义在c文件时可以声明到h文件中去，声明时可以不加inline</strong>）<br>(3)inline函数在项目中可以多次定义，只要函数体完全相同且在一个c文件范围只定义一次inline函数必须在调用该函数的每个文本文件中定义。当然，对于同一程序的不同文件，如果inline函数出现的话，其定义必须相同。<br>(4)<strong>inline只是一种对编译器的建议而不是强制，所以inline函数不一定真被inline</strong><br>(5)递归函数不应该被声明为inline(递归函数本身被多调用可能会出问题，比如不当inline处理,而且代码量可能太多使得很乱)，超过一定长度（通常是10行）的函数不应该被inline，内含循环的函数不建议被inline<br>(6)<strong>以 inline 修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升程序运行的效率。</strong></p>
<p>2、C++中inline新增的特性<br>(1)<strong>定义在类声明之中的成员函数将自动地成为内联函数</strong>，例如如下代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; ... &#125;   <span class="comment">// 自动地成为内联函数，即使没有inline关键字 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)<strong>如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上 inline，否则就认为不是内联的。</strong>值得注意的是：如果在类体外定义inline函数，则心须将类定义和成员函数的定义都放在同一个头文件中，否则编译时无法进行置换。</p>
<h3 id="C-11引入的nullptr"><a href="#C-11引入的nullptr" class="headerlink" title="C++11引入的nullptr"></a>C++11引入的nullptr</h3><p>1、C语言中的NULL<br>(1)NULL用来标记野指针<br>(2)NULL在C和C++中的定义为什么不同？因为C++不允许void *隐式转为int *等类型<br>(3)C++中也可以继续用NULL，但是因为函数重载的引入，NULL传参会带来歧义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C语言中NULL就是(void *)0</span></span><br><span class="line"><span class="comment">// C++语言中NULL就是0</span></span><br><span class="line"></span><br><span class="line">C++中：</span><br><span class="line"><span class="keyword">int</span> *p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">可以编译通过，因为C++编译器会进行隐式类型转换</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!p)<span class="comment">//判断指针是否为空</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> != p)<span class="comment">//判断指针是否为空</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//指针解引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func int a&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func char *p&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func int *p&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="literal">NULL</span>);<span class="literal">NULL</span>在这存在歧义，使得不知道调用那个函数，是<span class="number">0</span>还是隐式转换（<span class="keyword">int</span> *p = <span class="literal">NULL</span>;）</span><br></pre></td></tr></table></figure>

<p>2、nullptr如何工作<br>(1)<strong>nullptr传参，表示真正的空指针,NULL是个宏定义，而nullptr是个关键字</strong><br>(2)<strong>nullptr的本质是一个const类型的对象</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">class</span> <span class="title">nullptr_t</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="keyword">inline</span> <span class="keyword">operator</span> T*()<span class="keyword">const</span> &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">C</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="keyword">inline</span> <span class="keyword">operator</span> T C::*() <span class="keyword">const</span> &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">operator</span>&amp;() <span class="keyword">const</span>;</span><br><span class="line">&#125; <span class="literal">nullptr</span>=&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>3、nullptr的评价<br>NULL本质是一个数字0，而nullptr本质是一个指针类型 nullptr就是一个可以绕过C++严格的类型检查的NULL，就是因为C++不允许int *p = (void *)0这样，所以才有了nullptr；<br>(1)C++11开始可用，注意版本要求<br>(2)实践中在判断野指针时很多人还是喜欢if (!p)这样•••（因为许多人有C的开发经验，习惯了，并且C++又支持了这种写法）<br>(3)nullptr无法解决char *p和int *p这样的传参重载问题，所以还是有点不完美<br>(4)nullptr不属于任何一种对象指针，但是却可以表示任何类型的空指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is int&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is int *&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">char</span> p = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> *q = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">char</span> *b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!q <span class="keyword">and</span> !b)</span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;these pointers are clear.&lt;1&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (q == <span class="literal">nullptr</span> <span class="keyword">and</span> b == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;these pointers are clear.&lt;2&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;NULL = 0&quot;</span> &lt;&lt; endl;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;NULL = (void *)0&quot;</span> &lt;&lt; endl;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">func</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">func1</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">func1</span>(<span class="literal">nullptr</span>);</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用静态断言"><a href="#使用静态断言" class="headerlink" title="使用静态断言"></a>使用静态断言</h3><p>1、C中的断言assert<br>(1)直接参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvchaoshun/p/7816288.html">https://www.cnblogs.com/lvchaoshun/p/7816288.html</a><br>assert宏的原型定义在&lt;assert.h&gt;中，其作用是如果它的条件返回错误，则终止程序执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原型定义：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert</span><span class="params">( <span class="keyword">int</span> expression )</span></span>;</span><br><span class="line"><span class="comment">// assert的作用是先计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">FILE *fp;</span><br><span class="line">fp = <span class="built_in">fopen</span>( <span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span> );<span class="comment">//以可写的方式打开一个文件，如果不存在就创建一个同名文件</span></span><br><span class="line"><span class="built_in">assert</span>( fp );<span class="comment">//所以这里不会出错</span></span><br><span class="line"><span class="built_in">fclose</span>( fp );</span><br></pre></td></tr></table></figure>
<p>(2)C的assert是运行时检测发现错误，而不是编译时<br>已放弃使用assert()的原因是，频繁的调用会极大的影响程序的性能，增加额外的开销。在调试结束后，可以通过在包含#include &lt;assert.h&gt;的语句之前插入 #define NDEBUG 来禁用assert调用，示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>(3)C在编译时 错误用#error来输出</p>
<p>2、C++静态断言<br>(1)C++引入static_assert(表达式, “提示字符串”)来实现编译时的静态断言<br>(2)实例演示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in"><span class="keyword">static_assert</span></span>(<span class="number">6</span>==<span class="number">6</span>, <span class="string">&quot;6==6 error&quot;</span>);</span><br><span class="line">        <span class="comment">//static_assert(5==6, &quot;5==6 error&quot;);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、静态断言主要用途<br>(1)static_assert主要用于检查模板参数是否符合期望<br>(2)C++20中引入了concept来进一步更好的实现模板参数的编译时类型匹配检查</p>
<h3 id="C-内存对齐"><a href="#C-内存对齐" class="headerlink" title="C++内存对齐"></a>C++内存对齐</h3><p>1、C语言中内存对齐关键点<br>(1)#pragma 和 attribute((packed)) attribute((aligned(n)))<br>(2)__attribute__是GUN C中极具特设的一大机制，可以用来设置<br>函数属性(Function Attribute)<br>变量属性(Variable Attribute)<br>类型属性(Type Attribute)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">attribute</span>((<span class="built_in">aligned</span>(n)))  <span class="comment">//采用n字节对齐</span></span><br><span class="line"><span class="built_in">attribute</span>((packed))      <span class="comment">//采用1字节对齐</span></span><br></pre></td></tr></table></figure>
<p>attribute((aligned(n)))中，n的有效参数为2的幂值，32位最大为2^32,<br>64位为2^64，这个时候编译器会将让n与默认的对齐字节数进行比较，取较大值为对齐字节数，与#pragma pack(n)恰好相反。</p>
<p>attribute((packed))则为取消结构在编译过程中的优化对齐,按照实际占用字节数进行对齐，也就是采用1字节对齐。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************使用格式*******************************************/</span></span><br><span class="line"><span class="comment">/*定义结构体时不对类型重命名*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mystruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*成员变量定义*/</span></span><br><span class="line">&#125;__attribute__() <span class="comment">/*(可同时在这定义变量)*/</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>() <span class="title">mystruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*成员变量定义*/</span></span><br><span class="line">&#125;<span class="comment">/*(可同时在这定义变量)*/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义结构体同时对类型进行重命名*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mystruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*成员变量定义*/</span></span><br><span class="line">&#125;__attribute__() MS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>() <span class="title">mystruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*成员变量定义*/</span></span><br><span class="line">&#125;MS;</span><br><span class="line"><span class="comment">/*************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(n) <span class="comment">//作用：C编译器将对以下的结构体按照n个字节对齐。</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义结构体类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack() <span class="comment">//作用：取消自定义字节对齐方式。</span></span></span><br><span class="line"></span><br><span class="line">其中<span class="meta">#<span class="meta-keyword">pragma</span> pack(n)中，n的有效参数为1/2/4/8/16，</span></span><br><span class="line">这个时候编译器会将让n与默认的对齐字节数进行比较，取较小值为对齐字节数。</span><br><span class="line"></span><br><span class="line">在<span class="number">64</span>位操作系统<span class="number">64</span>位编译器的环境下，当n ≥ <span class="number">8</span>时，内存对齐的字节数是<span class="number">8</span>，不然为n</span><br><span class="line">在<span class="number">32</span>位操作系统<span class="number">32</span>位编译器的环境下，当n ≥ <span class="number">4</span>时，内存对齐的字节数是<span class="number">4</span>，不然为n</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push,n)与#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push,n) <span class="comment">//作用：把原来对齐方式设置压栈，并设新的对齐字节为n的对齐方式</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义结构体类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)     <span class="comment">//作用：恢复原来压栈的对齐方式。</span></span></span><br></pre></td></tr></table></figure>
<p>在指令#pragma pack(push,n)里n的一切效果和#pragma pack(n)中是一样的，这里不再赘述。<br>这个指令的优越性在于：他设置新的对齐方式时，会将原来的对齐方式(假设是M)进行压栈保存下来。待#pragma pack(pop)解除#pragma pack(push,n)的作用时，将会对原来的对齐方式进行弹栈恢复，执行之后结构体的对齐方式又变回了M而不是编译器默认的。 </p>
<p>2、C++中内存对齐新增关键字<br>(1)alignof (C++11 起)<br>alignof用来测定变量或者类型的字节对齐数<br>(2)alignas (C++11 起)<br>alianas用来往大改变字节对齐，使用方法类似__attribute__((aligned(n)))</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mystruct1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="keyword">double</span> c;</span><br><span class="line">&#125;__attribute__((packed)) s1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mystruct2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="keyword">double</span> c;</span><br><span class="line">&#125;__attribute__((<span class="built_in">aligned</span>(<span class="number">8</span>))) s2;</span><br><span class="line"></span><br><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">32</span>)</span> mystruct3</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="keyword">double</span> c;</span><br><span class="line">&#125;s3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(char)&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(int)&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(double)&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>) &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;alignof(s1) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">alignof</span></span>(s1) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(s1) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;alignof(s2) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">alignof</span></span>(s2) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(s2) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s2) &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;alignof(s3) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">alignof</span></span>(s3) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(s3) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s3) &lt;&lt; endl;                </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、什么情况下需要人为改变/指定对齐方式<br>(1)往大去对齐。有时候会有一些硬件特殊要求，譬如MMU，cache等。用__attribute__((aligned(n)))实测ok，用#pragma实测不ok<br>(2)往小去对齐。有时候需要节省内存而浪费效率，所以希望忽略内存对齐，紧密排放。用#pramgma实测ok，用__attribute__((aligned(n)))实测不ok </p>
<h3 id="alignas和typeid"><a href="#alignas和typeid" class="headerlink" title="alignas和typeid"></a>alignas和typeid</h3><p>1、alignas的用法补讲<br>(1)使用方法：一般在类型定义时，放在名称前<br>具体用法参考cppreference：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/alignas">https://zh.cppreference.com/w/cpp/language/alignas</a><br>(2)效果：和__attribute__((aligned(n)))</p>
<p>2、typeid<br>(1)typeid是一个运算符，类似于sizeof<br>(2)typeid定义在头文件typeinfo中，必须包含该头文件<br>(3)typeid用来返回一个变量（表达式）（对象）的类型，类似于C语言中的：typeof() 是GUN C提供的一种特性，它可以取得变量的类型，或者表达式的类型。<br>(4)typeid使用实战 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        cout &lt;&lt; <span class="string">&quot;a type = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(a).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        int a;                // int类型的type.name是                &quot;i&quot;</span></span><br><span class="line"><span class="comment">//        char a;                // char类型的type.name是        &quot;c&quot;</span></span><br><span class="line"><span class="comment">//        unsigned char a;        // unsigned char类型的type.name是        &quot;h&quot;</span></span><br><span class="line">        <span class="keyword">signed</span> <span class="keyword">char</span> a;                <span class="comment">//  signed char类型的type.name是        &quot;a&quot;</span></span><br></pre></td></tr></table></figure>


<p>3、typeid的深层次说明<br>(1)一个表达式的类型分静态类型（在编译的时候就可以确定类型）和动态类型（在运行的时候才可以确定类型，如C中的void *），分别对应编译期 和 运行时类型决策系统<br>(2)<strong>typeid可用来返回静态类型，也可用来返回动态类型</strong><br>(3)typeid是C++语言本身的特性，由编译器和库函数共同支撑<br>(4)typeid真正大用在引入class和继承后，并结合指针和引用后才能显现出来 </p>
<h3 id="C-的4种cast转换"><a href="#C-的4种cast转换" class="headerlink" title="C++的4种cast转换"></a>C++的4种cast转换</h3><p>1、static_cast</p>
<p>(1)源生类型之间的隐式类型转换，避免警告，转换后可能丢失精度，正确性需要程序员自己保证</p>
<p>(2)<strong>用来将void *p转为具体的指针类型，取回原有的指针类型</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">void</span> *p1 = p;                <span class="comment">// p1已经丢掉了自己的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(p1);                <span class="comment">// p2又取回了自己的类型</span></span><br><span class="line"><span class="keyword">int</span> *p3 = (<span class="keyword">int</span> *)p1;</span><br><span class="line"><span class="keyword">char</span> *p4 = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span> *&gt;(p1);</span><br></pre></td></tr></table></figure>
<p>(3)用于类层次结构中父类和子类之间指针和引用的转换。其中上行转换时安全的，而下行转换时不安全的。<br>(4)总结：<strong>static_cast&lt;&gt;()是编译时静态类型检查，使用static_cast可以尽量发挥编译器的静态类型检查功能，但是并不能保证代码一定“正确”</strong>（譬如可能会丢失精度导致错误，可能经过void *之后导致指针类型错误，可能下行转换导致访问错误。） </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5444</span>;</span><br><span class="line">        <span class="keyword">char</span> c = a;                        </span><br><span class="line">        <span class="keyword">char</span> c = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(a);<span class="comment">// 有可能有错误</span></span><br></pre></td></tr></table></figure>
<p>(5)评价：static_cast必须会用，见了必须认识，能理解使用static_cast的意义，但是实际上只能解决很初级的编程问题，属于初级语法特性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C++中：</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> *p5 = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span> *&gt;(p);         <span class="comment">// 编译器报错</span></span><br><span class="line">        <span class="keyword">char</span> *p6 = (<span class="keyword">char</span> *)p;                      <span class="comment">// OK的</span></span><br><span class="line">        <span class="keyword">char</span> *p5 = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span> *&gt;(p);    <span class="comment">//可以的</span></span><br><span class="line">        </span><br><span class="line">而C中：</span><br><span class="line">        <span class="keyword">char</span> *p6 = (<span class="keyword">char</span> *)p;<span class="comment">//也是可以的</span></span><br></pre></td></tr></table></figure>

<p>2、reinterpret_cast<br>(1)<strong>用于明确告知编译器该类型转换在编译时放行</strong>，正确性由程序员自己负责<br>(2)reintepret_cast转换前后对象的二进制未发生任何变化，只是对这些二进制位的编译器类型标识发生了变化，或者说是编译器看待这些二进制位的结论不同了<br>(3)reintepret_cast一般用于将指针转成int或者回转，将A类型指针转为B类型指针等</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 把一个16写入内存地址为0x530000e0的寄存器中</span></span><br><span class="line"><span class="comment">unsigned int *p = (unsigned int *)(0x530000e0);</span></span><br><span class="line"><span class="comment">*p = 16;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span> *&gt;(<span class="number">0x530000e0</span>); </span><br></pre></td></tr></table></figure>
<p>(4)<strong>reintepret_cast其实就是让C++在本次转换中放弃严苛的编译器类型检查</strong></p>
<p>3、const_cast<br>(1)<strong>用来修改类型的const或volatile属性</strong><br>(2)格式为：const_cast&lt;type_id&gt; (expression)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">a = <span class="number">6</span>;                             <span class="comment">// 编译报错，因为a是const类型所以编译器发现操作非法</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)&amp;a;                <span class="comment">// 老式转换可以，但是不推荐</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(&amp;a);    <span class="comment">// 新式写法，推荐</span></span><br><span class="line">*p = <span class="number">14</span>;</span><br></pre></td></tr></table></figure>
<p>(3)思考：const_cast为什么能修改const为非const？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *p1, <span class="keyword">const</span> <span class="keyword">char</span> *p2)</span></span>;</span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">&quot;dfdfdf&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *pa = &amp;a;</span><br><span class="line"><span class="built_in">strcmp</span>(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(pa), <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(pb));</span><br></pre></td></tr></table></figure>

<p>4、dynamic_cast<br>(1)<strong>只用在父子class的指针和引用访问时的转换中，尤其是下行转换时</strong><br>(2)属于一种运行时转换机制，运行时才能知道转换结果是NULL还是有效对象<br>(3)运行时确定对象类型RTTI（run time type indentification）是一种需求，C++有一套机制来实现 </p>
<p>5、4种cast转换总结<br><strong>前三种都是在编译时起作用的，最后一种dynamic_cast是在运行时起作用的</strong>。<br>(1)C中一般都用隐式转换或强制类型转换解决，本质上是一种一刀切方案，全靠程序员自己把控<br>(2)C++中4种cast转换实际上是细分了具体场景，让程序员在具体情况下显式的使用相应的cast来转换，让编译器和运行时尽可能帮程序员把关。 </p>
<h3 id="C-的自动类型推导"><a href="#C-的自动类型推导" class="headerlink" title="C++的自动类型推导"></a>C++的自动类型推导</h3><p>1、auto关键字<br>(1)auto在C中修饰局部变量，可以省略，完全无用。C++中的auto完全是一个新关键字<br>(2)auto要求至少不低于C++11标准来支撑<br>(3)<strong>auto在编译器由编译器帮我们自动推导出变量（对象）类型</strong>，所以定义时必须初始化右边右值的类型，自动推导出左值的类型。<br>(4)<strong>auto可以一次定义多个同类型的变量，但是不能一次定义多个类型不同的变量，这是auto的类型推导机制决定的</strong>。</p>
<p>2、decltype关键字<br>(1)C++11新增关键字<br>(2)<strong>decltype可以让编译器推导目标表达式的类型作为一种类型符使用</strong><br>(3)decltype(表达式)作为类型定义变量不要求初始化</p>
<p>3、auto和decltype的对比<br>(1)auto忽略顶层const，而decltype则保 留const<br>(2)auto作为类型占用符，而decltype用法类似于sizeof运算符<br>(3)对引用操作，auto推断出原有类型，decltype推断出引用<br>(4)对解引用操作，auto推断出原有类型，decltype推断出引用<br>(5)auto推断时会实际执行，decltype不会执行，只做分析。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">pf</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">decltype</span>(func) a;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in"><span class="keyword">typeid</span></span>(a) == <span class="built_in"><span class="keyword">typeid</span></span>(pf))</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;haha&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;typeid(a) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(a).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">decltype</span>(i) j = <span class="number">8</span>;</span><br><span class="line">        <span class="comment">// j = 9;         //编译报错，因为j是const的</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;typeid(j) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(j).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">auto</span> j = i;</span><br><span class="line">        j = <span class="number">4</span>;                         <span class="comment">// 正确， 因为auto会忽略顶层const</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;typeid(j) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(j).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">decltype</span>(i) j;                <span class="comment">// 定义了变量j，类型是和i相同</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;typeid(j) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(j).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">auto</span> i1 = <span class="number">5</span>;                        <span class="comment">// 编译器在编译时自动帮我们推导出i1的类型是int</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="keyword">auto</span> a1 = <span class="number">4</span>, b1 = <span class="number">5</span>;              <span class="comment">// 正确</span></span><br><span class="line">        <span class="comment">// auto a = 4, b = 5.5;           // 错误, auto可以一次定义多个同类型的变量，但是不能一次定义多个类型不同的变量</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;typeid(i) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(a1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-类与面向对象"><a href="#C-类与面向对象" class="headerlink" title="C++类与面向对象"></a>C++类与面向对象</h3><p>1、struct和class<br>(1)struct是C中用户自定义类型，主要功能是对功能相关数据的封装<br>(2)struct不能直接封装函数，但可以通过封装函数指针来间接封装函数<br>(3)struct就是class的初级阶段，class在struct基础上做了很多扩展，便有了面向对象</p>
<p>2、访问权限<br>(1)类是对数据（成员变量）和方法（成员函数）的封装<br>(2)封装的一个重要特征就是访问权限管控，本质是为了隐藏实现细节，避免意外篡改,而<strong>struct没有访问权限管控，其内的成员都可任意访问</strong>。<br>(3)C++支持三个访问管控级别：private、protected、public</p>
<p>3、C++的对象创建和销毁<br>(1)对象的本质等同于C中的变量，对象的创建和销毁也就是变量的产生和销毁，本质上是变量对应的内存地址的分配和释放归还<br>(2)C中全局变量和局部变量都是自动分配和回收内存的，堆内存需要用户手工申请和释放（malloc和free调用）<br>(3)C++中因为变量升级成了对象，涉及到构造函数和析构函数，因此malloc和free升级为了new和delete<br>(4)C++中仍然大量使用全局变量和局部变量，但是动态分配占比例越来越多。这是业务（完成的任务）特点决定的，不是C++语言决定的。语言只是提供机制，业务才决定策略。</p>
<p>c：偏控制，体量偏小<br>c++：偏大，数据结构较复杂，动态性较大</p>
<h3 id="C-中static和this关键字"><a href="#C-中static和this关键字" class="headerlink" title="C++中static和this关键字"></a>C++中static和this关键字</h3><p>1、C语言中的static<br>(1)静态全局变量和函数，限制链接属性。C++中建议优先使用命名空间机制替代<br>(2)静态局部变量，更改地址域和生命周期。C++中继续沿用。</p>
<p>2、static在C++中新增用法<br>(1)用在class中，有静态数据成员和静态成员函数<br>(2)简单理解：<strong>静态成员和方法是属于class的，而非静态是属于对象的</strong><br>(3)静态类往往用在单例模式中，实际上和面向对象的思想有所差异<br>(4)要真正理解静态类，得先学习面向对象和普通非静态类后才可以</p>
<p>3、this关键字<br>(1)<strong>本质是个指针，指向当前对象</strong>(编译器在编译时帮我们加入到class内部的)<br>(2)this的主要作用是让我们在未定义对象前可以在方法（函数）中调用对象里的成员</p>
<h3 id="C-面向对象的其他关键字"><a href="#C-面向对象的其他关键字" class="headerlink" title="C++面向对象的其他关键字"></a>C++面向对象的其他关键字</h3><p>1、面向对象允许类的继承机制<br>(1)C++中用” : “来表示继承关系，有些编程语言有extends关键字表示继承关系<br>(2)virtual修饰class的成员函数为虚函数，一般在基类中，只有接口声明没有实体定义<br>(3)基类的virtual成员可以在派生类中override重写，以实现面向对象的多态特性<br>(4)注意区分重写override与重载overload<br>(5)override关键字是C++11引入，用来在派生类中成员函数声明时明确表明需要派生类去重写的那些成员方法，这样如果程序员在成员方法实体定义中做的不对编译器可以报错提醒 </p>
<p>2、继承的终止final<br>(1)<strong>一个class不希望被继承（不想做父类），可以定义时用final修饰</strong><br>(2)<strong>一个成员方法不希望被子类override，可以声明时用final修饰</strong><br>(3)final是C++11引入的<br>(4)很多其他面向对象语言如java中也有final关键字，也是这个作用 </p>
<p>3、using关键字<br>(1)用法1就是using namespace std;这种<br>(2)用法2与class的继承和访问权限限制有关，属于一个声明，<strong>能够让private继承的子类去声明并访问父类中本来无权限访问的成员</strong></p>
<p>4、operator<br>(1)用于运算符重载，也就是为一个class重定义某种运算符</p>
<p>5、friend<br>(1)让不属于一个class的外部函数也能访问class内受保护的成员变量<br>(2)实际上是对面向对象的一种扩展或者说破坏，在面向对象深入理解之后再来学习更好</p>
<p>6、explicit<br>(1)本意为显式的，对应implicit隐式的<br>(2)用来修饰只有一个参数的构造函数，以阻止构造函数不合时宜的类型转换</p>
<h3 id="C-的const关键字以及const有关的其他几个关键字"><a href="#C-的const关键字以及const有关的其他几个关键字" class="headerlink" title="C++的const关键字以及const有关的其他几个关键字"></a>C++的const关键字以及const有关的其他几个关键字</h3><p>1、C语言中const用法回顾<br>(1)const变量，比宏定义的优势是带数据类型，可以让编译器帮我们做类型检查，二者修饰的东西都不可更改<br>(2)const数组，和常量变量类似<br>(3)const指针，三种情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p,             <span class="comment">// p 指针指向的内容不可修改，就是 *p 不可改  </span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p,            <span class="comment">// p 指针本身不可修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p;    <span class="comment">// p 指针和 p指针指向的内容均不可修改</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *pa)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 调用时，int i;                </span></span></span><br><span class="line"><span class="function"><span class="title">func1</span><span class="params">(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span> *&gt;(&amp;i))</span></span>;</span><br></pre></td></tr></table></figure>
<p>2、C++中const新增用法<br>(1)<strong>const引用，主要用于函数传参，限制函数内部对实参进行修改</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a)</span></span></span><br></pre></td></tr></table></figure>
<p>(2)const成员函数，限制函数内部对类的成员变量的修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">func6</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">func8</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span>;          <span class="comment">// 这样写，隐含意思就是func8内部很有可能会修改传参a的值</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">func9</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a)</span></span>;    <span class="comment">// 这样写，隐含意思就是func9内部不会改变a的值</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">func10</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span></span>;    <span class="comment">// const成员，明确告知func10内部不会修改class A</span></span><br><span class="line">                                    <span class="comment">// 的成员变量的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3、mutable<br>(1)mutable用来突破const成员函数的限制，让其可以修改特定的成员变量<br>在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。<br>(2)案例参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yongdaimi/p/9565996.html">https://www.cnblogs.com/yongdaimi/p/9565996.html</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">/*调用方法*/</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCallingTimes</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">/*获取上面的getAge方法被调用了多少次*/</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">char</span> *name;</span><br><span class="line">        <span class="keyword">float</span> score;</span><br><span class="line">        <span class="keyword">mutable</span> <span class="keyword">int</span> m_nums;<span class="comment">/*用于统计次数*/</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Person::getAge</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Calling the method&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_nums++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Person::getCallingTimes</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        Person *person = <span class="keyword">new</span> <span class="built_in">Person</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        </span><br><span class="line">                person-&gt;<span class="built_in">getAge</span>();</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;getAge方法被调用了&quot;</span> &lt;&lt; person-&gt;<span class="built_in">getCallingTimes</span>() &lt;&lt; <span class="string">&quot;次&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> person;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、constexpr<br>(1)用法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">multiply</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="built_in">multiply</span>( <span class="number">10</span>, <span class="number">10</span> );                <span class="comment">// 将在编译时计算</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">100</span>;<span class="comment">//效果与上边的相同</span></span><br></pre></td></tr></table></figure>
<p>(2)<strong>本质上是让程序利用编译时的计算能力，增加运行时效率</strong>，<br><strong>inline也可提高运行时的效率</strong><br>(3)由C++11引入，但是实际有一些编译器并不支持，需实际测试</p>
<p>5、C++20新引入的2个<br>(1)constinit <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/constinit">https://zh.cppreference.com/w/cpp/language/constinit</a><br>(2)consteval <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/consteval">https://zh.cppreference.com/w/cpp/language/consteval</a></p>
<h3 id="模板编程的几个关键字"><a href="#模板编程的几个关键字" class="headerlink" title="模板编程的几个关键字"></a>模板编程的几个关键字</h3><p>1、模(mu)板编程初体验(结合自己所写的程序便于理解)<br>(1)template和typename<br>(2)模板实际上是一种抽象，C++的高级编程特性就是不断向抽象化发展</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span><span class="comment">//T就被当作这个模板的泛型数据类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、export<br>(1)用来在cpp文件中定义一个模板类或模板函数，而它的声明在对应的h文件中<br>(2)export专用于模板，类似于extern之于简单类型<br>(3)实际很多环境不支持，暂不必细究，看到代码时能认出即可</p>
<p>3、requires<br>(1)C++20引入，用于表示模板的参数约束，因为有些模板函数的参数是有一定限制的，例如add函数其参数不能是两个结构体，结构体是无法相加的<br>(2)了解即可，暂时不用管</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> METHOD 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> METHOD  </span></span><br><span class="line"><span class="comment">//写一个函数add，完成两个数的求和</span></span><br><span class="line"><span class="comment">//若有十种数据类型要考虑，就需要写多个add的重载函数，十分麻烦</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, in b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;int add(int a, in b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> (a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;double add(double a, double b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> (a+b);        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//如何解决上述问题，可通过模板编程来解决</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span><span class="comment">//T就被当作这个模板的泛型数据类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> i = <span class="number">5</span>, j = <span class="number">6</span>;</span><br><span class="line">        <span class="comment">//short i = 5, j = 6;</span></span><br><span class="line">        <span class="comment">//int i = 5, j = 6;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个不同的数据类型会将低的转为高的类型（不同数据类型的高低级不同）</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a + b = &quot;</span> &lt;&lt; <span class="built_in">add</span>(i ,j) &lt;&lt; endl;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<h3 id="C-的异常处理机制"><a href="#C-的异常处理机制" class="headerlink" title="C++的异常处理机制"></a>C++的异常处理机制</h3><p>1、何为异常处理<br>(1)异常exception，即运行时错误<br>(2)C中没有异常机制，所以运行时遇到错误只能终止程序<br>(3)C++中新增了异常处理机制，允许程序在运行时拦截错误并处理，这样程序就不用终止<br>(4)异常机制的一个典型案例就是：由用户输入2个数字然后相除中的除0异常</p>
<p>2、异常处理编程实践<br>(1)try（其包含的代码表示有可能爆发错误）, catch（捕捉异常）, throw（抛出异常）<br>(2)异常处理机制为什么优于出错条件判断：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wkfvawl/p/10816156.html">https://www.cnblogs.com/wkfvawl/p/10816156.html</a> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C 0</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m, n;</span><br><span class="line">        <span class="comment">//让用户输入两个数，二者相除返回二者的商</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;please input two numbers&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> C        <span class="comment">//在C中这样处理除数为0的情况</span></span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;n can‘t be 0.&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;        </span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;m / n = &quot;</span> &lt;&lt; m/n &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">//在C++中的处理方式</span></span></span><br><span class="line">        <span class="comment">//C++中异常处理机制进行处理</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">//try括号里的代码就是有可能触发异常的代码</span></span><br><span class="line">                <span class="comment">//这部分代码不应过多，会消耗过多的资源</span></span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span>(<span class="number">0</span>);<span class="comment">//抛出异常</span></span><br><span class="line">                        <span class="comment">//throw(&#x27;A&#x27;);//抛出的这个类型异常无法被抓取，因为下方无catch(char e)</span></span><br><span class="line">                                                 <span class="comment">//在执行过程中会出错退出        </span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;m /n = &quot;</span> &lt;&lt; m/n &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span> e)<span class="comment">//catch的()里写上要抓取的异常类型</span></span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;catch int e&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">double</span> e)<span class="comment">//catch的()里写上要抓取的异常类型</span></span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;catch double&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;---other code---&quot;</span> &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、异常和函数<br>(1)在某个函数内throw一个异常后如果没有catch会层层向外传递(顺着函数的调用关系)直到被catch为止<br>(2)函数可以用throw列表来标识自己会抛出的异常<br>有时候有些函数只负责抛出异常，有些函数只负责处理异常<br>void func(void) throw(A, B, C);//这种声明就是告诉调用者可能会抛出A,B,C三种异常 </p>
<p>4、标准库中的exception类（标准异常：不是我们自定义的，是标准库定义好的，包括常见的很多错误）<br>(1)标准库中定义的异常类及其派生类，很多内置代码的错误会抛出这些异常<br>(2)譬如bad_typeid，使用 typeid 运算符时，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常<br>(3)譬如bad_cast，用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常</p>
<p>5、noexcept关键字<br>(1)throw(int, double, A, B, C)表示函数可能会抛出这5种类型的exception<br>(2)throw() 表示函数不会抛出任何异常<br>(3)<strong>C++11中引入noexcept关键字替代throw()表示函数不会抛出任何异常</strong></p>
<ul>
<li>noexcept(bool)//bool值为true表示无异常<br>(4)没有throw列表的函数，表示函数可能会抛出任意类型的异常</li>
</ul>
<p>6、剩余一些关键字<br>(1)线程相关：thread_local (C++11 起)<br>(2)import和module (C++20)<br>(3)协程相关：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">co_await</span></span> (C++<span class="number">20</span> 起)</span><br><span class="line"><span class="built_in"><span class="keyword">co_return</span></span> (C++<span class="number">20</span> 起)</span><br><span class="line"><span class="built_in"><span class="keyword">co_yield</span></span> (C++<span class="number">20</span> 起)</span><br></pre></td></tr></table></figure>

<p>(4)并发相关：synchronized (TM TS)<br>(5)反射相关：reflexpr (反射 TS)<br>(6)其他：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">transaction\_safe (TM TS)</span><br><span class="line">transaction\_safe\_dynamic (TM TS)</span><br><span class="line">atomic\_cancel (TM TS)</span><br><span class="line">atomic\_commit (TM TS)</span><br><span class="line">atomic\_noexcept (TM TS) </span><br></pre></td></tr></table></figure>

<p>7、总结<br>(1)C++关键字和复杂度远超过C语言，语言特性较多<br>(2)面向对象编程相关特性是C++的基础核心，占比非常大<br>(3)模板泛型和抽象化编程是C++的重要特征，甚至可以说是精髓所在<br>(4)和java、python相比，C++的语法细节过多，这也是C++较难学习的重要原因<br>(5)不要试图去记，以理解为主，配合代码实验去消化吸收，形成自己对C++的认知<br>(6)经典C++与C++11、14、17、20的差异其实就是相应增加的关键字带来的新语言特性 </p>
<h2 id="C-的内存管理"><a href="#C-的内存管理" class="headerlink" title="C++的内存管理"></a>C++的内存管理</h2><h3 id="为什么要研究内存管理"><a href="#为什么要研究内存管理" class="headerlink" title="为什么要研究内存管理"></a>为什么要研究内存管理</h3><p>1、<strong>程序就是数据加算法</strong><br>(1)写程序是为了解决某个问题，生活中的问题最终被计算机抽象为控制或运算<br>(2)CPU中的主要构件就是运算器和控制器，本质上是一堆组合逻辑电路，表现为机器指令集<br>(3)一个问题对应一个程序，一个程序分为多个函数，一个函数分为多个机器指令<br>(4)存储机器指令需要内存（ROM），机器指令的执行过程需要内存（RAM）参与，这是内存的2大作用<br>(5)算法对应机器指令（ROM内存），数据对应RAM内存，CPU对应工作机器<br>(6)<strong>越是偏底层的语言，越对内存管理具体化，效率也越高，同时对编程者要求也越高</strong> </p>
<p>2、计算机中如何管理内存<br>(1)C++项目大多数对应在操作系统中运行，很少有裸机的<br>(2)OS提供最基本的内存管理体系，OS直接管理物理内存，并向应用层提供一套内存接口<br>(3)C++语言对OS的内存接口进行封装，提供给编程者一套内存使用方法<br>(4)编程人员写的代码在编译工具链、OS等体系的帮助下最终在计算机物理层运行 </p>
<p>3、总结<br>(1)内存管理的原理虽然庞大而复杂，然而<strong>程序员只需要掌握好C++语言的内存管理语言特性即可</strong><br>(2)C++程序容易出bug，主要就是因为内存管理部分的复杂性<br>(3)Java,python等语言提供了更多的封装，所以降低了程序员操作难度和犯错可能性</p>
<h3 id="C-可用内存区域"><a href="#C-可用内存区域" class="headerlink" title="C++可用内存区域"></a>C++可用内存区域</h3><p>1、C语言可用内存区域<br>(1)<strong>栈，对应局部变量</strong><br>(2)<strong>全局数据区/静态数据区，对应全局变量，静态局部变量</strong><br>(3)<strong>const数据区，在内存层面是不存在的，是C编译器营造出来的，通过编译器的检查来实现只读，实际上并没有这样一个数据区</strong><br>(4)<strong>代码段，放可执行程序的，性质是rom，不是内存，但实质是ram</strong><br>(5)<strong>堆heap，由malloc和free来管理的一块内存,也是动态内存</strong> </p>
<p>2、C++新增内存区域<br><strong>自由存储区，由new申请得到的动态内存区域</strong></p>
<p>3、总结<br>(1)代码段只会读不会写，一般不会出任何问题<br>(2)全局数据区和栈区都是自动管理的，只要可用内存足够不会出问题<br>(3)const数据区实际上是由编译器来保证只读的，本质就是普通的内存区域<br>(4)<strong>灵活性和风险都集中在heap区域，常见问题如内存泄漏、内存碎片</strong>等</p>
<h3 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h3><p>1、简单区别<br>(1)malloc是C库函数，new是C++运算符关键字<br>(2)malloc申请空间大小靠传参确定，而new不需要传参，对象本身大小由编译器自动计算给出<br>(3)<strong>malloc返回值为void *因此需要强转，而new返回值类型为确定的对象指针类型</strong><br>(4)malloc对应free释放，new对应delete和delete[]释放 </p>
<p>2、深度区别<br>(1)<strong>malloc 只能申请内存不能带初始化，而new可以带初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">3</span>);<span class="comment">//即*p = 3;</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;<span class="comment">//即*p = 0;</span></span><br></pre></td></tr></table></figure>
<p>(2)<strong>new会执行类的构造函数而malloc不会</strong><br>(3)malloc失败返回NULL，而new失败引发bad_alloc异常<br>(4)申请和释放数组类型时不同<br><strong>new申请的是数组类型时使用delete[]释放，不是则用delete释放</strong></p>
<p>3、总结<br>(1)linux平台中new内部是通过malloc实现的，new比malloc多一个调用构造函数<br>(2)malloc只是返回一块荒地给你，而new会给你修好路盖好房子规划好田地等</p>
<h3 id="智能指针的引入"><a href="#智能指针的引入" class="headerlink" title="智能指针的引入"></a>智能指针的引入</h3><p>1、指针的优势和劣势<br>(1)<strong>指针的本质是一个变量，变量的值是其他对象的地址，因此可以解引用</strong><br>(2)<strong>指针本质上对应CPU指令中的间接寻址，所以指针是天然存在的，是CPU设计决定了的</strong><br>(3)指针的优势就是灵活、代码效率高<br>(4)<strong>指针的劣势也是太灵活，尤其结合动态内存和构造（比如越界访问）、析构后，在复杂业务中容易出错</strong></p>
<p>2、如何解决<br>(1)底层不用指针是不可能的，因此这个问题是绕不开的<br>(2)解决方案1：由程序员来自主把控，C/C++典型编程就是这样<br>(3)解决方案2：由程序员和专门设计的自动管理机制共同把控，典型代表是智能指针<br>(4)解决方案3：由自动管理机制全权把控，程序员不用管，典型代表是Java的垃圾回收机制</p>
<p>3、智能指针如何实现<br>(1)<strong>将普通的简单纯指针封装为栈式复合指针对象，即智能指针对象</strong><br>(2)<strong>智能指针本身定义为局部变量，分配在栈内存上，因此本身是自动回收的</strong><br>(3)<strong>智能指针内部设计为当智能指针本身要被弹栈释放时，执行事先挂接好的清理函数（在C++中一般是析构函数）</strong><br>(4)智能指针的正常使用通过一些提供的方法和运算符重载来使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> *p;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="comment">//记录使用的次数</span></span><br><span class="line">        函数指针;<span class="comment">//指向一个清理函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单指针 int *p1; 出错一般不是p1本身出错，而是其所指向的那块内存出错。</p>
<p>4、智能指针总结<br>(1)<strong>智能指针是普通指针的升级版，封装版，本身具备指针的功能，且多出一些自动释放资源机制。占用的内存多余普通指针</strong>。<br>(2)<strong>智能指针进行动态内存管理，要比普通指针多出很多（内存和性能上的）开销</strong>。<br>(3)智能指针的实现不是唯一的，C++有很多智能指针，各有优劣和适用场景，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::auto_ptr、boost::scoped_ptr、boost::shared_ptr、boost::scoped_array、boost::shared_array、boost::weak_ptr、boost::intrusive_ptr。</span><br></pre></td></tr></table></figure>
<p>(4)智能指针也要按照设计去正确使用，否则也会出问题。具体用法后续文章再讲。</p>
<h3 id="Java的垃圾回收机制"><a href="#Java的垃圾回收机制" class="headerlink" title="Java的垃圾回收机制"></a>Java的垃圾回收机制</h3><p>1、Java语言整体框架<br>(1)CPU-&gt;操作系统内核-&gt;应用层框架-&gt;JVM（java虚拟机）-&gt;Java字节码-&gt;Java源代码<br>Java虚拟机是java语言的运行环境，Java字节码是java自己定义的一种格式，与任何CPU的机器码都不对应，是虚拟出来的一种机器语言，其在任何CPU和操作系统上都无法直接运行，必须放在java的虚拟机上运行。<br>android与windows的虚拟机并不兼容。<br>Java与C++不在一个层次上，C++在应用层框架，Java运行在java的虚拟机上。<br>(2)Java是解释型语言，而非编译型语言<br>(3)Java虚拟机是Java语言的运行时环境，也是Java语言跨平台的关键</p>
<p>2、Java的垃圾回收机制介绍<br>(1)什么是垃圾？<br>待回收的内存资源（主要指动态内存），本质是生命周期结束了的变量对象等。<br>(2)谁来回收？<br>GC线程，Java虚拟机中的守护线程。<br>(3)什么时候回收？<br>GC机制和算法来决定，程序员不用管。<br>(4)如何确定谁是垃圾？<br>引用计数法和可达性分析法。<br>介绍见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiangtunan/p/11025521.html">https://www.cnblogs.com/jiangtunan/p/11025521.html</a><br><strong>引用计数法：</strong></p>
<ul>
<li>引用计数法就是给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的，可以当做垃圾收集。这种方法实现起来很简单而且优缺点都很明显。</li>
<li>优点:执行效率高，程序执行受影响较小</li>
<li>缺点:无法检测出循环引用的情况，导致内存泄露</li>
</ul>
<p><strong>可达性分析算法：</strong></p>
<ul>
<li>这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</li>
</ul>
<p>3、垃圾回收机制点评<br>(1)不止java，其他语言如C#也是类似设计理念，典型特征就是语言没有指针的概念<br>(2)垃圾回收机制让程序员免于考虑对象的生命周期和资源的申请与释放，编程难度大减。<br>(3)垃圾回收机制的稳定性和效率取决于运行时环境(JVM等)设计和实现的好坏<br>(4)垃圾回收机制用效率和内存资源成本，换来了更简单不易错的语言特性。<br>应用了垃圾回收机制的语言没有指针。</p>
<p>4、最后的总结<br>(1)本篇文章主要讲了C/C++/Java等语言的内存管理策略，尤其是动态内存管理策略<br>(2)机制本身有优点就有缺点，没有绝对好坏，适合的场景使用适合的机制才是上策<br>(3)C++掌握好以后再学习Java、Python等就简单多了 </p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C-C/" rel="tag"><i class="fa fa-tag"></i> C/C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/10/25/hello-world/" rel="prev" title="文章汇总">
                  <i class="fa fa-angle-left"></i> 文章汇总
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/11/17/2024-11-17-CPP-Basics-C-and-ObjectOrientation/" rel="next" title="C++从入门到进阶之二-C++和面向对象">
                  C++从入门到进阶之二-C++和面向对象 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">空白</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">288k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:22</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"shenweikun/helloworld","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
