<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shenweikun.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="面向对象是一种编程思想">
<meta property="og:type" content="article">
<meta property="og:title" content="C++从入门到进阶之二-C++和面向对象">
<meta property="og:url" content="https://shenweikun.github.io/2024/11/17/2024-11-17-CPP-Basics-C-and-ObjectOrientation/index.html">
<meta property="og:site_name" content="Weikun&#39;s Notes">
<meta property="og:description" content="面向对象是一种编程思想">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-11-16T17:07:50.000Z">
<meta property="article:modified_time" content="2024-11-20T17:51:52.621Z">
<meta property="article:author" content="空白">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://shenweikun.github.io/2024/11/17/2024-11-17-CPP-Basics-C-and-ObjectOrientation/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://shenweikun.github.io/2024/11/17/2024-11-17-CPP-Basics-C-and-ObjectOrientation/","path":"2024/11/17/2024-11-17-CPP-Basics-C-and-ObjectOrientation/","title":"C++从入门到进阶之二-C++和面向对象"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++从入门到进阶之二-C++和面向对象 | Weikun's Notes</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Weikun's Notes</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">怀揣代码中的唏嘘，记录生活中的点滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E9%AB%98%E5%A4%84%E7%9C%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.</span> <span class="nav-text">从高处看面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%80%E7%A7%8D%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="nav-number">1.1.</span> <span class="nav-text">面向对象是一种编程思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%B9%B6%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8D%95%E4%B8%80%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.</span> <span class="nav-text">面向对象并不是一个单一概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E5%B1%95%E5%88%86%E6%9E%90%E5%92%8C%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.</span> <span class="nav-text">拓展分析和总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%9A%84%E5%B0%81%E8%A3%85%E5%92%8C%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="nav-number">2.</span> <span class="nav-text">C++的封装和访问权限</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E7%9A%84C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">典型的C++面向对象编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">C++的构造函数和析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="nav-number">2.3.</span> <span class="nav-text">在构造和析构函数中使用动态内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.4.</span> <span class="nav-text">构造函数与类的成员初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-number">2.5.</span> <span class="nav-text">拷贝构造函数的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98"><span class="nav-number">2.6.</span> <span class="nav-text">什么是访问权限问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="nav-number">2.7.</span> <span class="nav-text">C++为什么要设计访问权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E7%BC%96%E7%A8%8B%E7%90%86%E5%BF%B5"><span class="nav-number">2.8.</span> <span class="nav-text">访问权限带来的一些新编程理念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#struct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.9.</span> <span class="nav-text">struct和class的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const%E5%92%8Cmutable%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84"><span class="nav-number">2.10.</span> <span class="nav-text">const和mutable是干嘛的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%E7%89%B9%E6%80%A7"><span class="nav-number">3.</span> <span class="nav-text">C++的继承和多态特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%A7%E6%89%BF%E7%89%B9%E6%80%A7"><span class="nav-number">3.1.</span> <span class="nav-text">什么是面向对象的继承特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E6%8E%A7"><span class="nav-number">3.2.</span> <span class="nav-text">C++继承中的权限管控</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E5%AD%90%E7%B1%BB%E5%92%8C%E7%88%B6%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">3.3.</span> <span class="nav-text">继承体系下子类和父类的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E5%85%B3%E7%B3%BB"><span class="nav-number">3.4.</span> <span class="nav-text">派生类和基类的构造析构关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E9%97%AE%E9%A2%98"><span class="nav-number">3.5.</span> <span class="nav-text">派生类和基类的同名成员问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E5%92%8C%E7%88%B6%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99"><span class="nav-number">3.6.</span> <span class="nav-text">子类和父类的类型兼容规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E4%B8%8D%E8%89%AF%E7%BB%A7%E6%89%BF"><span class="nav-number">3.7.</span> <span class="nav-text">继承的优势与不良继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E4%B8%8E%E7%BB%A7%E6%89%BF%E5%AF%B9%E6%AF%94"><span class="nav-number">3.8.</span> <span class="nav-text">组合介绍以及与继承对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%8F%8A%E5%85%B6%E4%BA%8C%E4%B9%89%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">3.9.</span> <span class="nav-text">多继承及其二义性问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E8%A7%A3%E5%86%B3%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BA%8C%E4%B9%89%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">3.10.</span> <span class="nav-text">虚继承解决菱形继承的二义性问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">3.11.</span> <span class="nav-text">多态和虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">3.12.</span> <span class="nav-text">纯虚函数与抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">3.13.</span> <span class="nav-text">虚析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#using%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E6%97%B6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="nav-number">3.14.</span> <span class="nav-text">using重新定义继承时访问权限</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">4.</span> <span class="nav-text">C++的运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%BC%95%E5%85%A5"><span class="nav-number">4.1.</span> <span class="nav-text">运算符重载引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">4.2.</span> <span class="nav-text">深度理解运算符重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E5%85%B3%E9%94%AE%E7%82%B9"><span class="nav-number">4.3.</span> <span class="nav-text">理解运算符重载的关键点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%BB%86%E8%8A%82"><span class="nav-number">4.4.</span> <span class="nav-text">运算符重载函数中的细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8"><span class="nav-number">4.5.</span> <span class="nav-text">赋值运算符重载函数返回引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E7%B1%BB%E7%9A%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">4.6.</span> <span class="nav-text">String类的赋值运算符重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%92%8C%E2%80%93%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%89%8D%E7%BD%AE%E5%90%8E%E7%BD%AE%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.7.</span> <span class="nav-text">++和–运算符的前置后置如何实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E6%96%B9%E6%B3%95"><span class="nav-number">4.8.</span> <span class="nav-text">两种运算符重载方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%9A%84%E9%9D%99%E6%80%81%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">5.</span> <span class="nav-text">C++的静态类和静态成员</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">5.1.</span> <span class="nav-text">类的静态成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3"><span class="nav-number">5.2.</span> <span class="nav-text">静态成员的深度理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E7%94%A8%E9%80%94"><span class="nav-number">5.3.</span> <span class="nav-text">静态成员的用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E7%9A%84%E6%89%A9%E5%B1%95%E8%AE%B2%E8%A7%A3"><span class="nav-number">5.4.</span> <span class="nav-text">静态类的扩展讲解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%9A%84%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="nav-number">6.</span> <span class="nav-text">C++的友元函数和友元类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-number">6.1.</span> <span class="nav-text">什么是友元函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%842%E7%A7%8D%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.2.</span> <span class="nav-text">友元函数的2种实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="nav-number">6.3.</span> <span class="nav-text">友元类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-number">6.4.</span> <span class="nav-text">为什么会有友元函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%92%8C%E5%B1%80%E9%83%A8%E7%B1%BB"><span class="nav-number">6.5.</span> <span class="nav-text">嵌套类和局部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E4%B8%8E%E5%AF%B9%E8%B1%A1%E4%BA%92%E8%BD%AC"><span class="nav-number">6.6.</span> <span class="nav-text">数值与对象互转</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">空白</p>
  <div class="site-description" itemprop="description">记录生活与职业中的点滴</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shenweikun.github.io/2024/11/17/2024-11-17-CPP-Basics-C-and-ObjectOrientation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="空白">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weikun's Notes">
      <meta itemprop="description" content="记录生活与职业中的点滴">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++从入门到进阶之二-C++和面向对象 | Weikun's Notes">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++从入门到进阶之二-C++和面向对象
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-17 01:07:50" itemprop="dateCreated datePublished" datetime="2024-11-17T01:07:50+08:00">2024-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-21 01:51:52" itemprop="dateModified" datetime="2024-11-21T01:51:52+08:00">2024-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/4-C-C/" itemprop="url" rel="index"><span itemprop="name">4. C/C++</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>52k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>48 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>面向对象是一种编程思想</p>
<span id="more"></span>
<h2 id="从高处看面向对象"><a href="#从高处看面向对象" class="headerlink" title="从高处看面向对象"></a>从高处看面向对象</h2><h3 id="面向对象是一种编程思想"><a href="#面向对象是一种编程思想" class="headerlink" title="面向对象是一种编程思想"></a>面向对象是一种编程思想</h3><p>(1)<strong>面向对象并不是C++特有的，所有编程语言都可以面向对象</strong><br>(2)面向对象语言就是设计语言特性时充分考虑并且原生支持面向对象特征的那些编程语言<br>(3)<strong>面向对象之于编程，就好像比喻修辞法之于写作</strong><br>(4)面向对象只是编程语言语法层面的东西，不影响最终生成的二进制程序，也不关CPU的事</p>
<h3 id="面向对象并不是一个单一概念"><a href="#面向对象并不是一个单一概念" class="headerlink" title="面向对象并不是一个单一概念"></a>面向对象并不是一个单一概念</h3><p>(1)面向对象三大特征：<strong>封装、继承、多态</strong><br>(2)面向对象还会延伸出很多细节，而不同编程语言会选择不同的应对方法<br>(3)C++的语法细节很多，而Java的语法细节少，但都是面向对象的<br>(4)面向对象是设计模式的基础，凡事从简单到复杂其实学起来顺理成章</p>
<h3 id="拓展分析和总结"><a href="#拓展分析和总结" class="headerlink" title="拓展分析和总结"></a>拓展分析和总结</h3><p>1、Linux中面向对象编程、华为LiteOS中面向对象编程、STM32 HAL库中面向对象编程<br>  - 使用C语言，借助结构体和函数指针来实现面向对象的思想。</p>
<p>2、总结<br>(1)面向对象是针对面向过程说的，编程时关注对象由“过程”转为“对象”<br>(2)面向对象的外部表象就是一种组织代码，写程序的方式<br>(3)<strong>面向对象的本质是一种封装数据和看待问题的更高层次的视角</strong><br>(4)<strong>面向对象是应对越来越复杂问题，是处理越来越庞大程序的更有效的方法</strong><br>(5)语言由非面向对象升级到面向对象是自然而然的成长，和人一样</p>
<h2 id="C-的封装和访问权限"><a href="#C-的封装和访问权限" class="headerlink" title="C++的封装和访问权限"></a>C++的封装和访问权限</h2><h3 id="典型的C-面向对象编程"><a href="#典型的C-面向对象编程" class="headerlink" title="典型的C++面向对象编程"></a>典型的C++面向对象编程</h3><p>1、C++面向对象式编程总结<br>(1)整个工作分为2大块：一个是建模和编写类库，一个是使用类库来编写主程序完成任务。<br>(2)有些人只负责建模和编写类库 。<br>(3)有些人直接调用现成类库来编写自己的主任务程序，譬如使用opencv分析一张图片中有没有电动车<br>(4)难度上不确定，2个都可能很难或者很简单。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//person.hpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __PERSON_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PERSON_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> MAN</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">                <span class="comment">//属性</span></span><br><span class="line">                string name;</span><br><span class="line">                <span class="keyword">int</span> age;</span><br><span class="line">                <span class="keyword">int</span> male;<span class="comment">//1表示男，0表示女</span></span><br><span class="line">                <span class="comment">//方法        </span></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:        </span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//person.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MAN::person::<span class="built_in">work</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;male) </span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;working is coding&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;shopping&quot;</span> &lt;&lt; endl;        </span><br><span class="line">        &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MAN::person::<span class="built_in">eat</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;eating food and fruits.&quot;</span> &lt;&lt; endl;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MAN::person::<span class="built_in">sleep</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sleeping.age = &quot;</span> &lt;&lt; age &lt;&lt; endl;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> MAN;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        person zhangsan;</span><br><span class="line">        </span><br><span class="line">        zhangsan.name = <span class="string">&quot;zhangzheng&quot;</span>;</span><br><span class="line">        zhangsan.age = <span class="number">22</span>;</span><br><span class="line">        zhangsan.male = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        zhangsan.<span class="built_in">eat</span>();</span><br><span class="line">        zhangsan.<span class="built_in">work</span>();</span><br><span class="line">        zhangsan.<span class="built_in">sleep</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<p>2、C++学习的三重境界<br>(1)学习C++第一重境界就是语法层面，先学会如何利用C++来建模、来编程，学习语法时先别解决难度大问题。<br>(2)学习C++第二重境界是解决问题层面，学习如果理解并调用现成类库来编写主程序解决问题。<br>(3)学习C++第三重境界是编写类库和sample给别人用，需要基础好且有一定架构思维。</p>
<h3 id="C-的构造函数和析构函数"><a href="#C-的构造函数和析构函数" class="headerlink" title="C++的构造函数和析构函数"></a>C++的构造函数和析构函数</h3><p>1、什么是构造函数<br>(1)constructor，字面意思是用来构造对象的函数；destructor，字面意思是用来析构对象的函数<br>(2)可以理解为语言自带的一种hook函数（回调函数）<br>  回调函数就是一个被作为参数传递的函数。回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。<br>(3)<strong>当对象产生时构造函数会自动被调用，一般用于初始化class的属性、分配class内部需要的动态内存</strong><br>(4)<strong>对象消亡时析构函数会自动被调用，一般用于回收constructor中分配的动态内存，避免内存丢失</strong></p>
<p>2、构造和析构一般用法<br><strong>(1)不写时C++会自动提供默认的构造和析构，也可以显式提供默认构造和析构函数<br>(2)构造和析构函数不需要返回值类型，构造函数可以带参或不带参，析构函数不带参<br>(3)构造函数可以重载（overload），析构函数不需要重载</strong></p>
<p>3、为什么需要构造函数和析构函数<br>(1)构造函数可以看作是<strong>对象的初始化式</strong>，注意对比对象和变量的初始化区别<br>(2)<strong>构造函数可以为对象完成动态内存申请，同时在析构函数中再释放，形成动态内存的完整使用循环。</strong><br>(3)<strong>C语言中struct无构造函数概念，所以struct中需要用到动态内存时必须在定义struct变量后再次单独申请和释放，而这些操作都需要程序员手工完成</strong><br>(4)C++ class的构造和析构特性，是C++支持面向对象编程的一大语言特性。 </p>
<h3 id="在构造和析构函数中使用动态内存"><a href="#在构造和析构函数中使用动态内存" class="headerlink" title="在构造和析构函数中使用动态内存"></a>在构造和析构函数中使用动态内存</h3><p>1、析构函数的使用<br>(1)<strong>析构函数在对象对销毁时自动调用</strong>，一般有2种情况<br>(2)<strong>用new分配的对象，用delete显式析构,才会调用析构函数</strong><br>(3)<strong>分配在栈上的对象（例如局部变量），当栈释放时自动析构</strong><br>(4)普通情况下析构函数都是空的，因为不必做什么特别的事情</p>
<p>2、在class中使用动态内存变量<br>(1)什么情况下用动态内存？<br>  - 需要大块内存，且需要按需灵活的申请和释放，用栈怕爆、用全局怕浪费等<br>(2)在class person中增加一个int *指针，用于指向一个int类型元素的内存空间<br>(3)在构造函数中分配动态内存<br>(4)在析构函数中回收动态内存<br>(5)将动态内存从int变量升级到int数组变量<br>(6)实战中C++常用的动态内存往往是容器vector那些，之后的文章会讲到</p>
<p>3、用valgrind工具查看内存泄漏<br>(1)valgrind工具介绍：参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012662731/article/details/78652651">https://blog.csdn.net/u012662731/article/details/78652651</a><br>(2)安装：sudo apt-get install valgrind（ubuntu16.04 X64）<br>(3)编译程序：主要是添加-g参数便于调试时有行号 g++ person.cpp main.cpp -g -o apptest<br>(4)使用：valgrind –tool=memcheck –leak-check=full –show-reachable=yes –trace-children=yes ./可执行程序名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//person.hpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __PERSON_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PERSON_H_</span></span><br><span class="line"><span class="comment">//要学会使用条件宏从而避免重复包含，否则会出现一些奇怪的错误，如</span></span><br><span class="line"><span class="comment">//person()的重载不支持，会报错，只能有一个person函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> MAN&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">person</span>;</span><span class="comment">//声明这个类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">        &#123;</span>                </span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">                <span class="comment">//属性</span></span><br><span class="line">                string name;</span><br><span class="line">                <span class="keyword">int</span> age;</span><br><span class="line">                <span class="keyword">int</span> male;<span class="comment">//0表示女，1表示男</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//构造与析构函数</span></span><br><span class="line">                <span class="built_in">person</span>();<span class="comment">//默认构造函数        </span></span><br><span class="line">                <span class="built_in">person</span>(string name);<span class="comment">//自定义构造函数</span></span><br><span class="line">                ~<span class="built_in">person</span>();<span class="comment">//默认析构函数</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//方法</span></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span>:        </span><br><span class="line">                </span><br><span class="line">        &#125;;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//person.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MAN::person::<span class="built_in">eat</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot;eat&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> MAN::person::<span class="built_in">sleep</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;        </span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot;sleeping&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> MAN::person::<span class="built_in">work</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;male)</span><br><span class="line">        &#123;                </span><br><span class="line">                cout &lt;&lt; name &lt;&lt; <span class="string">&quot;coding&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; name &lt;&lt; <span class="string">&quot;shopping&quot;</span> &lt;&lt; endl;                </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">MAN::person::<span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//默认构造函数是空的</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">MAN::person::<span class="built_in">person</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;<span class="comment">//构造对象后同时对对象的属性初始化</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">MAN::person::~<span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//默认析构函数也是空的</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp 文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> MAN;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        string s1 = <span class="string">&quot;linux&quot;</span>;</span><br><span class="line">        <span class="comment">//person *pPerson = new person;</span></span><br><span class="line">        person *pPerson = <span class="keyword">new</span> <span class="built_in">person</span>(s1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//pPerson-&gt;name = &quot;zhangsan&quot;;</span></span><br><span class="line">        pPerson-&gt;age = <span class="number">23</span>;</span><br><span class="line">        pPerson-&gt;male = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        pPerson-&gt;<span class="built_in">eat</span>();</span><br><span class="line">        pPerson-&gt;<span class="built_in">work</span>();</span><br><span class="line">        pPerson-&gt;<span class="built_in">sleep</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数与类的成员初始化"><a href="#构造函数与类的成员初始化" class="headerlink" title="构造函数与类的成员初始化"></a>构造函数与类的成员初始化</h3><p>1、构造函数一大功能就是初始化成员变量<br>(1)<strong>默认构造函数不带参，无初始化功能</strong><br>(2)若无其他构造函数，则默认构造函数可以省略。但若有个其他构造函数但还想使用默认构造函数，则默认构造函数不能省，必须写上。<br>(3)栈上分配对象时，若使用默认构造函数，则对象变量后面不加空的()，若用带参构造才需要加”(初始化参数)”</p>
<p>2、C++的成员初始化列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Person::<span class="built_in">Person</span>(string my_name, <span class="keyword">int</span> my_age, <span class="keyword">bool</span> my_male):<span class="built_in">name</span>(my_name),</span><br><span class="line">                                                         <span class="built_in">age</span>(my_age),</span><br><span class="line">                                                         <span class="built_in">male</span>(my_male)</span><br><span class="line">&#123;<span class="comment">//使用构造函数的参数给属性赋值</span></span><br><span class="line">                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="comment">// example 1,构造函数初始化列表</span></span><br><span class="line">    <span class="built_in">CExample</span>(): <span class="built_in">a</span>(<span class="number">0</span>),<span class="built_in">b</span>(<span class="number">8.8</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// example 2,构造函数内部赋值</span></span><br><span class="line">    <span class="built_in">CExample</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        a=<span class="number">0</span>;</span><br><span class="line">        b=<span class="number">8.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的例子中两个构造函数的结果是一样的。上面的构造函数（使用初始化列表的构造函数）显式的初始化类的成员；而没使用初始化列表的构造函数是对类的成员赋值，并没有进行显式的初始化<br><strong>(1)一般用于带参构造函数中，用来给属性传参赋值<br>(2)成员初始化列表和构造函数之间用冒号间隔，多个列表项之间用逗号间隔<br>(3)初始化列表可以替代构造函数内的赋值语句，达到同样效果</strong></p>
<p>3、构造函数使用参数默认值<br><strong>(1)class声明时可以给函数形参赋值一个默认值，实际调用时若不传参就使用默认值<br>(2)方法实现时形参可以不写默认值，但是实际是按照声明时的默认值规则的<br>(3)有默认值情况，要注意实际调用不能有重载歧义，否则编译不能通过</strong><br>要注意这样一种歧义情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">person</span>()&#123;&#125;;</span><br><span class="line"><span class="built_in">person</span>(string myname = <span class="string">&quot;linux&quot;</span>, <span class="keyword">int</span> myage = <span class="number">10</span>, <span class="keyword">bool</span> male = <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>这样去创建对象时:person pPerson;无法判断你是使用的无参数构造函数还是使用有了参数的并且设定了默认值的构造函数。</p>
<p>还有一种情况也会出现歧义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">person</span>(string myname, <span class="keyword">int</span> myage);</span><br><span class="line"><span class="built_in">person</span>(string myname, <span class="keyword">int</span> myage, <span class="keyword">bool</span> male = <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>因为第二个的最后一个形参有默认参数可以不传参，所以就会造成重载上的歧义。<br>函数重载不考虑参数的默认值，只看参数多个形参情况下，<strong>若有一个形参有默认参数，则其之后的形参也必须有默认参数，其之前的可以不必有。否则会报错。</strong><br>(4)所有参数都带默认值的构造函数，1个可以顶多个构造函数（举例说明）,通过传的参数个数和默认参数的结合实现多种情况:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">person</span>(string myname = <span class="string">&quot;linux&quot;</span>, <span class="keyword">int</span> myage = <span class="number">10</span>, <span class="keyword">bool</span> male = <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">person</span>(s1)</span><br><span class="line"><span class="built_in">person</span>(string myname, <span class="keyword">int</span> myage = <span class="number">10</span>, <span class="keyword">bool</span> male = <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">person</span>(s1, <span class="number">23</span>)</span><br><span class="line"><span class="built_in">person</span>(string myname, <span class="keyword">int</span> myage, <span class="keyword">bool</span> male = <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h3 id="拷贝构造函数的引入"><a href="#拷贝构造函数的引入" class="headerlink" title="拷贝构造函数的引入"></a>拷贝构造函数的引入</h3><p>1、用对象来初始化对象<br>(1)<strong>简单变量</strong>定义时，可以直接初始化，<strong>也可以用另一个同类型变量来初始化</strong>（间接初始化）。举例说明:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">//直接初始化</span></span><br><span class="line"><span class="keyword">int</span> b = a;<span class="comment">//间接初始化</span></span><br></pre></td></tr></table></figure>

<p>(2)用class来定义对象时，可以直接初始化，也可以用另一个对象来初始化。举例说明:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(“linux”, <span class="number">100</span>, <span class="number">0</span>)</span></span>;<span class="comment">//直接初始化，调用构造函数初始化</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;  <span class="comment">//间接初始化，调用拷贝构造函数初始化</span></span><br><span class="line">Person p2 = p1; <span class="comment">//间接初始化，调用拷贝构造函数初始化</span></span><br></pre></td></tr></table></figure>

<p>2、为什么可以<br>(1)变量的直接初始化，是变量在被分配内存之后直接用初始化值去填充赋值完成初始化<br>(2)变量用另一个变量来初始化，是给变量分配了内存后执行了一个内存复制操作来完成的初始化<br>(3)<strong>对象的直接初始化，是对象在分配内存之后调用了相应constructor来完成的初始化</strong><br>(4)<strong>对象用另一个对象来初始化，是对象在分配之后调用了相应的copy constructor来完成初始化</strong></p>
<p>3、拷贝构造函数<br>(1)拷贝构造函数是构造函数的一种，符合构造函数的一般性规则<br>(2)<strong>拷贝构造函数的引入是为了让对象在初始化时能够像简单变量一样的被直接用”=”来赋值</strong><br>(3)<strong>拷贝构造函数不需要重载，他的参数列表固定为const classname&amp; xx</strong><br>    &amp;表示引用<br>(4)拷贝构造函数很合适用初始化列表来实现<br>默认提供的拷贝函数会自动去完成拷贝，而我们自己写的拷贝函数需要自己去进行拷贝。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//person.hpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __PERSON_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PERSON_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> MAN</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//声明这个类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">                <span class="comment">//访问权限</span></span><br><span class="line">                <span class="keyword">public</span>:</span><br><span class="line">                        <span class="comment">//属性</span></span><br><span class="line">                        string name;</span><br><span class="line">                        <span class="keyword">int</span> age;</span><br><span class="line">                        <span class="keyword">bool</span> male;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//构造与析构函数</span></span><br><span class="line">                        <span class="built_in">person</span>(string myname, <span class="keyword">int</span> myage, <span class="keyword">bool</span> mymale);</span><br><span class="line">                        <span class="built_in">person</span>(<span class="keyword">const</span> person&amp; pn);  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">                        ~<span class="built_in">person</span>();</span><br><span class="line">                        <span class="keyword">int</span> *p;</span><br><span class="line">                        <span class="keyword">int</span> *p1;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//方法</span></span><br><span class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                        </span><br><span class="line">                <span class="keyword">private</span>:        </span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//person.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> MAN;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">person::eat</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot;eat&quot;</span> &lt;&lt; endl;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">person::work</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;male)</span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot; coding&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot; shopping&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">person::sleep</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot;sleep&quot;</span> &lt;&lt; endl;                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出对象中所有成员的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">person::print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name = &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;male = &quot;</span> &lt;&lt; male &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p = &quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot; p size:&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p) &lt;&lt;endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*p1 = &quot;</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-----------&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person::<span class="built_in">person</span>(string myname, <span class="keyword">int</span> myage, <span class="keyword">bool</span> mymale):<span class="built_in">name</span>(myname),<span class="built_in">age</span>(myage),<span class="built_in">male</span>(mymale)</span><br><span class="line"><span class="comment">//MAN::person::person(string myname, int myage, bool mymale)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">this</span>-&gt;p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;userdefined constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line">person::<span class="built_in">person</span>(<span class="keyword">const</span> person&amp; pn):<span class="built_in">name</span>(pn.name),<span class="built_in">age</span>(pn.age),<span class="built_in">male</span>(pn.male)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //使用初始化成员列表和以下方法的效果相同，已使用初始化列表，这里可以屏蔽</span></span><br><span class="line"><span class="comment">        this-&gt;name = pn.name;</span></span><br><span class="line"><span class="comment">        this-&gt;age = pn.age;</span></span><br><span class="line"><span class="comment">        this-&gt;male = pn.male;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(pn.p));</span><br><span class="line">        <span class="keyword">this</span>-&gt;p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*pn.p1); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person::~<span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;p;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;p1;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;userdefined destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> MAN;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//方式一：直接初始化</span></span><br><span class="line">        <span class="function">person <span class="title">p1</span><span class="params">(<span class="string">&quot;astyon&quot;</span>, <span class="number">35</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式二：用另一个对象来初始化新定义的对象</span></span><br><span class="line">        <span class="comment">//person p2=p1;  // OK </span></span><br><span class="line">        <span class="function">person <span class="title">p2</span><span class="params">(p1)</span></span>;   <span class="comment">// OK</span></span><br><span class="line">        </span><br><span class="line">        p1.<span class="built_in">print</span>();</span><br><span class="line">        p2.<span class="built_in">print</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么是访问权限问题"><a href="#什么是访问权限问题" class="headerlink" title="什么是访问权限问题"></a>什么是访问权限问题</h3><p>1、public访问权限是全局的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="keyword">public</span>的成员变量，在类的成员方法中可以直接访问</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)<span class="keyword">public</span>的成员变量，在任何外部代码中可以通过类的对象来直接访问</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)<span class="keyword">public</span>的成员方法，在类内其他成员方法中可以直接调用</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)<span class="keyword">public</span>的成员方法，在任何外部代码中可以通过类的对象来直接访问</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>)<span class="keyword">public</span>就是完全不设防</span><br></pre></td></tr></table></figure>

<p>2、private访问权限</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="keyword">private</span>的成员变量，在类的成员方法中可以直接访问</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)<span class="keyword">private</span>的成员变量，在任何外部代码中不可以通过对象来直接访问</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)<span class="keyword">private</span>的成员方法，在类内其他成员方法中可以直接调用</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)<span class="keyword">private</span>的成员方法，在任何外部代码中不可以通过对象来直接访问</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>)<span class="keyword">private</span>就是对内不设防，对外完全设防的</span><br></pre></td></tr></table></figure>

<p>3、更多关于访问权限问题的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="keyword">protected</span>是第三种访问权限修饰符，如果有必要还可以有第<span class="number">4</span>种甚至更多</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)访问权限叠加类的继承、<span class="keyword">static</span>、<span class="keyword">friend</span>等特性后才更加显出复杂性和威力</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)暂时只先引入这个概念，掌握基本用法和规则即可，后面逐步去深入</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)<span class="keyword">protected</span>: 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问</span><br></pre></td></tr></table></figure>

<h3 id="C-为什么要设计访问权限"><a href="#C-为什么要设计访问权限" class="headerlink" title="C++为什么要设计访问权限"></a>C++为什么要设计访问权限</h3><p>1、访问权限作用1：保护内部资源</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="keyword">private</span>的成员是<span class="class"><span class="keyword">class</span>内部使用，外部没必要直接访问（读取或赋值），所以干脆在语法上让你看不见</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(2)访问权限的保护是一种语法层面的保护，而非硬件上限制访问，硬件做不了这么细致</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(3)最终目的也是为了整个程序更安全</span></span><br></pre></td></tr></table></figure>

<p>2、访问权限作用2：隐藏外部无需关心的细节</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)将<span class="class"><span class="keyword">class</span>内部使用而外部绝不会用到的成员变量隐藏起来，以免干扰外部或者不小心被外部修改了</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(2)隐藏细节可以降低使用类库的人的难度，调用时只看到对我有用的东西</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(3)这个隐藏其实是把<span class="keyword">class</span>的作者和使用者专业分工，是很有必要的</span></span><br></pre></td></tr></table></figure>

<p>3、这就是面向对象的封装特性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)封装特性的体现之一就是抽象，抽象的一层意思就是隐藏掉不必要的细节</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)封装特性的体现之一就是组织和保护，便于整个整体和外部更合理的交流</span><br></pre></td></tr></table></figure>

<h3 id="访问权限带来的一些新编程理念"><a href="#访问权限带来的一些新编程理念" class="headerlink" title="访问权限带来的一些新编程理念"></a>访问权限带来的一些新编程理念</h3><p>1、只读或只写变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)问题：你的<span class="class"><span class="keyword">class</span>中需要一个变量，但是希望外部只能读不能写，怎么实现？</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(2)分析：硬件、<span class="title">OS</span>、编程语言都未提供这样的<span class="title">RO</span>或<span class="title">WO</span>的机制，只能间接实现了</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(3)解决方案：利用访问权限，将成员变量设计为<span class="title">private</span>，然后再通过封装成员方法来实现</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(4)如果只提供<span class="title">read</span>方法那就是只读成员，如果只提供<span class="title">write</span>方法那就是只写成员</span></span><br><span class="line"><span class="class"><span class="title">eg</span>:</span>上方的<span class="keyword">private</span>.<span class="built_in">cpp</span></span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>)这样的成员经常被称为属性（property），C#等高级编程语言中就源生支撑这种新编程思想</span><br></pre></td></tr></table></figure>

<p>2、复杂程序架构化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)简单程序规模小，参与人少，靠人本身的逻辑能力就能保证实现和质量</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)复杂程序规模大参与人多，协作成本高，水平良莠不齐，必须靠架构式设计才能保证实现和质量</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)架构化设计中权限管控的思想很重要，每一层的访问权限和主要关注点都不同</span><br></pre></td></tr></table></figure>

<p>3、为什么C语言不需要这些</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)C主要做裸机开发和OS内核开发，都是独立一体化程序，不隔离，所以不需要也没法管控权限</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)C程序一般规模小，不需要管控权限</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)C程序强调性能，而权限管控一定程度会牺牲性能(存储、运行速度等)。凡事都有两面性。</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)越是高级语言，编程越偏业务逻辑，就越需要权限管控和架构思想这些。</span><br></pre></td></tr></table></figure>

<h3 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h3><p>1、C和C++中struct的区别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)C中不支持成员函数（只能通过函数指针成员变量间接支持），而C++源生支持。</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)C中不支持<span class="keyword">static</span>成员，而C++中支持。后面会详细讲，C++ <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>是一个大知识点</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(3)访问权限，<span class="title">C</span>中默认<span class="title">public</span>，<span class="title">C</span>++中默认<span class="title">public</span>，但是可以显式指定<span class="title">public</span>/<span class="title">private</span>/<span class="title">protected</span>三者之一</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(4)继承特性上，<span class="title">C</span>中不支持（只能通过结构体包含来间接实现），而<span class="title">C</span>++源生支持，且</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>和<span class="keyword">class</span>可以互相继承</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(5)初始化方面，<span class="title">C</span>中靠初始化式（<span class="title">gcc</span>扩展了初始化语法），而<span class="title">C</span>++靠构造函数所以初始化更</span></span><br><span class="line"><span class="class">自由可定制化</span></span><br></pre></td></tr></table></figure>

<p>2、C++中struct和class的区别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)默认成员权限，<span class="class"><span class="keyword">struct</span>默认<span class="title">public</span>，<span class="keyword">class</span>默认<span class="title">private</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(2)继承关系的权限管控，<span class="keyword">struct</span>默认<span class="title">public</span>，<span class="keyword">class</span>默认<span class="title">private</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(3)<span class="keyword">struct</span>和<span class="keyword">class</span>交叉继承时，默认的权限管控取决于子类而不是基类</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(4)模板相关使用都用<span class="keyword">class</span>，而不用<span class="keyword">struct</span>了</span></span><br></pre></td></tr></table></figure>

<p>3、总结<br>(1)C++中struct和class差别不大，大多数情况下都可以直接替换使用而不出错<br>(2)C++中struct其实有点“人格分裂”，他既要兼容C中struct，又要像C++的class当struct有了一个构造函数，他C的初始化方式就不能用了。<br>(3)结论：<strong>除非是只需要打包几个变量数据就用C方式的struct，否则如果需要面向对象式编程就用class</strong></p>
<h3 id="const和mutable是干嘛的"><a href="#const和mutable是干嘛的" class="headerlink" title="const和mutable是干嘛的"></a>const和mutable是干嘛的</h3><p>1、const可以实现常函数<br>(1)<strong>常函数，就是class的成员函数承诺在函数内部不会修改class的任何成员变量，注意是任何一个</strong><br>(2)思考：C++为什么设计常函数？<br>  为了class的设计者和使用者更好的协作，避免错误的使用类库c++规定，使用函数的参数是一个const类型的引用，则该引用包括的所有成员方法必须是常方法，即常函数 </p>
<p>2、mutable可以局部打破const常函数<br>(1)<strong>const常函数承诺在函数内不会修改class的任何一个成员变量</strong><br>(2)<strong>但是有时候个别成员变量，就是需要在const的常函数中也能修改</strong>（注意只是个别，其他大部分是不需要修改的）<br>(3)怎么办？<br>2个解法：<strong>要么去掉const，要么使用mutable局部打洞</strong> </p>
<p>(4)const、mutable使用演示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//person.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __PERSON_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PERSON_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> MAN</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">person</span>;</span><span class="comment">//前置声明</span></span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">person</span>//声明这个类</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">                <span class="keyword">int</span> salary;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">                string name;</span><br><span class="line">                <span class="keyword">int</span> age;</span><br><span class="line">                </span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">add_age</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">radd_age</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">                <span class="keyword">int</span> grade;</span><br><span class="line">                <span class="keyword">mutable</span>        <span class="keyword">int</span> great_grade;</span><br><span class="line">        <span class="keyword">protected</span>:</span><br><span class="line">                        </span><br><span class="line">        &#125;;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//person.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> MAN;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">person::work</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot;is working.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">person::add_age</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age++;</span><br><span class="line">        <span class="keyword">this</span>-&gt;great_grade =<span class="number">149</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age =&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">person::radd_age</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//this-&gt;age++;//这个是不行的，可以取消注释，编译看看实际效果</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;great_grade++;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;age =&quot; &lt;&lt; this-&gt;age &lt;&lt; endl;        </span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;great_grade =&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;great_grade &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> MAN;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> person&amp; pn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        pn.<span class="built_in">radd_age</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        person human;</span><br><span class="line">        </span><br><span class="line">        human.name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">        human.age = <span class="number">22</span>;</span><br><span class="line">        <span class="comment">//human.grade = 59;</span></span><br><span class="line">        <span class="comment">//human.great_grade = 150;</span></span><br><span class="line">        </span><br><span class="line">        human.<span class="built_in">work</span>();</span><br><span class="line">        human.<span class="built_in">add_age</span>();</span><br><span class="line">        <span class="built_in">test</span>(human);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(5)思考：C++为什么设计mutable？<br>和private那里一样，还是“<strong>先全部禁了再按需打开</strong>”的思路。</p>
<p>3、class的前置声明<br>(1)就是class的声明，安慰编译器的<br>(2)看到了认识即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明这个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、inline 成员函数<br>(1)<strong>类的声明中直接写函数体，则此函数会被编译器inline化处理</strong><br>(2)类的声明中正常处理，而成员函数的实现中加inline<br>(3)<strong>inline的成员函数应该放在hpp中而不是cpp中，这个一定要注意，因为inline是在编译时替换的</strong><br>因为C/C++编译时是以当前.c文件为单位的，只考虑当前c文件，如果将inline函数放在另一个文件中，而在这个文件中有使用，编译时是会报错的，提示无法找到函数体，只有在c文件都编译完链接的时候才会发现，所以要将其放在头文件中。</p>
<p>5、本篇文章总结<br>(1)本篇文章主要在讲C++的封装特性，以及由此引发的各种细节语法特性。<br>(2)语法上掌握是第一层，会写代码跑起来是第二层，遇到问题能调出来是第三层，理解设计原理是第四层。</p>
<h2 id="C-的继承和多态特性"><a href="#C-的继承和多态特性" class="headerlink" title="C++的继承和多态特性"></a>C++的继承和多态特性</h2><h3 id="什么是面向对象的继承特性"><a href="#什么是面向对象的继承特性" class="headerlink" title="什么是面向对象的继承特性"></a>什么是面向对象的继承特性</h3><p>1、C++类的继承语法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span>访问控制（继承的权限描述） 基类名<span class="number">1</span>,访问控制 基类名<span class="number">2</span>,访问控制 基类名n</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 成员变量和成员方法列表（除了构造和析构之外的成员方法）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、什么是继承<br>(1)继承是C++源生支持的一种语法特性，是C++面向对象的一种表现<br>(2)<strong>继承特性可以让派生类“瞬间”拥有基类的所有（当然还得考虑权限）属性和方法</strong><br>(3)<strong>继承特性本质上是为了代码复用</strong>（在C语言中可以通过结构体变量中包含结构结构体变量来实现）<br>(4)类在C++编译器的内部可以理解为结构体，派生类是由基类成员叠加派生类新成员得到的</p>
<p>3、继承特性是天然的<br>(1)天然的意思就是：符合现实世界的本质规律，而不是纯粹人为施加的。<br>(2)继承inheritance和组合composition是软件重用的2种有效方式<br>(3)<strong>派生类,范围小,具体。 基类,范围大,抽象</strong><br>(4)派生类又叫子类，基类又叫父类。两种叫法都有人常用</p>
<h3 id="C-继承中的权限管控"><a href="#C-继承中的权限管控" class="headerlink" title="C++继承中的权限管控"></a>C++继承中的权限管控</h3><p>1、C++类中的访问权限管控<br>(1)public 类内部可以访问，类的外部可以访问<br>(2)private 类内部可以访问，类的外部不能访问<br>(3)protected 类内部可以访问，类的外部不能访问</p>
<p>2、继承时的三种权限设置对派生类的影响<br>(1)public继承（公有继承）：父类成员在子类中保持原有访问级别<br>(2)private继承（私有继承）：父类成员在子类中变为private成员<br>(3)protected继承（保护继承）：<strong>父类中public成员会变成protected</strong>,父类中protected成员仍然为protected,父类中private成员仍然为private<br>(4)<strong>如果继承时不写则默认情况下派生类为class时是private继承，而派生类为struct时是public继承</strong> </p>
<p>3、设计类时如何规定成员的访问权限<br>(1)需要被外界访问的成员直接设置为public<br>(2)只能在当前类中访问的成员设置为private<br>(3)只能在当前类和子类中访问的成员设置为protected。</p>
<p>总结：<br>（1）父类的public成员，<strong>经过public继承后</strong>，在子类中是public的。<br>（2）父类的private成员，<strong>经过public继承后</strong>，在子类中是比private还可怜的。意思是这个成员在子类中是存在的，意思是它不能被直接访问（子类的成员方法），怎么能访问？<br>  答：只能通过子类从父类继承而来的父类里实现了的成员函数来间接访问。此时使用的父类实现的函数以及访问的父类继承的成员变量都是子类中继承过来的，并不属于父类，都是子类的。<br>（3）父类的protected成员，<strong>经过public继承后</strong>，在子类中是protected的。意思就是该成员在子类中是子类内部成员可以访问，子类对象外部不可以访问，子类再次去继承产生孙类中他还是protected的。<br>（4）<strong>public继承，对于父类中public和protected成员的权限在子类中，其实是没有增强也没有削弱的；</strong>但是对于父类中private成员，其实在子类中是有削弱的（比private还可怜）<br>（5）<strong>如果是private继承，那么父类中的public成员和protected成员就变成了子类中的private成员，父类中的private成员成了子类中比private还可怜的那种成员。</strong><br>（6）<strong>如果是protected继承，那么父类中的public成员和protected成员就变成了子类中的protected成员，父类中的private成员成了子类中比private还可怜的那种成员。</strong></p>
<p>进一步总结：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、父类的<span class="keyword">private</span>成员，在三种继承下都会变成在子类中是比<span class="keyword">private</span>还可怜的这种成员</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、父类的<span class="keyword">public</span>成员，在<span class="keyword">public</span>继承下到子类中还是<span class="keyword">public</span>，在<span class="keyword">protected</span>继承下到子类</span><br><span class="line">中是<span class="keyword">protected</span>的，在<span class="keyword">private</span>继承下到子类中是<span class="keyword">private</span>的。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、父类的<span class="keyword">protected</span>成员，在<span class="keyword">public</span>继承下到子类中是<span class="keyword">protected</span>的，在<span class="keyword">protected</span>继承下</span><br><span class="line">到子类中是<span class="keyword">protected</span>的，在<span class="keyword">private</span>继承下到子类中是<span class="keyword">private</span>的。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、<span class="keyword">private</span>：如果是父类中的<span class="keyword">private</span>权限成员，那么在继承时会被降到比<span class="keyword">private</span>还惨的</span><br><span class="line">这种；而如果是<span class="keyword">private</span>继承，则不会导致父类中<span class="keyword">public</span>和<span class="keyword">protected</span>的成员降权到比</span><br><span class="line"><span class="keyword">private</span>还惨的这种，只会降级到<span class="keyword">private</span>权限。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、在继承中父类中所有的成员（不管哪种权限）都会被继承给子类，而不会丢失任何一个。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">父类中的成员继承到子类后的权限简单记忆方法：继承权限和继承的权限那个惨用哪个，即那</span><br><span class="line">个更严格用那个。</span><br><span class="line">eg:继承权限：<span class="class"><span class="keyword">class</span> <span class="title">person</span>:</span><span class="keyword">public</span></span><br><span class="line">   继承的权限：<span class="keyword">protected</span></span><br><span class="line">   父类中的成员继承到子类后的权限:<span class="keyword">protected</span></span><br></pre></td></tr></table></figure>

<h3 id="继承体系下子类和父类的关系"><a href="#继承体系下子类和父类的关系" class="headerlink" title="继承体系下子类和父类的关系"></a>继承体系下子类和父类的关系</h3><p>1、本质上是2个独立的类<br>(1)<strong>继承只是通过父类来快速构建子类的一种语法技术，继承后得到的子类和父类是独立的2个类</strong><br>(2)<strong>程序中子类的对象和父类的对象是2个独立的对象，没有任何关系，只是形成对象的模板有部分相同</strong><br>(3)子类对象中访问的子类从父类继承而来的成员，其实是属于子类自己的，并不是父类（对象）里面的</p>
<p>2、站在子类角度看继承<br>(1)非继承体系下的类，完全是自己“手工”构建的，所有成员根据访问权限不同而分为1个层级3大块（逻辑上）<br>(2)继承体系下的子类，部分直接从父类继承，部分自己手工打造，所有成员分成2个层级（继承来的，自己写的），每个层级3大块（访问权限）<br>(3)继承就是子类在构建自己的过程中使用的一种快速批量成员获取方法而已 </p>
<p> 3、为什么父类private成员在子类中还有<br>(1)思考：父类的所有成员在子类中都必须有吗？有没有可能父类有一个成员其实子类没必要具备的？<br>    答：1、不一定；2、有可能<br>(2)思考：如何做到在继承时让程序员指定父类的哪些成员参与继承，哪些不参与？<br>  答：可以通过某个关键字实现。但是C++并没有这么做，他选择了全继承。<br>(3)选择：继承就是父类所有成员全部按分类规则传给子类</p>
<p>4、为什么父类private成员在子类中还有但不能直接访问<br>(1)思考：这个规定是天然的，还是人为规定的？其实是：人为规定的。 因为：访问权限这一套本身就是人为的<br>(2)为什么这样设计1：如果能直接访问，那就打破了父类private的含义（父类私有），破坏了class的封装性<br>(3)为什么这样设计2：父类的private成员在子类中很大可能本来就不需要去访问，所以能直接访问反而有风险，没必要<br>(4)为什么这样设计3：间接访问合乎一个原则：在哪里定义的成员变量在哪里操作。子类和父类不是一个人写的时尤其要这样，避免问题<br>(5)这也是一个如何选择的设计哲学问题。 </p>
<h3 id="派生类和基类的构造析构关系"><a href="#派生类和基类的构造析构关系" class="headerlink" title="派生类和基类的构造析构关系"></a>派生类和基类的构造析构关系</h3><p>1、<strong>派生类并不继承基类的构造和析构函数，只继承成员变量和普通成员方法</strong><br>(1)不继承，意思是派生类中确实没有，不包含基类的构造和析构函数<br>(2)派生类自己有自己的构造和析构，规则和之前讲过的完全一样<br>(3)研究构造和析构函数时，一定要注意默认规则</p>
<p>2、<strong>派生类的构造函数一定会调用基类的构造函数，析构也一样</strong><br>(1)代码验证：在基类和派生类中都显式提供“默认构造”并添加打印信息，通过执行结果来验证</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()&#123; cout &lt;&lt; <span class="string">&quot;Person()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    ~<span class="built_in">Person</span>()&#123; cout &lt;&lt; <span class="string">&quot;~Person()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">man</span>:</span><span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">man</span>()&#123; cout &lt;&lt; <span class="string">&quot;man()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    ~<span class="built_in">man</span>()&#123; cout &lt;&lt; <span class="string">&quot;~man()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    man *m = <span class="keyword">new</span> <span class="built_in">man</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面代码输出：</span></span><br><span class="line"><span class="built_in">Person</span>()</span><br><span class="line"><span class="built_in">man</span>()</span><br><span class="line">~<span class="built_in">man</span>()</span><br><span class="line">~<span class="built_in">Person</span>()</span><br></pre></td></tr></table></figure>
<p>通过代码执行结果看到的现象总结：<strong>派生类的构造函数执行之前，会先调用基类的构造函数，然后再调用自己的构造函数。而在派生类的析构函数之后，会先执行自己的析构函数，再执行基类的析构函数。</strong></p>
<p>3、为什么派生类的构造（析构）必须调用基类的某个构造（析构）<br>(1)<strong>牢记构造函数的2大作用：初始化成员，分配动态内存</strong><br>(2)派生类和基类各自有各自的构造函数和析构函数，所以是各自管理各自的成员初始化，各自分配和释放各自所需的动态内存<br>(3)继承的语言特性，允许派生类调用基类的构造和析构函数，以管理派生类从基类继承而来的那些成员。<br>(4)明确：<strong>派生类的构造和析构处理的永远是派生类自己的对象，只是派生类对象模板中有一部分是从基类继承而来的而已。</strong></p>
<p>4、其他几个细节<br>派生类构造函数可以直接全部写在派生类声明的class中，也可以只在clas中声明时只写派生类构造函数名和自己的参数列表，不写继承基类的构造函数名和参数列表，而在派生类的cpp文件中再写满整个继承列表，这就是语法要求<br>(2)派生类析构函数则不用显式调用，直接写即可直接调用基类析构函数。猜测是因为参数列表问题。<br>(3)构造函数的调用顺序是先基类再派生类，而析构函数是先派生类再基类，遵循栈规则。<br>(4)派生类的构造函数可以在调用基类构造函数同时，用逗号间隔同时调用初始化式来初始化派生类自己的成员 </p>
<p>5、派生类做的三件事<br>(1)吸收基类成员：除过构造和析构函数以外的所有成员全部吸收进入派生类中<br>(2)更改继承的成员。1是更改访问控制权限(根据继承类型还有成员在基类中的访问类型决定) 2是同名覆盖(派生类中同名成员覆盖掉基类中)<br>(3)添加派生类独有的成员。</p>
<h3 id="派生类和基类的同名成员问题"><a href="#派生类和基类的同名成员问题" class="headerlink" title="派生类和基类的同名成员问题"></a>派生类和基类的同名成员问题</h3><p>1、<strong>派生类中再实现一个基类中的方法会怎样</strong><br>(1)代码实验：派生类和基类中各自实现一个内容不同但函数原型完全相同的方法，会怎么样？<br>(2)结论：<strong>基类对象调用的是基类的方法，派生类对象调用执行的是派生类中重新提供的方法</strong><br>(3)<strong>这种派生类中同名同参方法替代掉基类方法的现象，叫做：重定义（redefining），也有人叫做隐藏。</strong><br>(4)隐藏特性生效时派生类中实际同时存在2份同名同参（但在不同类域名中）的方法，同时都存在，只是一个隐藏了 另一个 </p>
<p>2、<strong>派生类中如何访问被隐藏的基类方法</strong><br>(1)<strong>派生类对象直接调用时，隐藏规则生效，直接调用的肯定是派生类中重新实现的那一个</strong><br>(2)<strong>将派生类强制类型转换成基类的类型，再去调用则这时编译器认为是基类在调用，则调用的是基类那一个，隐藏规则被绕过了</strong><br>(3)在派生类内部，使用父类::方法()的方式，可以强制绕过隐藏规则，调用父类实现的那一个 </p>
<p>3、注意和总结<br>(1)其实不止成员方法，成员变量也遵循隐藏规则。<br>(2)<strong>隐藏规则本质上是大小作用域内同名变量的认领规则问题，实际上2个同名成员都存在当前派生类的对象内存中的</strong><br>(3)<strong>隐藏（重定义，redefining）</strong>，与<strong>重载（overload）</strong>、<strong>重写（override，又叫覆盖）</strong>，这三个概念一定要区分清楚。 </p>
<h3 id="子类和父类的类型兼容规则"><a href="#子类和父类的类型兼容规则" class="headerlink" title="子类和父类的类型兼容规则"></a>子类和父类的类型兼容规则</h3><p>1、何为类型兼容规则<br>(1)C和C++都是强类型语言，任何变量和对象，指针，引用等都有类型，编译器根据类型来确定很多事<br>(2)派生类是基类的超集，基类有的派生类都有（但构造函数和析构函数例外），派生类有的基类不一定有，所以这2个类型间有关联<br>(3)派生类对象可以cast(类型转换相关的关键字)后当作基类对象，而基类对象不能放大成派生类对象，否则就可能会出错<br>(4)考虑到指针和引用与对象指向后，派生类和基类对象的访问规则就是所谓类型兼容规则。</p>
<p>2、类型兼容规则的常见情况及演示<br><strong>(1)子类对象可以当作父类对象使用，也就是说子类对象可以无条件隐式类型转换为一个父类对象，但是将父类强转成子类是隐藏危险的。<br>(2)子类对象可以直接初始化或直接赋值给父类对象<br>(3)父类指针可以直接指向子类对象<br>(4)父类引用可以直接引用子类对象</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()&#123; cout &lt;&lt; <span class="string">&quot;Person()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    ~<span class="built_in">Person</span>()&#123; cout &lt;&lt; <span class="string">&quot;~Person()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Person::eat()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">man</span>:</span><span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">man</span>()&#123; cout &lt;&lt; <span class="string">&quot;man()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    ~<span class="built_in">man</span>()&#123; cout &lt;&lt; <span class="string">&quot;~man()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;man::eat()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">eat</span>();</span><br><span class="line">        Person::<span class="built_in">eat</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    man m1;</span><br><span class="line"></span><br><span class="line">    Person&amp; p2 = m1;  <span class="comment">// 父类引用可以直接引用子类对象，类型兼容，没有警告没有错误，</span></span><br><span class="line">    p2.<span class="built_in">eat</span>();         <span class="comment">// 编译器在解析这句时，认为p2是 Person&amp; 类型的，所以会调用:Person::eat()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//man *m2 = &amp;p1; // 子类的指针指向父类，会编译报错，因为编译器认为父类对象不能直接当做之类对象使用</span></span><br><span class="line"></span><br><span class="line">    Person *p3 = &amp;p1;</span><br><span class="line">    Person *p4 = &amp;m1;  <span class="comment">// 父类的指针指向子类的对象，类型兼容，没有警告没有错误，</span></span><br><span class="line">    p4-&gt;<span class="built_in">eat</span>();         <span class="comment">// 编译器在解析这句时，认为p2是 Person* 类型的，所以会调用:Person::eat()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span>()</span><br><span class="line"><span class="built_in">Person</span>()</span><br><span class="line"><span class="built_in">man</span>()</span><br><span class="line">Person::<span class="built_in">eat</span>()</span><br><span class="line">Person::<span class="built_in">eat</span>()</span><br><span class="line">~<span class="built_in">man</span>()</span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">~<span class="built_in">Person</span>()</span><br></pre></td></tr></table></figure>

<p>3、总结<br>(1)派生类对象可以作为基类的对象使用，但是只能使用从基类继承的成员。<br>(2)类型兼容规则是<strong>多态性</strong>的重要基础之一。<br>(3)总结：子类就是特殊的父类 (base *p = &child;)</p>
<h3 id="继承的优势与不良继承"><a href="#继承的优势与不良继承" class="headerlink" title="继承的优势与不良继承"></a>继承的优势与不良继承</h3><p>1、为什么会有继承<br>(1)本质上为了代码复用<br>(2)继承方式很适合用来构建复杂框架体系<br>(3)用继承来设计类进而构建各层级对象，符合现实中的需要。举例：描述人的种群</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">人类</span><br><span class="line">男人     女人</span><br><span class="line">小男孩   青年   中年男人   老年男人</span><br></pre></td></tr></table></figure>

<p>2、何为不良继承<br>(1)鸵鸟不是鸟问题。因为鸵鸟从鸟继承了fly方法但是鸵鸟不会飞<br>(2)圆不是椭圆问题。因为圆从椭圆继承了长短轴属性然而圆没有长短轴属性<br>(3)不良继承是天然的，是现实世界和编程的继承特性之间的不完美契合</p>
<p>3、如何解决不良继承<br>(1)修改继承关系设计。既然圆继承椭圆是一种不良类设计就应该杜绝。去掉继承关系，两个类可以继承自同一个共同的父类，不过该类不能执行不对称的setSize计算，然后在圆和椭圆这2个子类中分别再设计以区分<br>(2)所有不良继承都可以归结为“圆不是椭圆”这一著名具有代表性的问题上。在不良继承中，基类总会有一些额外能力，而派生类却无法满足它。这些额外的能力通常表现为一个或多个成员函数提供的功能。要解决这一问题，<strong>要么使基类弱化，要么消除继承关系</strong>，需要根据具体情形来选择。 </p>
<h3 id="组合介绍以及与继承对比"><a href="#组合介绍以及与继承对比" class="headerlink" title="组合介绍以及与继承对比"></a>组合介绍以及与继承对比</h3><p>1、什么是组合<br>(1)composition，组合，就是在一个class内使用其他多个class的对象作为成员<br>(2)用五官做案例讲解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">eye</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">eyebrow</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">nose</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mouth</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ear</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FacialFeatures</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    eye      ey;</span><br><span class="line">    eyebrow  eb;</span><br><span class="line">    nose     n;</span><br><span class="line">    mouth    m;</span><br><span class="line">    ear      er;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>(3)组合也是一种代码复用方法，本质也是结构体包含</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用组合的方式实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    C c;</span><br><span class="line">    <span class="keyword">short</span> s1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用继承的方式实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A, <span class="keyword">public</span> B, <span class="keyword">public</span> C </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">short</span> s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、继承与组合的特点对比<br>(1)继承是a kind of（is a）关系，具有传递性,不具有对称性。<br>(2)组合是a part of（has a）的关系，<br>(3)继承是白盒复用。因为类继承允许我们根据自己的实现来覆盖重写父类的实现细节，父类的实现对于子类是可见的。<br>(4)继承的白盒复用特点，一定程度上破坏了类的封装特性，因为这会将父类的实现细节暴露给子类<br>(5)组合属于黑盒复用。被包含对象的内部细节对外是不可见的，所以它的封装性相对较好，实现上相互依赖比较小<br>(6)组合中被包含类会随着包含类创建而创建，消亡而消亡。组合属于黑盒复用，并且可以通过获取其它具有相同类型的对象引用或指针，在运行期间动态的定义组合（例如上边提到的子类对象可作为一个父类对象使用）。而缺点就是致使系统中的对象过多。<br>(7)OO设计原则是<strong>优先组合，而后继承</strong> </p>
<h3 id="多继承及其二义性问题"><a href="#多继承及其二义性问题" class="headerlink" title="多继承及其二义性问题"></a>多继承及其二义性问题</h3><p>1、多继承<br>(1)多继承就是一个子类有多个父类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;</span>派生类名&gt;:&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">    &lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>(2)多继承演示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类 Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line">      <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类 PaintCost</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintCost</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getCost</span><span class="params">(<span class="keyword">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> area * <span class="number">70</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line">   <span class="keyword">int</span> area;</span><br><span class="line"> </span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">   area = Rect.<span class="built_in">getArea</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出总花费</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total paint cost: $&quot;</span> &lt;&lt; Rect.<span class="built_in">getCost</span>(area) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)多继承和单继承的原理，效果并无明显区别<br>(4)多继承会导致二义性问题</p>
<p>2、多继承的二义性问题1<br>(1)场景：<strong>C多继承自A和B，则C中调用A和B的同名成员时会有二义性</strong><br>(2)原因：<strong>C从A和B各自继承了一个同名（不同namespace域）成员，所以用C的对象来调用时编译器无法确定我们想调用的是哪一个</strong><br>(3)解决办法1：避免出现，让A和B的public成员命名不要重复冲突。但这个有时不可控。<br>(4)解决办法2：编码时明确指定要调用哪一个，用c.A::func()明确指定调用的是class A的func而不是class B的<br>(5)解决办法3：在C中重定义func，则调用时会调用C中的func，A和B中的都被隐藏了<br>(6)总结：能解决，但是都没有很好的解决。 </p>
<p>3、多继承的二义性问题2<br>(1)场景：菱形继承问题。即A为祖类，B1:A, B2:A, C:B1,B2，此时用C的对象调用A中的某个方法时会有二义性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>:</span> <span class="keyword">public</span> A&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span>:</span> <span class="keyword">public</span> A&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B1, <span class="keyword">public</span> B2&#123;.....&#125;;</span><br></pre></td></tr></table></figure>
<p>(2)分析：c.func()有二义性，c.A::func()也有二义性，但是c.B1::func()和c.B2::func()却没有二义性<br>(3)解决办法：和问题1中的一样，但是问题2更隐蔽，也更难以避免</p>
<p>4、总结<br>(1)二义性就是歧义，好的情况表现为编译错误，不好的情况表现为运行时错误，最惨的情况表现为运行时莫名其妙<br>(2)随着系统的变大和变复杂，难免出现二义性，这不是程序员用不用心的问题，是系统自身带来的<br>(3)<strong>解决二义性问题不能靠程序员个人的细心和调试能力，而要靠机制，也就是编程语言的更高级语法特性</strong><br>(4)<strong>虚函数、虚继承、纯虚函数、抽象类、override（重写，覆盖）、多态等概念就是干这些事的</strong><br>(5)感慨：欲戴王冠必承其重，要揽瓷器活就得有金刚钻，C++学得越清楚就越能想象将来用C++去解决的都是些什么层次的问题 </p>
<h3 id="虚继承解决菱形继承的二义性问题"><a href="#虚继承解决菱形继承的二义性问题" class="headerlink" title="虚继承解决菱形继承的二义性问题"></a>虚继承解决菱形继承的二义性问题</h3><p>1、虚继承怎么用<br>(1)场景：菱形继承导致二义性问题，本质上是在孙子类C中有B1和B2中包含的2份A对象，所以有了二义性。<br>(2)虚继承解决方案：让A和B虚继承D，C再正常多继承A和B即可，虚继承会使得C继承A、B时只选择AB其中的一份D，不会重复，类似于头文件不重复包含</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>()&#123;cout&lt;&lt;<span class="string">&quot;D()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">D</span>()&#123;cout&lt;&lt;<span class="string">&quot;~D()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> D</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;B()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;~B()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> D</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;~A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> B, <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>()&#123;cout&lt;&lt;<span class="string">&quot;C()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">C</span>()&#123;cout&lt;&lt;<span class="string">&quot;~C()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    C c;   <span class="comment">//D, B, A ,C</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(c)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)<strong>虚继承就这么简单，就是为了解决菱形继承的二义性问题而生，和虚函数（为了实现多态特性）并没有直接关系</strong></p>
<p>2、虚继承的实现原理<br>(1)虚继承的原理是：虚基类表指针vbptr 和 虚基类表virtual table<br>  vbptr指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。<br>  菱形继承中，两个虚基类表指针vbptr通过指针偏移量来找寻虚基类表（避免了二义性），但通过两个虚基类表最终找到的是同一个基类。<br>详解参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiejingfa/article/details/48028491">https://blog.csdn.net/xiejingfa/article/details/48028491</a> </p>
<h3 id="多态和虚函数"><a href="#多态和虚函数" class="headerlink" title="多态和虚函数"></a>多态和虚函数</h3><p>1、通过案例学多态<br>(1)案例：父类Animal，2个子类Dog和Cat，实现speak方法<br>(2)用父类指针指向各对象，调用各方法看效果，记下来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Animal::speak</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Speaking!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dog::speak</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wang wang wang!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cat::speak</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;miao miao miao!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal a;</span><br><span class="line">    Dog d;</span><br><span class="line">    Cat c;</span><br><span class="line">    </span><br><span class="line">    a.<span class="built_in">speak</span>();  <span class="comment">// 打印 Speaking!</span></span><br><span class="line">    d.<span class="built_in">speak</span>();  <span class="comment">// 打印 wang wang wang!</span></span><br><span class="line">    c.<span class="built_in">speak</span>();  <span class="comment">// 打印 miao miao miao!</span></span><br><span class="line"></span><br><span class="line">    Animal *p; </span><br><span class="line">    p = &amp;a;</span><br><span class="line">    p-&gt;<span class="built_in">speak</span>();  <span class="comment">// 打印 Speaking!</span></span><br><span class="line"></span><br><span class="line">    p = &amp;d;</span><br><span class="line">    p-&gt;<span class="built_in">speak</span>();  <span class="comment">// 打印 Speaking!</span></span><br><span class="line">    </span><br><span class="line">    p = &amp;c;</span><br><span class="line">    p-&gt;<span class="built_in">speak</span>();  <span class="comment">// 打印 Speaking!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Speaking!</span><br><span class="line">wang wang wang!</span><br><span class="line">miao miao miao!</span><br><span class="line">Speaking!</span><br><span class="line">Speaking!</span><br><span class="line">Speaking!</span><br></pre></td></tr></table></figure>
<p>(3)将父类speak方法声明为virtual，再用父类指针调用各方法看效果，记下来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// 添加 virtual 关键字</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Speaking!</span><br><span class="line">wang wang wang!</span><br><span class="line">miao miao miao!</span><br><span class="line">Speaking!</span><br><span class="line">wang wang wang!</span><br><span class="line">miao miao miao!</span><br></pre></td></tr></table></figure>
<p>(4)对比差异，理解什么叫多态</p>
<p>2、什么是多态<br>(1)<strong>polymorphism，多态，面向对象的三大特征之一</strong>。<br>(2)<strong>从宏观讲，多态就是要实现一套逻辑多种具体适配的执行结果</strong>。猫就应该是猫的叫声，狗就应该是狗的叫声.<br>(3)<strong>从微观讲，多态就是要一套代码在运行时根据实际对象的不同来动态绑定/跳转执行相匹配的具体函数</strong>.<br>(4)<strong>函数声明前加virtual的即是虚函数</strong><br>(5)虚函数是C++实现多态特性的基础，从语法上讲多态特性的基类方法必须是虚函数 </p>
<p>3、多态中的override（复写）<br>(1)<strong>基类中方法声明为virtual，派生类中重新实现同名方法以实现多态，这就叫override</strong>（中文为覆盖，或重写）<br>(2)注意区分<strong>override</strong>和<strong>redefining</strong>，微观上最大区别就是是否有virtual，宏观上最大区别就是是否表现为多态</p>
<p>4、多态一定要通过面向对象和override来实现吗？<br>(1)<strong>宏观上的多态是一种编程效果，微观上的多态是一种C++支持的编程技术，微观是为了去实现宏观</strong><br>(2)不用C++的virtual和override，也可以实现宏观上的多态，C中我们就经常这么干。<br>(3)C中实现多态的案例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Cat,</span><br><span class="line">    Dog</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dog_speak</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wang wang wang!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cat_speak</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;miao miao miao!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (type == Dog)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Dog_speak</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == Cat)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Cat_speak</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tmp);</span><br><span class="line">    <span class="built_in">speak</span>(tmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4)C++源生支持多态，实现起来更容易，后续修改和维护更容易，架构复杂后优势更大。</p>
<p>5、对比<strong>重载、重定义、重写</strong>三个概念<br>(1)<strong>overload，重载</strong>  同一个类里面的多个方法，函数名相同但参数列表不同<br>(2)<strong>redifining，重定义，隐藏</strong>  继承中子类再次实现父类中同名方法然后把父类方法隐藏掉<br>(3)<strong>override，覆盖，重写</strong>  继承中子类去实现父类中同名virtual方法然后实现多态特性 </p>
<h3 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h3><p>(1)<strong>纯虚函数就是基类中只有原型没有实体的一种虚函数</strong><br>(2)<strong>纯虚函数形式：virtual 函数原型=0；</strong><br>纯虚函数在实现多态时与虚函数一样，可当作虚函数使用。<br>(3)代码实践：在基类Animal中使用纯虚函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span>=<span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cat::speak</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;miao miao miao!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal *p;</span><br><span class="line">    Cat c;</span><br><span class="line"></span><br><span class="line">    p = &amp;c;</span><br><span class="line">    p-&gt;<span class="built_in">speak</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4)纯虚函数为什么没有实体？<br>  因为语义上不需要<br>(5)纯虚函数是否占用内存？<br>  不会，因为<strong>纯虚函数所在的类根本无法实例化对象！</strong></p>
<p>2、抽象类(abstract type)<br><strong>(1)带有纯虚函数的类成为抽象类。抽象类只能作为基类来派生新类，不可实例化对象（即抽象类不可用来定义对象）。<br>(2)派生类 必须实现 基类的纯虚函数 后 才能用于实例化对象。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;wang wang wang!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Animal p;  // 会编译报错，因为抽象类不能用来实例化对象</span></span><br><span class="line">    Dog g;     <span class="comment">// 正常，因为子类实现了基类的纯虚函数，已经不是抽象类了，可以用来实例化对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)抽象类的作用：将有关的数据和行为组织在一个继承层次结构中，保证派生类必须具有所要求的方法。对应暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现。这种机制可以让语法和语义保持一致。<br>(4)<strong>抽象类的子类必须实现基类中的纯虚函数，这样子类才能创建对象，否则子类就还是个抽象类</strong></p>
<p>3、接口（interface）<br>(1)接口是一种特殊的类，用来定义一套访问接口，也就是定义一套规约<br>(2)<strong>接口类中不应该定义任何成员变量</strong><br>(3)<strong>接口类中所有成员函数都是公有且都是纯虚函数</strong><br>(4)有些高级语言中直接提供关键字interface定义接口，接口其实就是个纯粹的抽象基类</p>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>1、什么是虚析构函数<br>(1)析构函数前加virtual，则析构函数变为虚析构函数<br>(2)规则：<strong>基类有1个或多个虚函数时（注意不要求是纯虚函数），则其析构函数应该声明为virtual</strong></p>
<p>2、为什么需要虚析构函数<br>(1)代码演示：父子类各自添加析构函数，用2种分配和回收对象的方式分别实验，观察析构函数被调用的规律</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span>=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>();</span><br><span class="line">    <span class="comment">//~Animal();//这个和上面的执行结果相同</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~Animal()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">Cat</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Cat::~<span class="built_in">Cat</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~cat()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cat::speak</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;miao miao miao!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal *p;</span><br><span class="line">    Cat c;</span><br><span class="line"></span><br><span class="line">    p = &amp;c;</span><br><span class="line">    p-&gt;<span class="built_in">speak</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">miao miao miao!</span><br><span class="line">~<span class="built_in">cat</span>()</span><br><span class="line">~<span class="built_in">Animal</span>()</span><br></pre></td></tr></table></figure>
<p>上面这种情况实际析构时只执行了子类Cat的析构函数，并没有执行父类Animal的析构函数，是子类的析构函数调用了父类的析构函数.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span>=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>();</span><br><span class="line">    <span class="comment">//~Animal();//这个和上面的执行结果不相同</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~Animal()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">Cat</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Cat::~<span class="built_in">Cat</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~cat()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cat::speak</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;miao miao miao!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal *p = <span class="keyword">new</span> <span class="built_in">Cat</span>();<span class="comment">//对象是Cat类对象，分配在堆上</span></span><br><span class="line">    p-&gt;<span class="built_in">speak</span>();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当 <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>();时，输出：</span><br><span class="line">miao miao miao!</span><br><span class="line">~<span class="built_in">cat</span>()</span><br><span class="line">~<span class="built_in">Animal</span>()</span><br><span class="line"></span><br><span class="line">当 ~<span class="built_in">Animal</span>(); 时，输出：</span><br><span class="line">miao miao miao!</span><br><span class="line">~<span class="built_in">Animal</span>()</span><br><span class="line">上面这种情况实际析构时只执行了父类Animal的析构函数，并没有执行子类Cat的析构函数。</span><br></pre></td></tr></table></figure>
<p>(2)结论：<strong>虚析构函数在各种情况下总能调用正确的（和对象真正匹配的）析构函数</strong>。</p>
<p>3、分析和总结<br>(1)<strong>其实虚函数的virtual的价值，就是让成员函数 在运行时 动态解析 和 绑定 具体执行的函数，这是RTTI机制（动态运行时类型识别机制）的一部分</strong>。<br>(2)析构函数也是成员函数，加virtual的效果和普通成员函数加virtual没什么本质差异<br>(3)<strong>加virtual是有开销的，运行时动态绑定不如编译时静态绑定效率高资源消耗优，但是可以多态</strong>。 </p>
<h3 id="using重新定义继承时访问权限"><a href="#using重新定义继承时访问权限" class="headerlink" title="using重新定义继承时访问权限"></a>using重新定义继承时访问权限</h3><p>1、using关键字 在非public继承时的 权限重开作用<br>(1)<strong>父类的public方法在private/protected继承时，到了子类就成了private/protected而不是public了，无法用子类对象来调用了</strong><br>(2)解决方法1：是改为public继承，有用但是有时候不得不protected或者private继承时就没办法了<br>(3)解决方法2：是在子类中再实现一个public的方法，内部调用父类继承而来的那个方法，能用但是有点麻烦而且有额外开销<br>(4)解决方法3：是在子类中使用using关键字将该方法声明为public访问权限，本质上类似于权限打洞<br>(5)用法：在子类public声明中使用 <strong>using Base::func;</strong> 即可，不带返回值类型不带参数列表。<br>(6)注意：using只用于private/protected继承中的权限损失找回，如果方法在父类中本来就是private的子类中没法using后访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">father</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">live</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">father::work</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I am working.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">father::live</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I am living.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span>:</span><span class="keyword">private</span> father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">way</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="keyword">using</span> father::live;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">son::way</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">work</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    son s;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">way</span>();</span><br><span class="line">    s.<span class="built_in">live</span>();  <span class="comment">// live是通过private继承过来的，权限会变成private，正常不能像这样通过</span></span><br><span class="line">               <span class="comment">// 对象来访问，但是使用了   using father::live; 就可以了</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>权限 本身是 编译器在编译时的一种设定。</p>
<p>3、C++继承和多态特性总结<br>(1)本部分主要讲了OO的2个特性：<strong>继承和多态</strong>，其中继承和权限管控、继承中的构造和析构、隐藏和覆盖、虚函数和多态、纯虚函数和抽象类、接口、静态和动态绑定等是重点。<br>(2)面向对象三大特征中：<strong>封装是基础、继承是关键、多态是延伸</strong>。<br>(3)本部分内容很重要，属于C++知识体系中关键基础零件，对于以后理解复杂代码和架构意义重大，必须彻底理解和熟悉。<br>(4)要求要见过、认识、会写、理解原理、熟练运用。 </p>
<h2 id="C-的运算符重载"><a href="#C-的运算符重载" class="headerlink" title="C++的运算符重载"></a>C++的运算符重载</h2><h3 id="运算符重载引入"><a href="#运算符重载引入" class="headerlink" title="运算符重载引入"></a>运算符重载引入</h3><p>1、从函数重载说起<br>(1)<strong>函数重载是在一定作用域内，多个相同名称但不同参数列表的函数重载</strong><br>(2)<strong>编译时由编译器根据实际调用时给的实参情况来判定本次实际用哪个函数，这个过程叫重载决策</strong><br>(3)<strong>重载函数本质上就是多个独立函数，重载机制在编译时发生，运行时不参与</strong><br>(4)函数重载的意义就是避免我们胡乱起名，方便编写类库覆盖所有可能操作，是一种语法糖 </p>
<p>2、什么是运算符重载<br>(1)什么是运算符？<br>  譬如+ - * / %等算术运算符和&gt; &lt; == !=等关系运算符就是典型的可重载运算符（但不是所有的运算符都可以重载，譬如sizeof）<br>(2)运算符诞生于C语言中，用来对变量进行某种“预定义”的运算操作，这种预定义是编译器预制好的，编译时会翻译对应到CPU机器码<br>(3)面向对象时代带来新的问题：两个对象如何运算？<br>  譬如：Person a, b, c; c = a + b; 此处的+让编译器如何解读？见下面示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1, p2, p3;</span><br><span class="line"></span><br><span class="line">    p3 = p1 + p2;  <span class="comment">// 这里会编译报错，因为编译器不知道如何去解析 &quot;+&quot; 运算符</span></span><br><span class="line">                   <span class="comment">// 要让编译器认识这个 &quot;+&quot; ,需要在Person类中实现 operator+ 函数</span></span><br><span class="line">                   <span class="comment">// 这就是&quot;+&quot;运算符重载</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、运算符重载示例<br>(1)class coordinate, 2个属性x和y，直接对2个对象执行+，编译不通过<br>(2)重载+运算符后，再编译并执行，查看结果，分析结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">coordinate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;  <span class="comment">//x轴的坐标</span></span><br><span class="line">    <span class="keyword">int</span> y;  <span class="comment">//y轴的坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">coordinate</span>();</span><br><span class="line">    <span class="built_in">coordinate</span>(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义类的时候，提供一个运算符重载的对应的解析函数即可</span></span><br><span class="line">    coordinate <span class="keyword">operator</span>+(<span class="keyword">const</span> coordinate&amp; other);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">coordinate::<span class="built_in">coordinate</span>()</span><br><span class="line">&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">coordinate::<span class="built_in">coordinate</span>(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0)</span><br><span class="line">&#123;   </span><br><span class="line">    x = x0;</span><br><span class="line">    y = y0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">coordinate::print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">coordinate coordinate::<span class="keyword">operator</span>+(<span class="keyword">const</span> coordinate&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在该函数内实现 “+” 应该实现的操作</span></span><br><span class="line">    coordinate tmp;</span><br><span class="line"></span><br><span class="line">    tmp.x = <span class="keyword">this</span>-&gt;x + other.x;</span><br><span class="line">    tmp.y = <span class="keyword">this</span>-&gt;y + other.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">coordinate <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">coordinate <span class="title">b</span><span class="params">(<span class="number">2</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    coordinate c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//c = a + b;//编译时被翻译成 c = a.operator+(b)</span></span><br><span class="line">    c = a.<span class="keyword">operator</span>+(b);<span class="comment">//和上边等效</span></span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line">    c.<span class="built_in">print</span>();    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line">(<span class="number">3</span>,<span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<h3 id="深度理解运算符重载"><a href="#深度理解运算符重载" class="headerlink" title="深度理解运算符重载"></a>深度理解运算符重载</h3><p>1、运算符重载的本质<br>(1)表面上，<strong>运算符重载是对C++源生运算符的意义，在某个class中做重定义</strong><br>(2)本质上，<strong>运算符被映射到执行相应的成员函数，所以运算符重载其实是重定义对象的运算符所对应的函数</strong></p>
<p>2、运算符重载的意义<br>(1)运算符重载是一种语法特性，C++全面支持，Java不支持，python有限度的支持<br>(2)没有运算符重载照样写代码，所有操作全部通过显式调用相应成员函数来完成即可<br>(3)运算符重载是一种语法糖，可以让代码“看起来更简洁，更优雅”，将复杂实现隐藏在类的内部<br>(4)运算符重载机制加大了类库作者的工作量，减少了调用类库写功能的人的书写量<br>(5)C++支持运算符重载机制有其理念和历史原因，是对写法简洁和效率优秀的综合考量<br>(6)<strong>赋值运算符，=重载和引用结合，可有效提升代码效率，</strong>后面会有案例详解<br>(7)<strong>赋值运算符=重载时要注意有指针成员时会涉及浅拷贝和深拷贝，后面会有案例详解</strong><br>(8)<strong>运算符重载一定程度上体现了C++的多态性，因为同样的运算符在不同的class中表现是不同的</strong></p>
<p>3、运算符重载如何学习<br>(1)本篇文章内讲的基本理论、写法、理解方法等要全部掌握，见了认识、理解原理、会用。<br>(2)实际工作中遇到别人的类库中有使用运算符重载时，利用本篇文章讲的基础原理去研究和理解，看懂并用好，如此可加深功力。</p>
<h3 id="理解运算符重载的关键点"><a href="#理解运算符重载的关键点" class="headerlink" title="理解运算符重载的关键点"></a>理解运算符重载的关键点</h3><p>1、理解运算符重载机制的两部曲<br>(1)记住、理解、并且能轻松认出写出运算符重载函数的格式、名称、对应的运算符。<br>(2)理解在运算符重载函数中this表示谁，参数表示谁，返回值对应谁，这个是重中之重。</p>
<p>2、通过代码实践来深度理解运算符重载函数<br>(1)运算符 + 的重载中的对应关系回顾<br>  总结：<strong>a + b; -&gt; a.operator+(b)，a对应this，b对应函数参数other，a+b的表达式的值对应函数返回值</strong><br>(2)运算符=的重载中的对应关系</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">coordinate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;<span class="comment">//x轴的坐标</span></span><br><span class="line">    <span class="keyword">int</span> y;<span class="comment">//y轴的坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">coordinate</span>();</span><br><span class="line">    <span class="built_in">coordinate</span>(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义类的时候，提供一个运算符重载的对应的解析函数即可</span></span><br><span class="line">    coordinate <span class="keyword">operator</span>+(<span class="keyword">const</span> coordinate&amp; other);</span><br><span class="line">    <span class="comment">//coordinate operator=(const coordinate&amp; other);</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> coordinate&amp; other);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">coordinate coordinate::<span class="keyword">operator</span>+(<span class="keyword">const</span> coordinate&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在该函数内实现 “+” 应该实现的操作</span></span><br><span class="line">    coordinate tmp;</span><br><span class="line"></span><br><span class="line">    tmp.x = <span class="keyword">this</span>-&gt;x + other.x;</span><br><span class="line">    tmp.y = <span class="keyword">this</span>-&gt;y + other.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">coordinate coordinate::operator=(const coordinate&amp; other)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    //在该函数内实现 “=” 应该实现的操作</span></span><br><span class="line"><span class="comment">    this-&gt;x = other.x;</span></span><br><span class="line"><span class="comment">    this-&gt;y = other.y;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return *this;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">上述两个“=”不同的运算符重载函数对于表达式</span><br><span class="line">d = (c = a);</span><br><span class="line">有着不同的结果，但对于表达式</span><br><span class="line">c = a;</span><br><span class="line">而言，结果是相同的，赋值操作是在函数内部就已经完成的，和返回值无关</span><br></pre></td></tr></table></figure>
<p>总结：c = a; -&gt; c.operator=(a); c对应this，a对应other，c=a整个表达式的值（其实就是c）对应函数返回值<br>运算符重载总的规则：运算符左边的是this，右边的是other，运算符加操作数的整个表达式的返回值就是返回值</p>
<p>3、运算符=的默认提供问题<br>(1)=运算符有点特殊，编译器会提供一个默认的=运算符的重载，所以不提供时也能用<br>(2)如果自己显式写了=运算符的重载函数，则会覆盖编译器自动提供的那一个</p>
<p>4、+=运算符<br>(1)运算符+=的重载中的对应关系</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> coordinate::<span class="keyword">operator</span>+=(<span class="keyword">const</span> coordinate&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x = <span class="keyword">this</span>-&gt;x + other.x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = <span class="keyword">this</span>-&gt;y + other.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为我们一般不会写：c = (a+=b);这样的表达式，所以这个运算符函数重载函数不需要返回值</span></span><br></pre></td></tr></table></figure>
<p>总结：a += b; -&gt; a.operator+=(b); a对应this，b对应other，a+=b的整体表达式对应返回值</p>
<p>5、总结<br>(1)编译器会为每个自定义class提供一个默认的赋值运算符的重载，而我们可以覆盖这个重载<br>(2)盯紧表达式实际对应执行哪个函数，盯紧函数的参数是谁，this是谁，返回值是谁，一切都清楚了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a是this，b是other， a &gt; b这个整体表达式的bool值就是返回值，所以返回值才是关键</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)a+b有可能不等于b+a，这个也是运算符重载衍生出来的不好把控的风险问题<br>(4)运算符重载给了类库作者非常大自由度，所以容易失控，实际中不乏写的很雷人的运算符重载，或者纯粹炫技的代码惹人讨厌</p>
<h3 id="运算符重载函数中的细节"><a href="#运算符重载函数中的细节" class="headerlink" title="运算符重载函数中的细节"></a>运算符重载函数中的细节</h3><p>1、赋值运算符重载与拷贝构造函数<br>(1)区分初始化时的赋值（一般就叫初始化），和非初始化时的赋值（一般就叫赋值）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">“=”运算符重载函数中：<span class="keyword">return</span> *<span class="keyword">this</span>;会执行拷贝构造函数</span><br><span class="line"></span><br><span class="line">    <span class="function">coordinate <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    coordinate c = a;<span class="comment">//通过类的拷贝构造函数生成b,这个“=”并未执行运算符重载函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">coordinate <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    coordinate c;</span><br><span class="line">    c = a;          <span class="comment">//这个“=”执行运算符重载函数</span></span><br></pre></td></tr></table></figure>
<p>(2)实验验证初始化和赋值时各自对应</p>
<p>2、赋值运算符重载函数参数中的const<br>(1)如果运算符对其右侧的操作数并不改变，则应该在参数列表中使用const引用<br>(2)C++的const要求非常严格，在c = a + b;中如果=运算符的重载函数参数列表中没有用const会编译报错。</p>
<p>3、避免赋值运算符中的自赋值<br>(1)自赋值就是Person a; a = a;<br>(2)<strong>自赋值如果不处理，轻则浪费效率，重则导致内存丢失（该深拷贝时做了浅拷贝）</strong><br>(3)避免自赋值很简单，只需要在赋值运算符重载函数所有操作前加上一个判断 if (this != &amp;other)即可（一个变量的引用，对引用取地址，可以当变量的地址使用） </p>
<h3 id="赋值运算符重载函数返回引用"><a href="#赋值运算符重载函数返回引用" class="headerlink" title="赋值运算符重载函数返回引用"></a>赋值运算符重载函数返回引用</h3><p>1、返回引用好处1：提升程序效率<br>(1)赋值运算符重载函数返回值可以返回对象类型，也可以返回对象引用类型，都能工作。代码验证</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">C++</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">coordinate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="comment">//coordinate&amp; operator=(const coordinate&amp; other);</span></span><br><span class="line">    coordinate <span class="keyword">operator</span>=(<span class="keyword">const</span> coordinate&amp; other);</span><br><span class="line">    <span class="built_in">coordinate</span>();</span><br><span class="line">    <span class="built_in">coordinate</span>(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0);</span><br><span class="line">    <span class="built_in">coordinate</span>(<span class="keyword">const</span> coordinate&amp; rhs);    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">coordinate::print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=(&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">coordinate&amp; coordinate::<span class="keyword">operator</span>=(<span class="keyword">const</span> coordinate&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x = other.x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = other.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">coordinate coordinate::<span class="keyword">operator</span>=(<span class="keyword">const</span> coordinate&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x = other.x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = other.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">coordinate::<span class="built_in">coordinate</span>()<span class="comment">//默认构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">coordinate::<span class="built_in">coordinate</span>(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0)<span class="comment">//自定义构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------constructor-------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;x = x0;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = y0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">coordinate::<span class="built_in">coordinate</span>(<span class="keyword">const</span> coordinate&amp; rhs)<span class="comment">//拷贝构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------copy_constructor-------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;x = rhs.x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = rhs.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">coordinate <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">coordinate <span class="title">b</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    coordinate c;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------c = a---------&quot;</span> &lt;&lt;endl;</span><br><span class="line">    c = a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------c = a---------&quot;</span> &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line">    c.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)区别在于：<strong>返回引用可以避免一次返回值值传递的对象复制，这需要消耗资源的</strong>。<br>(3)总结：虽然C++语法并未强制要求，但是好的写法是应该返回引用</p>
<p>2、返回引用好处2：允许连续赋值式<br>(1)返回对象而不是引用时，在连续赋值（c = a = b;）时会编译可以，运行也可以，但是效率低同1中所讲。<br>(2)原因是先执行a=b操作，返回值再作为第2次赋值运算的右值（也就是函数参数），对象和引用是类型兼容的<br>(3)总结：<strong>连等在返回对象和引用时都可以，但是在返回void时就不可以了</strong></p>
<p>3、思考：<strong>传参为什么要传引用</strong><br>(1)<strong>如果传对象，则调用时是值传递，调用时需要复制一次，增加额外开销</strong><br>(2)如果传指针，则重载后，使用时为了符合函数参数格式必须写成 a = &b;这种，不符合C语言写法习惯，也有歧义<br>(3)实际测试发现真的传指针时，写 c=a; c=&a;都能编译通过，且运行正确。但是确实很别扭。<br>(4)总结：有资料表明，其实C++早期发明引用概念时，就是为了解决此处运算符重载传参的尴尬。 </p>
<h3 id="String类的赋值运算符重载"><a href="#String类的赋值运算符重载" class="headerlink" title="String类的赋值运算符重载"></a>String类的赋值运算符重载</h3><p>1、标准库中String类的运算符重载<br>(1)<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5</a><br>(2)String类提供了 = 和 + 等多个运算符重载函数的成员<br>(3)标准库只给了API，没给实现，咱们可以自己实现个=运算符重载函数</p>
<p>2、String的=运算符重载演练<br>(1)自己编写一个MyString类，成员变量char *buf指向实际存储字符串的buf，new动态内存来使用。<br>(2)实践：先完成构造函数，成员函数print，len等基础设计，写代码测试ok<br>(3)<strong>编写=运算符重载函数，引出浅拷贝深拷贝问题</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mystring</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *buf; <span class="comment">//指针指向实际存储字符串内容的buffer空间，采用动态分配</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> len;   <span class="comment">//字符中存储的有效字符个数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Mystring</span>();                <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Mystring</span>(<span class="keyword">const</span> <span class="keyword">char</span> *pSrc);      <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">Mystring</span>();               <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;          <span class="comment">//普通成员函数</span></span><br><span class="line">    Mystring&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Mystring&amp; other);<span class="comment">//运算符重载函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Mystring::<span class="built_in">Mystring</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//不写，空着等需要时再写，因为提供了自定义的构造函数，</span></span><br><span class="line">    <span class="comment">//所以必须要由默认的构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;len = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">32</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mystring::<span class="built_in">Mystring</span>(<span class="keyword">const</span> <span class="keyword">char</span> *pSrc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//计算有效字符的个数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p = pSrc;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">this</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*p++ != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;cnt of pSrc is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;len &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先给buf分配动态内存空间</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">this</span>-&gt;len+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将pSrc指向的源字符串内容，复制给当前Mystring对象来存储</span></span><br><span class="line">    p = pSrc;</span><br><span class="line">    <span class="keyword">char</span> *tmp = <span class="keyword">this</span>-&gt;buf;</span><br><span class="line">    <span class="keyword">while</span>(*p != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *tmp++ = *p++;            </span><br><span class="line">    &#125;</span><br><span class="line">    *tmp = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mystring::~<span class="built_in">Mystring</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mystring::print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;length of string = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;len &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *p = <span class="keyword">this</span>-&gt;buf;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this string is : &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(*p != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *p++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mystring&amp; Mystring::<span class="keyword">operator</span>=(<span class="keyword">const</span> Mystring&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;buf;<span class="comment">//释放掉原来的内存，重新申请内存</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;buf = <span class="keyword">new</span> <span class="keyword">char</span>[other.len+<span class="number">1</span>];<span class="comment">//避免字符串内存越界</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;len = other.len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *p1 = <span class="keyword">this</span>-&gt;buf;</span><br><span class="line">    <span class="keyword">char</span> *p2 = other.buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*p2 != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p1++ = *p2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return *this;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Mystring <span class="title">s1</span><span class="params">(<span class="string">&quot;123456&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Mystring <span class="title">s2</span><span class="params">(<span class="string">&quot;absjhlllbsb&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">print</span>();</span><br><span class="line">    s2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl; </span><br><span class="line">    s1 = s2;</span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">print</span>();</span><br><span class="line">    s2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、总结<br>(1)运算符重载技术本身很简单，就是个语法糖，前面讲的完全够了<br>(2)运算符重载会牵出其他技术点（譬如浅拷贝，深拷贝）共同完成某个工作，这就有难点，讲究功底了<br>(3)C++编程中涉及到动态内存的地方一定要慎重，三思五思再慎重都不为过,运算符重载函数返回值类型不是引用而是对象可能会引发段错误，我上面提供的程序就会，调试了半小时才发现（我太菜了）。 </p>
<h3 id="和–运算符的前置后置如何实现"><a href="#和–运算符的前置后置如何实现" class="headerlink" title="++和–运算符的前置后置如何实现"></a>++和–运算符的前置后置如何实现</h3><p>1、可前置可后置的运算符<br>(1)int a = 5; a++; ++a;结果不同<br>(2)重载++和–有无意义？<br>  有意义，因为我们有时习惯了C语言的++和–的便利性。</p>
<p>2、如何重载++和–</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C++编译器认为：</span><br><span class="line"></span><br><span class="line">a++; 对应Type&amp; <span class="keyword">operator</span>++(<span class="keyword">int</span> x); <span class="comment">//int x用来做区分，此外没有任何其他作用。</span></span><br><span class="line"></span><br><span class="line">++a对应Type&amp; <span class="keyword">operator</span>++(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">示例代码：https:<span class="comment">//www.runoob.com/cplusplus/increment-decrement-operators-overloading.html</span></span><br></pre></td></tr></table></figure>

<p>3、总结<br>(1)即使你觉得没必要，但是也得会，因为总有人会这样写<br>(2)掌握最本质的规律的人最强大，遇到越困难的问题越需要这种能力来解决</p>
<h3 id="两种运算符重载方法"><a href="#两种运算符重载方法" class="headerlink" title="两种运算符重载方法"></a>两种运算符重载方法</h3><p>1、并非所有运算符都支持重载<br>(1)下面是不可重载的运算符列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.                        成员访问运算符</span><br><span class="line">.*, -&gt;*                成员指针访问运算符</span><br><span class="line">::                        域运算符</span><br><span class="line"><span class="keyword">sizeof</span>                长度运算符</span><br><span class="line">? :                        条件运算符 </span><br><span class="line">#           预处理符号</span><br></pre></td></tr></table></figure>

<p>2、并非只有一种方式实现重载<br>(1)有两种方法可以使运算符重载<br>第一种：使重载运算符成为该类的<strong>成员函数</strong>。这允许运算符函数访问类的私有成员。它也允许函数使用隐式的<strong>this</strong>指针形参来访问调用对象。<br>第二种：使重载的成员函数成为<strong>独立分开的函数</strong>。当以这种方式重载时，运算符函数必须声明为类的友元才能访问类的私有成员。 </p>
<p>3、如何选择两种运算符重载<br>(1)大多数运算符（如+ =等）既可以作为成员函数也可以作为独立函数重载。<br>(2)更好的做法是将二元运算符重载为釆用相同类型形参的独立函数。这是因为，与独立运算符的重载不同，成员函数的重载通过使左侧形参变成隐式的，造成了两个形参之间的人为区别，这将允许转换构造函数应用右侧形参，但不应用左侧形参，从而产生了更改形参顺序的情况，导致正确的程序如果换个方式却出现了编译器错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Length <span class="title">a</span><span class="params">(<span class="number">4</span>, <span class="number">2</span>)</span>, <span class="title">c</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">c = a + <span class="number">2</span>; <span class="comment">//编译，当于 c = a.operator+(2)</span></span><br><span class="line">c = <span class="number">2</span> + a; <span class="comment">//不能编译：相当于 c = 2.operator+(a);</span></span><br></pre></td></tr></table></figure>
<p>参考学习：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jacket_/article/details/89714947">https://blog.csdn.net/jacket_/article/details/89714947</a></p>
<h2 id="C-的静态类和静态成员"><a href="#C-的静态类和静态成员" class="headerlink" title="C++的静态类和静态成员"></a>C++的静态类和静态成员</h2><h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><p>1、static关键字<br>(1)static，C语言中有2种用法：static修饰局部变量和全局变量，含义完全不同<br>(2)static，C++中扩展了第3种用法：静态类、静态成员，含义和前2种完全不同</p>
<p>2、什么是静态成员<br>(1)<strong>用static修饰成员变量，即为静态成员变量；用static修饰成员方法，即为静态成员方法</strong><br>(2)<strong>静态成员属于class本身，而不属于对象</strong></p>
<p>3、静态成员的特征和实践验证<br>(1)<strong>静态成员变量在类的多个对象中均可访问，且是同一个实体，被多个对象“共享”。</strong><br>(2)<strong>静态成员变量和方法可以用对象调用，也可以根本不产生对象而用类本身来调用。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、静态方法只能访问静态成员</span><br><span class="line"><span class="number">2</span>、静态方法中不可以定义<span class="keyword">this</span>，super关键字</span><br><span class="line">因为静态优先于对象存在，所以静态方法中不可以出现<span class="keyword">this</span></span><br></pre></td></tr></table></figure>
<p>(3)静态成员函数在类外实现时只需在类内声明时加static，类外实体无须加static关键字，否则是错误的（思考下为什么？）<br>答：修改了函数的链接属性，将函数变为一个静态函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;        <span class="comment">//普通成员变量  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> flag;<span class="comment">//静态成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> t)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sample::print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt;<span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;flag = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;flag &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sample::test</span><span class="params">(<span class="keyword">int</span> aage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this is a test function.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; flag &lt;&lt; endl;<span class="comment">//不可以使用this-&gt;flag</span></span><br><span class="line">    cout &lt;&lt; sample::flag &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; aage &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; age &lt;&lt; endl;//非静态成员引用必须与特定对象相对,这个报错，静态方法只能访问静态成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sample::flag = <span class="number">0</span>;<span class="comment">//静态成员变量与普通成员变量的不同之处，否则该类的对象无法使用该变量 </span></span><br><span class="line"><span class="comment">//void sample::test(void);//静态成员方法不需要这样,虽然写了编译也不会报错</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sample s1, s2;</span><br><span class="line"></span><br><span class="line">    s1.flag = <span class="number">2</span>;</span><br><span class="line">    s1.age = <span class="number">21</span>;</span><br><span class="line">    s1.<span class="built_in">print</span>();</span><br><span class="line">    s1.<span class="built_in">test</span>(s1.age);</span><br><span class="line"></span><br><span class="line">    s2.age = <span class="number">22</span>;</span><br><span class="line">    s2.<span class="built_in">print</span>();</span><br><span class="line">    s2.<span class="built_in">test</span>(s2.age);</span><br><span class="line"></span><br><span class="line">    sample::flag = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态成员的深度理解"><a href="#静态成员的深度理解" class="headerlink" title="静态成员的深度理解"></a>静态成员的深度理解</h3><p>1、静态数据成员的使用<br>(1)<strong>静态数据成员不能在类中初始化</strong>，因为类定义实际只是模型，本身并没有和变量/对象实体去关联<br>(2)<strong>静态数据成员不能在类的构造函数中初始化</strong>，因为构造函数是用来构造具体单个对象的，而静态成员属于类（或者说类和他的所有对象共享），如果在构造函数中允许对静态成员初始化或赋值，就会每多创建一个对象，原有对象中该静态成员的值莫名其妙变了，不合理<br>(3)静态数据成员不能用初始化列表方式来初始化<br>(4)<strong>静态数据成员如果不初始化则值默认为0</strong><br>(5)静态成员仍然遵循public，private，protected访问准则。</p>
<p>2、静态成员和普通成员的互相调用规则<br>(1)普通成员函数中可以调用静态成员变量和方法，调用方法有3种：直接访问、this指针访问、类名::func()方式访问<br>(2)<strong>静态方法中只能访问静态成员变量和方法，不能访问任何非静态的东西</strong><br>(3)<strong>静态方法中如果确实需要访问非静态成员，应该通过函数传参方式</strong></p>
<p>3、从内存角度出发<br>(1)<strong>class定义时只是定义类型，并不定义变量和对象，静态成员变量真正定义是在外部，类似于全局变量</strong><br>(2)<strong>静态成员变量在编译链接时分配，程序加载时被落实到内存中，程序结束时死亡，等同于全局变量</strong><br>(3)<strong>静态成员函数在编译链接时分配，程序加载时被落实到内存中，程序结束时死亡，类似于全局函数</strong><br>(4)普通成员和对象绑定，随对象的创建和释放而生死（不管在栈里还是堆里），类似于局部变量和malloc堆内存<br>(5)<strong>静态成员变量在对象中不占用存储空间</strong> </p>
<h3 id="静态成员的用途"><a href="#静态成员的用途" class="headerlink" title="静态成员的用途"></a>静态成员的用途</h3><p>1、用途举例<br>(1)静态数据成员的用途之一是统计有多少个对象实际存在，比如声明一个学生类，其中一个成员为学生总数，则这个变量就应当声明为静态变量，应该根据实际需求来设置成员变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> grade;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">student</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="string">&quot;student&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;grade = <span class="number">0</span>;</span><br><span class="line">        student::cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">student</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        student::cnt--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The number of students is &quot;</span> &lt;&lt; student::cnt &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> student::cnt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    student p1;</span><br><span class="line">    p1.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    student p2;</span><br><span class="line">    p2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)<strong>静态方法就是与该类相关的，是类的一种行为，而不是与该类的实例对象相关</strong></p>
<p>2、静态成员与面向对象<br>(1)静态成员仍然在class内，仍可通过对象调用，因此表面上遵守面向对象规则。<br>(2)静态成员一定程度上破坏了面向对象，因为没有对象直接用class名也可以调用静态成员。<br>(3)静态成员可被看做是类外部的全局变量和全局函数被封装到了类的内部<br>(4)一个类的静态成员和非静态成员是完全不同的，两者唯一的关联可能就是隶属于同一个class的作用域内。</p>
<h3 id="静态类的扩展讲解"><a href="#静态类的扩展讲解" class="headerlink" title="静态类的扩展讲解"></a>静态类的扩展讲解</h3><p>1、什么是静态类<br>(1)class声明时使用static，整个类是个静态类<br>(2)<strong>静态类内部全是静态成员，没有非静态成员</strong><br>(3)<strong>静态类不能被实例化</strong><br>(4)静态类是密封(sealed)的。 补充：什么是密封？<br>(5)静态类不包括构造函数<br>(6)静态类不能指定任何接口实现，不能有任何实例成员<br>(7)静态类的成员不能有protected或protected internal访问保护修饰符。<br>(8)静态类不能包含构造函数，但仍可声明静态构造函数以分配初始值或设置某个静态状态。</p>
<p>2、静态类的优势<br>(1)编译器能够执行检查以确保不致偶然地添加实例成员。编译器将保证不会创建此类的实例。<br>(2)静态类是密封的，因此不可被继承。</p>
<p>3、C++不支持静态类<br>(1)<strong>Java/C#等高级语言支持静态类，而C++并不支持。</strong><br>(2)C++中创建静态类与创建仅包含静态成员和私有构造函数的类大致一样。私有构造函数阻止类被实例化。 </p>
<h2 id="C-的友元函数和友元类"><a href="#C-的友元函数和友元类" class="headerlink" title="C++的友元函数和友元类"></a>C++的友元函数和友元类</h2><h3 id="什么是友元函数"><a href="#什么是友元函数" class="headerlink" title="什么是友元函数"></a>什么是友元函数</h3><p>1、外部函数访问类内成员<br>(1)写一个Person类，内部有private、protected、public的三类访问权限的成员<br>(2)写一个外部函数disp_info来打印这三类成员<br>(3)代码实战</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">person</span>()&#123;&#125;;<span class="comment">//由于使用了自己的构造函数，编译器不会再为我们提供默认构造函数</span></span><br><span class="line">    <span class="built_in">person</span>(<span class="keyword">int</span> age, <span class="keyword">int</span> height, string name);<span class="comment">//自定义构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person::<span class="built_in">person</span>(<span class="keyword">int</span> age, <span class="keyword">int</span> height, string name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;height = height;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disp_info</span><span class="params">(person&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;My name is &quot;</span> &lt;&lt; p.name &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;I am &quot; &lt;&lt; p.age &lt;&lt; &quot;years old.&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;My height is &quot; &lt;&lt; p.height &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">155</span>, <span class="string">&quot;Jack&quot;</span>)</span></span>;</span><br><span class="line">    person &amp;p2 = p1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">disp_info</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4)总结：可以访问public的，但是protected和private的无法访问<br>(5)想办法：除非把disp_info挪到Person类内部成为成员函数，否则没办法</p>
<p>2、友元函数的引入<br>(1)将外部函数disp_info声明为Person类的友元函数即可解决<br>(2)代码实战验证</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">person</span>()&#123;&#125;;<span class="comment">//由于使用了自己的构造函数，编译器不会再为我们提供默认构造函数</span></span><br><span class="line">    <span class="built_in">person</span>(<span class="keyword">int</span> age, <span class="keyword">int</span> height, string name);<span class="comment">//自定义构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">disp_info</span><span class="params">(person&amp; p)</span></span>;<span class="comment">//友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line">person::<span class="built_in">person</span>(<span class="keyword">int</span> age, <span class="keyword">int</span> height, string name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;height = height;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disp_info</span><span class="params">(person&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;My name is &quot;</span> &lt;&lt; p.name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I am &quot;</span> &lt;&lt; p.age &lt;&lt; <span class="string">&quot;years old.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;My height is &quot;</span> &lt;&lt; p.height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">155</span>, <span class="string">&quot;Jack&quot;</span>)</span></span>;</span><br><span class="line">    person &amp;p2 = p1;</span><br><span class="line">    <span class="built_in">disp_info</span>(p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、总结<br>(1)<strong>友元函数不是本类的成员函数，而是一个外部函数</strong><br>(2)友元函数的标志就是<strong>在类内部加friend关键字来声明</strong><br>(3)友元函数声明的位置不要求，写在private或者protected或者public内都可以，反正只要有声明就行<br>(4)<strong>一个外部函数成为类的友元后，访问权限被扩展了，等同于类的内部成员函数了</strong><br>(5)友元函数是单向的，反过来是不行的，一个类可以有多个友元函数<br>例如：类Y为类X的友元类，类Y中的类内函数可访问类X的类内数据，但，类X并不能访问类Y中的数据。<br>(6)友元函数就好像在类的封装和访问权限保护上打了个“洞”，所以<strong>是对面向对象的一种破坏，所以不能滥用</strong></p>
<h3 id="友元函数的2种实现"><a href="#友元函数的2种实现" class="headerlink" title="友元函数的2种实现"></a>友元函数的2种实现</h3><p>1、友元函数的2种实现<br>(1)<strong>友元函数为外部函数</strong><br>(2)<strong>友元函数为另一个类中的成员函数</strong>（也叫友元成员，友元成员方法，友元成员函数）<br>(3)第2种实现的代码实战</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span>//如果将<span class="title">person</span>类与<span class="title">animal</span>类调换位置，声明<span class="title">animal</span>类，是不可以的，编译报错</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//person p1;//编译不通过</span></span><br><span class="line">    person *p1;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(person&amp; p)</span></span>;<span class="comment">//类的前置声明不包括类的详细信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">person</span>()&#123;&#125;;<span class="comment">//由于使用了自己的构造函数，编译器不会再为我们提供默认构造函数</span></span><br><span class="line">    <span class="built_in">person</span>(<span class="keyword">int</span> age, <span class="keyword">int</span> height, string name);<span class="comment">//自定义构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">disp_info</span><span class="params">(person&amp; p)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">animal::eat</span><span class="params">(person&amp; p)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">person::<span class="built_in">person</span>(<span class="keyword">int</span> age, <span class="keyword">int</span> height, string name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;height = height;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">animal::eat</span><span class="params">(person&amp; p)</span><span class="comment">//注意该函数的位置，不能放在person类之前，负责编译无法通过</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This animal wants to eat a person.His message is as follows.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;My name is &quot;</span> &lt;&lt; p.name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I am &quot;</span> &lt;&lt; p.age &lt;&lt; <span class="string">&quot;years old.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;My height is &quot;</span> &lt;&lt; p.height &lt;&lt; endl;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disp_info</span><span class="params">(person&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;My name is &quot;</span> &lt;&lt; p.name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I am &quot;</span> &lt;&lt; p.age &lt;&lt; <span class="string">&quot;years old.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;My height is &quot;</span> &lt;&lt; p.height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">155</span>, <span class="string">&quot;Jack&quot;</span>)</span></span>;</span><br><span class="line">    person &amp;p2 = p1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">disp_info</span>(p2);</span><br><span class="line"></span><br><span class="line">    animal a;</span><br><span class="line">    a.<span class="built_in">eat</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、类的前置声明<br>(1)<strong>两个类要互相引用，就会出现“未定义”尴尬，此时可以用前置声明来解决</strong><br>(2)前置声明<strong>不包括类的详细信息，所以编译器无法得到前置声明类的size，成员等详细信息</strong><br>(3)不能试图通过前置声明解决类成员的调用。<br>(4)不能试图通过前置声明来定义类的对象，<strong>只能改为定义类对象的指针</strong>。 </p>
<p>3、总结<br>(1)理解编译器的工作原理和“脾气”，很多事自然就很简单了<br>(2)设计多个类的体系时，尽量设计好层次关系成单向的，尽量避免互相引用的情况</p>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>1、友元类的概念和使用<br>(1)将类A声明为B中的friend class后，则A中所有成员函数都成为类B的友元函数了<br>(2)友元类的定义和使用友元类是单向的<br>(3)友元类是单向的和上边的友元函数一样</p>
<p>2、互为友元类<br>(1)2个类可以互为友元类<br>(2)互为友元类要注意互相引用的细节规则</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">monkey</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">monkey</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">monkey</span>(<span class="keyword">int</span> mage, string mfood):<span class="built_in">age</span>(mage),<span class="built_in">food</span>(mfood)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_friend_monkey</span><span class="params">(people&amp; s1)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string food;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">people</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> male;</span><br><span class="line">    <span class="built_in">people</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">people</span>(<span class="keyword">int</span> mmale, string mname):<span class="built_in">male</span>(mmale),<span class="built_in">name</span>(mname)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_friend_people</span><span class="params">(monkey&amp; s2)</span></span>;    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">monkey</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">monkey::test_friend_monkey</span><span class="params">(people&amp; s1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test_friend_monkey function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;class people male = &quot;</span> &lt;&lt; s1.male &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;class people name = &quot;</span> &lt;&lt; s1.name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">people::test_friend_people</span><span class="params">(monkey&amp; s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test_friend_people function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;class monkey age = &quot;</span> &lt;&lt; s2.age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;class monkey food = &quot;</span> &lt;&lt; s2.food &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">monkey <span class="title">a</span><span class="params">(<span class="number">11</span>, <span class="string">&quot;banana&quot;</span>)</span></span>;</span><br><span class="line">    monkey&amp; a1 = a;</span><br><span class="line">    <span class="function">people <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;Jack&quot;</span>)</span></span>;</span><br><span class="line">    people b1 = b;</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">test_friend_monkey</span>(b1);</span><br><span class="line">    b.<span class="built_in">test_friend_people</span>(a1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、友元类总结<br>(1)友元类其实就是批量制造友元函数<br>(2)友元类中所有全部成员都成为了友元函数，相当于一次打了很多洞，极大破坏了面向对象<br>(3)除非确实有必要，否则建议按需定义友元函数，尽量维护面向对象，让代码更安全健壮</p>
<h3 id="为什么会有友元函数"><a href="#为什么会有友元函数" class="headerlink" title="为什么会有友元函数"></a>为什么会有友元函数</h3><p>1、使用友元函数的优缺点<br>(1)缺点：破坏了封装机制，尽量不使用友元函数，不得已才使用友元函数<br>(2)优点：在实现类之间数据共享时，减少系统开销，提高效率。</p>
<p>2、使用友元函数的两种情况<br>(1)运算符重载的某些场合需要使用友元<br>(2)两个类要共享数据的时候</p>
<p>3、运算符重载中使用友元回顾<br>(1)并非所有运算符重载都可用友元函数，有四个运算符 =, -&gt;, [], ()就不可以<br>(2)详解可参考：<a target="_blank" rel="noopener" href="https://www.jb51.net/article/40143.htm">https://www.jb51.net/article/40143.htm</a><br>(3)总结：<strong>C++的语法特性确实大而细，正确的方法是去理解而不是死记硬背</strong>。</p>
<p>4、两个类如何共享数据<br>(1)类内的数据，其实就是类的成员变量<br>(2)2个类共享数据方法1：将共享数据访问权限设置为public。<br>(3)2个类共享数据方法2：通过第三个专门封装数据的类，和2个类中带参数的成员函数来传参共享<br>(4)2个类共享数据方法3：通过友元函数打洞</p>
<p>5、友元函数和类的成员函数的区别<br>(1)成员函数有this指针，而<strong>友元函数没有this指针。为什么？因为友元只是朋友，并不是类内“自家人”</strong><br>(2)友元函数是不能被继承的，就像父亲的朋友未必是儿子的朋友。<br>(3)友元关系不具有传递性。类B是类A的友元，类C是B的友元，类C不一定是类A的友元，要看类中是否有相应的声明</p>
<p>6、共有友元函数<br>(1)1个函数同时成为2个类的友元函数<br>(2)共有友元函数可以是外部函数，也可以是某个（第3个）类的成员函数<br>(3)共有友元函数内可同时访问2个类的受保护成员，间接将2个完全无关的类的数据打通了</p>
<h3 id="嵌套类和局部类"><a href="#嵌套类和局部类" class="headerlink" title="嵌套类和局部类"></a>嵌套类和局部类</h3><p>1、嵌套类<br>(1)在一个类（叫外围类）的内部定义一个类（叫内部类）。<br>(2)<strong>嵌套类技术也是一种类的组合技术</strong>，和前面讲的继承、组合有类似。<br>(3)<strong>嵌套类主要是限定了内部类的作用域</strong><br>(4)嵌套类的内部类和外围类各自有各自的访问权限限定符，且遵守传统权限规则<br>(5)嵌套类中的成员函数可以在它的类体外定义，但是要附加类名的作用域限定说明<br>(6)<strong>嵌套类的内部类中声明的友元，并不是外围类的友元</strong><br>(7)<strong>定义嵌套类的目的在于隐藏类名，减少全局标识符，限制用户使用该类建立对象。以提高类的抽象能力，强调两个类(外围类和嵌套类)之间的主从关系。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string food;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;   </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">People::print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;People print function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> People::Animal::<span class="built_in">print</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Animal print function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;food is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;food &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;count is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    People s1;</span><br><span class="line">    People::Animal s2;</span><br><span class="line"></span><br><span class="line">    s1.age = <span class="number">10</span>;</span><br><span class="line">    s1.name = <span class="string">&quot;wqewqe&quot;</span>;</span><br><span class="line"></span><br><span class="line">    s2.count = <span class="number">100</span>;</span><br><span class="line">    s2.food = <span class="string">&quot;rice&quot;</span>;</span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">print</span>();</span><br><span class="line">    s2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、局部类<br>(1)<strong>定义在函数内部的类，叫做局部类，只在定义他的作用域内可见，也是一种类型隐藏技术</strong><br>(2)局部类除作用域外其他和正常类一样<br>(3)局部类一般不需要访问权限限定，因为本身作用域就很小了<br>(4)局部类内还可以再做嵌套类，如果有需要的话<br>(5)<strong>C++允许在函数内定义类，但是不允许在函数内定义函数，所以没有局部函数一说</strong></p>
<p>3、总结<br>(1)不管是嵌套类还是局部类，都是为了隐藏类型，将没必要给外部看的类型隐藏在实现内部<br>(2)没必要纠结嵌套类和局部类的各种访问细节，真的需要用时写代码验证让编译器告诉你即可<br>(3)不要求会写这些，不写框架是用不到的，只需要知道，见了能认识即可。<br>(4)模板中会用到嵌套类，讲到模板时再说</p>
<h3 id="数值与对象互转"><a href="#数值与对象互转" class="headerlink" title="数值与对象互转"></a>数值与对象互转</h3><p>1、数值与对象概念<br>(1)数值是简单类型，如int，float，double等，是C++从C继承而来的<br>(2)数值类型是源生类型，数值类型定义的是变量，非面向对象概念<br>(3)纯正的面向对象中是没有数值类型和变量的，会提供类库来替代数值类型，用数值对象来替代变量</p>
<p>2、C++中数值与对象互转<br>(1)数值转对象，实际是调用形参类型相匹配的构造函数来实现。<br>(2)对象转数值，不能默认转，必须调用对象的相应转换函数来实现。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Int</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Int</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Int()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Int</span>(<span class="keyword">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Int(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Int a;</span><br><span class="line">    a = <span class="number">7</span>;<span class="comment">//这句会先把数值7内部隐式转成一个临时Int对象，</span></span><br><span class="line">          <span class="comment">//然后再将临时对象（调用Int类的默认的oprator=函数）赋值给a</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    b = a.<span class="built_in">toint</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、对象数组<br>(1)就是一次定义多个对象<br>(2)对象数组的访问和普通变量数组没区别<br>(3)要注意如果是用new来分配的对象数组，则销毁时要用delete[] xx;</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C-C/" rel="tag"><i class="fa fa-tag"></i> C/C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/10/30/2024-10-30-CPP-Basics-C-to-Cpp/" rel="prev" title="C++从入门到进阶之一-从C到C++">
                  <i class="fa fa-angle-left"></i> C++从入门到进阶之一-从C到C++
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/11/18/2024-11-18-CPP-Basics-about-STL/" rel="next" title="C++从入门到进阶之三-STL等高阶话题">
                  C++从入门到进阶之三-STL等高阶话题 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">空白</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">288k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:22</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"shenweikun/helloworld","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
