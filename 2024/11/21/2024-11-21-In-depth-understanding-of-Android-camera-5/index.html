<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shenweikun.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一、概览始于谷歌的Treble开源项目，基于接口与实现的分离的设计原则，谷歌加入了Camera Provider这一抽象层，该层作为一个独立进程存在于整个系统中，并且通过HIDL这一自定义语言成功地将Camera Hal Module从Camera Service中解耦出来，承担起了对Camera HAL的封装工作，纵观整个Android系统，对于Camera Provider而言，对上是通过HI">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Android相机体系结构之五：相机硬件抽象层">
<meta property="og:url" content="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-5/index.html">
<meta property="og:site_name" content="Weikun&#39;s Notes">
<meta property="og:description" content="一、概览始于谷歌的Treble开源项目，基于接口与实现的分离的设计原则，谷歌加入了Camera Provider这一抽象层，该层作为一个独立进程存在于整个系统中，并且通过HIDL这一自定义语言成功地将Camera Hal Module从Camera Service中解耦出来，承担起了对Camera HAL的封装工作，纵观整个Android系统，对于Camera Provider而言，对上是通过HI">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-5/Image.png">
<meta property="og:image" content="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-5/Image-1.png">
<meta property="og:image" content="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-5/Image-2.png">
<meta property="og:image" content="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-5/Image-3.png">
<meta property="article:published_time" content="2024-11-20T16:25:50.000Z">
<meta property="article:modified_time" content="2024-11-22T17:24:45.998Z">
<meta property="article:author" content="空白">
<meta property="article:tag" content="Android Camera">
<meta property="article:tag" content="Camera系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-5/Image.png">


<link rel="canonical" href="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-5/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-5/","path":"2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-5/","title":"深入理解Android相机体系结构之五：相机硬件抽象层"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>深入理解Android相机体系结构之五：相机硬件抽象层 | Weikun's Notes</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Weikun's Notes</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">怀揣代码中的唏嘘，记录生活中的点滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%A7%88"><span class="nav-number">1.</span> <span class="nav-text">一、概览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Camera-HIDL-%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.</span> <span class="nav-text">二、Camera HIDL 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E3%80%81Camera-Provider-%E4%B8%BB%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">三 、Camera Provider 主程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81Camera-HAL3-%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.</span> <span class="nav-text">四、Camera HAL3 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84%E4%BD%93%E8%A7%A3%E6%9E%90"><span class="nav-number">4.1.</span> <span class="nav-text">1. 核心结构体解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="nav-number">4.2.</span> <span class="nav-text">2. 核心接口函数解析</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">空白</p>
  <div class="site-description" itemprop="description">记录生活与职业中的点滴</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="空白">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weikun's Notes">
      <meta itemprop="description" content="记录生活与职业中的点滴">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="深入理解Android相机体系结构之五：相机硬件抽象层 | Weikun's Notes">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入理解Android相机体系结构之五：相机硬件抽象层
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-21 00:25:50" itemprop="dateCreated datePublished" datetime="2024-11-21T00:25:50+08:00">2024-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-23 01:24:45" itemprop="dateModified" datetime="2024-11-23T01:24:45+08:00">2024-11-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/1-Android-Camera/" itemprop="url" rel="index"><span itemprop="name">1. Android Camera</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>97k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4:01</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h2><p>始于谷歌的Treble开源项目，基于接口与实现的分离的设计原则，谷歌加入了Camera Provider这一抽象层，该层作为一个独立进程存在于整个系统中，并且通过HIDL这一自定义语言成功地将Camera Hal Module从Camera Service中解耦出来，承担起了对Camera HAL的封装工作，纵观整个Android系统，对于Camera Provider而言，对上是通过HIDL接口负责与Camera Service的跨进程通信，对下通过标准的HAL3接口下发针对Camera的实际操作，这俨然是一个中央枢纽般的调配中心的角色，而事实上正是如此，由此看来，对Camera Provider的梳理变得尤为重要，接下来就以我个人理解出发来简单介绍下Camera Provider。</p>
<span id="more"></span>
<p>Camera Provider通过提供标准的HIDL接口给Camera Service进行调用，保持与Service的正常通信，其中谷歌将HIDL接口的定义直接暴露给平台厂商进行自定义实现，其中为了极大地减轻并降低开发者的工作量和开发难度，谷歌很好地封装了其跨进程实现细节，同样地，Camera Provider通过标准的HAL3接口，向下控制着具体的Camera HAL Module，而这个接口依然交由平台厂商负责去实现，而进程内部则通过简单的函数调用，将HIDL接口与HAL3接口完美的衔接起来，由此构成了Provider整体架构。<br><img src="Image.png" alt="alt text"></p>
<p>由图中可以看出Camera Provider进程由两部分组成，一是运行在系统中的主程序通过提供了标准的HIDL接口保持了与Camera Service的跨进程通讯，二是为了进一步扩展其功能，通过dlopen方式加载了一系列So库，而其中就包括了实现了Camera HAL3接口的So库，而HAL3接口主要定义了主要用于实现图像控制的功能，其实现主要交由平台厂商或者开发者来完成，所以Camera HAL3 So库的实现各式各样，在高通平台上，这里的实现就是我们本文重点需要分析的CamX-CHI框架。<br>在开始梳理CamX-CHI之前，不防先从上到下，以接口为主线简单梳理下Camera Provider的各个部分:</p>
<h2 id="二、Camera-HIDL-接口"><a href="#二、Camera-HIDL-接口" class="headerlink" title="二、Camera HIDL 接口"></a>二、Camera HIDL 接口</h2><p>首先需要明确一个概念，就是HIDL是一种自定义语言，其核心是接口的定义，而谷歌为了使开发者将注意力落在接口的定义上而不是机制的实现上，主动封装了HIDL机制的实现细节，开发者只需要通过*.hal文件定义接口，填充接口内部实际的实现即可，接下来来看下具体定义的几个主要接口：<br><img src="Image-1.png" alt="alt text"></p>
<p>因为HIDL机制本身是跨进程通讯的，所以Camera Service本身通过HIDL接口获取的对象都会有Bn端和Bp端，分别代表了Binder两端，接下来为了方便理解，我们都省略掉Bn/Bp说法,直接用具体接口类代表，忽略跨进程两端的区别。<br>ICameraProvider.hal源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2016 The Android Open Source Project</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">package android.hardware.camera.provider@<span class="number">2.4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ICameraProviderCallback;</span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.common@<span class="number">1.0</span>::types;</span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.device@<span class="number">1.0</span>::ICameraDevice;</span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.device@<span class="number">3.2</span>::ICameraDevice;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Camera provider HAL, which enumerates the available individual camera devices</span></span><br><span class="line"><span class="comment"> * known to the provider, and provides updates about changes to device status,</span></span><br><span class="line"><span class="comment"> * such as connection, disconnection, or torch mode enable/disable.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The provider is responsible for generating a list of camera device service</span></span><br><span class="line"><span class="comment"> * names that can then be opened via the hardware service manager.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Multiple camera provider HALs may be present in a single system.</span></span><br><span class="line"><span class="comment"> * For discovery, the service names, and process names, must be of the form</span></span><br><span class="line"><span class="comment"> * &quot;android.hardware.camera.provider@&lt;major&gt;.&lt;minor&gt;/&lt;type&gt;/&lt;instance&gt;&quot;</span></span><br><span class="line"><span class="comment"> * where</span></span><br><span class="line"><span class="comment"> *   - &lt;major&gt;/&lt;minor&gt; is the provider HAL HIDL version,</span></span><br><span class="line"><span class="comment"> *   - &lt;type&gt; is the type of devices this provider knows about, such as</span></span><br><span class="line"><span class="comment"> *     &quot;internal&quot;, &quot;legacy&quot;, &quot;external&quot;, &quot;remote&quot; etc. The camera framework</span></span><br><span class="line"><span class="comment"> *     must not differentiate or chage its behavior based on the specific type.</span></span><br><span class="line"><span class="comment"> *   - &lt;instance&gt; is a non-negative integer starting from 0 to disambiguate</span></span><br><span class="line"><span class="comment"> *     between multiple HALs of the same type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The &quot;legacy&quot; type is only used for passthrough legacy HAL mode, and must</span></span><br><span class="line"><span class="comment"> * not be used by a standalone binderized HAL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The device instance names enumerated by the provider in getCameraIdList() or</span></span><br><span class="line"><span class="comment"> * ICameraProviderCallback::cameraDeviceStatusChange() must be of the form</span></span><br><span class="line"><span class="comment"> * &quot;device@&lt;major&gt;.&lt;minor&gt;/&lt;type&gt;/&lt;id&gt;&quot; where</span></span><br><span class="line"><span class="comment"> * &lt;major&gt;/&lt;minor&gt; is the HIDL version of the interface. &lt;id&gt; is either a small</span></span><br><span class="line"><span class="comment"> * incrementing integer for &quot;internal&quot; device types, with 0 being the main</span></span><br><span class="line"><span class="comment"> * back-facing camera and 1 being the main front-facing camera, if they exist.</span></span><br><span class="line"><span class="comment"> * Or, for external devices, a unique serial number (if possible) that can be</span></span><br><span class="line"><span class="comment"> * used to identify the device reliably when it is disconnected and reconnected.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Multiple providers must not enumerate the same device ID.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">interface ICameraProvider &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * setCallback:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Provide a callback interface to the HAL provider to inform framework of</span></span><br><span class="line"><span class="comment">     * asynchronous camera events. The framework must call this function once</span></span><br><span class="line"><span class="comment">     * during camera service startup, before any other calls to the provider</span></span><br><span class="line"><span class="comment">     * (note that in case the camera service restarts, this method must be</span></span><br><span class="line"><span class="comment">     * invoked again during its startup).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param callback</span></span><br><span class="line"><span class="comment">     *     A non-null callback interface to invoke when camera events occur.</span></span><br><span class="line"><span class="comment">     * @return status</span></span><br><span class="line"><span class="comment">     *     Status code for the operation, one of:</span></span><br><span class="line"><span class="comment">     *     OK:</span></span><br><span class="line"><span class="comment">     *         On success</span></span><br><span class="line"><span class="comment">     *     INTERNAL_ERROR:</span></span><br><span class="line"><span class="comment">     *         An unexpected internal error occurred while setting the callbacks</span></span><br><span class="line"><span class="comment">     *     ILLEGAL_ARGUMENT:</span></span><br><span class="line"><span class="comment">     *         The callback argument is invalid (for example, null).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">setCallback</span>(ICameraProviderCallback callback) <span class="built_in">generates</span> (Status status);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getVendorTags:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Retrieve all vendor tags supported by devices discoverable through this</span></span><br><span class="line"><span class="comment">     * provider. The tags are grouped into sections.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return status</span></span><br><span class="line"><span class="comment">     *     Status code for the operation, one of:</span></span><br><span class="line"><span class="comment">     *     OK:</span></span><br><span class="line"><span class="comment">     *         On success</span></span><br><span class="line"><span class="comment">     *     INTERNAL_ERROR:</span></span><br><span class="line"><span class="comment">     *         An unexpected internal error occurred while setting the callbacks</span></span><br><span class="line"><span class="comment">     * @return sections</span></span><br><span class="line"><span class="comment">     *     The supported vendor tag sections; empty if there are no supported</span></span><br><span class="line"><span class="comment">     *     vendor tags, or status is not OK.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">getVendorTags</span>() <span class="built_in">generates</span> (Status status, vec&lt;VendorTagSection&gt; sections);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getCameraIdList:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Returns the list of internal camera device interfaces known to this</span></span><br><span class="line"><span class="comment">     * camera provider. These devices can then be accessed via the hardware</span></span><br><span class="line"><span class="comment">     * service manager.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * External camera devices (camera facing EXTERNAL) must be reported through</span></span><br><span class="line"><span class="comment">     * the device status change callback, not in this list. Only devices with</span></span><br><span class="line"><span class="comment">     * facing BACK or FRONT must be listed here.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return status Status code for the operation, one of:</span></span><br><span class="line"><span class="comment">     *     OK:</span></span><br><span class="line"><span class="comment">     *         On a succesful generation of camera ID list</span></span><br><span class="line"><span class="comment">     *     INTERNAL_ERROR:</span></span><br><span class="line"><span class="comment">     *         A camera ID list cannot be created. This may be due to</span></span><br><span class="line"><span class="comment">     *         a failure to initialize the camera subsystem, for example.</span></span><br><span class="line"><span class="comment">     * @return cameraDeviceNames The vector of internal camera device</span></span><br><span class="line"><span class="comment">     *     names known to this provider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">getCameraIdList</span>()</span><br><span class="line">            <span class="built_in">generates</span> (Status status, vec&lt;string&gt; cameraDeviceNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * isSetTorchModeSupported:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Returns if the camera devices known to this camera provider support</span></span><br><span class="line"><span class="comment">     * setTorchMode API or not. If the provider does not support setTorchMode</span></span><br><span class="line"><span class="comment">     * API, calling to setTorchMode will return METHOD_NOT_SUPPORTED.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that not every camera device has a flash unit, so even this API</span></span><br><span class="line"><span class="comment">     * returns true, setTorchMode call might still fail due to the camera device</span></span><br><span class="line"><span class="comment">     * does not have a flash unit. In such case, the returned status will be</span></span><br><span class="line"><span class="comment">     * OPERATION_NOT_SUPPORTED.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return status Status code for the operation, one of:</span></span><br><span class="line"><span class="comment">     *     OK:</span></span><br><span class="line"><span class="comment">     *         On a succesful call</span></span><br><span class="line"><span class="comment">     *     INTERNAL_ERROR:</span></span><br><span class="line"><span class="comment">     *         Torch API support cannot be queried. This may be due to</span></span><br><span class="line"><span class="comment">     *         a failure to initialize the camera subsystem, for example.</span></span><br><span class="line"><span class="comment">     * @return support Whether the camera devices known to this provider</span></span><br><span class="line"><span class="comment">     *     supports setTorchMode API or not. Devices launched with SDK</span></span><br><span class="line"><span class="comment">     *     level 29 or higher must return true.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">isSetTorchModeSupported</span>() <span class="built_in">generates</span> (Status status, <span class="keyword">bool</span> support);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getCameraDeviceInterface_VN_x:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return a android.hardware.camera.device@N.x/ICameraDevice interface for</span></span><br><span class="line"><span class="comment">     * the requested device name. This does not power on the camera device, but</span></span><br><span class="line"><span class="comment">     * simply acquires the interface for querying the device static information,</span></span><br><span class="line"><span class="comment">     * or to additionally open the device for active use.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A separate method is required for each major revision of the camera device</span></span><br><span class="line"><span class="comment">     * HAL interface, since they are not compatible with each other.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Valid device names for this provider can be obtained via either</span></span><br><span class="line"><span class="comment">     * getCameraIdList(), or via availability callbacks from</span></span><br><span class="line"><span class="comment">     * ICameraProviderCallback::cameraDeviceStatusChange().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The returned interface must be of the highest defined minor version for</span></span><br><span class="line"><span class="comment">     * the major version; it&#x27;s the responsibility of the HAL client to ensure</span></span><br><span class="line"><span class="comment">     * they do not use methods/etc that are not valid for the actual minor</span></span><br><span class="line"><span class="comment">     * version of the device.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param cameraDeviceName the name of the device to get an interface to.</span></span><br><span class="line"><span class="comment">     * @return status Status code for the operation, one of:</span></span><br><span class="line"><span class="comment">     *     OK:</span></span><br><span class="line"><span class="comment">     *         On a succesful generation of camera ID list</span></span><br><span class="line"><span class="comment">     *     ILLEGAL_ARGUMENT:</span></span><br><span class="line"><span class="comment">     *         This device name is unknown, or has been disconnected</span></span><br><span class="line"><span class="comment">     *     OPERATION_NOT_SUPPORTED:</span></span><br><span class="line"><span class="comment">     *         The specified device does not support this major version of the</span></span><br><span class="line"><span class="comment">     *         HAL interface.</span></span><br><span class="line"><span class="comment">     *     INTERNAL_ERROR:</span></span><br><span class="line"><span class="comment">     *         A camera interface cannot be returned due to an unexpected</span></span><br><span class="line"><span class="comment">     *         internal error.</span></span><br><span class="line"><span class="comment">     * @return device The inteface to this camera device, or null in case of</span></span><br><span class="line"><span class="comment">     *     error.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">getCameraDeviceInterface_V1_x</span>(string cameraDeviceName) <span class="built_in">generates</span></span><br><span class="line">            (Status status,</span><br><span class="line">             android.hardware.camera.device@<span class="number">1.0</span>::ICameraDevice device);</span><br><span class="line">    <span class="built_in">getCameraDeviceInterface_V3_x</span>(string cameraDeviceName) <span class="built_in">generates</span></span><br><span class="line">            (Status status,</span><br><span class="line">             android.hardware.camera.device@<span class="number">3.2</span>::ICameraDevice device);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该文件中定义了ICameraProvider接口类，由CameraProvider继承并实现，在Camera Provider启动的时候被实例化，主要接口如下：</p>
<ul>
<li>getCameraDeviceInterface_V3_x: 该方法主要用于Camera Service获取ICameraDevice，通过该对象可以控制Camera 设备的诸如配置数据流、下发request等具体行为。</li>
<li>setCallback： 将Camera Service 实现的ICameraProviderCallback传入Camera Provider，一旦Provider有事件产生时便可以通过该对象通知Camera Service。</li>
</ul>
<p>ICameraProviderCallback.hal源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2016 The Android Open Source Project</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">package android.hardware.camera.provider@<span class="number">2.4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.common@<span class="number">1.0</span>::types;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callback functions for a camera provider HAL to use to inform the camera</span></span><br><span class="line"><span class="comment"> * service of changes to the camera subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">interface ICameraProviderCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cameraDeviceStatusChange:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Callback to the camera service to indicate that the state of a specific</span></span><br><span class="line"><span class="comment">     * camera device has changed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * On camera service startup, when ICameraProvider::setCallback is invoked,</span></span><br><span class="line"><span class="comment">     * the camera service must assume that all internal camera devices are in</span></span><br><span class="line"><span class="comment">     * the CAMERA_DEVICE_STATUS_PRESENT state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The provider must call this method to inform the camera service of any</span></span><br><span class="line"><span class="comment">     * initially NOT_PRESENT devices, and of any external camera devices that</span></span><br><span class="line"><span class="comment">     * are already present, as soon as the callbacks are available through</span></span><br><span class="line"><span class="comment">     * setCallback.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param cameraDeviceName The name of the camera device that has a</span></span><br><span class="line"><span class="comment">     *     new status.</span></span><br><span class="line"><span class="comment">     * @param newStatus The new status that device is in.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">cameraDeviceStatusChange</span>(string cameraDeviceName,</span><br><span class="line">            CameraDeviceStatus newStatus);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * torchModeStatusChange:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Callback to the camera service to indicate that the state of the torch</span></span><br><span class="line"><span class="comment">     * mode of the flash unit associated with a specific camera device has</span></span><br><span class="line"><span class="comment">     * changed. At provider registration time, the camera service must assume</span></span><br><span class="line"><span class="comment">     * the torch modes are in the TORCH_MODE_STATUS_AVAILABLE_OFF state if</span></span><br><span class="line"><span class="comment">     * android.flash.info.available is reported as true via the</span></span><br><span class="line"><span class="comment">     * ICameraDevice::getCameraCharacteristics call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param cameraDeviceName The name of the camera device that has a</span></span><br><span class="line"><span class="comment">     *     new status.</span></span><br><span class="line"><span class="comment">     * @param newStatus The new status that device is in.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">torchModeStatusChange</span>(string cameraDeviceName,</span><br><span class="line">            TorchModeStatus newStatus);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该文件中定义了ICameraDeviceCallback接口类，由Camera Service中的Camera3Device继承并实现，通过调用ICameraDevice::open方法注册到Provider中，其主要接口如下：</p>
<ul>
<li>processCaptureResult_3_4: 一旦有图像数据产生会通过调用该方法将数据以及meta data上传至Camera Service。</li>
<li>notify: 通过该方法上传事件至Camera Service中，比如shutter事件等。</li>
</ul>
<p>ICameraDeviceSession.hal源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2016 The Android Open Source Project</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">package android.hardware.camera.device@<span class="number">3.2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.common@<span class="number">1.0</span>::types;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Camera device active session interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Obtained via ICameraDevice::open(), this interface contains the methods to</span></span><br><span class="line"><span class="comment"> * configure and request captures from an active camera device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">interface ICameraDeviceSession &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * constructDefaultRequestSettings:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Create capture settings for standard camera use cases.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The device must return a settings buffer that is configured to meet the</span></span><br><span class="line"><span class="comment">     * requested use case, which must be one of the CAMERA3_TEMPLATE_*</span></span><br><span class="line"><span class="comment">     * enums. All request control fields must be included.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This must be a non-blocking call. The HAL should return from this call</span></span><br><span class="line"><span class="comment">     * in 1ms, and must return from this call in 5ms.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     * @return status Status code for the operation, one of:</span></span><br><span class="line"><span class="comment">     *     OK:</span></span><br><span class="line"><span class="comment">     *         On a successful construction of default settings.</span></span><br><span class="line"><span class="comment">     *     INTERNAL_ERROR:</span></span><br><span class="line"><span class="comment">     *         An unexpected internal error occurred, and the default settings</span></span><br><span class="line"><span class="comment">     *         are not available.</span></span><br><span class="line"><span class="comment">     *     ILLEGAL_ARGUMENT:</span></span><br><span class="line"><span class="comment">     *         The camera HAL does not support the input template type</span></span><br><span class="line"><span class="comment">     *     CAMERA_DISCONNECTED:</span></span><br><span class="line"><span class="comment">     *         An external camera device has been disconnected, and is no longer</span></span><br><span class="line"><span class="comment">     *         available. This camera device interface is now stale, and a new</span></span><br><span class="line"><span class="comment">     *         instance must be acquired if the device is reconnected. All</span></span><br><span class="line"><span class="comment">     *         subsequent calls on this interface must return</span></span><br><span class="line"><span class="comment">     *         CAMERA_DISCONNECTED.</span></span><br><span class="line"><span class="comment">     * @return template The default capture request settings for the requested</span></span><br><span class="line"><span class="comment">     *     use case, or an empty metadata structure if status is not OK.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">constructDefaultRequestSettings</span>(RequestTemplate type) <span class="built_in">generates</span></span><br><span class="line">            (Status status, CameraMetadata requestTemplate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * configureStreams:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Reset the HAL camera device processing pipeline and set up new input and</span></span><br><span class="line"><span class="comment">     * output streams. This call replaces any existing stream configuration with</span></span><br><span class="line"><span class="comment">     * the streams defined in the streamList. This method must be called at</span></span><br><span class="line"><span class="comment">     * least once before a request is submitted with processCaptureRequest().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The streamList must contain at least one output-capable stream, and may</span></span><br><span class="line"><span class="comment">     * not contain more than one input-capable stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The streamList may contain streams that are also in the currently-active</span></span><br><span class="line"><span class="comment">     * set of streams (from the previous call to configureStreams()). These</span></span><br><span class="line"><span class="comment">     * streams must already have valid values for usage, maxBuffers, and the</span></span><br><span class="line"><span class="comment">     * private pointer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the HAL needs to change the stream configuration for an existing</span></span><br><span class="line"><span class="comment">     * stream due to the new configuration, it may rewrite the values of usage</span></span><br><span class="line"><span class="comment">     * and/or maxBuffers during the configure call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework must detect such a change, and may then reallocate the</span></span><br><span class="line"><span class="comment">     * stream buffers before using buffers from that stream in a request.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If a currently-active stream is not included in streamList, the HAL may</span></span><br><span class="line"><span class="comment">     * safely remove any references to that stream. It must not be reused in a</span></span><br><span class="line"><span class="comment">     * later configureStreams() call by the framework, and all the gralloc</span></span><br><span class="line"><span class="comment">     * buffers for it must be freed after the configureStreams() call returns.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the stream is new, the client must set the consumer usage flags in</span></span><br><span class="line"><span class="comment">     * requestedConfiguration. Upon return, the HAL device must set producerUsage,</span></span><br><span class="line"><span class="comment">     * maxBuffers, and other fields in the configureStreams() return values. These</span></span><br><span class="line"><span class="comment">     * fields are then used by the framework and the platform gralloc module to</span></span><br><span class="line"><span class="comment">     * allocate the gralloc buffers for each stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Newly allocated buffers may be included in a capture request at any time</span></span><br><span class="line"><span class="comment">     * by the framework. Once a gralloc buffer is returned to the framework</span></span><br><span class="line"><span class="comment">     * with processCaptureResult (and its respective releaseFence has been</span></span><br><span class="line"><span class="comment">     * signaled) the framework may free or reuse it at any time.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Preconditions:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework must only call this method when no captures are being</span></span><br><span class="line"><span class="comment">     * processed. That is, all results have been returned to the framework, and</span></span><br><span class="line"><span class="comment">     * all in-flight input and output buffers have been returned and their</span></span><br><span class="line"><span class="comment">     * release sync fences have been signaled by the HAL. The framework must not</span></span><br><span class="line"><span class="comment">     * submit new requests for capture while the configureStreams() call is</span></span><br><span class="line"><span class="comment">     * underway.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Postconditions:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL device must configure itself to provide maximum possible output</span></span><br><span class="line"><span class="comment">     * frame rate given the sizes and formats of the output streams, as</span></span><br><span class="line"><span class="comment">     * documented in the camera device&#x27;s static metadata.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This call is expected to be heavyweight and possibly take several hundred</span></span><br><span class="line"><span class="comment">     * milliseconds to complete, since it may require resetting and</span></span><br><span class="line"><span class="comment">     * reconfiguring the image sensor and the camera processing pipeline.</span></span><br><span class="line"><span class="comment">     * Nevertheless, the HAL device should attempt to minimize the</span></span><br><span class="line"><span class="comment">     * reconfiguration delay to minimize the user-visible pauses during</span></span><br><span class="line"><span class="comment">     * application operational mode changes (such as switching from still</span></span><br><span class="line"><span class="comment">     * capture to video recording).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL should return from this call in 500ms, and must return from this</span></span><br><span class="line"><span class="comment">     * call in 1000ms.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return Status Status code for the operation, one of:</span></span><br><span class="line"><span class="comment">     *     OK:</span></span><br><span class="line"><span class="comment">     *          On successful stream configuration.</span></span><br><span class="line"><span class="comment">     *     INTERNAL_ERROR:</span></span><br><span class="line"><span class="comment">     *         If there has been a fatal error and the device is no longer</span></span><br><span class="line"><span class="comment">     *         operational. Only close() can be called successfully by the</span></span><br><span class="line"><span class="comment">     *         framework after this error is returned.</span></span><br><span class="line"><span class="comment">     *     ILLEGAL_ARGUMENT:</span></span><br><span class="line"><span class="comment">     *         If the requested stream configuration is invalid. Some examples</span></span><br><span class="line"><span class="comment">     *         of invalid stream configurations include:</span></span><br><span class="line"><span class="comment">     *           - Including more than 1 INPUT stream</span></span><br><span class="line"><span class="comment">     *           - Not including any OUTPUT streams</span></span><br><span class="line"><span class="comment">     *           - Including streams with unsupported formats, or an unsupported</span></span><br><span class="line"><span class="comment">     *             size for that format.</span></span><br><span class="line"><span class="comment">     *           - Including too many output streams of a certain format.</span></span><br><span class="line"><span class="comment">     *           - Unsupported rotation configuration</span></span><br><span class="line"><span class="comment">     *           - Stream sizes/formats don&#x27;t satisfy the</span></span><br><span class="line"><span class="comment">     *             StreamConfigurationMode requirements for non-NORMAL mode, or</span></span><br><span class="line"><span class="comment">     *             the requested operation_mode is not supported by the HAL.</span></span><br><span class="line"><span class="comment">     *           - Unsupported usage flag</span></span><br><span class="line"><span class="comment">     *         The camera service cannot filter out all possible illegal stream</span></span><br><span class="line"><span class="comment">     *         configurations, since some devices may support more simultaneous</span></span><br><span class="line"><span class="comment">     *         streams or larger stream resolutions than the minimum required</span></span><br><span class="line"><span class="comment">     *         for a given camera device hardware level. The HAL must return an</span></span><br><span class="line"><span class="comment">     *         ILLEGAL_ARGUMENT for any unsupported stream set, and then be</span></span><br><span class="line"><span class="comment">     *         ready to accept a future valid stream configuration in a later</span></span><br><span class="line"><span class="comment">     *         configureStreams call.</span></span><br><span class="line"><span class="comment">     * @return finalConfiguration The stream parameters desired by the HAL for</span></span><br><span class="line"><span class="comment">     *     each stream, including maximum buffers, the usage flags, and the</span></span><br><span class="line"><span class="comment">     *     override format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">configureStreams</span>(StreamConfiguration requestedConfiguration)</span><br><span class="line">            <span class="built_in">generates</span> (Status status,</span><br><span class="line">                    HalStreamConfiguration halConfiguration);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * processCaptureRequest:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Send a list of capture requests to the HAL. The HAL must not return from</span></span><br><span class="line"><span class="comment">     * this call until it is ready to accept the next set of requests to</span></span><br><span class="line"><span class="comment">     * process. Only one call to processCaptureRequest() must be made at a time</span></span><br><span class="line"><span class="comment">     * by the framework, and the calls must all be from the same thread. The</span></span><br><span class="line"><span class="comment">     * next call to processCaptureRequest() must be made as soon as a new</span></span><br><span class="line"><span class="comment">     * request and its associated buffers are available. In a normal preview</span></span><br><span class="line"><span class="comment">     * scenario, this means the function is generally called again by the</span></span><br><span class="line"><span class="comment">     * framework almost instantly. If more than one request is provided by the</span></span><br><span class="line"><span class="comment">     * client, the HAL must process the requests in order of lowest index to</span></span><br><span class="line"><span class="comment">     * highest index.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The cachesToRemove argument contains a list of buffer caches (see</span></span><br><span class="line"><span class="comment">     * StreamBuffer document for more information on buffer cache) to be removed</span></span><br><span class="line"><span class="comment">     * by camera HAL. Camera HAL must remove these cache entries whether or not</span></span><br><span class="line"><span class="comment">     * this method returns OK.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The actual request processing is asynchronous, with the results of</span></span><br><span class="line"><span class="comment">     * capture being returned by the HAL through the processCaptureResult()</span></span><br><span class="line"><span class="comment">     * call. This call requires the result metadata to be available, but output</span></span><br><span class="line"><span class="comment">     * buffers may simply provide sync fences to wait on. Multiple requests are</span></span><br><span class="line"><span class="comment">     * expected to be in flight at once, to maintain full output frame rate.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework retains ownership of the request structure. It is only</span></span><br><span class="line"><span class="comment">     * guaranteed to be valid during this call. The HAL device must make copies</span></span><br><span class="line"><span class="comment">     * of the information it needs to retain for the capture processing. The HAL</span></span><br><span class="line"><span class="comment">     * is responsible for waiting on and closing the buffers&#x27; fences and</span></span><br><span class="line"><span class="comment">     * returning the buffer handles to the framework.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL must write the file descriptor for the input buffer&#x27;s release</span></span><br><span class="line"><span class="comment">     * sync fence into input_buffer-&gt;release_fence, if input_buffer is not</span></span><br><span class="line"><span class="comment">     * valid. If the HAL returns -1 for the input buffer release sync fence, the</span></span><br><span class="line"><span class="comment">     * framework is free to immediately reuse the input buffer. Otherwise, the</span></span><br><span class="line"><span class="comment">     * framework must wait on the sync fence before refilling and reusing the</span></span><br><span class="line"><span class="comment">     * input buffer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The input/output buffers provided by the framework in each request</span></span><br><span class="line"><span class="comment">     * may be brand new (having never before seen by the HAL).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * Performance considerations:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Handling a new buffer should be extremely lightweight and there must be</span></span><br><span class="line"><span class="comment">     * no frame rate degradation or frame jitter introduced.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This call must return fast enough to ensure that the requested frame</span></span><br><span class="line"><span class="comment">     * rate can be sustained, especially for streaming cases (post-processing</span></span><br><span class="line"><span class="comment">     * quality settings set to FAST). The HAL should return this call in 1</span></span><br><span class="line"><span class="comment">     * frame interval, and must return from this call in 4 frame intervals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return status Status code for the operation, one of:</span></span><br><span class="line"><span class="comment">     *     OK:</span></span><br><span class="line"><span class="comment">     *         On a successful start to processing the capture request</span></span><br><span class="line"><span class="comment">     *     ILLEGAL_ARGUMENT:</span></span><br><span class="line"><span class="comment">     *         If the input is malformed (the settings are empty when not</span></span><br><span class="line"><span class="comment">     *         allowed, there are 0 output buffers, etc) and capture processing</span></span><br><span class="line"><span class="comment">     *         cannot start. Failures during request processing must be</span></span><br><span class="line"><span class="comment">     *         handled by calling ICameraDeviceCallback::notify(). In case of</span></span><br><span class="line"><span class="comment">     *         this error, the framework retains responsibility for the</span></span><br><span class="line"><span class="comment">     *         stream buffers&#x27; fences and the buffer handles; the HAL must not</span></span><br><span class="line"><span class="comment">     *         close the fences or return these buffers with</span></span><br><span class="line"><span class="comment">     *         ICameraDeviceCallback::processCaptureResult().</span></span><br><span class="line"><span class="comment">     *     INTERNAL_ERROR:</span></span><br><span class="line"><span class="comment">     *         If the camera device has encountered a serious error. After this</span></span><br><span class="line"><span class="comment">     *         error is returned, only the close() method can be successfully</span></span><br><span class="line"><span class="comment">     *         called by the framework.</span></span><br><span class="line"><span class="comment">     * @return numRequestProcessed Number of requests successfully processed by</span></span><br><span class="line"><span class="comment">     *     camera HAL. When status is OK, this must be equal to the size of</span></span><br><span class="line"><span class="comment">     *     requests. When the call fails, this number is the number of requests</span></span><br><span class="line"><span class="comment">     *     that HAL processed successfully before HAL runs into an error.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">processCaptureRequest</span>(vec&lt;CaptureRequest&gt; requests,</span><br><span class="line">            vec&lt;BufferCache&gt; cachesToRemove)</span><br><span class="line">            <span class="built_in">generates</span> (Status status, <span class="keyword">uint32_t</span> numRequestProcessed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getCaptureRequestMetadataQueue:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Retrieves the queue used along with processCaptureRequest. If</span></span><br><span class="line"><span class="comment">     * client decides to use fast message queue to pass request metadata,</span></span><br><span class="line"><span class="comment">     * it must:</span></span><br><span class="line"><span class="comment">     * - Call getCaptureRequestMetadataQueue to retrieve the fast message queue;</span></span><br><span class="line"><span class="comment">     * - In each of the requests sent in processCaptureRequest, set</span></span><br><span class="line"><span class="comment">     *   fmqSettingsSize field of CaptureRequest to be the size to read from the</span></span><br><span class="line"><span class="comment">     *   fast message queue; leave settings field of CaptureRequest empty.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return queue the queue that client writes request metadata to.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">getCaptureRequestMetadataQueue</span>() <span class="built_in">generates</span> (fmq_sync&lt;<span class="keyword">uint8_t</span>&gt; queue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getCaptureResultMetadataQueue:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Retrieves the queue used along with</span></span><br><span class="line"><span class="comment">     * ICameraDeviceCallback.processCaptureResult.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Clients to ICameraDeviceSession must:</span></span><br><span class="line"><span class="comment">     * - Call getCaptureRequestMetadataQueue to retrieve the fast message queue;</span></span><br><span class="line"><span class="comment">     * - In implementation of ICameraDeviceCallback, test whether</span></span><br><span class="line"><span class="comment">     *   .fmqResultSize field is zero.</span></span><br><span class="line"><span class="comment">     *     - If .fmqResultSize != 0, read result metadata from the fast message</span></span><br><span class="line"><span class="comment">     *       queue;</span></span><br><span class="line"><span class="comment">     *     - otherwise, read result metadata in CaptureResult.result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return queue the queue that implementation writes result metadata to.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">getCaptureResultMetadataQueue</span>() <span class="built_in">generates</span> (fmq_sync&lt;<span class="keyword">uint8_t</span>&gt; queue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * flush:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Flush all currently in-process captures and all buffers in the pipeline</span></span><br><span class="line"><span class="comment">     * on the given device. Generally, this method is used to dump all state as</span></span><br><span class="line"><span class="comment">     * quickly as possible in order to prepare for a configure_streams() call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * No buffers are required to be successfully returned, so every buffer</span></span><br><span class="line"><span class="comment">     * held at the time of flush() (whether successfully filled or not) may be</span></span><br><span class="line"><span class="comment">     * returned with CAMERA3_BUFFER_STATUS_ERROR. Note the HAL is still allowed</span></span><br><span class="line"><span class="comment">     * to return valid (CAMERA3_BUFFER_STATUS_OK) buffers during this call,</span></span><br><span class="line"><span class="comment">     * provided they are successfully filled.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * All requests currently in the HAL are expected to be returned as soon as</span></span><br><span class="line"><span class="comment">     * possible. Not-in-process requests must return errors immediately. Any</span></span><br><span class="line"><span class="comment">     * interruptible hardware blocks must be stopped, and any uninterruptible</span></span><br><span class="line"><span class="comment">     * blocks must be waited on.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * flush() may be called concurrently to processCaptureRequest(), with the</span></span><br><span class="line"><span class="comment">     * expectation that processCaptureRequest returns quickly and the</span></span><br><span class="line"><span class="comment">     * request submitted in that processCaptureRequest call is treated like</span></span><br><span class="line"><span class="comment">     * all other in-flight requests. Due to concurrency issues, it is possible</span></span><br><span class="line"><span class="comment">     * that from the HAL&#x27;s point of view, a processCaptureRequest() call may</span></span><br><span class="line"><span class="comment">     * be started after flush has been invoked but has not returned yet. If such</span></span><br><span class="line"><span class="comment">     * a call happens before flush() returns, the HAL must treat the new</span></span><br><span class="line"><span class="comment">     * capture request like other in-flight pending requests (see #4 below).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * More specifically, the HAL must follow below requirements for various</span></span><br><span class="line"><span class="comment">     * cases:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. For captures that are too late for the HAL to cancel/stop, and must be</span></span><br><span class="line"><span class="comment">     *    completed normally by the HAL; i.e. the HAL can send shutter/notify</span></span><br><span class="line"><span class="comment">     *    and processCaptureResult and buffers as normal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. For pending requests that have not done any processing, the HAL must</span></span><br><span class="line"><span class="comment">     *    call notify CAMERA3_MSG_ERROR_REQUEST, and return all the output</span></span><br><span class="line"><span class="comment">     *    buffers with processCaptureResult in the error state</span></span><br><span class="line"><span class="comment">     *    (CAMERA3_BUFFER_STATUS_ERROR). The HAL must not place the release</span></span><br><span class="line"><span class="comment">     *    fence into an error state, instead, the release fences must be set to</span></span><br><span class="line"><span class="comment">     *    the acquire fences passed by the framework, or -1 if they have been</span></span><br><span class="line"><span class="comment">     *    waited on by the HAL already. This is also the path to follow for any</span></span><br><span class="line"><span class="comment">     *    captures for which the HAL already called notify() with</span></span><br><span class="line"><span class="comment">     *    CAMERA3_MSG_SHUTTER but won&#x27;t be producing any metadata/valid buffers</span></span><br><span class="line"><span class="comment">     *    for. After CAMERA3_MSG_ERROR_REQUEST, for a given frame, only</span></span><br><span class="line"><span class="comment">     *    processCaptureResults with buffers in CAMERA3_BUFFER_STATUS_ERROR</span></span><br><span class="line"><span class="comment">     *    are allowed. No further notifys or processCaptureResult with</span></span><br><span class="line"><span class="comment">     *    non-empty metadata is allowed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. For partially completed pending requests that do not have all the</span></span><br><span class="line"><span class="comment">     *    output buffers or perhaps missing metadata, the HAL must follow</span></span><br><span class="line"><span class="comment">     *    below:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.1. Call notify with CAMERA3_MSG_ERROR_RESULT if some of the expected</span></span><br><span class="line"><span class="comment">     *         result metadata (i.e. one or more partial metadata) won&#x27;t be</span></span><br><span class="line"><span class="comment">     *         available for the capture.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.2. Call notify with CAMERA3_MSG_ERROR_BUFFER for every buffer that</span></span><br><span class="line"><span class="comment">     *         won&#x27;t be produced for the capture.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.3. Call notify with CAMERA3_MSG_SHUTTER with the capture timestamp</span></span><br><span class="line"><span class="comment">     *         before any buffers/metadata are returned with</span></span><br><span class="line"><span class="comment">     *         processCaptureResult.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.4. For captures that will produce some results, the HAL must not</span></span><br><span class="line"><span class="comment">     *         call CAMERA3_MSG_ERROR_REQUEST, since that indicates complete</span></span><br><span class="line"><span class="comment">     *         failure.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.5. Valid buffers/metadata must be passed to the framework as</span></span><br><span class="line"><span class="comment">     *         normal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.6. Failed buffers must be returned to the framework as described</span></span><br><span class="line"><span class="comment">     *         for case 2. But failed buffers do not have to follow the strict</span></span><br><span class="line"><span class="comment">     *         ordering valid buffers do, and may be out-of-order with respect</span></span><br><span class="line"><span class="comment">     *         to valid buffers. For example, if buffers A, B, C, D, E are sent,</span></span><br><span class="line"><span class="comment">     *         D and E are failed, then A, E, B, D, C is an acceptable return</span></span><br><span class="line"><span class="comment">     *         order.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.7. For fully-missing metadata, calling CAMERA3_MSG_ERROR_RESULT is</span></span><br><span class="line"><span class="comment">     *         sufficient, no need to call processCaptureResult with empty</span></span><br><span class="line"><span class="comment">     *         metadata or equivalent.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 4. If a flush() is invoked while a processCaptureRequest() invocation</span></span><br><span class="line"><span class="comment">     *    is active, that process call must return as soon as possible. In</span></span><br><span class="line"><span class="comment">     *    addition, if a processCaptureRequest() call is made after flush()</span></span><br><span class="line"><span class="comment">     *    has been invoked but before flush() has returned, the capture request</span></span><br><span class="line"><span class="comment">     *    provided by the late processCaptureRequest call must be treated</span></span><br><span class="line"><span class="comment">     *    like a pending request in case #2 above.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * flush() must only return when there are no more outstanding buffers or</span></span><br><span class="line"><span class="comment">     * requests left in the HAL. The framework may call configure_streams (as</span></span><br><span class="line"><span class="comment">     * the HAL state is now quiesced) or may issue new requests.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that it&#x27;s sufficient to only support fully-succeeded and</span></span><br><span class="line"><span class="comment">     * fully-failed result cases. However, it is highly desirable to support</span></span><br><span class="line"><span class="comment">     * the partial failure cases as well, as it could help improve the flush</span></span><br><span class="line"><span class="comment">     * call overall performance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL should return from this call in 100ms, and must return from this</span></span><br><span class="line"><span class="comment">     * call in 1000ms. And this call must not be blocked longer than pipeline</span></span><br><span class="line"><span class="comment">     * latency (see S7 for definition).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return status Status code for the operation, one of:</span></span><br><span class="line"><span class="comment">     *     OK:</span></span><br><span class="line"><span class="comment">     *         On a successful flush of the camera HAL.</span></span><br><span class="line"><span class="comment">     *     INTERNAL_ERROR:</span></span><br><span class="line"><span class="comment">     *         If the camera device has encountered a serious error. After this</span></span><br><span class="line"><span class="comment">     *         error is returned, only the close() method can be successfully</span></span><br><span class="line"><span class="comment">     *         called by the framework.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">flush</span>() <span class="built_in">generates</span> (Status status);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * close:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Shut down the camera device.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * After this call, all calls to this session instance must return</span></span><br><span class="line"><span class="comment">     * INTERNAL_ERROR.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method must always succeed, even if the device has encountered a</span></span><br><span class="line"><span class="comment">     * serious error.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">close</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该文件中定义了ICameraDeviceSession接口类，由CameraDeviceSession::TrampolineSessionInterface_3_2继承并实现，其主要接口如下：</p>
<ul>
<li>constructDefaultRequestSettings：用于创建默认的Request配置项。</li>
<li>configureStreams_3_5：用于配置数据流，其中包括了output buffer/Surface/图像格式大小等属性。</li>
<li>processCaptureRequest_3_4：下发request到Provider中，一个request对应着一次图像需求。</li>
<li>close: 关闭当前会话。</li>
</ul>
<h2 id="三-、Camera-Provider-主程序"><a href="#三-、Camera-Provider-主程序" class="headerlink" title="三 、Camera Provider 主程序"></a>三 、Camera Provider 主程序</h2><p>接下来进入到Provider内部去看看，整个进程是如何运转的，以下图为例进行分析:<br><img src="Image-2.png" alt="alt text"><br>在系统初始化的时候，系统会去运行<a href="mailto:&#97;&#110;&#100;&#114;&#111;&#x69;&#x64;&#x2e;&#104;&#97;&#114;&#100;&#119;&#97;&#114;&#101;&#x2e;&#x63;&#97;&#x6d;&#x65;&#114;&#x61;&#x2e;&#x70;&#x72;&#x6f;&#x76;&#x69;&#100;&#101;&#114;&#x40;&#x32;&#46;&#x34;&#x2d;&#x73;&#101;&#x72;&#x76;&#105;&#99;&#101;&#x5f;&#x36;&#x34;">&#97;&#110;&#100;&#114;&#111;&#x69;&#x64;&#x2e;&#104;&#97;&#114;&#100;&#119;&#97;&#114;&#101;&#x2e;&#x63;&#97;&#x6d;&#x65;&#114;&#x61;&#x2e;&#x70;&#x72;&#x6f;&#x76;&#x69;&#100;&#101;&#114;&#x40;&#x32;&#46;&#x34;&#x2d;&#x73;&#101;&#x72;&#x76;&#105;&#99;&#101;&#x5f;&#x36;&#x34;</a>程序启动Provider进程，并加入HW Service Manager中接受统一管理，在该过程中实例化了一个LegacyCameraProviderImpl_2_4对象，并在其构造函数中通过hw_get_module标准方法获取HAL的camera_module_t结构体,并将其存入CameraModule对象中，之后通过调用该camera_modult_t结构体的init方法初始化HAL Module，紧接着调用其get_number_of_camera方法获取当前HAL支持的Camera数量，最后通过调用其set_callbacks方法将LegcyCameraProviderImpl_2_4（LegcyCameraProviderImpl_2_4继承了camera_modult_callback_t）作为参数传入CamX-CHI中，接受来自CamX-CHI中的数据以及事件，当这一系列动作完成了之后，Camera Provider进程便一直便存在于系统中，监听着来自Camera Service的调用。</p>
<p><img src="Image-3.png" alt="alt text"><br>接下来以上图为例简单介绍下Provider中几个重要流程：</p>
<ul>
<li>Camera Service通过调用ICameraProvider的getCameraDeviceInterface_v3_x接口获取ICameraDevice，在此过程中，Provider会去实例化一个CameraDevice对象，并且将之前存有camera_modult_t结构体的CameraModule对象传入CameraDevice中，这样就可以在CameraDevice内部通过CameraModule访问到camera_module_t的相关资源，然后将CameraDevice内部类TrampolineDeviceInterface_3_2（该类继承并实现了ICameraDevice接口）返回给Camera Service。</li>
<li>Camera Service通过之前获取的ICameraDevice，调用其open方法来打开Camera设备，接着在Provider中会去调用CameraDevice对象的open方法，在该方法内部会去调用camera_module_t结构体的open方法，从而获取到HAL部分的camera3_device_t结构体，紧接着Provider会实例化一个CameraDeviceSession对象，并且将刚才获取到的camera3_device_t结构体以参数的方式传入CameraDeviceSession中，在CameraDeviceSession的构造方法中又会调用CameraDeviceSession的initialize方法，在该方法内部又会去调用camera3_device_t结构体的ops内的initialize方法开始HAL部分的初始化工作，最后CameraDeviceSession对象被作为camera3_callback_ops的实现传入HAL，接收来自HAL的数据或者具体事件，当一切动作都完成后，Provider会将CameraDeviceSession::TrampolineSessionInterface_3_2（该类继承并实现了ICameraDeviceSession接口）对象通过HIDL回调的方法返回给Camera Service中。</li>
<li>Camera Service通过调用ICameraDevcieSession的configureStreams_3_5接口进行数据流的配置，在Provider中，最终会通过调用之前获取的camera3_device_t结构体内ops的configure_streams方法下发到HAL中进行处理。</li>
<li>Camera Service通过调用ICameraDevcieSession的processCaptureRequest_3_4接口下发request请求到Provider中，在Provider中，最终依然会通过调用获取的camera3_device_t结构体内ops中的process_capture_request方法将此次请求下发到HAL中进行处理。</li>
</ul>
<p>从整个流程不难看出，这几个接口最终对应的是HAL3的接口，并且Provider并没有经过太多复杂的额外的处理。</p>
<h2 id="四、Camera-HAL3-接口"><a href="#四、Camera-HAL3-接口" class="headerlink" title="四、Camera HAL3 接口"></a>四、Camera HAL3 接口</h2><p>HAL硬件抽象层(Hardware Abstraction Layer)，是谷歌开发的用于屏蔽底层硬件抽象出来的一个软件层， 每一个平台厂商可以将不开源的的代码封装在这一层，仅仅提供二进制文件。<br>该层定义了自己的一套通用标准接口，平台厂商务必按照以下规则定义自己的Module:</p>
<ul>
<li>每一个硬件都通过hw_module_t来描述，具有固定的名字HMI</li>
<li>每一个硬件都必须实现hw_module_t里面的open方法，用于打开硬件设备，并返回对应的操作接口集合</li>
<li>硬件的操作接口集合使用hw_device_t 来描述，并可以通过自定义一个更大的包含hw_device_t的结构体来拓展硬件操作集合</li>
</ul>
<p>其中代表模块的是hw_module_t，对应的设备是通过hw_device_t来描述，这两者的定义如下：<br>hw_module_t/hw_device_t源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2008 The Android Open Source Project</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ANDROID_INCLUDE_HARDWARE_HARDWARE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_INCLUDE_HARDWARE_HARDWARE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/cdefs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cutils/native_handle.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;system/graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__BEGIN_DECLS</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Value for the hw_module_t.tag field</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_TAG_CONSTANT(A,B,C,D) (((A) &lt;&lt; 24) | ((B) &lt;&lt; 16) | ((C) &lt;&lt; 8) | (D))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_MODULE_TAG MAKE_TAG_CONSTANT(<span class="meta-string">&#x27;H&#x27;</span>, <span class="meta-string">&#x27;W&#x27;</span>, <span class="meta-string">&#x27;M&#x27;</span>, <span class="meta-string">&#x27;T&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_DEVICE_TAG MAKE_TAG_CONSTANT(<span class="meta-string">&#x27;H&#x27;</span>, <span class="meta-string">&#x27;W&#x27;</span>, <span class="meta-string">&#x27;D&#x27;</span>, <span class="meta-string">&#x27;T&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_MAKE_API_VERSION(maj,min) \</span></span><br><span class="line"><span class="meta">            ((((maj) &amp; 0xff) &lt;&lt; 8) | ((min) &amp; 0xff))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_MAKE_API_VERSION_2(maj,min,hdr) \</span></span><br><span class="line"><span class="meta">            ((((maj) &amp; 0xff) &lt;&lt; 24) | (((min) &amp; 0xff) &lt;&lt; 16) | ((hdr) &amp; 0xffff))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_API_VERSION_2_MAJ_MIN_MASK 0xffff0000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_API_VERSION_2_HEADER_MASK  0x0000ffff</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The current HAL API version.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All module implementations must set the hw_module_t.hal_api_version field</span></span><br><span class="line"><span class="comment"> * to this value when declaring the module with HAL_MODULE_INFO_SYM.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that previous implementations have always set this field to 0.</span></span><br><span class="line"><span class="comment"> * Therefore, libhardware HAL API will always consider versions 0.0 and 1.0</span></span><br><span class="line"><span class="comment"> * to be 100% binary compatible.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_HAL_API_VERSION HARDWARE_MAKE_API_VERSION(1, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper macros for module implementors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The derived modules should provide convenience macros for supported</span></span><br><span class="line"><span class="comment"> * versions so that implementations can explicitly specify module/device</span></span><br><span class="line"><span class="comment"> * versions at definition time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use this macro to set the hw_module_t.module_api_version field.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_MODULE_API_VERSION(maj,min) HARDWARE_MAKE_API_VERSION(maj,min)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_MODULE_API_VERSION_2(maj,min,hdr) HARDWARE_MAKE_API_VERSION_2(maj,min,hdr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Use this macro to set the hw_device_t.version field</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_DEVICE_API_VERSION(maj,min) HARDWARE_MAKE_API_VERSION(maj,min)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HARDWARE_DEVICE_API_VERSION_2(maj,min,hdr) HARDWARE_MAKE_API_VERSION_2(maj,min,hdr)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hw_device_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Every hardware module must have a data structure named HAL_MODULE_INFO_SYM</span></span><br><span class="line"><span class="comment"> * and the fields of this data structure must begin with hw_module_t</span></span><br><span class="line"><span class="comment"> * followed by module specific information.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span> &#123;</span></span><br><span class="line">    <span class="comment">/** tag must be initialized to HARDWARE_MODULE_TAG */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The API version of the implemented module. The module owner is</span></span><br><span class="line"><span class="comment">     * responsible for updating the version when a module interface has</span></span><br><span class="line"><span class="comment">     * changed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The derived modules such as gralloc and audio own and manage this field.</span></span><br><span class="line"><span class="comment">     * The module user must interpret the version field to decide whether or</span></span><br><span class="line"><span class="comment">     * not to inter-operate with the supplied module implementation.</span></span><br><span class="line"><span class="comment">     * For example, SurfaceFlinger is responsible for making sure that</span></span><br><span class="line"><span class="comment">     * it knows how to manage different versions of the gralloc-module API,</span></span><br><span class="line"><span class="comment">     * and AudioFlinger must know how to do the same for audio-module API.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The module API version should include a major and a minor component.</span></span><br><span class="line"><span class="comment">     * For example, version 1.0 could be represented as 0x0100. This format</span></span><br><span class="line"><span class="comment">     * implies that versions 0x0100-0x01ff are all API-compatible.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * In the future, libhardware will expose a hw_get_module_version()</span></span><br><span class="line"><span class="comment">     * (or equivalent) function that will take minimum/maximum supported</span></span><br><span class="line"><span class="comment">     * versions as arguments and would be able to reject modules with</span></span><br><span class="line"><span class="comment">     * versions outside of the supplied range.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> module_api_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> version_major module_api_version</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * version_major/version_minor defines are supplied here for temporary</span></span><br><span class="line"><span class="comment">     * source code compatibility. They will be removed in the next version.</span></span><br><span class="line"><span class="comment">     * ALL clients must convert to the new version format.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The API version of the HAL module interface. This is meant to</span></span><br><span class="line"><span class="comment">     * version the hw_module_t, hw_module_methods_t, and hw_device_t</span></span><br><span class="line"><span class="comment">     * structures and definitions.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL interface owns this field. Module users/implementations</span></span><br><span class="line"><span class="comment">     * must NOT rely on this value for version information.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Presently, 0 is the only valid value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> hal_api_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> version_minor hal_api_version</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Identifier of module */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Name of this module */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Author/owner/implementor of the module */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *author;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Modules methods */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span>* <span class="title">methods</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** module&#x27;s dso */</span></span><br><span class="line">    <span class="keyword">void</span>* dso;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint64_t</span> reserved[<span class="number">32</span><span class="number">-7</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/** padding to 128 bytes, reserved for future use */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved[<span class="number">32</span><span class="number">-7</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">hw_module_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span> &#123;</span></span><br><span class="line">    <span class="comment">/** Open a specific device */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*open)(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* id,</span><br><span class="line">            struct <span class="keyword">hw_device_t</span>** device);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">hw_module_methods_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Every device data structure must begin with hw_device_t</span></span><br><span class="line"><span class="comment"> * followed by module specific public methods and attributes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_device_t</span> &#123;</span></span><br><span class="line">    <span class="comment">/** tag must be initialized to HARDWARE_DEVICE_TAG */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Version of the module-specific device API. This value is used by</span></span><br><span class="line"><span class="comment">     * the derived-module user to manage different device implementations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The module user is responsible for checking the module_api_version</span></span><br><span class="line"><span class="comment">     * and device version fields to ensure that the user is capable of</span></span><br><span class="line"><span class="comment">     * communicating with the specific module implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * One module can support multiple devices with different versions. This</span></span><br><span class="line"><span class="comment">     * can be useful when a device interface changes in an incompatible way</span></span><br><span class="line"><span class="comment">     * but it is still necessary to support older implementations at the same</span></span><br><span class="line"><span class="comment">     * time. One such example is the Camera 2.0 API.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This field is interpreted by the module user and is ignored by the</span></span><br><span class="line"><span class="comment">     * HAL interface itself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** reference to the module this device belongs to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span>* <span class="title">module</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** padding reserved for future use */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint64_t</span> reserved[<span class="number">12</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved[<span class="number">12</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Close this device */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*close)(struct <span class="keyword">hw_device_t</span>* device);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">hw_device_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TO_HW_DEVICE_T_OPEN(x) reinterpret_cast<span class="meta-string">&lt;struct hw_device_t**&gt;</span>(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TO_HW_DEVICE_T_OPEN(x) (struct hw_device_t**)(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Name of the hal_module_info</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_MODULE_INFO_SYM         HMI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Name of the hal_module_info as a string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_MODULE_INFO_SYM_AS_STR  <span class="meta-string">&quot;HMI&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the module info associated with a module by id.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return: 0 == success, &lt;0 == error and *module == NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw_get_module</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *id, <span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> **<span class="keyword">module</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the module info associated with a module instance by class &#x27;class_id&#x27;</span></span><br><span class="line"><span class="comment"> * and instance &#x27;inst&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Some modules types necessitate multiple instances. For example audio supports</span></span><br><span class="line"><span class="comment"> * multiple concurrent interfaces and thus &#x27;audio&#x27; is the module class</span></span><br><span class="line"><span class="comment"> * and &#x27;primary&#x27; or &#x27;a2dp&#x27; are module interfaces. This implies that the files</span></span><br><span class="line"><span class="comment"> * providing these modules would be named audio.primary.&lt;variant&gt;.so and</span></span><br><span class="line"><span class="comment"> * audio.a2dp.&lt;variant&gt;.so</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return: 0 == success, &lt;0 == error and *module == NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw_get_module_by_class</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *class_id, <span class="keyword">const</span> <span class="keyword">char</span> *inst,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> **<span class="keyword">module</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">__END_DECLS</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">/* ANDROID_INCLUDE_HARDWARE_HARDWARE_H */</span></span></span><br></pre></td></tr></table></figure>
<p>从上面的定义可以看出，主要是通过hw_module_t 代表了模块，通过其open方法用来打开一个设备，而该设备是用hw_device_t来表示，其中除了用来关闭设备的close方法外，并无其它方法，由此可见谷歌定义的HAL接口，并不能满足绝大部分HAL模块的需要，所以谷歌想出了一个比较好的解决方式，那便是将这两个基本结构嵌入到更大的结构体内部，同时在更大的结构内部定义了各自模块特有的方法，用于实现模块的功能，这样，一来对上保持了HAL的统一规范，二来也扩展了模块的功能。</p>
<p>基于上面的方式，谷歌便针对Camera 提出了HAL3接口，其中主要包括了用于代表一系列操作主体的结构体以及具体操作函数，接下来我们分别进行详细介绍：</p>
<h3 id="1-核心结构体解析"><a href="#1-核心结构体解析" class="headerlink" title="1. 核心结构体解析"></a>1. 核心结构体解析</h3><p>HAL3中主要定义了camera_module_t/camera3_device_t/camera3_stream_configuration/camera3_stream以及camera3_stream_buffer几个主要结构体。</p>
<p>其中camera_module_t以及camera3_device_t代码定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera_module</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Common methods of the camera module.  This *must* be the first member of</span></span><br><span class="line"><span class="comment">     * camera_module as users of this structure will cast a hw_module_t to</span></span><br><span class="line"><span class="comment">     * camera_module pointer in contexts where it&#x27;s known the hw_module_t</span></span><br><span class="line"><span class="comment">     * references a camera_module.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The return values for common.methods-&gt;open for camera_module are:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0:           On a successful open of the camera device.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENODEV:     The camera device cannot be opened due to an internal</span></span><br><span class="line"><span class="comment">     *              error.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL:     The input arguments are invalid, i.e. the id is invalid,</span></span><br><span class="line"><span class="comment">     *              and/or the module is invalid.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EBUSY:      The camera device was already opened for this camera id</span></span><br><span class="line"><span class="comment">     *              (by using this method or open_legacy),</span></span><br><span class="line"><span class="comment">     *              regardless of the device HAL version it was opened as.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EUSERS:     The maximal number of camera devices that can be</span></span><br><span class="line"><span class="comment">     *              opened concurrently were opened already, either by</span></span><br><span class="line"><span class="comment">     *              this method or the open_legacy method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * All other return values from common.methods-&gt;open will be treated as</span></span><br><span class="line"><span class="comment">     * -ENODEV.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">hw_module_t</span> common;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get_number_of_cameras:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Returns the number of camera devices accessible through the camera</span></span><br><span class="line"><span class="comment">     * module.  The camera devices are numbered 0 through N-1, where N is the</span></span><br><span class="line"><span class="comment">     * value returned by this call. The name of the camera device for open() is</span></span><br><span class="line"><span class="comment">     * simply the number converted to a string. That is, &quot;0&quot; for camera ID 0,</span></span><br><span class="line"><span class="comment">     * &quot;1&quot; for camera ID 1.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information (based on camera_module_t.common.module_api_version):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_2_3 or lower:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   The value here must be static, and cannot change after the first call</span></span><br><span class="line"><span class="comment">     *   to this method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_2_4 or higher:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   The value here must be static, and must count only built-in cameras,</span></span><br><span class="line"><span class="comment">     *   which have CAMERA_FACING_BACK or CAMERA_FACING_FRONT camera facing values</span></span><br><span class="line"><span class="comment">     *   (camera_info.facing). The HAL must not include the external cameras</span></span><br><span class="line"><span class="comment">     *   (camera_info.facing == CAMERA_FACING_EXTERNAL) into the return value</span></span><br><span class="line"><span class="comment">     *   of this call. Frameworks will use camera_device_status_change callback</span></span><br><span class="line"><span class="comment">     *   to manage number of external cameras.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*get_number_of_cameras)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get_camera_info:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return the static camera information for a given camera device. This</span></span><br><span class="line"><span class="comment">     * information may not change for a camera device.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0:           On a successful operation</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENODEV:     The information cannot be provided due to an internal</span></span><br><span class="line"><span class="comment">     *              error.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL:     The input arguments are invalid, i.e. the id is invalid,</span></span><br><span class="line"><span class="comment">     *              and/or the module is invalid.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information (based on camera_module_t.common.module_api_version):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_2_4 or higher:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   When a camera is disconnected, its camera id becomes invalid. Calling this</span></span><br><span class="line"><span class="comment">     *   this method with this invalid camera id will get -EINVAL and NULL camera</span></span><br><span class="line"><span class="comment">     *   static metadata (camera_info.static_camera_characteristics).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*get_camera_info)(<span class="keyword">int</span> camera_id, struct camera_info *info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set_callbacks:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Provide callback function pointers to the HAL module to inform framework</span></span><br><span class="line"><span class="comment">     * of asynchronous camera module events. The framework will call this</span></span><br><span class="line"><span class="comment">     * function once after initial camera HAL module load, after the</span></span><br><span class="line"><span class="comment">     * get_number_of_cameras() method is called for the first time, and before</span></span><br><span class="line"><span class="comment">     * any other calls to the module.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information (based on camera_module_t.common.module_api_version):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  CAMERA_MODULE_API_VERSION_1_0, CAMERA_MODULE_API_VERSION_2_0:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    Not provided by HAL module. Framework may not call this function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  CAMERA_MODULE_API_VERSION_2_1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    Valid to be called by the framework.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0:           On a successful operation</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENODEV:     The operation cannot be completed due to an internal</span></span><br><span class="line"><span class="comment">     *              error.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL:     The input arguments are invalid, i.e. the callbacks are</span></span><br><span class="line"><span class="comment">     *              null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*set_callbacks)(<span class="keyword">const</span> <span class="keyword">camera_module_callbacks_t</span> *callbacks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get_vendor_tag_ops:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Get methods to query for vendor extension metadata tag information. The</span></span><br><span class="line"><span class="comment">     * HAL should fill in all the vendor tag operation methods, or leave ops</span></span><br><span class="line"><span class="comment">     * unchanged if no vendor tags are defined.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The vendor_tag_ops structure used here is defined in:</span></span><br><span class="line"><span class="comment">     * system/media/camera/include/system/vendor_tags.h</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information (based on camera_module_t.common.module_api_version):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  CAMERA_MODULE_API_VERSION_1_x/2_0/2_1:</span></span><br><span class="line"><span class="comment">     *    Not provided by HAL module. Framework may not call this function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  CAMERA_MODULE_API_VERSION_2_2:</span></span><br><span class="line"><span class="comment">     *    Valid to be called by the framework.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*get_vendor_tag_ops)(<span class="keyword">vendor_tag_ops_t</span>* ops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * open_legacy:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Open a specific legacy camera HAL device if multiple device HAL API</span></span><br><span class="line"><span class="comment">     * versions are supported by this camera HAL module. For example, if the</span></span><br><span class="line"><span class="comment">     * camera module supports both CAMERA_DEVICE_API_VERSION_1_0 and</span></span><br><span class="line"><span class="comment">     * CAMERA_DEVICE_API_VERSION_3_2 device API for the same camera id,</span></span><br><span class="line"><span class="comment">     * framework can call this function to open the camera device as</span></span><br><span class="line"><span class="comment">     * CAMERA_DEVICE_API_VERSION_1_0 device.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This is an optional method. A Camera HAL module does not need to support</span></span><br><span class="line"><span class="comment">     * more than one device HAL version per device, and such modules may return</span></span><br><span class="line"><span class="comment">     * -ENOSYS for all calls to this method. For all older HAL device API</span></span><br><span class="line"><span class="comment">     * versions that are not supported, it may return -EOPNOTSUPP. When above</span></span><br><span class="line"><span class="comment">     * cases occur, The normal open() method (common.methods-&gt;open) will be</span></span><br><span class="line"><span class="comment">     * used by the framework instead.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information (based on camera_module_t.common.module_api_version):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  CAMERA_MODULE_API_VERSION_1_x/2_0/2_1/2_2:</span></span><br><span class="line"><span class="comment">     *    Not provided by HAL module. Framework will not call this function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  CAMERA_MODULE_API_VERSION_2_3:</span></span><br><span class="line"><span class="comment">     *    Valid to be called by the framework.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0:           On a successful open of the camera device.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENOSYS      This method is not supported.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EOPNOTSUPP: The requested HAL version is not supported by this method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL:     The input arguments are invalid, i.e. the id is invalid,</span></span><br><span class="line"><span class="comment">     *              and/or the module is invalid.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EBUSY:      The camera device was already opened for this camera id</span></span><br><span class="line"><span class="comment">     *              (by using this method or common.methods-&gt;open method),</span></span><br><span class="line"><span class="comment">     *              regardless of the device HAL version it was opened as.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EUSERS:     The maximal number of camera devices that can be</span></span><br><span class="line"><span class="comment">     *              opened concurrently were opened already, either by</span></span><br><span class="line"><span class="comment">     *              this method or common.methods-&gt;open method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*open_legacy)(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* id,</span><br><span class="line">            <span class="keyword">uint32_t</span> halVersion, struct <span class="keyword">hw_device_t</span>** device);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set_torch_mode:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Turn on or off the torch mode of the flash unit associated with a given</span></span><br><span class="line"><span class="comment">     * camera ID. If the operation is successful, HAL must notify the framework</span></span><br><span class="line"><span class="comment">     * torch state by invoking</span></span><br><span class="line"><span class="comment">     * camera_module_callbacks.torch_mode_status_change() with the new state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The camera device has a higher priority accessing the flash unit. When</span></span><br><span class="line"><span class="comment">     * there are any resource conflicts, such as open() is called to open a</span></span><br><span class="line"><span class="comment">     * camera device, HAL module must notify the framework through</span></span><br><span class="line"><span class="comment">     * camera_module_callbacks.torch_mode_status_change() that the</span></span><br><span class="line"><span class="comment">     * torch mode has been turned off and the torch mode state has become</span></span><br><span class="line"><span class="comment">     * TORCH_MODE_STATUS_NOT_AVAILABLE. When resources to turn on torch mode</span></span><br><span class="line"><span class="comment">     * become available again, HAL module must notify the framework through</span></span><br><span class="line"><span class="comment">     * camera_module_callbacks.torch_mode_status_change() that the torch mode</span></span><br><span class="line"><span class="comment">     * state has become TORCH_MODE_STATUS_AVAILABLE_OFF for set_torch_mode() to</span></span><br><span class="line"><span class="comment">     * be called.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When the framework calls set_torch_mode() to turn on the torch mode of a</span></span><br><span class="line"><span class="comment">     * flash unit, if HAL cannot keep multiple torch modes on simultaneously,</span></span><br><span class="line"><span class="comment">     * HAL should turn off the torch mode that was turned on by</span></span><br><span class="line"><span class="comment">     * a previous set_torch_mode() call and notify the framework that the torch</span></span><br><span class="line"><span class="comment">     * mode state of that flash unit has become TORCH_MODE_STATUS_AVAILABLE_OFF.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information (based on camera_module_t.common.module_api_version):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_1_x/2_0/2_1/2_2/2_3:</span></span><br><span class="line"><span class="comment">     *   Not provided by HAL module. Framework will not call this function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_2_4:</span></span><br><span class="line"><span class="comment">     *   Valid to be called by the framework.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0:           On a successful operation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENOSYS:     The camera device does not support this operation. It is</span></span><br><span class="line"><span class="comment">     *              returned if and only if android.flash.info.available is</span></span><br><span class="line"><span class="comment">     *              false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EBUSY:      The camera device is already in use.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EUSERS:     The resources needed to turn on the torch mode are not</span></span><br><span class="line"><span class="comment">     *              available, typically because other camera devices are</span></span><br><span class="line"><span class="comment">     *              holding the resources to make using the flash unit not</span></span><br><span class="line"><span class="comment">     *              possible.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL:     camera_id is invalid.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*set_torch_mode)(<span class="keyword">const</span> <span class="keyword">char</span>* camera_id, <span class="keyword">bool</span> enabled);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * init:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method is called by the camera service before any other methods</span></span><br><span class="line"><span class="comment">     * are invoked, right after the camera HAL library has been successfully</span></span><br><span class="line"><span class="comment">     * loaded. It may be left as NULL by the HAL module, if no initialization</span></span><br><span class="line"><span class="comment">     * in needed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It can be used by HAL implementations to perform initialization and</span></span><br><span class="line"><span class="comment">     * other one-time operations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information (based on camera_module_t.common.module_api_version):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_1_x/2_0/2_1/2_2/2_3:</span></span><br><span class="line"><span class="comment">     *   Not provided by HAL module. Framework will not call this function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_2_4:</span></span><br><span class="line"><span class="comment">     *   If not NULL, will always be called by the framework once after the HAL</span></span><br><span class="line"><span class="comment">     *   module is loaded, before any other HAL module method is called.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0:           On a successful operation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENODEV:     Initialization cannot be completed due to an internal</span></span><br><span class="line"><span class="comment">     *              error. The HAL must be assumed to be in a nonfunctional</span></span><br><span class="line"><span class="comment">     *              state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*init)();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get_physical_camera_info:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return the static metadata for a physical camera as a part of a logical</span></span><br><span class="line"><span class="comment">     * camera device. This function is only called for those physical camera</span></span><br><span class="line"><span class="comment">     * ID(s) that are not exposed independently. In other words, camera_id will</span></span><br><span class="line"><span class="comment">     * be greater or equal to the return value of get_number_of_cameras().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0:           On a successful operation</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENODEV:     The information cannot be provided due to an internal</span></span><br><span class="line"><span class="comment">     *              error.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL:     The input arguments are invalid, i.e. the id is invalid,</span></span><br><span class="line"><span class="comment">     *              and/or the module is invalid.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information (based on camera_module_t.common.module_api_version):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_1_x/2_0/2_1/2_2/2_3/2_4:</span></span><br><span class="line"><span class="comment">     *   Not provided by HAL module. Framework will not call this function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_2_5 or higher:</span></span><br><span class="line"><span class="comment">     *   If any of the camera devices accessible through this camera module is</span></span><br><span class="line"><span class="comment">     *   a logical multi-camera, and at least one of the physical cameras isn&#x27;t</span></span><br><span class="line"><span class="comment">     *   a stand-alone camera device, this function will be called by the camera</span></span><br><span class="line"><span class="comment">     *   framework. Calling this function with invalid physical_camera_id will</span></span><br><span class="line"><span class="comment">     *   get -EINVAL, and NULL static_metadata.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*get_physical_camera_info)(<span class="keyword">int</span> physical_camera_id,</span><br><span class="line">            <span class="keyword">camera_metadata_t</span> **static_metadata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * is_stream_combination_supported:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Check for device support of specific camera stream combination.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0:           In case the stream combination is supported.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL:     In case the stream combination is not supported.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENOSYS:     In case stream combination query is not supported.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information (based on camera_module_t.common.module_api_version):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_1_x/2_0/2_1/2_2/2_3/2_4:</span></span><br><span class="line"><span class="comment">     *   Not provided by HAL module. Framework will not call this function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_MODULE_API_VERSION_2_5 or higher:</span></span><br><span class="line"><span class="comment">     *   Valid to be called by the framework.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*is_stream_combination_supported)(<span class="keyword">int</span> camera_id,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera_stream_combination_t</span> *streams);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * notify_device_state_change:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Notify the camera module that the state of the overall device has</span></span><br><span class="line"><span class="comment">     * changed in some way that the HAL may want to know about.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, a physical shutter may have been uncovered or covered,</span></span><br><span class="line"><span class="comment">     * or a camera may have been covered or uncovered by an add-on keyboard</span></span><br><span class="line"><span class="comment">     * or other accessory.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The state is a bitfield of potential states, and some physical configurations</span></span><br><span class="line"><span class="comment">     * could plausibly correspond to multiple different combinations of state bits.</span></span><br><span class="line"><span class="comment">     * The HAL must ignore any state bits it is not actively using to determine</span></span><br><span class="line"><span class="comment">     * the appropriate camera configuration.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, on some devices the FOLDED state could mean that</span></span><br><span class="line"><span class="comment">     * backward-facing cameras are covered by the fold, so FOLDED by itself implies</span></span><br><span class="line"><span class="comment">     * BACK_COVERED. But other devices may support folding but not cover any cameras</span></span><br><span class="line"><span class="comment">     * when folded, so for those FOLDED would not imply any of the other flags.</span></span><br><span class="line"><span class="comment">     * Since these relationships are very device-specific, it is difficult to specify</span></span><br><span class="line"><span class="comment">     * a comprehensive policy.  But as a recommendation, it is suggested that if a flag</span></span><br><span class="line"><span class="comment">     * necessarily implies other flags are set as well, then those flags should be set.</span></span><br><span class="line"><span class="comment">     * So even though FOLDED would be enough to infer BACK_COVERED on some devices, the</span></span><br><span class="line"><span class="comment">     * BACK_COVERED flag should also be set for clarity.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method may be invoked by the HAL client at any time. It must not</span></span><br><span class="line"><span class="comment">     * cause any active camera device sessions to be closed, but may dynamically</span></span><br><span class="line"><span class="comment">     * change which physical camera a logical multi-camera is using for its</span></span><br><span class="line"><span class="comment">     * active and future output.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The method must be invoked by the HAL client at least once before the</span></span><br><span class="line"><span class="comment">     * client calls ICameraDevice::open on any camera device interfaces listed</span></span><br><span class="line"><span class="comment">     * by this provider, to establish the initial device state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that the deviceState is 64-bit bitmask, with system defined states in</span></span><br><span class="line"><span class="comment">     * lower 32-bit and vendor defined states in upper 32-bit.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*notify_device_state_change)(<span class="keyword">uint64_t</span> deviceState);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reserved for future use */</span></span><br><span class="line">    <span class="keyword">void</span>* reserved[<span class="number">2</span>];</span><br><span class="line">&#125; <span class="keyword">camera_module_t</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera3_device</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * common.version must equal CAMERA_DEVICE_API_VERSION_3_0 to identify this</span></span><br><span class="line"><span class="comment">     * device as implementing version 3.0 of the camera device HAL.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Camera open (common.module-&gt;common.methods-&gt;open) should return in 200ms, and must return</span></span><br><span class="line"><span class="comment">     * in 500ms.</span></span><br><span class="line"><span class="comment">     * Camera close (common.close) should return in 200ms, and must return in 500ms.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">hw_device_t</span> common;</span><br><span class="line">    <span class="keyword">camera3_device_ops_t</span> *ops;</span><br><span class="line">    <span class="keyword">void</span> *priv;</span><br><span class="line">&#125; <span class="keyword">camera3_device_t</span>;</span><br></pre></td></tr></table></figure>
<p>由定义不难发现，camera_module_t包含了hw_module_t，主要用于表示Camera模块，其中定义了诸如get_number_of_cameras以及set_callbacks等扩展方法，而camera3_device_t包含了hw_device_t，主要用来表示Camera设备，其中定义了camera3_device_ops操作方法集合，用来实现正常获取图像数据以及控制Camera的功能。</p>
<p>结构体camera3_stream_configuration代码定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera3_stream_configuration</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The total number of streams requested by the framework.  This includes</span></span><br><span class="line"><span class="comment">     * both input and output streams. The number of streams will be at least 1,</span></span><br><span class="line"><span class="comment">     * and there will be at least one output-capable stream.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> num_streams;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An array of camera stream pointers, defining the input/output</span></span><br><span class="line"><span class="comment">     * configuration for the camera HAL device.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * At most one input-capable stream may be defined (INPUT or BIDIRECTIONAL)</span></span><br><span class="line"><span class="comment">     * in a single configuration.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * At least one output-capable stream must be defined (OUTPUT or</span></span><br><span class="line"><span class="comment">     * BIDIRECTIONAL).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">camera3_stream_t</span> **streams;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_3:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The operation mode of streams in this configuration, one of the value</span></span><br><span class="line"><span class="comment">     * defined in camera3_stream_configuration_mode_t.  The HAL can use this</span></span><br><span class="line"><span class="comment">     * mode as an indicator to set the stream property (e.g.,</span></span><br><span class="line"><span class="comment">     * camera3_stream-&gt;max_buffers) appropriately. For example, if the</span></span><br><span class="line"><span class="comment">     * configuration is</span></span><br><span class="line"><span class="comment">     * CAMERA3_STREAM_CONFIGURATION_CONSTRAINED_HIGH_SPEED_MODE, the HAL may</span></span><br><span class="line"><span class="comment">     * want to set aside more buffers for batch mode operation (see</span></span><br><span class="line"><span class="comment">     * android.control.availableHighSpeedVideoConfigurations for batch mode</span></span><br><span class="line"><span class="comment">     * definition).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> operation_mode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_5:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The session metadata buffer contains the initial values of</span></span><br><span class="line"><span class="comment">     * ANDROID_REQUEST_AVAILABLE_SESSION_KEYS. This field is optional</span></span><br><span class="line"><span class="comment">     * and camera clients can choose to ignore it, in which case it will</span></span><br><span class="line"><span class="comment">     * be set to NULL. If parameters are present, then Hal should examine</span></span><br><span class="line"><span class="comment">     * the parameter values and configure its internal camera pipeline</span></span><br><span class="line"><span class="comment">     * accordingly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">camera_metadata_t</span> *session_parameters;</span><br><span class="line">&#125; <span class="keyword">camera3_stream_configuration_t</span>;</span><br></pre></td></tr></table></figure>
<p>该结构体主要用来代表配置的数据流列表，内部装有上层需要进行配置的数据流的指针，内部的定义简单介绍下：</p>
<ul>
<li>num_streams: 代表了来自上层的数据流的数量，其中包括了output以及input stream。</li>
<li>streams: 是streams的指针数组，包括了至少一条output stream以及至多一条input stream。</li>
<li>operation_mode: 当前数据流的操作模式，该模式在camera3_stream_configuration_mode_t中被定义，HAL通过这个参数可以针对streams做不同的设置。</li>
<li>session_parameters: 该参数可以作为缺省参数，直接设置为NULL即可，CAMERA_DEVICE_API_VERSION_3_5以上的版本才支持。</li>
</ul>
<p>结构体camera3_stream_t的代码定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * camera3_stream_t:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A handle to a single camera input or output stream. A stream is defined by</span></span><br><span class="line"><span class="comment"> * the framework by its buffer resolution and format, and additionally by the</span></span><br><span class="line"><span class="comment"> * HAL with the gralloc usage flags and the maximum in-flight buffer count.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The stream structures are owned by the framework, but pointers to a</span></span><br><span class="line"><span class="comment"> * camera3_stream passed into the HAL by configure_streams() are valid until the</span></span><br><span class="line"><span class="comment"> * end of the first subsequent configure_streams() call that _does not_ include</span></span><br><span class="line"><span class="comment"> * that camera3_stream as an argument, or until the end of the close() call.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All camera3_stream framework-controlled members are immutable once the</span></span><br><span class="line"><span class="comment"> * camera3_stream is passed into configure_streams().  The HAL may only change</span></span><br><span class="line"><span class="comment"> * the HAL-controlled parameters during a configure_streams() call, except for</span></span><br><span class="line"><span class="comment"> * the contents of the private pointer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If a configure_streams() call returns a non-fatal error, all active streams</span></span><br><span class="line"><span class="comment"> * remain valid as if configure_streams() had not been called.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The endpoint of the stream is not visible to the camera HAL device.</span></span><br><span class="line"><span class="comment"> * In DEVICE_API_VERSION_3_1, this was changed to share consumer usage flags</span></span><br><span class="line"><span class="comment"> * on streams where the camera is a producer (OUTPUT and BIDIRECTIONAL stream</span></span><br><span class="line"><span class="comment"> * types) see the usage field below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera3_stream</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*****</span></span><br><span class="line"><span class="comment">     * Set by framework before configure_streams()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The type of the stream, one of the camera3_stream_type_t values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> stream_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The width in pixels of the buffers in this stream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The height in pixels of the buffers in this stream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The pixel format for the buffers in this stream. Format is a value from</span></span><br><span class="line"><span class="comment">     * the HAL_PIXEL_FORMAT_* list in system/core/include/system/graphics.h, or</span></span><br><span class="line"><span class="comment">     * from device-specific headers.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED is used, then the platform</span></span><br><span class="line"><span class="comment">     * gralloc module will select a format based on the usage flags provided by</span></span><br><span class="line"><span class="comment">     * the camera device and the other endpoint of the stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;= CAMERA_DEVICE_API_VERSION_3_1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The camera HAL device must inspect the buffers handed to it in the</span></span><br><span class="line"><span class="comment">     * subsequent register_stream_buffers() call to obtain the</span></span><br><span class="line"><span class="comment">     * implementation-specific format details, if necessary.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * register_stream_buffers() won&#x27;t be called by the framework, so the HAL</span></span><br><span class="line"><span class="comment">     * should configure the ISP and sensor pipeline based purely on the sizes,</span></span><br><span class="line"><span class="comment">     * usage flags, and formats for the configured streams.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> format;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*****</span></span><br><span class="line"><span class="comment">     * Set by HAL during configure_streams().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The gralloc usage flags for this stream, as needed by the HAL. The usage</span></span><br><span class="line"><span class="comment">     * flags are defined in gralloc.h (GRALLOC_USAGE_*), or in device-specific</span></span><br><span class="line"><span class="comment">     * headers.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For output streams, these are the HAL&#x27;s producer usage flags. For input</span></span><br><span class="line"><span class="comment">     * streams, these are the HAL&#x27;s consumer usage flags. The usage flags from</span></span><br><span class="line"><span class="comment">     * the producer and the consumer will be combined together and then passed</span></span><br><span class="line"><span class="comment">     * to the platform gralloc HAL module for allocating the gralloc buffers for</span></span><br><span class="line"><span class="comment">     * each stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * == CAMERA_DEVICE_API_VERSION_3_0:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   No initial value guaranteed when passed via configure_streams().</span></span><br><span class="line"><span class="comment">     *   HAL may not use this field as input, and must write over this field</span></span><br><span class="line"><span class="comment">     *   with its usage flags.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   For stream_type OUTPUT and BIDIRECTIONAL, when passed via</span></span><br><span class="line"><span class="comment">     *   configure_streams(), the initial value of this is the consumer&#x27;s</span></span><br><span class="line"><span class="comment">     *   usage flags.  The HAL may use these consumer flags to decide stream</span></span><br><span class="line"><span class="comment">     *   configuration.</span></span><br><span class="line"><span class="comment">     *   For stream_type INPUT, when passed via configure_streams(), the initial</span></span><br><span class="line"><span class="comment">     *   value of this is 0.</span></span><br><span class="line"><span class="comment">     *   For all streams passed via configure_streams(), the HAL must write</span></span><br><span class="line"><span class="comment">     *   over this field with its usage flags.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   From Android O, the usage flag for an output stream may be bitwise</span></span><br><span class="line"><span class="comment">     *   combination of usage flags for multiple consumers, for the purpose of</span></span><br><span class="line"><span class="comment">     *   sharing one camera stream between those consumers. The HAL must fail</span></span><br><span class="line"><span class="comment">     *   configure_streams call with -EINVAL if the combined flags cannot be</span></span><br><span class="line"><span class="comment">     *   supported due to imcompatible buffer format, dataSpace, or other hardware</span></span><br><span class="line"><span class="comment">     *   limitations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> usage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum number of buffers the HAL device may need to have dequeued at</span></span><br><span class="line"><span class="comment">     * the same time. The HAL device may not have more buffers in-flight from</span></span><br><span class="line"><span class="comment">     * this stream than this value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> max_buffers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A handle to HAL-private information for the stream. Will not be inspected</span></span><br><span class="line"><span class="comment">     * by the framework code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> *priv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A field that describes the contents of the buffer. The format and buffer</span></span><br><span class="line"><span class="comment">     * dimensions define the memory layout and structure of the stream buffers,</span></span><br><span class="line"><span class="comment">     * while dataSpace defines the meaning of the data within the buffer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For most formats, dataSpace defines the color space of the image data.</span></span><br><span class="line"><span class="comment">     * In addition, for some formats, dataSpace indicates whether image- or</span></span><br><span class="line"><span class="comment">     * depth-based data is requested.  See system/core/include/system/graphics.h</span></span><br><span class="line"><span class="comment">     * for details of formats and valid dataSpace values for each format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt; CAMERA_DEVICE_API_VERSION_3_3:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   Not defined and should not be accessed. dataSpace should be assumed to</span></span><br><span class="line"><span class="comment">     *   be HAL_DATASPACE_UNKNOWN, and the appropriate color space, etc, should</span></span><br><span class="line"><span class="comment">     *   be determined from the usage flags and the format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * = CAMERA_DEVICE_API_VERSION_3_3:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   Always set by the camera service. HAL must use this dataSpace to</span></span><br><span class="line"><span class="comment">     *   configure the stream to the correct colorspace, or to select between</span></span><br><span class="line"><span class="comment">     *   color and depth outputs if supported. The dataspace values are the</span></span><br><span class="line"><span class="comment">     *   legacy definitions in graphics.h</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_4:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   Always set by the camera service. HAL must use this dataSpace to</span></span><br><span class="line"><span class="comment">     *   configure the stream to the correct colorspace, or to select between</span></span><br><span class="line"><span class="comment">     *   color and depth outputs if supported. The dataspace values are set</span></span><br><span class="line"><span class="comment">     *   using the V0 dataspace definitions in graphics.h</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">android_dataspace_t</span> data_space;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The required output rotation of the stream, one of</span></span><br><span class="line"><span class="comment">     * the camera3_stream_rotation_t values. This must be inspected by HAL along</span></span><br><span class="line"><span class="comment">     * with stream width and height. For example, if the rotation is 90 degree</span></span><br><span class="line"><span class="comment">     * and the stream width and height is 720 and 1280 respectively, camera service</span></span><br><span class="line"><span class="comment">     * will supply buffers of size 720x1280, and HAL should capture a 1280x720 image</span></span><br><span class="line"><span class="comment">     * and rotate the image by 90 degree counterclockwise. The rotation field is</span></span><br><span class="line"><span class="comment">     * no-op when the stream type is input. Camera HAL must ignore the rotation</span></span><br><span class="line"><span class="comment">     * field for an input stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;= CAMERA_DEVICE_API_VERSION_3_2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    Not defined and must not be accessed. HAL must not apply any rotation</span></span><br><span class="line"><span class="comment">     *    on output images.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_3:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    Always set by camera service. HAL must inspect this field during stream</span></span><br><span class="line"><span class="comment">     *    configuration and returns -EINVAL if HAL cannot perform such rotation.</span></span><br><span class="line"><span class="comment">     *    HAL must always support CAMERA3_STREAM_ROTATION_0, so a</span></span><br><span class="line"><span class="comment">     *    configure_streams() call must not fail for unsupported rotation if</span></span><br><span class="line"><span class="comment">     *    rotation field of all streams is CAMERA3_STREAM_ROTATION_0.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> rotation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The physical camera id this stream belongs to.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;= CAMERA_DEVICE_API_VERISON_3_4:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    Not defined and must not be accessed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERISON_3_5:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    Always set by camera service. If the camera device is not a logical</span></span><br><span class="line"><span class="comment">     *    multi camera, or if the camera is a logical multi camera but the stream</span></span><br><span class="line"><span class="comment">     *    is not a physical output stream, this field will point to a 0-length</span></span><br><span class="line"><span class="comment">     *    string.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    A logical multi camera is a camera device backed by multiple physical</span></span><br><span class="line"><span class="comment">     *    cameras that are also exposed to the application. And for a logical</span></span><br><span class="line"><span class="comment">     *    multi camera, a physical output stream is an output stream specifically</span></span><br><span class="line"><span class="comment">     *    requested on an underlying physical camera.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    For an input stream, this field is guaranteed to be a 0-length string.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* physical_camera_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reserved for future use */</span></span><br><span class="line">    <span class="keyword">void</span> *reserved[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">camera3_stream_t</span>;</span><br></pre></td></tr></table></figure>
<p>该结构体主要用来代表具体的数据流实体，在整个的配置过程中，需要在上层进行填充，当下发到HAL中后，HAL会针对其中的各项属性进行配置，这里便简单介绍下其内部的各个元素的意义：</p>
<ul>
<li>stream_type: 表示数据流的类型，类型在camera3_stream_type_t中被定义。</li>
<li>width： 表示当前数据流中的buffer的宽度。</li>
<li>height: 表示当前数据流中buffer的高度。</li>
<li>format: 表示当前数据流中buffer的格式，该格式是在system/core/include/system/graphics.h中被定义。</li>
<li>usage： 表示当前数据流的gralloc用法，其用法定义在gralloc.h中。</li>
<li>max_buffers： 指定了当前数据流中可能支持的最大数据buffer数量。</li>
<li>data_space: 指定了当前数据流buffer中存储的图像数据的颜色空间。</li>
<li>rotation：指定了当前数据流的输出buffer的旋转角度，其角度的定义在camera3_stream_rotation_t中，该参数由Camera Service进行设置，必须在HAL中进行设置，该参数对于input stream并没有效果。</li>
<li>physical_camera_id： 指定了当前数据流从属的物理camera Id。</li>
</ul>
<p>结构体camera3_stream_buffer_t定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * camera3_stream_buffer_t:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A single buffer from a camera3 stream. It includes a handle to its parent</span></span><br><span class="line"><span class="comment"> * stream, the handle to the gralloc buffer itself, and sync fences</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The buffer does not specify whether it is to be used for input or output;</span></span><br><span class="line"><span class="comment"> * that is determined by its parent stream type and how the buffer is passed to</span></span><br><span class="line"><span class="comment"> * the HAL device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera3_stream_buffer</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The handle of the stream this buffer is associated with</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">camera3_stream_t</span> *stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The native handle to the buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">buffer_handle_t</span> *buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Current state of the buffer, one of the camera3_buffer_status_t</span></span><br><span class="line"><span class="comment">     * values. The framework will not pass buffers to the HAL that are in an</span></span><br><span class="line"><span class="comment">     * error state. In case a buffer could not be filled by the HAL, it must</span></span><br><span class="line"><span class="comment">     * have its status set to CAMERA3_BUFFER_STATUS_ERROR when returned to the</span></span><br><span class="line"><span class="comment">     * framework with process_capture_result().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The acquire sync fence for this buffer. The HAL must wait on this fence</span></span><br><span class="line"><span class="comment">     * fd before attempting to read from or write to this buffer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework may be set to -1 to indicate that no waiting is necessary</span></span><br><span class="line"><span class="comment">     * for this buffer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When the HAL returns an output buffer to the framework with</span></span><br><span class="line"><span class="comment">     * process_capture_result(), the acquire_fence must be set to -1. If the HAL</span></span><br><span class="line"><span class="comment">     * never waits on the acquire_fence due to an error in filling a buffer,</span></span><br><span class="line"><span class="comment">     * when calling process_capture_result() the HAL must set the release_fence</span></span><br><span class="line"><span class="comment">     * of the buffer to be the acquire_fence passed to it by the framework. This</span></span><br><span class="line"><span class="comment">     * will allow the framework to wait on the fence before reusing the buffer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For input buffers, the HAL must not change the acquire_fence field during</span></span><br><span class="line"><span class="comment">     * the process_capture_request() call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When the HAL returns an input buffer to the framework with</span></span><br><span class="line"><span class="comment">     * process_capture_result(), the acquire_fence must be set to -1. If the HAL</span></span><br><span class="line"><span class="comment">     * never waits on input buffer acquire fence due to an error, the sync</span></span><br><span class="line"><span class="comment">     * fences should be handled similarly to the way they are handled for output</span></span><br><span class="line"><span class="comment">     * buffers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">int</span> acquire_fence;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The release sync fence for this buffer. The HAL must set this fence when</span></span><br><span class="line"><span class="comment">     * returning buffers to the framework, or write -1 to indicate that no</span></span><br><span class="line"><span class="comment">     * waiting is required for this buffer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For the output buffers, the fences must be set in the output_buffers</span></span><br><span class="line"><span class="comment">     * array passed to process_capture_result().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;= CAMERA_DEVICE_API_VERSION_3_1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For the input buffer, the release fence must be set by the</span></span><br><span class="line"><span class="comment">     * process_capture_request() call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For the input buffer, the fences must be set in the input_buffer</span></span><br><span class="line"><span class="comment">     * passed to process_capture_result().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * After signaling the release_fence for this buffer, the HAL</span></span><br><span class="line"><span class="comment">     * should not make any further attempts to access this buffer as the</span></span><br><span class="line"><span class="comment">     * ownership has been fully transferred back to the framework.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If a fence of -1 was specified then the ownership of this buffer</span></span><br><span class="line"><span class="comment">     * is transferred back immediately upon the call of process_capture_result.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> release_fence;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">camera3_stream_buffer_t</span>;</span><br></pre></td></tr></table></figure>
<p>该结构体主要用来代表具体的buffer对象，其中重要元素如下：</p>
<ul>
<li>stream: 代表了从属的数据流</li>
<li>buffer：buffer句柄</li>
</ul>
<h3 id="2-核心接口函数解析"><a href="#2-核心接口函数解析" class="headerlink" title="2. 核心接口函数解析"></a>2. 核心接口函数解析</h3><p>HAL3的核心接口都是在camera3_device_ops中被定义，代码定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera3_device_ops</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * One-time initialization to pass framework callback function pointers to</span></span><br><span class="line"><span class="comment">     * the HAL. Will be called once after a successful open() call, before any</span></span><br><span class="line"><span class="comment">     * other functions are called on the camera3_device_ops structure.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This should be a non-blocking call. The HAL should return from this call</span></span><br><span class="line"><span class="comment">     * in 5ms, and must return from this call in 10ms.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  0:     On successful initialization</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENODEV: If initialization fails. Only close() can be called successfully</span></span><br><span class="line"><span class="comment">     *          by the framework after this.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*initialize)(<span class="keyword">const</span> struct camera3_device *,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_callback_ops_t</span> *callback_ops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">     * Stream management</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * configure_streams:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_DEVICE_API_VERSION_3_0 only:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Reset the HAL camera device processing pipeline and set up new input and</span></span><br><span class="line"><span class="comment">     * output streams. This call replaces any existing stream configuration with</span></span><br><span class="line"><span class="comment">     * the streams defined in the stream_list. This method will be called at</span></span><br><span class="line"><span class="comment">     * least once after initialize() before a request is submitted with</span></span><br><span class="line"><span class="comment">     * process_capture_request().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The stream_list must contain at least one output-capable stream, and may</span></span><br><span class="line"><span class="comment">     * not contain more than one input-capable stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The stream_list may contain streams that are also in the currently-active</span></span><br><span class="line"><span class="comment">     * set of streams (from the previous call to configure_stream()). These</span></span><br><span class="line"><span class="comment">     * streams will already have valid values for usage, max_buffers, and the</span></span><br><span class="line"><span class="comment">     * private pointer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If such a stream has already had its buffers registered,</span></span><br><span class="line"><span class="comment">     * register_stream_buffers() will not be called again for the stream, and</span></span><br><span class="line"><span class="comment">     * buffers from the stream can be immediately included in input requests.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the HAL needs to change the stream configuration for an existing</span></span><br><span class="line"><span class="comment">     * stream due to the new configuration, it may rewrite the values of usage</span></span><br><span class="line"><span class="comment">     * and/or max_buffers during the configure call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework will detect such a change, and will then reallocate the</span></span><br><span class="line"><span class="comment">     * stream buffers, and call register_stream_buffers() again before using</span></span><br><span class="line"><span class="comment">     * buffers from that stream in a request.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If a currently-active stream is not included in stream_list, the HAL may</span></span><br><span class="line"><span class="comment">     * safely remove any references to that stream. It will not be reused in a</span></span><br><span class="line"><span class="comment">     * later configure() call by the framework, and all the gralloc buffers for</span></span><br><span class="line"><span class="comment">     * it will be freed after the configure_streams() call returns.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The stream_list structure is owned by the framework, and may not be</span></span><br><span class="line"><span class="comment">     * accessed once this call completes. The address of an individual</span></span><br><span class="line"><span class="comment">     * camera3_stream_t structure will remain valid for access by the HAL until</span></span><br><span class="line"><span class="comment">     * the end of the first configure_stream() call which no longer includes</span></span><br><span class="line"><span class="comment">     * that camera3_stream_t in the stream_list argument. The HAL may not change</span></span><br><span class="line"><span class="comment">     * values in the stream structure outside of the private pointer, except for</span></span><br><span class="line"><span class="comment">     * the usage and max_buffers members during the configure_streams() call</span></span><br><span class="line"><span class="comment">     * itself.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the stream is new, the usage, max_buffer, and private pointer fields</span></span><br><span class="line"><span class="comment">     * of the stream structure will all be set to 0. The HAL device must set</span></span><br><span class="line"><span class="comment">     * these fields before the configure_streams() call returns. These fields</span></span><br><span class="line"><span class="comment">     * are then used by the framework and the platform gralloc module to</span></span><br><span class="line"><span class="comment">     * allocate the gralloc buffers for each stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Before such a new stream can have its buffers included in a capture</span></span><br><span class="line"><span class="comment">     * request, the framework will call register_stream_buffers() with that</span></span><br><span class="line"><span class="comment">     * stream. However, the framework is not required to register buffers for</span></span><br><span class="line"><span class="comment">     * _all_ streams before submitting a request. This allows for quick startup</span></span><br><span class="line"><span class="comment">     * of (for example) a preview stream, with allocation for other streams</span></span><br><span class="line"><span class="comment">     * happening later or concurrently.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * CAMERA_DEVICE_API_VERSION_3_1 only:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Reset the HAL camera device processing pipeline and set up new input and</span></span><br><span class="line"><span class="comment">     * output streams. This call replaces any existing stream configuration with</span></span><br><span class="line"><span class="comment">     * the streams defined in the stream_list. This method will be called at</span></span><br><span class="line"><span class="comment">     * least once after initialize() before a request is submitted with</span></span><br><span class="line"><span class="comment">     * process_capture_request().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The stream_list must contain at least one output-capable stream, and may</span></span><br><span class="line"><span class="comment">     * not contain more than one input-capable stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The stream_list may contain streams that are also in the currently-active</span></span><br><span class="line"><span class="comment">     * set of streams (from the previous call to configure_stream()). These</span></span><br><span class="line"><span class="comment">     * streams will already have valid values for usage, max_buffers, and the</span></span><br><span class="line"><span class="comment">     * private pointer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If such a stream has already had its buffers registered,</span></span><br><span class="line"><span class="comment">     * register_stream_buffers() will not be called again for the stream, and</span></span><br><span class="line"><span class="comment">     * buffers from the stream can be immediately included in input requests.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the HAL needs to change the stream configuration for an existing</span></span><br><span class="line"><span class="comment">     * stream due to the new configuration, it may rewrite the values of usage</span></span><br><span class="line"><span class="comment">     * and/or max_buffers during the configure call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework will detect such a change, and will then reallocate the</span></span><br><span class="line"><span class="comment">     * stream buffers, and call register_stream_buffers() again before using</span></span><br><span class="line"><span class="comment">     * buffers from that stream in a request.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If a currently-active stream is not included in stream_list, the HAL may</span></span><br><span class="line"><span class="comment">     * safely remove any references to that stream. It will not be reused in a</span></span><br><span class="line"><span class="comment">     * later configure() call by the framework, and all the gralloc buffers for</span></span><br><span class="line"><span class="comment">     * it will be freed after the configure_streams() call returns.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The stream_list structure is owned by the framework, and may not be</span></span><br><span class="line"><span class="comment">     * accessed once this call completes. The address of an individual</span></span><br><span class="line"><span class="comment">     * camera3_stream_t structure will remain valid for access by the HAL until</span></span><br><span class="line"><span class="comment">     * the end of the first configure_stream() call which no longer includes</span></span><br><span class="line"><span class="comment">     * that camera3_stream_t in the stream_list argument. The HAL may not change</span></span><br><span class="line"><span class="comment">     * values in the stream structure outside of the private pointer, except for</span></span><br><span class="line"><span class="comment">     * the usage and max_buffers members during the configure_streams() call</span></span><br><span class="line"><span class="comment">     * itself.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the stream is new, max_buffer, and private pointer fields of the</span></span><br><span class="line"><span class="comment">     * stream structure will all be set to 0. The usage will be set to the</span></span><br><span class="line"><span class="comment">     * consumer usage flags. The HAL device must set these fields before the</span></span><br><span class="line"><span class="comment">     * configure_streams() call returns. These fields are then used by the</span></span><br><span class="line"><span class="comment">     * framework and the platform gralloc module to allocate the gralloc</span></span><br><span class="line"><span class="comment">     * buffers for each stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Before such a new stream can have its buffers included in a capture</span></span><br><span class="line"><span class="comment">     * request, the framework will call register_stream_buffers() with that</span></span><br><span class="line"><span class="comment">     * stream. However, the framework is not required to register buffers for</span></span><br><span class="line"><span class="comment">     * _all_ streams before submitting a request. This allows for quick startup</span></span><br><span class="line"><span class="comment">     * of (for example) a preview stream, with allocation for other streams</span></span><br><span class="line"><span class="comment">     * happening later or concurrently.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Reset the HAL camera device processing pipeline and set up new input and</span></span><br><span class="line"><span class="comment">     * output streams. This call replaces any existing stream configuration with</span></span><br><span class="line"><span class="comment">     * the streams defined in the stream_list. This method will be called at</span></span><br><span class="line"><span class="comment">     * least once after initialize() before a request is submitted with</span></span><br><span class="line"><span class="comment">     * process_capture_request().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The stream_list must contain at least one output-capable stream, and may</span></span><br><span class="line"><span class="comment">     * not contain more than one input-capable stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The stream_list may contain streams that are also in the currently-active</span></span><br><span class="line"><span class="comment">     * set of streams (from the previous call to configure_stream()). These</span></span><br><span class="line"><span class="comment">     * streams will already have valid values for usage, max_buffers, and the</span></span><br><span class="line"><span class="comment">     * private pointer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the HAL needs to change the stream configuration for an existing</span></span><br><span class="line"><span class="comment">     * stream due to the new configuration, it may rewrite the values of usage</span></span><br><span class="line"><span class="comment">     * and/or max_buffers during the configure call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework will detect such a change, and may then reallocate the</span></span><br><span class="line"><span class="comment">     * stream buffers before using buffers from that stream in a request.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If a currently-active stream is not included in stream_list, the HAL may</span></span><br><span class="line"><span class="comment">     * safely remove any references to that stream. It will not be reused in a</span></span><br><span class="line"><span class="comment">     * later configure() call by the framework, and all the gralloc buffers for</span></span><br><span class="line"><span class="comment">     * it will be freed after the configure_streams() call returns.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The stream_list structure is owned by the framework, and may not be</span></span><br><span class="line"><span class="comment">     * accessed once this call completes. The address of an individual</span></span><br><span class="line"><span class="comment">     * camera3_stream_t structure will remain valid for access by the HAL until</span></span><br><span class="line"><span class="comment">     * the end of the first configure_stream() call which no longer includes</span></span><br><span class="line"><span class="comment">     * that camera3_stream_t in the stream_list argument. The HAL may not change</span></span><br><span class="line"><span class="comment">     * values in the stream structure outside of the private pointer, except for</span></span><br><span class="line"><span class="comment">     * the usage and max_buffers members during the configure_streams() call</span></span><br><span class="line"><span class="comment">     * itself.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the stream is new, max_buffer, and private pointer fields of the</span></span><br><span class="line"><span class="comment">     * stream structure will all be set to 0. The usage will be set to the</span></span><br><span class="line"><span class="comment">     * consumer usage flags. The HAL device must set these fields before the</span></span><br><span class="line"><span class="comment">     * configure_streams() call returns. These fields are then used by the</span></span><br><span class="line"><span class="comment">     * framework and the platform gralloc module to allocate the gralloc</span></span><br><span class="line"><span class="comment">     * buffers for each stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Newly allocated buffers may be included in a capture request at any time</span></span><br><span class="line"><span class="comment">     * by the framework. Once a gralloc buffer is returned to the framework</span></span><br><span class="line"><span class="comment">     * with process_capture_result (and its respective release_fence has been</span></span><br><span class="line"><span class="comment">     * signaled) the framework may free or reuse it at any time.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Preconditions:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework will only call this method when no captures are being</span></span><br><span class="line"><span class="comment">     * processed. That is, all results have been returned to the framework, and</span></span><br><span class="line"><span class="comment">     * all in-flight input and output buffers have been returned and their</span></span><br><span class="line"><span class="comment">     * release sync fences have been signaled by the HAL. The framework will not</span></span><br><span class="line"><span class="comment">     * submit new requests for capture while the configure_streams() call is</span></span><br><span class="line"><span class="comment">     * underway.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Postconditions:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL device must configure itself to provide maximum possible output</span></span><br><span class="line"><span class="comment">     * frame rate given the sizes and formats of the output streams, as</span></span><br><span class="line"><span class="comment">     * documented in the camera device&#x27;s static metadata.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This call is expected to be heavyweight and possibly take several hundred</span></span><br><span class="line"><span class="comment">     * milliseconds to complete, since it may require resetting and</span></span><br><span class="line"><span class="comment">     * reconfiguring the image sensor and the camera processing pipeline.</span></span><br><span class="line"><span class="comment">     * Nevertheless, the HAL device should attempt to minimize the</span></span><br><span class="line"><span class="comment">     * reconfiguration delay to minimize the user-visible pauses during</span></span><br><span class="line"><span class="comment">     * application operational mode changes (such as switching from still</span></span><br><span class="line"><span class="comment">     * capture to video recording).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL should return from this call in 500ms, and must return from this</span></span><br><span class="line"><span class="comment">     * call in 1000ms.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  0:      On successful stream configuration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL: If the requested stream configuration is invalid. Some examples</span></span><br><span class="line"><span class="comment">     *          of invalid stream configurations include:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *          - Including more than 1 input-capable stream (INPUT or</span></span><br><span class="line"><span class="comment">     *            BIDIRECTIONAL)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *          - Not including any output-capable streams (OUTPUT or</span></span><br><span class="line"><span class="comment">     *            BIDIRECTIONAL)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *          - Including streams with unsupported formats, or an unsupported</span></span><br><span class="line"><span class="comment">     *            size for that format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *          - Including too many output streams of a certain format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *          - Unsupported rotation configuration (only applies to</span></span><br><span class="line"><span class="comment">     *            devices with version &gt;= CAMERA_DEVICE_API_VERSION_3_3)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *          - Stream sizes/formats don&#x27;t satisfy the</span></span><br><span class="line"><span class="comment">     *            camera3_stream_configuration_t-&gt;operation_mode requirements for non-NORMAL mode,</span></span><br><span class="line"><span class="comment">     *            or the requested operation_mode is not supported by the HAL.</span></span><br><span class="line"><span class="comment">     *            (only applies to devices with version &gt;= CAMERA_DEVICE_API_VERSION_3_3)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *          Note that the framework submitting an invalid stream</span></span><br><span class="line"><span class="comment">     *          configuration is not normal operation, since stream</span></span><br><span class="line"><span class="comment">     *          configurations are checked before configure. An invalid</span></span><br><span class="line"><span class="comment">     *          configuration means that a bug exists in the framework code, or</span></span><br><span class="line"><span class="comment">     *          there is a mismatch between the HAL&#x27;s static metadata and the</span></span><br><span class="line"><span class="comment">     *          requirements on streams.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENODEV: If there has been a fatal error and the device is no longer</span></span><br><span class="line"><span class="comment">     *          operational. Only close() can be called successfully by the</span></span><br><span class="line"><span class="comment">     *          framework after this error is returned.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*configure_streams)(<span class="keyword">const</span> struct camera3_device *,</span><br><span class="line">            <span class="keyword">camera3_stream_configuration_t</span> *stream_list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * register_stream_buffers:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * DEPRECATED. This will not be called and must be set to NULL.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;= CAMERA_DEVICE_API_VERSION_3_1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Register buffers for a given stream with the HAL device. This method is</span></span><br><span class="line"><span class="comment">     * called by the framework after a new stream is defined by</span></span><br><span class="line"><span class="comment">     * configure_streams, and before buffers from that stream are included in a</span></span><br><span class="line"><span class="comment">     * capture request. If the same stream is listed in a subsequent</span></span><br><span class="line"><span class="comment">     * configure_streams() call, register_stream_buffers will _not_ be called</span></span><br><span class="line"><span class="comment">     * again for that stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework does not need to register buffers for all configured</span></span><br><span class="line"><span class="comment">     * streams before it submits the first capture request. This allows quick</span></span><br><span class="line"><span class="comment">     * startup for preview (or similar use cases) while other streams are still</span></span><br><span class="line"><span class="comment">     * being allocated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method is intended to allow the HAL device to map or otherwise</span></span><br><span class="line"><span class="comment">     * prepare the buffers for later use. The buffers passed in will already be</span></span><br><span class="line"><span class="comment">     * locked for use. At the end of the call, all the buffers must be ready to</span></span><br><span class="line"><span class="comment">     * be returned to the stream.  The buffer_set argument is only valid for the</span></span><br><span class="line"><span class="comment">     * duration of this call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the stream format was set to HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED,</span></span><br><span class="line"><span class="comment">     * the camera HAL should inspect the passed-in buffers here to determine any</span></span><br><span class="line"><span class="comment">     * platform-private pixel format information.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This should be a non-blocking call. The HAL should return from this call</span></span><br><span class="line"><span class="comment">     * in 1ms, and must return from this call in 5ms.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  0:      On successful registration of the new stream buffers</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL: If the stream_buffer_set does not refer to a valid active</span></span><br><span class="line"><span class="comment">     *          stream, or if the buffers array is invalid.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENOMEM: If there was a failure in registering the buffers. The framework</span></span><br><span class="line"><span class="comment">     *          must consider all the stream buffers to be unregistered, and can</span></span><br><span class="line"><span class="comment">     *          try to register again later.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENODEV: If there is a fatal error, and the device is no longer</span></span><br><span class="line"><span class="comment">     *          operational. Only close() can be called successfully by the</span></span><br><span class="line"><span class="comment">     *          framework after this error is returned.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*register_stream_buffers)(<span class="keyword">const</span> struct camera3_device *,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_stream_buffer_set_t</span> *buffer_set);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">     * Request creation and submission</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * construct_default_request_settings:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Create capture settings for standard camera use cases.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The device must return a settings buffer that is configured to meet the</span></span><br><span class="line"><span class="comment">     * requested use case, which must be one of the CAMERA3_TEMPLATE_*</span></span><br><span class="line"><span class="comment">     * enums. All request control fields must be included.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL retains ownership of this structure, but the pointer to the</span></span><br><span class="line"><span class="comment">     * structure must be valid until the device is closed. The framework and the</span></span><br><span class="line"><span class="comment">     * HAL may not modify the buffer once it is returned by this call. The same</span></span><br><span class="line"><span class="comment">     * buffer may be returned for subsequent calls for the same template, or for</span></span><br><span class="line"><span class="comment">     * other templates.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This should be a non-blocking call. The HAL should return from this call</span></span><br><span class="line"><span class="comment">     * in 1ms, and must return from this call in 5ms.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   Valid metadata: On successful creation of a default settings</span></span><br><span class="line"><span class="comment">     *                   buffer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   NULL:           In case of a fatal error. After this is returned, only</span></span><br><span class="line"><span class="comment">     *                   the close() method can be called successfully by the</span></span><br><span class="line"><span class="comment">     *                   framework.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">camera_metadata_t</span>* (*construct_default_request_settings)(</span><br><span class="line">            <span class="keyword">const</span> struct camera3_device *,</span><br><span class="line">            <span class="keyword">int</span> type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * process_capture_request:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Send a new capture request to the HAL. The HAL should not return from</span></span><br><span class="line"><span class="comment">     * this call until it is ready to accept the next request to process. Only</span></span><br><span class="line"><span class="comment">     * one call to process_capture_request() will be made at a time by the</span></span><br><span class="line"><span class="comment">     * framework, and the calls will all be from the same thread. The next call</span></span><br><span class="line"><span class="comment">     * to process_capture_request() will be made as soon as a new request and</span></span><br><span class="line"><span class="comment">     * its associated buffers are available. In a normal preview scenario, this</span></span><br><span class="line"><span class="comment">     * means the function will be called again by the framework almost</span></span><br><span class="line"><span class="comment">     * instantly.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The actual request processing is asynchronous, with the results of</span></span><br><span class="line"><span class="comment">     * capture being returned by the HAL through the process_capture_result()</span></span><br><span class="line"><span class="comment">     * call. This call requires the result metadata to be available, but output</span></span><br><span class="line"><span class="comment">     * buffers may simply provide sync fences to wait on. Multiple requests are</span></span><br><span class="line"><span class="comment">     * expected to be in flight at once, to maintain full output frame rate.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework retains ownership of the request structure. It is only</span></span><br><span class="line"><span class="comment">     * guaranteed to be valid during this call. The HAL device must make copies</span></span><br><span class="line"><span class="comment">     * of the information it needs to retain for the capture processing. The HAL</span></span><br><span class="line"><span class="comment">     * is responsible for waiting on and closing the buffers&#x27; fences and</span></span><br><span class="line"><span class="comment">     * returning the buffer handles to the framework.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL must write the file descriptor for the input buffer&#x27;s release</span></span><br><span class="line"><span class="comment">     * sync fence into input_buffer-&gt;release_fence, if input_buffer is not</span></span><br><span class="line"><span class="comment">     * NULL. If the HAL returns -1 for the input buffer release sync fence, the</span></span><br><span class="line"><span class="comment">     * framework is free to immediately reuse the input buffer. Otherwise, the</span></span><br><span class="line"><span class="comment">     * framework will wait on the sync fence before refilling and reusing the</span></span><br><span class="line"><span class="comment">     * input buffer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The input/output buffers provided by the framework in each request</span></span><br><span class="line"><span class="comment">     * may be brand new (having never before seen by the HAL).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * Performance considerations:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Handling a new buffer should be extremely lightweight and there should be</span></span><br><span class="line"><span class="comment">     * no frame rate degradation or frame jitter introduced.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This call must return fast enough to ensure that the requested frame</span></span><br><span class="line"><span class="comment">     * rate can be sustained, especially for streaming cases (post-processing</span></span><br><span class="line"><span class="comment">     * quality settings set to FAST). The HAL should return this call in 1</span></span><br><span class="line"><span class="comment">     * frame interval, and must return from this call in 4 frame intervals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  0:      On a successful start to processing the capture request</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL: If the input is malformed (the settings are NULL when not</span></span><br><span class="line"><span class="comment">     *          allowed, invalid physical camera settings,</span></span><br><span class="line"><span class="comment">     *          there are 0 output buffers, etc) and capture processing</span></span><br><span class="line"><span class="comment">     *          cannot start. Failures during request processing should be</span></span><br><span class="line"><span class="comment">     *          handled by calling camera3_callback_ops_t.notify(). In case of</span></span><br><span class="line"><span class="comment">     *          this error, the framework will retain responsibility for the</span></span><br><span class="line"><span class="comment">     *          stream buffers&#x27; fences and the buffer handles; the HAL should</span></span><br><span class="line"><span class="comment">     *          not close the fences or return these buffers with</span></span><br><span class="line"><span class="comment">     *          process_capture_result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENODEV: If the camera device has encountered a serious error. After this</span></span><br><span class="line"><span class="comment">     *          error is returned, only the close() method can be successfully</span></span><br><span class="line"><span class="comment">     *          called by the framework.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*process_capture_request)(<span class="keyword">const</span> struct camera3_device *,</span><br><span class="line">            <span class="keyword">camera3_capture_request_t</span> *request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">     * Miscellaneous methods</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get_metadata_vendor_tag_ops:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Get methods to query for vendor extension metadata tag information. The</span></span><br><span class="line"><span class="comment">     * HAL should fill in all the vendor tag operation methods, or leave ops</span></span><br><span class="line"><span class="comment">     * unchanged if no vendor tags are defined.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The definition of vendor_tag_query_ops_t can be found in</span></span><br><span class="line"><span class="comment">     * system/media/camera/include/system/camera_metadata.h.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span></span><br><span class="line"><span class="comment">     *    DEPRECATED. This function has been deprecated and should be set to</span></span><br><span class="line"><span class="comment">     *    NULL by the HAL.  Please implement get_vendor_tag_ops in camera_common.h</span></span><br><span class="line"><span class="comment">     *    instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*get_metadata_vendor_tag_ops)(<span class="keyword">const</span> struct camera3_device*,</span><br><span class="line">            <span class="keyword">vendor_tag_query_ops_t</span>* ops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dump:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Print out debugging state for the camera device. This will be called by</span></span><br><span class="line"><span class="comment">     * the framework when the camera service is asked for a debug dump, which</span></span><br><span class="line"><span class="comment">     * happens when using the dumpsys tool, or when capturing a bugreport.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The passed-in file descriptor can be used to write debugging text using</span></span><br><span class="line"><span class="comment">     * dprintf() or write(). The text should be in ASCII encoding only.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This must be a non-blocking call. The HAL should return from this call</span></span><br><span class="line"><span class="comment">     * in 1ms, must return from this call in 10ms. This call must avoid</span></span><br><span class="line"><span class="comment">     * deadlocks, as it may be called at any point during camera operation.</span></span><br><span class="line"><span class="comment">     * Any synchronization primitives used (such as mutex locks or semaphores)</span></span><br><span class="line"><span class="comment">     * should be acquired with a timeout.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*dump)(<span class="keyword">const</span> struct camera3_device *, <span class="keyword">int</span> fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * flush:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Flush all currently in-process captures and all buffers in the pipeline</span></span><br><span class="line"><span class="comment">     * on the given device. The framework will use this to dump all state as</span></span><br><span class="line"><span class="comment">     * quickly as possible in order to prepare for a configure_streams() call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * No buffers are required to be successfully returned, so every buffer</span></span><br><span class="line"><span class="comment">     * held at the time of flush() (whether successfully filled or not) may be</span></span><br><span class="line"><span class="comment">     * returned with CAMERA3_BUFFER_STATUS_ERROR. Note the HAL is still allowed</span></span><br><span class="line"><span class="comment">     * to return valid (CAMERA3_BUFFER_STATUS_OK) buffers during this call,</span></span><br><span class="line"><span class="comment">     * provided they are successfully filled.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * All requests currently in the HAL are expected to be returned as soon as</span></span><br><span class="line"><span class="comment">     * possible.  Not-in-process requests should return errors immediately. Any</span></span><br><span class="line"><span class="comment">     * interruptible hardware blocks should be stopped, and any uninterruptible</span></span><br><span class="line"><span class="comment">     * blocks should be waited on.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * flush() may be called concurrently to process_capture_request(), with the expectation that</span></span><br><span class="line"><span class="comment">     * process_capture_request will return quickly and the request submitted in that</span></span><br><span class="line"><span class="comment">     * process_capture_request call is treated like all other in-flight requests.  Due to</span></span><br><span class="line"><span class="comment">     * concurrency issues, it is possible that from the HAL&#x27;s point of view, a</span></span><br><span class="line"><span class="comment">     * process_capture_request() call may be started after flush has been invoked but has not</span></span><br><span class="line"><span class="comment">     * returned yet. If such a call happens before flush() returns, the HAL should treat the new</span></span><br><span class="line"><span class="comment">     * capture request like other in-flight pending requests (see #4 below).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * More specifically, the HAL must follow below requirements for various cases:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. For captures that are too late for the HAL to cancel/stop, and will be</span></span><br><span class="line"><span class="comment">     *    completed normally by the HAL; i.e. the HAL can send shutter/notify and</span></span><br><span class="line"><span class="comment">     *    process_capture_result and buffers as normal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. For pending requests that have not done any processing, the HAL must call notify</span></span><br><span class="line"><span class="comment">     *    CAMERA3_MSG_ERROR_REQUEST, and return all the output buffers with</span></span><br><span class="line"><span class="comment">     *    process_capture_result in the error state (CAMERA3_BUFFER_STATUS_ERROR).</span></span><br><span class="line"><span class="comment">     *    The HAL must not place the release fence into an error state, instead,</span></span><br><span class="line"><span class="comment">     *    the release fences must be set to the acquire fences passed by the framework,</span></span><br><span class="line"><span class="comment">     *    or -1 if they have been waited on by the HAL already. This is also the path</span></span><br><span class="line"><span class="comment">     *    to follow for any captures for which the HAL already called notify() with</span></span><br><span class="line"><span class="comment">     *    CAMERA3_MSG_SHUTTER but won&#x27;t be producing any metadata/valid buffers for.</span></span><br><span class="line"><span class="comment">     *    After CAMERA3_MSG_ERROR_REQUEST, for a given frame, only process_capture_results with</span></span><br><span class="line"><span class="comment">     *    buffers in CAMERA3_BUFFER_STATUS_ERROR are allowed. No further notifys or</span></span><br><span class="line"><span class="comment">     *    process_capture_result with non-null metadata is allowed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. For partially completed pending requests that will not have all the output</span></span><br><span class="line"><span class="comment">     *    buffers or perhaps missing metadata, the HAL should follow below:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.1. Call notify with CAMERA3_MSG_ERROR_RESULT if some of the expected result</span></span><br><span class="line"><span class="comment">     *    metadata (i.e. one or more partial metadata) won&#x27;t be available for the capture.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.2. Call notify with CAMERA3_MSG_ERROR_BUFFER for every buffer that won&#x27;t</span></span><br><span class="line"><span class="comment">     *         be produced for the capture.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.3  Call notify with CAMERA3_MSG_SHUTTER with the capture timestamp before</span></span><br><span class="line"><span class="comment">     *         any buffers/metadata are returned with process_capture_result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.4 For captures that will produce some results, the HAL must not call</span></span><br><span class="line"><span class="comment">     *        CAMERA3_MSG_ERROR_REQUEST, since that indicates complete failure.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.5. Valid buffers/metadata should be passed to the framework as normal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.6. Failed buffers should be returned to the framework as described for case 2.</span></span><br><span class="line"><span class="comment">     *         But failed buffers do not have to follow the strict ordering valid buffers do,</span></span><br><span class="line"><span class="comment">     *         and may be out-of-order with respect to valid buffers. For example, if buffers</span></span><br><span class="line"><span class="comment">     *         A, B, C, D, E are sent, D and E are failed, then A, E, B, D, C is an acceptable</span></span><br><span class="line"><span class="comment">     *         return order.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    3.7. For fully-missing metadata, calling CAMERA3_MSG_ERROR_RESULT is sufficient, no</span></span><br><span class="line"><span class="comment">     *         need to call process_capture_result with NULL metadata or equivalent.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 4. If a flush() is invoked while a process_capture_request() invocation is active, that</span></span><br><span class="line"><span class="comment">     *    process call should return as soon as possible. In addition, if a process_capture_request()</span></span><br><span class="line"><span class="comment">     *    call is made after flush() has been invoked but before flush() has returned, the</span></span><br><span class="line"><span class="comment">     *    capture request provided by the late process_capture_request call should be treated like</span></span><br><span class="line"><span class="comment">     *    a pending request in case #2 above.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * flush() should only return when there are no more outstanding buffers or</span></span><br><span class="line"><span class="comment">     * requests left in the HAL. The framework may call configure_streams (as</span></span><br><span class="line"><span class="comment">     * the HAL state is now quiesced) or may issue new requests.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that it&#x27;s sufficient to only support fully-succeeded and fully-failed result cases.</span></span><br><span class="line"><span class="comment">     * However, it is highly desirable to support the partial failure cases as well, as it</span></span><br><span class="line"><span class="comment">     * could help improve the flush call overall performance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL should return from this call in 100ms, and must return from this</span></span><br><span class="line"><span class="comment">     * call in 1000ms. And this call must not be blocked longer than pipeline</span></span><br><span class="line"><span class="comment">     * latency (see S7 for definition).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Version information:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   only available if device version &gt;= CAMERA_DEVICE_API_VERSION_3_1.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  0:      On a successful flush of the camera HAL.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL: If the input is malformed (the device is not valid).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENODEV: If the camera device has encountered a serious error. After this</span></span><br><span class="line"><span class="comment">     *          error is returned, only the close() method can be successfully</span></span><br><span class="line"><span class="comment">     *          called by the framework.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*flush)(<span class="keyword">const</span> struct camera3_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * signal_stream_flush:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;= CAMERA_DEVICE_API_VERISON_3_5:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    Not defined and must be NULL</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERISON_3_6:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Signaling HAL camera service is about to perform configure_streams() call</span></span><br><span class="line"><span class="comment">     * and HAL must return all buffers of designated streams. HAL must finish</span></span><br><span class="line"><span class="comment">     * inflight requests normally and return all buffers belonging to the</span></span><br><span class="line"><span class="comment">     * designated streams through process_capture_result() or</span></span><br><span class="line"><span class="comment">     * return_stream_buffers() API in a timely manner, or camera service will run</span></span><br><span class="line"><span class="comment">     * into a fatal error.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that this call serves as an optional hint and camera service may</span></span><br><span class="line"><span class="comment">     * skip calling this if all buffers are already returned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*signal_stream_flush)(<span class="keyword">const</span> struct camera3_device*,</span><br><span class="line">            <span class="keyword">uint32_t</span> num_streams,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_stream_t</span>* <span class="keyword">const</span>* streams);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * is_reconfiguration_required:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;= CAMERA_DEVICE_API_VERISON_3_5:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    Not defined and must be NULL</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERISON_3_6:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Check whether complete stream reconfiguration is required for possible new session</span></span><br><span class="line"><span class="comment">     * parameter values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method must be called by the camera framework in case the client changes</span></span><br><span class="line"><span class="comment">     * the value of any advertised session parameters. Depending on the specific values</span></span><br><span class="line"><span class="comment">     * the HAL can decide whether a complete stream reconfiguration is required. In case</span></span><br><span class="line"><span class="comment">     * the HAL returns -ENVAL, the camera framework must skip the internal reconfiguration.</span></span><br><span class="line"><span class="comment">     * In case Hal returns 0, the framework must reconfigure the streams and pass the</span></span><br><span class="line"><span class="comment">     * new session parameter values accordingly.</span></span><br><span class="line"><span class="comment">     * This call may be done by the framework some time before the request with new parameters</span></span><br><span class="line"><span class="comment">     * is submitted to the HAL, and the request may be cancelled before it ever gets submitted.</span></span><br><span class="line"><span class="comment">     * Therefore, the HAL must not use this query as an indication to change its behavior in any</span></span><br><span class="line"><span class="comment">     * way.</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Preconditions:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The framework can call this method at any time after active</span></span><br><span class="line"><span class="comment">     * session configuration. There must be no impact on the performance of</span></span><br><span class="line"><span class="comment">     * pending camera requests in any way. In particular there must not be</span></span><br><span class="line"><span class="comment">     * any glitches or delays during normal camera streaming.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     * HW and SW camera settings must not be changed and there must not be</span></span><br><span class="line"><span class="comment">     * a user-visible impact on camera performance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param oldSessionParams The currently applied session parameters.</span></span><br><span class="line"><span class="comment">     * @param newSessionParams The new session parameters set by client.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return Status Status code for the operation, one of:</span></span><br><span class="line"><span class="comment">     * 0:                    In case the stream reconfiguration is required</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -EINVAL:              In case the stream reconfiguration is not required.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -ENOSYS:              In case the camera device does not support the</span></span><br><span class="line"><span class="comment">     *                       reconfiguration query.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*is_reconfiguration_required)(<span class="keyword">const</span> struct camera3_device*,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera_metadata_t</span>* old_session_params,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera_metadata_t</span>* new_session_params);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reserved for future use */</span></span><br><span class="line">    <span class="keyword">void</span> *reserved[<span class="number">6</span>];</span><br><span class="line">&#125; <span class="keyword">camera3_device_ops_t</span>;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看见，该结构体定义了一系列的函数指针，用来指向平台厂商实际的实现方法，接下来就其中几个方法简单介绍下：<br>a) initialize<br>该方法必须在camera_moudel_t中的open方法之后，其它camera3_device_ops中方法之前被调用，主要用来将上层实现的回调方法注册到HAL中，并且根据需要在该方法中加入自定义的一些初始化操作，另外，谷歌针对该方法在性能方面也有严格的限制，该方法需要在5ms内返回，最长不能超过10ms。<br>b) configure_streams<br>该方法在完成initialize方法之后，在调用process_capture_request方法之前被调用，主要用于重设当前正在运行的Pipeline以及设置新的输入输出流，其中它会将stream_list中的新的数据流替换之前配置的数据流。在调用该方法之前必须确保没有新的request下发并且当前request的动作已经完成，否则会引起无法预测的错误。一旦HAL调用了该方法，则必须在内部配置好满足当前数据流配置的帧率，确保这个流程的运行的顺畅性。<br>其中包含了两个参数，分别是camera3_device以及stream_list(camera3_stream_configuration_t ),其中第二个参数是上层传入的数据流配置列表，该列表中必须包含至少一个output stream，同时至多包含一个input stream。<br>另外，谷歌针对该方法有着严格的性能要求，平台厂商在实现该方法的时候，需要在500ms内返回，最长不能超过1000ms。<br>c) construct_default_request_settings<br>该方法主要用于构建一系列默认的Camera Usecase的capture 设置项，通过camera_metadata_t来进行描述，其中返回值是一个camera_metadata_t指针，其指向的内存地址是由HAL来进行维护的，同样地，该方法需要在1ms内返回，最长不能超过5ms。<br>d) process_capture_request<br>该方法用于下发单次新的capture request到HAL中， 上层必须保证该方法的调用都是在一个线程中完成，而且该方法是异步的，同时其结果并不是通过返回值给到上层，而是通过HAL调用另一个接口process_capture_result()来将结果返回给上层的，在使用的过程中，通过in-flight机制，保证短时间内下发足够多的request，从而满足帧率要求。<br>该方法的性能依然受到谷歌的严格要求，规定其需要在一帧图像处理完的时长内返回，最长不超过4帧图像处理完成的时长，比如当前预览帧率是30帧，则该方法的操作耗时最长不能超过120ms，否则便会引起明显的帧抖动，从而影响用户体验。<br>e) dump<br>该方法用于打印当前Camera设备的状态，一般是由上层通过dumpsys工具输出debug dump信息或者主动抓取bugreport的时候被调用，该方法必须是非阻塞实现，同时需要保证在1ms内返回，最长不能超过10ms。<br>f) flush<br>当上层需要执行新的configure_streams的时候，需要调用该方法去尽可能快地清除掉当前已经在处理中的或者即将处理的任务，为配置数据流提供一个相对稳定的环境，其具体工作如下：</p>
<ul>
<li>所有的还在流转的request会尽可能快的返回</li>
<li>并未开始进行流转的request会直接返回，并携带错误信息</li>
<li>任何可以打断的硬件操作会立即被停止</li>
<li>任何无法进行打断的硬件操作会在当前状态下进行休眠</li>
</ul>
<p>flush会在所有的buffer都得以释放，所有request都成功返回后才真正返回，该方法需要在100ms内返回，最长不能超过1000ms。</p>
<p>上面的一系列方法是上层直接对下控制Camera Hal，而一旦Camera Hal产生了数据或者事件的时候，可以通过camera3_callback_ops中定义的回调方法将数据或者事件返回至上层，该结构体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera3_callback_ops</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * process_capture_result:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Send results from a completed capture to the framework.</span></span><br><span class="line"><span class="comment">     * process_capture_result() may be invoked multiple times by the HAL in</span></span><br><span class="line"><span class="comment">     * response to a single capture request. This allows, for example, the</span></span><br><span class="line"><span class="comment">     * metadata and low-resolution buffers to be returned in one call, and</span></span><br><span class="line"><span class="comment">     * post-processed JPEG buffers in a later call, once it is available. Each</span></span><br><span class="line"><span class="comment">     * call must include the frame number of the request it is returning</span></span><br><span class="line"><span class="comment">     * metadata or buffers for.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A component (buffer or metadata) of the complete result may only be</span></span><br><span class="line"><span class="comment">     * included in one process_capture_result call. A buffer for each stream,</span></span><br><span class="line"><span class="comment">     * and the result metadata, must be returned by the HAL for each request in</span></span><br><span class="line"><span class="comment">     * one of the process_capture_result calls, even in case of errors producing</span></span><br><span class="line"><span class="comment">     * some of the output. A call to process_capture_result() with neither</span></span><br><span class="line"><span class="comment">     * output buffers or result metadata is not allowed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The order of returning metadata and buffers for a single result does not</span></span><br><span class="line"><span class="comment">     * matter, but buffers for a given stream must be returned in FIFO order. So</span></span><br><span class="line"><span class="comment">     * the buffer for request 5 for stream A must always be returned before the</span></span><br><span class="line"><span class="comment">     * buffer for request 6 for stream A. This also applies to the result</span></span><br><span class="line"><span class="comment">     * metadata; the metadata for request 5 must be returned before the metadata</span></span><br><span class="line"><span class="comment">     * for request 6.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * However, different streams are independent of each other, so it is</span></span><br><span class="line"><span class="comment">     * acceptable and expected that the buffer for request 5 for stream A may be</span></span><br><span class="line"><span class="comment">     * returned after the buffer for request 6 for stream B is. And it is</span></span><br><span class="line"><span class="comment">     * acceptable that the result metadata for request 6 for stream B is</span></span><br><span class="line"><span class="comment">     * returned before the buffer for request 5 for stream A is.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The HAL retains ownership of result structure, which only needs to be</span></span><br><span class="line"><span class="comment">     * valid to access during this call. The framework will copy whatever it</span></span><br><span class="line"><span class="comment">     * needs before this call returns.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The output buffers do not need to be filled yet; the framework will wait</span></span><br><span class="line"><span class="comment">     * on the stream buffer release sync fence before reading the buffer</span></span><br><span class="line"><span class="comment">     * data. Therefore, this method should be called by the HAL as soon as</span></span><br><span class="line"><span class="comment">     * possible, even if some or all of the output buffers are still in</span></span><br><span class="line"><span class="comment">     * being filled. The HAL must include valid release sync fences into each</span></span><br><span class="line"><span class="comment">     * output_buffers stream buffer entry, or -1 if that stream buffer is</span></span><br><span class="line"><span class="comment">     * already filled.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the result buffer cannot be constructed for a request, the HAL should</span></span><br><span class="line"><span class="comment">     * return an empty metadata buffer, but still provide the output buffers and</span></span><br><span class="line"><span class="comment">     * their sync fences. In addition, notify() must be called with an</span></span><br><span class="line"><span class="comment">     * ERROR_RESULT message.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If an output buffer cannot be filled, its status field must be set to</span></span><br><span class="line"><span class="comment">     * STATUS_ERROR. In addition, notify() must be called with a ERROR_BUFFER</span></span><br><span class="line"><span class="comment">     * message.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the entire capture has failed, then this method still needs to be</span></span><br><span class="line"><span class="comment">     * called to return the output buffers to the framework. All the buffer</span></span><br><span class="line"><span class="comment">     * statuses should be STATUS_ERROR, and the result metadata should be an</span></span><br><span class="line"><span class="comment">     * empty buffer. In addition, notify() must be called with a ERROR_REQUEST</span></span><br><span class="line"><span class="comment">     * message. In this case, individual ERROR_RESULT/ERROR_BUFFER messages</span></span><br><span class="line"><span class="comment">     * should not be sent.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This is a non-blocking call. The framework will return this call in 5ms.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The pipeline latency (see S7 for definition) should be less than or equal to</span></span><br><span class="line"><span class="comment">     * 4 frame intervals, and must be less than or equal to 8 frame intervals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*process_capture_result)(<span class="keyword">const</span> struct camera3_callback_ops *,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_capture_result_t</span> *result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * notify:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Asynchronous notification callback from the HAL, fired for various</span></span><br><span class="line"><span class="comment">     * reasons. Only for information independent of frame capture, or that</span></span><br><span class="line"><span class="comment">     * require specific timing. The ownership of the message structure remains</span></span><br><span class="line"><span class="comment">     * with the HAL, and the msg only needs to be valid for the duration of this</span></span><br><span class="line"><span class="comment">     * call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Multiple threads may call notify() simultaneously.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;= CAMERA_DEVICE_API_VERSION_3_1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The notification for the start of exposure for a given request must be</span></span><br><span class="line"><span class="comment">     * sent by the HAL before the first call to process_capture_result() for</span></span><br><span class="line"><span class="comment">     * that request is made.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Buffers delivered to the framework will not be dispatched to the</span></span><br><span class="line"><span class="comment">     * application layer until a start of exposure timestamp (or input image&#x27;s</span></span><br><span class="line"><span class="comment">     * start of exposure timestamp for a reprocess request) has been received</span></span><br><span class="line"><span class="comment">     * via a SHUTTER notify() call. It is highly recommended to dispatch this</span></span><br><span class="line"><span class="comment">     * call as early as possible.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This is a non-blocking call. The framework will return this call in 5ms.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*notify)(<span class="keyword">const</span> struct camera3_callback_ops *,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_notify_msg_t</span> *msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * request_stream_buffers:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;= CAMERA_DEVICE_API_VERISON_3_5:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    DO NOT USE: not defined and must be NULL.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERISON_3_6:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Synchronous callback for HAL to ask for output buffer from camera service.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This call may be serialized in camera service so it is strongly</span></span><br><span class="line"><span class="comment">     * recommended to only call this method from one thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When camera device advertises</span></span><br><span class="line"><span class="comment">     * (android.info.supportedBufferManagementVersion ==</span></span><br><span class="line"><span class="comment">     * ANDROID_INFO_SUPPORTED_BUFFER_MANAGEMENT_VERSION_HIDL_DEVICE_3_5), HAL</span></span><br><span class="line"><span class="comment">     * can use this method to request buffers from camera service.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Caller is responsible for allocating enough memory for returned_buf_reqs</span></span><br><span class="line"><span class="comment">     * argument (num_buffer_reqs * sizeof(camera3_stream_buffer_ret_t)) bytes</span></span><br><span class="line"><span class="comment">     * and also the memory for the output_buffers field in each</span></span><br><span class="line"><span class="comment">     * camera3_stream_buffer_ret_t</span></span><br><span class="line"><span class="comment">     * (num_buffers_requested * sizeof(camera3_stream_buffer_t)) bytes</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Performance requirements:</span></span><br><span class="line"><span class="comment">     * This is a blocking call that takes more time with more buffers requested.</span></span><br><span class="line"><span class="comment">     * HAL should not request large amount of buffers on a latency critical code</span></span><br><span class="line"><span class="comment">     * path. It is highly recommended to use a dedicated thread to perform</span></span><br><span class="line"><span class="comment">     * all requestStreamBuffer calls, and adjust the thread priority and/or</span></span><br><span class="line"><span class="comment">     * timing of making the call in order for buffers to arrive before HAL is</span></span><br><span class="line"><span class="comment">     * ready to fill the buffer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">camera3_buffer_request_status_t</span> (*request_stream_buffers)(</span><br><span class="line">            <span class="keyword">const</span> struct camera3_callback_ops *,</span><br><span class="line">            <span class="keyword">uint32_t</span> num_buffer_reqs,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_buffer_request_t</span> *buffer_reqs,</span><br><span class="line">            <span class="comment">/*out*/</span><span class="keyword">uint32_t</span> *num_returned_buf_reqs,</span><br><span class="line">            <span class="comment">/*out*/</span><span class="keyword">camera3_stream_buffer_ret_t</span> *returned_buf_reqs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * return_stream_buffers:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;= CAMERA_DEVICE_API_VERISON_3_5:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    DO NOT USE: not defined and must be NULL.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERISON_3_6:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Synchronous callback for HAL to return output buffers to camera service.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If this method is called during a configure_streams() call, it will be</span></span><br><span class="line"><span class="comment">     * blocked until camera service finishes the ongoing configure_streams() call.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*return_stream_buffers)(</span><br><span class="line">            <span class="keyword">const</span> struct camera3_callback_ops *,</span><br><span class="line">            <span class="keyword">uint32_t</span> num_buffers,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_stream_buffer_t</span>* <span class="keyword">const</span>* buffers);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">camera3_callback_ops_t</span>;</span><br></pre></td></tr></table></figure>
<p>其中常用的回调方法主要有两个：用于返回数据的process_capture_result以及用于返回事件的notify，接下来分别介绍下：<br>a) process_capture_result<br>该方法用于返回HAL部分产生的metadata和image buffers，它与request是多对一的关系，同一个request，可能会对应到几个result，比如可以通过调用一次该方法用于返回metadata以及低分辨率的图像数据，再调用一次该方法用于返回jpeg格式的拍照数据，而这两次调用时对应于同一个process_capture_request动作。<br>同一个request的metadata以及image buffers的先后顺序无关紧要，但是同一个数据流的不同Request之间的Result必须严格按照request的下发先后顺序进行依次返回的，如若不然，会导致图像数据显示出现顺序错乱的情况。<br>该方法是非阻塞的，而且并且必须要在5ms内返回。<br>b) notify<br>该方法用于异步返回HAL事件到上层，必须非阻塞实现，而且要在5ms内返回。<br>谷歌为了将系统框架和平台厂商的自定义部分相分离，在Android上推出了Treble项目，该项目直接将平台厂商的实现部分放入vendor分区中进行管理，进而与system分区保持隔离，这样便可以在相互独立的空间中进行各自的迭代升级，而互不干扰，而在相机框架体系中，便将Camera HAL Module从Camera Service中解耦出来，放入独立进程Camera Provider中进行管理，而为了更好的进行跨进程访问，谷歌针对Provider提出了HIDL机制用于Camera Servic对于Camera Provier的访问，而HIDL接口的实现是在Camera Provider中实现，针对Camera HAL Module的控制又是通过谷歌制定的Camera HAL3接口来完成，所以由此看来，Provider的职责也比较简单，通过HIDL机制保持与Camera Service的通信，通过HAL3接口控制着Camera HAL Module。</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>空白
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-5/" title="深入理解Android相机体系结构之五：相机硬件抽象层">https://shenweikun.github.io/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-5/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Android-Camera/" rel="tag"><i class="fa fa-tag"></i> Android Camera</a>
              <a href="/tags/Camera%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="fa fa-tag"></i> Camera系统</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-4/" rel="prev" title="深入理解Android相机体系结构之四：相机服务层">
                  <i class="fa fa-angle-left"></i> 深入理解Android相机体系结构之四：相机服务层
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/11/21/2024-11-21-In-depth-understanding-of-Android-camera-6/" rel="next" title="深入理解Android相机体系结构之六：相机硬件抽象层实现">
                  深入理解Android相机体系结构之六：相机硬件抽象层实现 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2021 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">空白</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">521k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">21:43</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"shenweikun/helloworld","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
