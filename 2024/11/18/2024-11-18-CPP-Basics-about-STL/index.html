<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shenweikun.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="C++模板编程入门一个案例引入模板1、模板和泛型编程系类文章介绍(1)模板编程是C++的一种高级特性，很常用，很有用，可以说是 C++的精髓，是C++被广泛使用的关键(2)泛型在C++、java、C#等多种语言中都有，是现代编程语言典型特性(3)本章开始不像以前以理论知识讲解为主，而是以写代码和实践为主，在实践中学为主。因为开始变得抽象起来了">
<meta property="og:type" content="article">
<meta property="og:title" content="C++从入门到进阶之三-STL等高阶话题">
<meta property="og:url" content="https://shenweikun.github.io/2024/11/18/2024-11-18-CPP-Basics-about-STL/index.html">
<meta property="og:site_name" content="Weikun&#39;s Notes">
<meta property="og:description" content="C++模板编程入门一个案例引入模板1、模板和泛型编程系类文章介绍(1)模板编程是C++的一种高级特性，很常用，很有用，可以说是 C++的精髓，是C++被广泛使用的关键(2)泛型在C++、java、C#等多种语言中都有，是现代编程语言典型特性(3)本章开始不像以前以理论知识讲解为主，而是以写代码和实践为主，在实践中学为主。因为开始变得抽象起来了">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-11-17T18:09:47.000Z">
<meta property="article:modified_time" content="2024-11-21T10:01:08.573Z">
<meta property="article:author" content="空白">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://shenweikun.github.io/2024/11/18/2024-11-18-CPP-Basics-about-STL/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://shenweikun.github.io/2024/11/18/2024-11-18-CPP-Basics-about-STL/","path":"2024/11/18/2024-11-18-CPP-Basics-about-STL/","title":"C++从入门到进阶之三-STL等高阶话题"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++从入门到进阶之三-STL等高阶话题 | Weikun's Notes</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Weikun's Notes</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">怀揣代码中的唏嘘，记录生活中的点滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8"><span class="nav-number">1.</span> <span class="nav-text">C++模板编程入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B%E5%BC%95%E5%85%A5%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.</span> <span class="nav-text">一个案例引入模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E5%87%A0%E4%B8%AA%E7%BB%86%E8%8A%82"><span class="nav-number">1.2.</span> <span class="nav-text">模板的理解和几个细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.3.</span> <span class="nav-text">函数模板和类模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.4.</span> <span class="nav-text">多模板参数的类模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.</span> <span class="nav-text">模板友元函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.</span> <span class="nav-text">模板运算符重载函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.7.</span> <span class="nav-text">模板运算符友元函数重载实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">1.8.</span> <span class="nav-text">模板类的继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="nav-number">1.9.</span> <span class="nav-text">非类型模板参数和模板类型推导</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL%E7%9A%84%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">STL的容器类和迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#STL%E7%9A%84%E5%AE%B9%E5%99%A8%E7%B1%BB%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.1.</span> <span class="nav-text">STL的容器类介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8%E4%B9%8Barray"><span class="nav-number">2.2.</span> <span class="nav-text">序列容器之array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-number">2.3.</span> <span class="nav-text">迭代器的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%87%A0%E4%B8%AA%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.</span> <span class="nav-text">迭代器的几个细节问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STL%E7%9A%84%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">2.5.</span> <span class="nav-text">STL的不同类型迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8%E4%B9%8BVector"><span class="nav-number">2.6.</span> <span class="nav-text">序列容器之Vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8%E4%B9%8Blist"><span class="nav-number">2.7.</span> <span class="nav-text">序列容器之list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8%E4%B9%8Bdeque"><span class="nav-number">2.8.</span> <span class="nav-text">序列容器之deque</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8%E9%80%89%E6%8B%A9"><span class="nav-number">2.9.</span> <span class="nav-text">序列容器选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.</span> <span class="nav-text">STL的泛型算法使用详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="nav-number">3.1.</span> <span class="nav-text">什么是泛型算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E4%BD%BF%E7%94%A8%E5%AE%9E%E6%88%98"><span class="nav-number">3.2.</span> <span class="nav-text">泛型算法使用实战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%93%E8%AF%8Dpredicate%E5%92%8C%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%BC%95%E5%85%A5"><span class="nav-number">3.3.</span> <span class="nav-text">谓词predicate和函数对象引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82"><span class="nav-number">3.4.</span> <span class="nav-text">函数对象的一些细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STL%E5%85%B8%E5%9E%8B%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E8%A7%A3%E8%AF%BB"><span class="nav-number">3.5.</span> <span class="nav-text">STL典型泛型算法解读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPP%E4%B9%8Blamba%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.6.</span> <span class="nav-text">CPP之lamba表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B9%8B%E5%8F%82%E6%95%B0%E6%8D%95%E8%8E%B7"><span class="nav-number">3.7.</span> <span class="nav-text">lambda表达式之参数捕获</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPP%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">3.8.</span> <span class="nav-text">CPP函数适配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STL%E5%85%B8%E5%9E%8B%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E8%A7%A3%E8%AF%BB-1"><span class="nav-number">3.9.</span> <span class="nav-text">STL典型泛型算法解读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96"><span class="nav-number">4.</span> <span class="nav-text">模板特化和类型萃取</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%A1%88%E4%BE%8B%E4%B8%AD%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96"><span class="nav-number">4.1.</span> <span class="nav-text">从案例中理解什么是模板特化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%8F%E7%89%B9%E5%8C%96%E5%92%8C%E5%85%A8%E7%89%B9%E5%8C%96"><span class="nav-number">4.2.</span> <span class="nav-text">偏特化和全特化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%81%8F%E7%89%B9%E5%8C%96"><span class="nav-number">4.3.</span> <span class="nav-text">类模板的多种偏特化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%81%8F%E7%89%B9%E5%8C%96"><span class="nav-number">4.4.</span> <span class="nav-text">函数模板为什么不能偏特化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E5%92%8C%E7%89%B9%E5%8C%96%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-number">4.5.</span> <span class="nav-text">编译器匹配规则和特化的总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96%E7%9A%84%E7%9B%AE%E7%9A%84%E5%92%8C%E6%84%8F%E4%B9%89"><span class="nav-number">4.6.</span> <span class="nav-text">类型萃取的目的和意义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83"><span class="nav-number">4.7.</span> <span class="nav-text">类型萃取实战演练</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">4.8.</span> <span class="nav-text">类型萃取是如何实现的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%8F%AF%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.9.</span> <span class="nav-text">类型萃取的另一种可能实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%90%83%E5%8F%96%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="nav-number">4.10.</span> <span class="nav-text">迭代器萃取与泛型算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%90%83%E5%8F%96%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%AF%BB"><span class="nav-number">4.11.</span> <span class="nav-text">迭代器萃取器的设计解读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%90%83%E5%8F%96%E5%99%A8%E7%9A%84%E7%89%B9%E5%8C%96"><span class="nav-number">4.12.</span> <span class="nav-text">迭代器萃取器的特化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL%E5%85%B6%E5%AE%83%E5%AE%B9%E5%99%A8%E8%AE%B2%E8%A7%A3"><span class="nav-number">5.</span> <span class="nav-text">STL其它容器讲解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#STL%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">5.1.</span> <span class="nav-text">STL的三种容器适配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8%E4%B9%8Bstack%E8%AF%A6%E8%A7%A3"><span class="nav-number">5.2.</span> <span class="nav-text">容器适配器之stack详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8%E4%B9%8Bqueue%E5%92%8Cpriority-queue%E8%AF%A6%E8%A7%A3"><span class="nav-number">5.3.</span> <span class="nav-text">容器适配器之queue和priority_queue详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8set"><span class="nav-number">5.4.</span> <span class="nav-text">有序关联容器set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E5%8E%9F%E5%9C%B0%E6%9E%84%E9%80%A0"><span class="nav-number">5.5.</span> <span class="nav-text">set的遍历和原地构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%92%8Cemplace-hint"><span class="nav-number">5.6.</span> <span class="nav-text">移动构造和emplace_hint</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="nav-number">5.7.</span> <span class="nav-text">set的其他方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8map"><span class="nav-number">5.8.</span> <span class="nav-text">有序关联容器map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#multi-set%E5%92%8Cmulti-map"><span class="nav-number">5.9.</span> <span class="nav-text">multi_set和multi_map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="nav-number">5.10.</span> <span class="nav-text">无序关联容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%92%8C%E6%A1%B6"><span class="nav-number">5.11.</span> <span class="nav-text">哈希函数和桶</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unordered-map%E4%B8%AD%E6%A1%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.12.</span> <span class="nav-text">unordered_map中桶相关的方法</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">空白</p>
  <div class="site-description" itemprop="description">记录生活与职业中的点滴</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shenweikun.github.io/2024/11/18/2024-11-18-CPP-Basics-about-STL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="空白">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weikun's Notes">
      <meta itemprop="description" content="记录生活与职业中的点滴">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++从入门到进阶之三-STL等高阶话题 | Weikun's Notes">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++从入门到进阶之三-STL等高阶话题
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-18 02:09:47" itemprop="dateCreated datePublished" datetime="2024-11-18T02:09:47+08:00">2024-11-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-21 18:01:08" itemprop="dateModified" datetime="2024-11-21T18:01:08+08:00">2024-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/4-C-C/" itemprop="url" rel="index"><span itemprop="name">4. C/C++</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>78k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3:15</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="C-模板编程入门"><a href="#C-模板编程入门" class="headerlink" title="C++模板编程入门"></a>C++模板编程入门</h2><h3 id="一个案例引入模板"><a href="#一个案例引入模板" class="headerlink" title="一个案例引入模板"></a>一个案例引入模板</h3><p>1、模板和泛型编程系类文章介绍<br>(1)模板编程是C++的一种高级特性，很常用，很有用，可以说是 C++的精髓，是C++被广泛使用的关键<br>(2)泛型在C++、java、C#等多种语言中都有，是现代编程语言典型特性<br>(3)本章开始不像以前以理论知识讲解为主，而是以写代码和实践为主，在实践中学为主。因为开始变得抽象起来了 </p>
<span id="more"></span>
<p>2、案例和传统解决方案<br>(1)问题：swap函数交换2个数<br>(2)传统解法：定义重载函数，用引用（或指针）来实现<br>(3)代码实战</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(<span class="keyword">double</span>&amp; a, <span class="keyword">double</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> tmp;</span><br><span class="line"></span><br><span class="line">    tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">3.3</span>, d = <span class="number">4.4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myswap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myswap</span>(c, d);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、传统方案的缺点<br>(1)<strong>要为每个数据类型提供一个重载函数，麻烦</strong><br>(2)<strong>所有重载函数除了类型外其他完全一致，重复而浪费</strong></p>
<p>4、解决办法思考与模板引入<br>(1)用到什么类型再实现相应重载。虽然可行但无法类库化，无法分工<br>(2)函数编写时进一步抽象化，调用时再给定具体类型，由<strong>编译器在编译时再绑定形成代码，这就是模板</strong><br>(3)代码实践，用函数模板来实现swap</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;<span class="comment">//定义一个抽象类型X，在函数被调用时确定具体类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(X&amp; a, X&amp; b)</span><span class="comment">//使用swap作为函数名会与某个库函数名冲突</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X tmp;</span><br><span class="line"></span><br><span class="line">    tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">3.3</span>, d = <span class="number">4.4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myswap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myswap</span>(c, d);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板的理解和几个细节"><a href="#模板的理解和几个细节" class="headerlink" title="模板的理解和几个细节"></a>模板的理解和几个细节</h3><p>1、模板是一种编译时的多态<br>(1)模板是关键是编写函数代码原型时不给定具体类型，每次调用时再给定具体类型<br>(2)模板特性由编译器提供，编译时根据调用时的实参具体类型推导匹配的原型中模板的本次具体类型<br>(3)<strong>模板在最终生成的可执行程序中是不可见的</strong><br>(4)<strong>模板是编译时的多态，也可以叫“静态”多态</strong><br>(5)<strong>模板是一种语法糖，是编译器提供给我们的减少编程劳动量的一种语法特性</strong> </p>
<p>2、模板有什么用<br>(1)让我们编写与类型无关的函数<br>(2)模板是一种抽象的维度，让我们能够写出抽象度更高的代码<br>(3)用模板来写库函数更好，因为这样的模板库可以在调用库函数时再指定各种数据类型<br>(4)模板没那么简单，抽象是拿复杂度换劳动量，所以学起来难，学会了用处大</p>
<p>3、模板的几个小细节<br>(1)函数模板定义时typename和class效果是一样的，视个人习惯而使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">X</span>&gt;</span></span><br><span class="line"><span class="comment">// 两个都可以，效果相同</span></span><br></pre></td></tr></table></figure>
<p>(2)函数模板中可以有多个typename，使用时按名称匹配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br></pre></td></tr></table></figure>

<h3 id="函数模板和类模板"><a href="#函数模板和类模板" class="headerlink" title="函数模板和类模板"></a>函数模板和类模板</h3><p>1、模板分2种<br>(1)<strong>函数模板</strong>。模板类型在函数参数列表中使用<br>(2)<strong>类模板</strong>。模板类型在类中（定义类成员变量，或类成员函数的参数列表）使用</p>
<p>2、类模板举例<br>单模板参数的类模板定义与使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(<span class="keyword">int</span> myage);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T x)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; People&lt;T&gt;::<span class="built_in">People</span>(<span class="keyword">int</span> myage)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = myage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> People&lt;T&gt;::<span class="built_in">print</span>(T x)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上边的部分为类模板的定义</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//类模板的使用</span></span><br><span class="line">    <span class="function">People&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">p2</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">4444</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(<span class="number">5.55</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多模板参数的类模板"><a href="#多模板参数的类模板" class="headerlink" title="多模板参数的类模板"></a>多模板参数的类模板</h3><p>1、同类型多参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(<span class="keyword">int</span> myage);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T x, T y)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; People&lt;T&gt;::<span class="built_in">People</span>(<span class="keyword">int</span> myage)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = myage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> People&lt;T&gt;::<span class="built_in">print</span>(T x, T y)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">p2</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">4444</span>, <span class="number">0000</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(<span class="number">5.55</span>, <span class="number">1.122</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、不同类型多参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(<span class="keyword">int</span> myage);</span><br><span class="line">    ~<span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T1 x, T2 y)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; People&lt;T1, T2&gt;::<span class="built_in">People</span>(<span class="keyword">int</span> myage)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = myage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="keyword">void</span> People&lt;T1, T2&gt;::<span class="built_in">print</span>(T1 x, T2 y)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; <span class="string">&quot;, x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">int</span>, string&gt; <span class="title">p1</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">5</span>, <span class="string">&quot;linux&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、成员函数在类内部的模板类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(<span class="keyword">int</span> myage)&#123;</span><br><span class="line">        age = myage;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T1 x, T2 y)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">int</span>, string&gt; <span class="title">p1</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">2</span>, <span class="string">&quot;linux&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板友元函数"><a href="#模板友元函数" class="headerlink" title="模板友元函数"></a>模板友元函数</h3><p>1、友元函数参数中不带模板的情况<br>(1)友元函数声明在class内，定义实现写在class外<br>(2)友元函数参数中类的直接给出具体类型，譬如<br>(3)这种友元函数实际是削弱了模板参数在使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//friend void friend_function(People&lt;int&gt;&amp; s);//方式一：友元函数定义在类的外部</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function</span><span class="params">(People&lt;<span class="keyword">int</span>&gt;&amp; s)</span><span class="comment">//方式二：友元函数定义在类的内部</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt;s.age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//方式一：友元函数定 义在类的外部</span></span><br><span class="line"><span class="comment">void friend_function(People&lt;int&gt;&amp; s)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;age = &quot; &lt;&lt;s.age &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>; </span><br><span class="line">    <span class="built_in">friend_function</span>(a);<span class="comment">//由于友元函数的类型被指定为int，若是定义的类不是int则无法使用该类的对象传参</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、友元函数参数中带模板参数方法1<br>(1)友元函数声明和定义都写在class内部<br>(2)虽然写在class内，但仍然是友元，而不是member function<br>(3)友元可以适配类的各种模板参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(People&lt;T&gt;&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span></span>;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;wwwwedsfs&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、友元函数参数中带模板参数方法2<br>(1)友元函数声明在class内，定义在class外<br>(2)声明时函数名加后缀，而定义时不用加<br>(3)需要class和friend function的2个前置声明<br>(4)调用friend function时可加&lt;实参类型&gt;后缀，也可以不加，但是加就必须加对了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前置声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;T&gt;&amp; s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> friend_function1&lt;T&gt;(<span class="keyword">const</span> People&lt;T&gt;&amp; s);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;T&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span></span>;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;wwwwedsfs&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、友元函数参数中带模板参数方法3</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span>;<span class="comment">//重定义一个U,不与T重名</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span></span>;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;wwwwedsfs&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板运算符重载函数"><a href="#模板运算符重载函数" class="headerlink" title="模板运算符重载函数"></a>模板运算符重载函数</h3><p>1、实现+和+=的运算符重载函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+号如果返回引用,一种是返回*<span class="keyword">this</span>,另一种是返回新建的对象的引用</span><br><span class="line"></span><br><span class="line">前者导致加数也被改</span><br><span class="line">后者导致返回垃圾</span><br><span class="line"></span><br><span class="line">所以只能返回对象</span><br><span class="line"></span><br><span class="line">--------------------------------------------</span><br><span class="line">=号返回引用,</span><br><span class="line">保证了效率,</span><br><span class="line">支持了连续的=号操作</span><br><span class="line"></span><br><span class="line">若返回对象,</span><br><span class="line">效率低下,</span><br><span class="line">并不支持连续=号操作</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;<span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;<span class="comment">//自定义构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span>;<span class="comment">//友元函数，重定义一个U,不与T冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//运算符重载函数</span></span><br><span class="line">    People&lt;T&gt; <span class="keyword">operator</span>+(People&lt;T&gt;&amp; other);</span><br><span class="line">    People&lt;T&gt;&amp; <span class="keyword">operator</span>+=(People&lt;T&gt;&amp; other);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; People&lt;T&gt; People&lt;T&gt;::<span class="keyword">operator</span>+(People&lt;T&gt;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    People&lt;T&gt; tmp;</span><br><span class="line"></span><br><span class="line">    tmp.age = <span class="keyword">this</span>-&gt;age + other.age; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; People&lt;T&gt;&amp; People&lt;T&gt;::<span class="keyword">operator</span>+=(People&lt;T&gt;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age += other.age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span>, <span class="title">c1</span><span class="params">(<span class="number">2.222</span>)</span>, c2</span>;</span><br><span class="line">    c2 = c + c1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line">    c2 += c;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;wwwwedsfs&quot;</span>)</span>, <span class="title">b1</span><span class="params">(<span class="string">&quot;ooosdfsdfsdqw&quot;</span>)</span>, b2</span>;</span><br><span class="line">    b2 = b + b1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line">    b2 += b;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板运算符友元函数重载实现"><a href="#模板运算符友元函数重载实现" class="headerlink" title="模板运算符友元函数重载实现"></a>模板运算符友元函数重载实现</h3><p>1、+作为友元运算符重载<br>(1)友元函数在class内实现，ok，但是因为是友元实现的，所以参数要有2个<br>(2)友元函数在class外实现，不ok，编译无法通过<br>(3)友元函数的第三种实现，ok<br>上述三种情况下的代码实现 在《2、+=作为友元运算符重载》中 给出了</p>
<p>2、+=作为友元运算符重载<br>(1)友元函数在class内实现，ok，但必须带2个参数，带1个不行 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;<span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;<span class="comment">//自定义构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span>;<span class="comment">//友元函数，重定义一个U,不与T冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//运算符重载函数</span></span><br><span class="line">    <span class="keyword">friend</span> People&lt;T&gt; <span class="keyword">operator</span>+(People&lt;T&gt;&amp; a, People&lt;T&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        People&lt;T&gt; tmp;</span><br><span class="line"></span><br><span class="line">        tmp.age = a.age + b.age;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> People&lt;T&gt;&amp; <span class="keyword">operator</span>+=(People&lt;T&gt;&amp; a, People&lt;T&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        a.age += b.age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span>, <span class="title">c1</span><span class="params">(<span class="number">2.222</span>)</span>, c2</span>;</span><br><span class="line">    c2 = c + c1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line">    c2 += c;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span>, <span class="title">b1</span><span class="params">(<span class="string">&quot;linux&quot;</span>)</span>, b2</span>;</span><br><span class="line">    b2 = b + b1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line">    b2 += b;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)友元函数在class外实现，ok</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; People&lt;T&gt;&amp; <span class="keyword">operator</span>+=(People&lt;T&gt; &amp;a, People&lt;T&gt; &amp;b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;<span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;<span class="comment">//自定义构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span>;<span class="comment">//友元函数，重定义一个U,不与T冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//运算符重载函数</span></span><br><span class="line">    <span class="keyword">friend</span> People&lt;T&gt; <span class="keyword">operator</span>+(People&lt;T&gt;&amp; a, People&lt;T&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        People&lt;T&gt; tmp;</span><br><span class="line"></span><br><span class="line">        tmp.age = a.age + b.age;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tmp;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> People&lt;T&gt;&amp; <span class="keyword">operator</span>+=&lt;T&gt;(People&lt;T&gt;&amp; a, People&lt;T&gt;&amp; b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; People&lt;T&gt;&amp; <span class="keyword">operator</span>+=(People&lt;T&gt; &amp;a, People&lt;T&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">        a.age += b.age;</span><br><span class="line">        <span class="keyword">return</span> a;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span>, <span class="title">c1</span><span class="params">(<span class="number">2.222</span>)</span>, c2</span>;</span><br><span class="line">    c2 = c + c1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line">    c2 += c;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;wwwwedsfs&quot;</span>)</span>, <span class="title">b1</span><span class="params">(<span class="string">&quot;ooosdfsdfsdqw&quot;</span>)</span>, b2</span>;</span><br><span class="line">    b2 = b + b1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line">    b2 += b;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3)友元函数的第三种实现，ok</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;<span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">People</span>(T myage):<span class="built_in">age</span>(myage)&#123;&#125;;<span class="comment">//自定义构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span>;<span class="comment">//友元函数，重定义一个U,不与T冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//运算符重载函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> People&lt;U&gt; <span class="keyword">operator</span>+(People&lt;U&gt;&amp; a, People&lt;U&gt;&amp; b);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> People&lt;U&gt;&amp; <span class="keyword">operator</span>+=(People&lt;U&gt;&amp; a, People&lt;U&gt;&amp; b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; People&lt;U&gt; <span class="keyword">operator</span>+(People&lt;U&gt;&amp; a, People&lt;U&gt;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    People&lt;T&gt; tmp;</span><br><span class="line"></span><br><span class="line">    tmp.age = a.age + b.age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; People&lt;U&gt;&amp; <span class="keyword">operator</span>+=(People&lt;U&gt;&amp; a, People&lt;U&gt;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    a.age += b.age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">void</span> <span class="title">friend_function1</span><span class="params">(<span class="keyword">const</span> People&lt;U&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">People&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.1223</span>)</span>, <span class="title">c1</span><span class="params">(<span class="number">2.222</span>)</span>, c2</span>;</span><br><span class="line">    c2 = c + c1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line">    c2 += c;</span><br><span class="line">    <span class="built_in">friend_function1</span>(c2);</span><br><span class="line"></span><br><span class="line">    <span class="function">People&lt;string&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span>, <span class="title">b1</span><span class="params">(<span class="string">&quot;linux&quot;</span>)</span>, b2</span>;</span><br><span class="line">    b2 = b + b1;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line">    b2 += b;</span><br><span class="line">    <span class="built_in">friend_function1</span>(b2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板类的继承"><a href="#模板类的继承" class="headerlink" title="模板类的继承"></a>模板类的继承</h3><p>1、模板类继承的多种情况（常见的）<br>类模板：不确定的类，类中用到了模板<br>模板类：确定的类，类中用到了模板</p>
<p>(1)类模板 继承 类模板<br>(2)类模板 继承 模板类<br>(3)类模板 继承 普通类<br>(4)普通类 继承 模板类</p>
<p>2、类模板继承类模板<br>(1)单模板参数，类模板继承类模板<br>(2)代码实战中学习</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    T x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">People</span>(T myx):<span class="built_in">x</span>(myx)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> People&lt;T&gt;::<span class="built_in">print</span>(<span class="keyword">void</span>)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">man</span>:</span><span class="keyword">public</span> People&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">man</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">man</span>(T myy):<span class="built_in">y</span>(myy)&#123;&#125;;</span><br><span class="line">    <span class="built_in">man</span>(T a, T b):People&lt;T&gt;(a),<span class="built_in">y</span>(b)&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">man</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> man&lt;T&gt;::<span class="built_in">print</span>(<span class="keyword">void</span>)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// (1)类模板 继承 类模板</span></span><br><span class="line">    <span class="function">People&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">man&lt;<span class="keyword">int</span>&gt; <span class="title">m</span><span class="params">(<span class="number">4</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">print</span>();</span><br><span class="line">    m.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)总结：在继承时，相当于用子类的模板参数T去实例填充了父类的模板参数T<br>(4)作用：用于构建模板化的类体系，写模板化的大框架</p>
<p>3、多模板参数<br>(1)2个或2个以上模板参数的情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    T1 x1; <span class="comment">//double</span></span><br><span class="line">    T2 x2;  <span class="comment">//int</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">People</span>(T1 myx1, T2 myx2):<span class="built_in">x1</span>(myx1),<span class="built_in">x2</span>(myx2)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U1, <span class="keyword">typename</span> U2&gt; <span class="class"><span class="keyword">class</span> <span class="title">man</span>:</span>People&lt;U1 ,U2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    U1 y1;  <span class="comment">// int               这里就决定了U1是int ，U2是double， 因此People&lt;U2 ,U1&gt;为People(double, int)，按照符号来决定</span></span><br><span class="line">    U2 y2;  <span class="comment">// double</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">man</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">man</span>( U1 myx1, U2 myx2, U1 myy1, U2 myy2):People&lt;U1, U2&gt;(myx1, myx2),<span class="built_in">y1</span>(myy1),<span class="built_in">y2</span>(myy2)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">man</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U1, <span class="keyword">typename</span> U2&gt; <span class="keyword">void</span> man&lt;U1, U2&gt;::<span class="built_in">print</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this-&gt;x1 = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x1 &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this-&gt;x2 = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x2 &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this-&gt;y1 = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;y1 &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this-&gt;y2 = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;y2 &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双模板参数</span></span><br><span class="line">    <span class="function">man&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; <span class="title">m</span><span class="params">(<span class="number">4</span>, <span class="number">3.3</span>, <span class="number">5</span>, <span class="number">6.6</span>)</span></span>;</span><br><span class="line">    m.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：多个模板参数是按照顺序对应的</p>
<p>4、类模板 继承 模板类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T attribute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(T my_attitude):<span class="built_in">attribute</span>(my_attitude)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> People&lt;T&gt;::<span class="built_in">print</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;attribute = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;attribute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span> <span class="keyword">public</span> People&lt;<span class="keyword">double</span>&gt;<span class="comment">//在这里将People类确定为double</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    U P_attribute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Man</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">Man</span>(<span class="keyword">double</span> a, U b):People&lt;<span class="keyword">double</span>&gt;(a),<span class="built_in">P_attribute</span>(b)&#123;&#125;;<span class="comment">//这里的a的类型也由此确定了</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Man_print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">void</span> Man&lt;U&gt;::<span class="built_in">Man_print</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P_attribute = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;P_attribute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Man&lt;string&gt; <span class="title">s</span><span class="params">(<span class="number">6.666</span>,<span class="string">&quot;asdasd&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">print</span>();</span><br><span class="line">    s.<span class="built_in">Man_print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、类模板 继承 普通类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> attribute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(<span class="keyword">double</span> my_attitude):<span class="built_in">attribute</span>(my_attitude)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">People::print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;attribute = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;attribute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span> <span class="keyword">public</span> People<span class="comment">//</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    U P_attribute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Man</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">Man</span>(<span class="keyword">double</span> a, U b):<span class="built_in">People</span>(a),<span class="built_in">P_attribute</span>(b)&#123;&#125;;<span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Man_print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">void</span> Man&lt;U&gt;::<span class="built_in">Man_print</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P_attribute = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;P_attribute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Man&lt;string&gt; <span class="title">s</span><span class="params">(<span class="number">6.666</span>,<span class="string">&quot;asdasd&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">print</span>();</span><br><span class="line">    s.<span class="built_in">Man_print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、普通类 继承 模板类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T attribute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">People</span>(T my_attitude):<span class="built_in">attribute</span>(my_attitude)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> People&lt;T&gt;::<span class="built_in">print</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;attribute = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;attribute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span> <span class="keyword">public</span> People&lt;<span class="keyword">double</span>&gt;<span class="comment">//在这里将People类确定为double</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string P_attribute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Man</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">Man</span>(<span class="keyword">double</span> a, string b):People&lt;<span class="keyword">double</span>&gt;(a),<span class="built_in">P_attribute</span>(b)&#123;&#125;;<span class="comment">//这里的a的类型也由此确定了</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Man_print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Man::Man_print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P_attribute = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;P_attribute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Man <span class="title">s</span><span class="params">(<span class="number">6.666</span>,<span class="string">&quot;asdasdsdfsdfoo&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">print</span>();</span><br><span class="line">    s.<span class="built_in">Man_print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非类型模板参数和模板类型推导"><a href="#非类型模板参数和模板类型推导" class="headerlink" title="非类型模板参数和模板类型推导"></a>非类型模板参数和模板类型推导</h3><p>1、非类型模版参数<br>详解阅读：参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/lanchunhui/article/details/49634077">https://blog.csdn.net/lanchunhui/article/details/49634077</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> MAXSIZE&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T elems[MAXSIZE];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">         Stack&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; int10Stack;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非类型模板参数是有类型限制的。一般而言，它可以是常整数（包括enum枚举类型）或者指向外部链接对象的指针。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、模板的本质<br>参数化：将其作为参数一样，通过传参确定<br>(1)类型参数化<br>(2)值参数化<br>(3)类型和值都参数化<br>(4)本质：延迟绑定</p>
<p>3、类型推导的隐式类型转换<br>(1)在决定模板参数类型前，编译器执行隐式类型转换，有时候实际类型和看起来会不同<br>(2)编译器用值类型实例化函数模板，而不是用相应的引用类型<br>(3)编译器用指针类型实例化函数模板，而不是相应的数组类型<br>(4)去除const修饰，绝不会用const类型实例化函数模板，总是用相应的非const类型<br>(5)对于指针来说，指针和 const 指针是不同的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">2</span>）</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;</span><br><span class="line">People&lt;b&gt;<span class="comment">//实例化时会将int&amp; 转换为 int</span></span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(a)</span></span>;                <span class="comment">// 数组做实参，实际实参不是数组而是指针</span></span><br><span class="line">People&lt;a&gt;</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">People&lt;a&gt;<span class="comment">//实例化时会去除const</span></span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1;</span><br><span class="line"><span class="keyword">int</span> *p2;</span><br></pre></td></tr></table></figure>

<p>4、模板和库<br>(1)模板无法单独编译，也就不能通过lib连接静态库的形式隐藏实现<br>(2)模板通常会把声明和定义写在头文件里，所以c++的模板总是开源的<br>(3)说明typename的一种用法，这种用法里typename不等同于class<br>详解阅读：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cthon/p/9201649.html">https://www.cnblogs.com/cthon/p/9201649.html</a></p>
<h2 id="STL的容器类和迭代器"><a href="#STL的容器类和迭代器" class="headerlink" title="STL的容器类和迭代器"></a>STL的容器类和迭代器</h2><h3 id="STL的容器类介绍"><a href="#STL的容器类介绍" class="headerlink" title="STL的容器类介绍"></a>STL的容器类介绍</h3><p>1、何为容器<br>(1)顾名思义，容器就是盛放东西的东西，这里被盛放的一般是数据对象，用来盛放的是容器类<br>(2)计算机中一切皆是数据，<strong>数据存储只能在内存中，而容器类是用做容器的内存的管理方法</strong><br>(3)容器类的内核就是：<strong>数据结构 (数据在内存中的排放、存储方法)+ 算法(数据的运算、处理，如排序)</strong><br>  数据结构 -&gt; 类的成员变量<br>  算法     -&gt; 类的成员方法<br>(4)C语言语法内置的数组和结构体，就是语言源生支持的容器（但并未提供相应的算法，不过通过库函数补充了部分算法）<br>(5)C++容器通过类库方式提供，容器类库被模板技术泛化后，就是STL容器了。STL一般指标准模板库。 标准模板库（Standard Template Library，STL） </p>
<p>2、STL有哪些容器类<br>(1)<strong>序列容器</strong>。<br>元素在容器中的位置同元素的值无关，即容器不是排序的（类似于C数组）。包括array、vector、deque、list、forward_list等几个。<br>(2)<strong>排序容器</strong>。<br>数据插入时即自动按照值从小到大排列好。包括set、multiset、map、mutilmap等。<br>(3)<strong>哈希容器</strong>。<br>哈希容器中的元素是未排序的，元素的位置由哈希函数确定，即遵守一定规则的&lt;key,value&gt;对式存储。包括unordered_set、unordered_map、hash_set、hash_multiset、hash_map、hash_multimap等 </p>
<p>3、容器类如何学习<br>(1)<strong>容器类就是STL的核心</strong>，STL其他技术点都围绕容器类开展<br>(2)可见<strong>STL的本质其实就是一套模板技术泛化类型的C++基本数据结构和算法类库</strong><br>(3)本部分文章会集中细致讲几个STL序列容器array、vector等，其他容器类似情况就简略讲过了<br>(4)第一层为学会使用stl容器，第二层为能合理使用stl容器，第三层为理解stl背后设计，第四层为自己能写新的stl容器。 </p>
<h3 id="序列容器之array"><a href="#序列容器之array" class="headerlink" title="序列容器之array"></a>序列容器之array</h3><p>1、array的特性<br>(1)<strong>array是定长、同类型多元素、内存中连续排布的一种容器</strong><br>(2)array其实就是C语言数组的C++ template封装，定义于头文件array</p>
<p>2、array的学习方法<br>(1)参考文档：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/array">https://zh.cppreference.com/w/cpp/container/array</a><br>(2)挨个理解文档相关所有元素<br>隐式声明与显示声明：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/snandy/archive/2011/03/04/1970777.html">https://www.cnblogs.com/snandy/archive/2011/03/04/1970777.html</a> </p>
<p>3、array的构造和初始化<br>(1)和C数组兼容的初始化方式<br>(2)需要C++11或以上标准来支持</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linux中使用g++编译时需加上：-std=c++<span class="number">11</span>选项</span><br><span class="line">低版本的ubuntu需要，高版本的ubuntu安装的g++并不需要</span><br></pre></td></tr></table></figure>

<p>4、array的元素访问<br>(1)at方法<br>(2)operator[]实现的C数组式访问<br>(3)front和back方法返回第1个和最后1个元素<br>(4)data返回真实存储内存中首元素首地址的值<br>如果array的元素访问越界了，那么编译时没问题，但是运行时会抛出异常</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1)array是定长、同类型多元素、内存中连续排布的一种容器</span></span><br><span class="line"><span class="comment">// (2)array其实就是C语言数组的C++ template封装，定义于头文件array</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;array&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a1;             <span class="comment">// 定义但是未初始化</span></span><br><span class="line">    <span class="comment">//array&lt;int, 3&gt; a2(1, 3, 5);    // 编译报错，因为这里相当于调用构造函数去初始化，C++不可能提供那么多个构造函数</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a2&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;    <span class="comment">// 定义并初始化 ，聚合初始化</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a3 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;; <span class="comment">// 初始化赋值</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a4 = a3;        <span class="comment">// 拷贝构造</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[0] = &quot;</span> &lt;&lt; a2[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[1] = &quot;</span> &lt;&lt; a2[<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[2] = &quot;</span> &lt;&lt; a2[<span class="number">2</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    a2[<span class="number">0</span>] = <span class="number">11</span>;                  <span class="comment">// 访问指定的元素，但是没有进行越界检查</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[0] = &quot;</span> &lt;&lt; a2[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    a2.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="number">33</span>;               <span class="comment">// 访问指定的元素，同时进行越界检查</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[1] = &quot;</span> &lt;&lt; a2.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//a2.at(3) = 33; //编译报错，越界了，编译没问题，运行时抛出异常 //terminate called after throwing an instance of &#x27;std::out_of_range&#x27;</span></span><br><span class="line"></span><br><span class="line">    a2[<span class="number">4</span>] = <span class="number">11</span>;                   <span class="comment">// 这里已经越界访问了，但是不一定会报错，因为这赋值是不会进行越界检查的</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[4] = &quot;</span> &lt;&lt; a2[<span class="number">4</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2.front = &quot;</span> &lt;&lt; a2.<span class="built_in">front</span>() &lt;&lt;endl;  <span class="comment">// 访问第一个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2.back = &quot;</span> &lt;&lt; a2.<span class="built_in">back</span>() &lt;&lt; endl;   <span class="comment">// 访问最后一个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2.size = &quot;</span> &lt;&lt; a2.<span class="built_in">size</span>() &lt;&lt; endl;   <span class="comment">// 返回容纳的元素数</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、array的容量设置和获取<br>(1)容量设置只能在定义时一次设定，且必须设定，设定后再不能改<br>(2)empty：若容器为空则为 true ，否则为 false<br>(3)size：容器中的元素数量。<br>(4)max_size：返回根据系统或库实现限制的容器可保有的元素最大数量</p>
<p>6、操作<br>(1)fill：以指定值填充容器<br>(2)swap：交换内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array &lt;<span class="keyword">int</span>, 3&gt; a1&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    array &lt;<span class="keyword">int</span>, 3&gt; a2&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[0] = &quot;</span> &lt;&lt; a1[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[1] = &quot;</span> &lt;&lt; a1[<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[2] = &quot;</span> &lt;&lt; a1[<span class="number">2</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[0] = &quot;</span> &lt;&lt; a2[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[1] = &quot;</span> &lt;&lt; a2[<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[2] = &quot;</span> &lt;&lt; a2[<span class="number">2</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x  = get&lt;<span class="number">0</span>&gt;(a1);  <span class="comment">// 获取第0个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt;endl;  </span><br><span class="line"></span><br><span class="line">    a1.<span class="built_in">swap</span>(a2); <span class="comment">//等价于 std::swap(a1, a2);</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[0] = &quot;</span> &lt;&lt; a1[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[1] = &quot;</span> &lt;&lt; a1[<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[2] = &quot;</span> &lt;&lt; a1[<span class="number">2</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[0] = &quot;</span> &lt;&lt; a2[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[1] = &quot;</span> &lt;&lt; a2[<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[2] = &quot;</span> &lt;&lt; a2[<span class="number">2</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    a1.<span class="built_in">fill</span>(<span class="number">0</span>);   <span class="comment">// 将 array 填充 0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[0] = &quot;</span> &lt;&lt; a1[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[1] = &quot;</span> &lt;&lt; a1[<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[2] = &quot;</span> &lt;&lt; a1[<span class="number">2</span>] &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    array &lt;string, 1&gt; a3&#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a3.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、非成员函数<br>(1)operator重载函数<br>(2)get<br>(3)swap<br>(4)to_array (C++20 起)，低版本编译器并不支持</p>
<p>8、辅助类tuple_size、tuple_element<br>tuple_size提供作为编译时常量表达式访问 std::array 中元素数量的方法。<br>tuple_element使用类 tuple 接口，提供 array 元素类型的编译时带下标访问</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[tuple_size&lt;T&gt;::value];<span class="comment">// 能用于编译时</span></span><br><span class="line">        cout &lt;&lt; tuple_size&lt;T&gt;::value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        array&lt;<span class="keyword">int</span>, 3&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        array&lt;string, 4&gt; b = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">         定义 a 并获取位于位置 <span class="number">0</span> 的元素类型,类型为<span class="keyword">int</span></span><br><span class="line">        <span class="keyword">using</span> T = tuple_element&lt;<span class="number">0</span>, <span class="keyword">decltype</span>(a)&gt;::type; <span class="comment">//这里的using作用类似于C中的typedef，给数据类型起别名</span></span><br><span class="line">        T c = <span class="number">6</span>;</span><br><span class="line">        cout &lt;&lt; is_same&lt;T, <span class="keyword">int</span>&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//判断T是否为int，是否都是int类型</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">test</span>(a);</span><br><span class="line">        <span class="built_in">test</span>(b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器的引入"><a href="#迭代器的引入" class="headerlink" title="迭代器的引入"></a>迭代器的引入</h3><p>1、迭代器是干嘛的<br>(1)迭代器就是能 <strong>通过移动 来 遍历处理 的 一种机制</strong><br>(2)C语言中遍历数组元素，用指针*p++方式，指针变量就是遍历迭代器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*        </span></span><br><span class="line"><span class="comment">        for (p=第1个元素; p!=最后一个元素; p++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">                *p就是每一个元素</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>(3)思考：结构体元素能够通过指针运算来遍历？<br>答：不能。因为结构体中元素的类型一般是不同的，无法得知访问下一个元素，地址的偏移量是多少</p>
<p>2、关于迭代器的分析<br>(1)每种容器理论上都可以被遍历，不存在不能被遍历的容器<br>(2)每种容器的遍历实现都可能不同，要结合容器和元素的特点来具体实现<br>(3)<strong>迭代器内部原理肯定是通过指针操作（地址运算）来实现</strong><br>(4)迭代器就是C++为我们设计的一个高层次的“指针”，高层指针是面向容器中的元素的，实现对容器中元素的遍历。其工作时最终会映射到底层指针(即我们C语言中使用指针的方法) </p>
<p>3、C++实际是这么设计迭代器的<br>(1)<strong>所有的迭代器有一个共同基类（接口），规定了迭代器的基本行为规范接口</strong><br>(2)<strong>每个容器类中均包含了一个专属化迭代器成员变量</strong>，这个专属化迭代器专门针对该容器的特点实现了迭代器应该有的所有接口<br>(3)需要遍历某STL容器时，只需要直接调出该容器的这个迭代器成员变量直接用即可，固定名字为iterator </p>
<p>4、典型的迭代器用法<br>(1)代码实战，用迭代器来实现遍历array</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt;::iterator iter;  <span class="comment">//这是一个可读可写的迭代器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">        *iter = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt;::const_iterator citer;  <span class="comment">//这是一个只读的迭代器</span></span><br><span class="line">    <span class="keyword">for</span> ( citer = a.<span class="built_in">cbegin</span>(); citer != a.<span class="built_in">cend</span>(); citer++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; *citer &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//*citer = 3;  //报错 error: assignment of read-only location ‘* citer’</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际写代码中，一般不会像前面这样写，会利用auto</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a1 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = a1.<span class="built_in">begin</span>(); iter != a1.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = a1.<span class="built_in">rbegin</span>(); iter != a1.<span class="built_in">rend</span>(); iter++)   <span class="comment">// 逆向迭代器</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)begin()和end()方法是得到容器遍历的开始和结尾的套路化方法</p>
<h3 id="迭代器的几个细节问题"><a href="#迭代器的几个细节问题" class="headerlink" title="迭代器的几个细节问题"></a>迭代器的几个细节问题</h3><p>1、const与非const<br>(1)begin和end返回可读可写的迭代器，而cbegin和cend返回const的只读迭代器<br>(2)代码验证迭代器的读写权限</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt;::iterator iter;<span class="comment">//可读可写</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt;::const_iterator citer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; iter &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">        *iter = <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(citer = a.<span class="built_in">cbegin</span>(); citer != a.<span class="built_in">cend</span>(); citer++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;citer = &quot;</span> &lt;&lt; citer &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*citer = &quot;</span> &lt;&lt; *citer &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; iter &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">        *iter = <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> citer = a.<span class="built_in">cbegin</span>(); citer != a.<span class="built_in">cend</span>(); citer++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;citer = &quot;</span> &lt;&lt; citer &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*citer = &quot;</span> &lt;&lt; *citer &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、begin和end的半开半闭区间<br>(1)begin返回第0个元素的迭代器（类似于C数组的首元素首地址指针）<br>(2)end指向的不是末尾元素的迭代器，而是末尾元素的（实际不存在的）下一个元素的迭代器<br>(3)前闭后开区间，经常记做[begin end)，这样设计是为了写循环遍历时方便 </p>
<p>3、正向和逆向迭代器<br>(1)rbegin和rend返回逆向迭代器<br>(2)逆向迭代器的begin是最末尾元素，而end是第0个元素去（实际不存在的）前面1个元素的迭代器<br>(3)逆向迭代器++是向前移动，而–是向后移动</p>
<p>4、迭代器越界会怎么样<br>(1)<strong>和数组越界类似，编译时不审查，运行时会崩溃</strong><br>(2)<strong>不管是正向还是逆向迭代器，++不到end，–不到begin，就不会越界</strong></p>
<h3 id="STL的不同类型迭代器"><a href="#STL的不同类型迭代器" class="headerlink" title="STL的不同类型迭代器"></a>STL的不同类型迭代器</h3><p>1、C++17前共有5种迭代器<br>(1)InputIterator，输入迭代器。只能从容器内读出而不能向容器内写入，只能单次读出（读出过一次后不保证再次操作仍然可以，想想流输入输出），只能++走不能–走（就是单向的），不能保证第二次遍历容器时，顺序不变。输入迭代器适用于单通只读型算法。<br>(2)OutputIterator，输出迭代器。用于将信息传输给容器（修改容器中元素的值），但是不能读取。（显示器就是只能写不能读的设备，可用输出容器来表示它）只能++走不能–走（就是单向的），输出迭代器适用于单通只写型算法。<br>(3)ForwardIterator，前向迭代器。只能++走不能–走（就是单向的）<br>(4)BidirectionalIterator，双向迭代器。既能++也可以–，双向移动。<br>(5)RandomAccessIterator，随机访问迭代器。能双向移动，并且可以单次跨越多个元素移动。 </p>
<p>2、C++17新增1种迭代器<br>(1)contiguousIterator,连续迭代器。所指向的逻辑相邻元素也在内存中物理上相邻。</p>
<p>3、STL的6种迭代器总结<br>(1)每种迭代器更应该被看作是具有某些预定义特征（或者满足某接口要求）的一个迭代器的实现。</p>
<p>(2)这些迭代器彼此之间有功能重叠，譬如随机访问迭代器可由双向迭代器扩展而来，详见文档：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/iterator">https://zh.cppreference.com/w/cpp/iterator</a></p>
<p>(3)为何定义多种迭代器？<br>  是为了适配容器特性和泛型算法，后面会看到array的迭代器既是一个双向迭代器，也是一个随机访问迭代器。</p>
<p>4、C++20的新迭代器<br>(1)C++20中重新实现了基于concept的新的迭代器体系<br>(2)原有的模板都被加了前缀Legecy，但很长时间仍然可用，甚至还是主流<br>(3)基于concept的新迭代器主要在类型约束和模板特化方面做了优化<br>(4)C++20目前还刚开始，可以先不管，先学好原有的，后面再扩展去学C++20新特性 </p>
<h3 id="序列容器之Vector"><a href="#序列容器之Vector" class="headerlink" title="序列容器之Vector"></a>序列容器之Vector</h3><p>参考学习文档:<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/vector">https://zh.cppreference.com/w/cpp/container/vector</a><br>1、Vector的特征<br>(1)Vector和Array相同点是：都是数组、都是contiguousIterator、容器内元素种类都相同<br>(2)Vector和Array不同点是：<strong>Array是固定数组；Vector是动态数组，可以按需扩展数组大小</strong><br>(3)<strong>vector 的存储是自动管理的，按需扩张收缩。</strong><br>(4)<strong>vector 通常占用多于静态数组的空间，因为要分配更多内存以管理将来的增长</strong><br>(5)vector 所用的内存分配方式不在每次插入元素时，而<strong>只在额外内存耗尽时重分配</strong>。 </p>
<p>使用例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = v.<span class="built_in">cbegin</span>(); iter != v.<span class="built_in">cend</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.size = &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.max_size = &quot;</span> &lt;&lt; v.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.capacity = &quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.size = &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.max_size = &quot;</span> &lt;&lt; v.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;push_back v.capacity  = &quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.size = &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.max_size = &quot;</span> &lt;&lt; v.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;push_back v.capacity = &quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : v)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">*iter = <span class="number">1</span></span><br><span class="line">*iter = <span class="number">3</span></span><br><span class="line">*iter = <span class="number">5</span></span><br><span class="line">v.size = <span class="number">3</span></span><br><span class="line">v.max_size = <span class="number">4611686018427387903</span></span><br><span class="line">v.capacity = <span class="number">3</span></span><br><span class="line">v.size = <span class="number">4</span></span><br><span class="line">v.max_size = <span class="number">4611686018427387903</span></span><br><span class="line">push_back v.capacity  = <span class="number">6</span></span><br><span class="line">v.size = <span class="number">5</span></span><br><span class="line">v.max_size = <span class="number">4611686018427387903</span></span><br><span class="line">push_back v.capacity = <span class="number">6</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">i = <span class="number">3</span></span><br><span class="line">i = <span class="number">5</span></span><br><span class="line">i = <span class="number">7</span></span><br><span class="line">i = <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h3 id="序列容器之list"><a href="#序列容器之list" class="headerlink" title="序列容器之list"></a>序列容器之list</h3><p>参考学习：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/list">https://zh.cppreference.com/w/cpp/container/list</a><br>(1) list 通常实现为双向链表。<br>(2) 可以高效地进行插入删除元素，但是随机访问却比较慢。<br>(3) list不支持随机存取，要访问第n个元素，必须先遍历前n-1个元素才能访问第n个元素。因此，list没有下标[ ]操作，也没有at()接口。</p>
<p>使用例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; l = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;; </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l.size = &quot;</span> &lt;&lt; l.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l.max_size = &quot;</span> &lt;&lt; l.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;is or not empty :&quot;</span> &lt;&lt; l.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : l)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    l.<span class="built_in">assign</span>(<span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    l.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">    l.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">    l.<span class="built_in">insert</span>(l.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">    l.<span class="built_in">sort</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = l.<span class="built_in">begin</span>(); iter != l.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l.size = <span class="number">6</span></span><br><span class="line">l.max_size = <span class="number">768614336404564650</span></span><br><span class="line">is <span class="keyword">or</span> <span class="keyword">not</span> empty :<span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">9</span> </span><br></pre></td></tr></table></figure>

<h3 id="序列容器之deque"><a href="#序列容器之deque" class="headerlink" title="序列容器之deque"></a>序列容器之deque</h3><p>(1) deque容器为一个给定类型的元素进行线性处理，像向量一样，它能够快速地随机访问任一个元素，并且能够高效地插入和删除容器的尾部元素。<br>(2) 它又与vector不同，deque支持高效插入和删除容器的头部元素，因此也叫做双端队列。<br>参考学习：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010710458/article/details/79540505">https://blog.csdn.net/u010710458/article/details/79540505</a><br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/deque">https://zh.cppreference.com/w/cpp/container/deque</a></p>
<p>使用例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建容纳整数的 deque</span></span><br><span class="line">    std::deque&lt;<span class="keyword">int</span>&gt; d = &#123;<span class="number">7</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">8</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 从 deque 的首尾添加整数</span></span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">13</span>);</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">25</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 迭代并打印 deque 的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : d) &#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>

<h3 id="序列容器选择"><a href="#序列容器选择" class="headerlink" title="序列容器选择"></a>序列容器选择</h3><p>如何选择这四个容器中哪一个，应根据你的需要而定，具体可以遵循下面的原则：</p>
<ol>
<li>   <strong>如果你需要高效的随即存取，而不在乎插入和删除的效率，使用array或vector，前者是固定大小的数组，后者是可变大小的数组</strong></li>
<li>   <strong>如果你需要大量的插入和删除，而不关心随即存取，则应使用list</strong></li>
<li>   <strong>如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque</strong></li>
</ol>
<p>注意：C++提供的容器还有很多，适用于各种场景，但是使用方法都大同小异，这里不再赘述。有需要查询<a target="_blank" rel="noopener" href="https://zh.cppreference.com/">C++ 参考手册</a>即可。</p>
<h2 id="STL的泛型算法使用详解"><a href="#STL的泛型算法使用详解" class="headerlink" title="STL的泛型算法使用详解"></a>STL的泛型算法使用详解</h2><h3 id="什么是泛型算法"><a href="#什么是泛型算法" class="headerlink" title="什么是泛型算法"></a>什么是泛型算法</h3><p>1、从容器说起<br>(1)容器是数据结构，是对数据的封装<br>(2)各容器都提供了少量处理元素操作的方法，譬如sort，但没有提供更多<br>(3)同样的操作譬如sort，在不同容器中底层处理肯定会不同<br>(4)<strong>泛型算法是独立于容器类的一些操作方法，可以用于多种容器，所以叫“泛型”算法</strong><br>(5)泛型算法实际上是<strong>更高层次的抽象</strong>，所以设计和实现的难度很大，这也是<strong>STL的核心技术</strong></p>
<p>2、泛型算法使用基础<br>(1)泛型算法学习参考：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm">https://zh.cppreference.com/w/cpp/algorithm</a><br>  泛型算法在元素范围上操作，即其操作的是元素的值。注意范围定义为 [first, last) ，其中 last 指代要查询或修改的最后元素的后一个元素。<br>(2)泛型算法所在头文件 </p>
<h3 id="泛型算法使用实战"><a href="#泛型算法使用实战" class="headerlink" title="泛型算法使用实战"></a>泛型算法使用实战</h3><p>1、泛型算法和容器迭代器的适配<br><strong>(1)算法中对迭代器有要求<br>(2)容器中包含的迭代器有特性<br>(3)2者兼容才可合使用，否则不可使用</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; class RandomIt &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">( RandomIt first, RandomIt last )</span></span>;(C++<span class="number">20</span> 前)</span><br><span class="line"></span><br><span class="line">类型要求:</span><br><span class="line">-RandomIt 必须满足值可交换 (ValueSwappable) 和 老式随机访问迭代器 (LegacyRandomAccessIterator) 的要求。</span><br><span class="line">-解引用 RandomIt 结果的类型必须满足可移动赋值 (MoveAssignable) 和可移动构造 (MoveConstructible) 的要求。</span><br></pre></td></tr></table></figure>

<p>2、泛型算法使用举例<br>下面的这个sort函数并非这几个容器自带的算法，而是泛型算法sort：<br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/sort">https://zh.cppreference.com/w/cpp/algorithm/sort</a><br>(1)使用sort为array默认排序<br>(2)使用sort为list默认排序<br>(3)使用sort为list由大到小排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>();)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter++ &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="keyword">int</span>, 5&gt; a1&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a2&#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; a3&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a1.<span class="built_in">begin</span>(), a1.<span class="built_in">end</span>());<span class="comment">//默认从小到大的顺序排列</span></span><br><span class="line">    <span class="built_in">sort</span>(a2.<span class="built_in">begin</span>(), a2.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());<span class="comment">//按从大到小的顺序排列</span></span><br><span class="line">    a3.<span class="built_in">sort</span>();<span class="comment">//list的迭代器不支持随机访问，故而不可使用泛型算法，可使用其自带的sort方法</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(a1);</span><br><span class="line">    <span class="built_in">print</span>(a2);</span><br><span class="line">    <span class="built_in">print</span>(a3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="谓词predicate和函数对象引入"><a href="#谓词predicate和函数对象引入" class="headerlink" title="谓词predicate和函数对象引入"></a>谓词predicate和函数对象引入</h3><p>1、何为谓词<br>(1)谓词就是可以<strong>做谓语的词，就是“动词、动作”性质语义的词</strong><br>(2)<strong>C/C++中的函数function就是典型的谓词语义</strong><br>(3)C++ STL中的谓词类似这样：<strong>bool func(T&amp; a); 或者 bool func(T&amp;a, T&amp; b);返回值是bool类型</strong><br>(4)常见的谓词：<strong>函数,函数指针,lambda表达式,函数对象,库定义的函数对象</strong></p>
<p>2、函数对象引入<br>(1)函数对象 function object， 也叫仿函数 functor<br>(2)函数对象在语法上不是函数，而是个类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a2.<span class="built_in">begin</span>(), a2.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">greater就是个函数对象。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; class RandomIt, class Compare &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">( RandomIt first, RandomIt last, Compare comp )</span></span>;</span><br></pre></td></tr></table></figure>
<p>(3)函数对象在<strong>调用形式上看起来像个函数</strong></p>
<p>3、函数对象案例实践<br>(1)写一个函数，判断传参是否大于0<br>(2)用函数对象实现，对比、分析、体会</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsGreater_function</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a&gt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsGreater_class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//我们通过()的运算符重载函数实现同样的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(U a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a&gt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用函数实现</span></span><br><span class="line">    <span class="keyword">bool</span> b = <span class="built_in">IsGreater_function</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    b = <span class="built_in">IsGreater_function</span>(<span class="number">-5</span>);</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用函数对象实现</span></span><br><span class="line">    IsGreater_class&lt;<span class="keyword">int</span>&gt; is_greater;</span><br><span class="line">    b = <span class="built_in">is_greater</span>(<span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    b = <span class="built_in">is_greater</span>(<span class="number">-6</span>); </span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数对象的一些细节"><a href="#函数对象的一些细节" class="headerlink" title="函数对象的一些细节"></a>函数对象的一些细节</h3><p>1、自定义函数对象用于STL算法库</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的函数对象，通过字符串的个数进行比较</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mygreater</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> string s1, <span class="keyword">const</span> string s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (s1.<span class="built_in">size</span>() &gt; s2.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>();)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter++ &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;string, 3&gt; a = &#123;<span class="string">&quot;linux&quot;</span>, <span class="string">&quot;android&quot;</span>, <span class="string">&quot;harmonyos&quot;</span>&#125;; </span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());<span class="comment">//默认是根据字符串首字母的字典序进行比较的，排序按照从小到大</span></span><br><span class="line">    <span class="built_in">print</span>(a);</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), greater&lt;string&gt;());<span class="comment">//使用泛型算法提供的函数对象greater</span></span><br><span class="line">    <span class="built_in">print</span>(a);</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">mygreater</span>());<span class="comment">//使用自定义的函数对象mygreater</span></span><br><span class="line">    <span class="built_in">print</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、函数对象的优势<br>(1)<strong>函数对象可以使用template技术实现多类型支持，这比函数的重载技术更有优势</strong><br>(2)函数对象可以有<strong>自己的状态</strong>。我们可以在类中定义状态变量（类私有成员变量），这样一个函数对象在多次的调用中可以共享这个状态。比如我们可以用这个状态表示函数被调用的次数。<br>参考学习：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/gis-user/p/5086218.html">https://www.cnblogs.com/gis-user/p/5086218.html</a> </p>
<h3 id="STL典型泛型算法解读"><a href="#STL典型泛型算法解读" class="headerlink" title="STL典型泛型算法解读"></a>STL典型泛型算法解读</h3><p>我们随机打开一个来分析学习：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/all_any_none_of">https://zh.cppreference.com/w/cpp/algorithm/all_any_none_of</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; class InputIt, class UnaryPredicate &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">all_of</span><span class="params">( InputIt first, InputIt last, UnaryPredicate p )</span></span>;</span><br><span class="line"></span><br><span class="line">UnaryPredicate：一元谓词，表示该谓词只接收一个参数</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Divisible</span> <span class="title">By</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> d;</span><br><span class="line">        <span class="built_in">DivisibleBy</span>(<span class="keyword">int</span> n) : <span class="built_in">d</span>(n) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n % d == <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">any_of</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), <span class="built_in">DivisibleBy</span>(<span class="number">7</span>))) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;At least one number is divisible by 7\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">any_of</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), <span class="built_in">DivisibleBy</span>(<span class="number">7</span>))中的<span class="number">7</span>对应DivisibleBy成员变量</span><br><span class="line">d，这里的<span class="built_in">DivisibleBy</span>(<span class="number">7</span>)既与构造函数有关（进行初始化），也与运算符重载函数有关（作</span><br><span class="line">为函数对象），<span class="built_in">DivisibleBy</span>(<span class="keyword">int</span> n)中的n是在迭代器遍历时内部传参的。</span><br></pre></td></tr></table></figure>

<h3 id="CPP之lamba表达式"><a href="#CPP之lamba表达式" class="headerlink" title="CPP之lamba表达式"></a>CPP之lamba表达式</h3><p>1、实践体会lamba表达式<br>(1)lambda表达式使用举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::<span class="built_in">all_of</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), [](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>; &#125;))</span><br><span class="line">&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;All numbers are even\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lamba表达式:[](int i)&#123; return i % 2 == 0; &#125;</span></span><br></pre></td></tr></table></figure>
<p>(2)使用函数对象实现类似于lambda表达式的效果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IsEven</span>//若使用<span class="keyword">class</span>关键字，则需将重载函数作为<span class="title">public</span>成员，<span class="keyword">class</span>和<span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span>                         <span class="comment">//关键字默认权限不一样</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if (all_of(v.begin(), v.end(), [](int i) -&gt;bool &#123;return i % 2 == 0;&#125;))//方式一：使用lamba表达式</span></span><br><span class="line">    <span class="comment">//IsEven()不传参，这个()对应使用构造函数进行初始化的参数，i是内部传参，迭代器遍历时容器中的元素</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">all_of</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">IsEven</span>()))<span class="comment">//方式二：使用函数对象</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;All numbers are even\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot; Not all numbers are  even\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、lambda表达式总结<br>(1)lambda表达式就是<strong>一个匿名函数，相当于一次使用的、直接原地展开调用的函数</strong><br>(2)lambda表达式也叫<strong>闭包，就是在别的地方无法调用的封包</strong><br>(3)lambda表达式其实<strong>就是一个函数对象，在内部创建了一个重载()操作符的类</strong></p>
<p>3、lambda表达式格式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)完整格式<span class="number">5</span>部分：[参数捕获] (操作符重载函数参数) <span class="keyword">mutable</span>或exception声明 -&gt;返回值类型 &#123;函数体&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)最简单的lambda表达式：[]()&#123;&#125;，调用执行时为[]()&#123;&#125;();</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)带传参的lambda表达式：[](<span class="keyword">int</span> i)&#123;<span class="comment">//i在这里可以用&#125;</span></span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)使用<span class="keyword">auto</span>将lambda表达式定义为一个变量，再以变量方式调用</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>)使用-&gt;<span class="keyword">int</span>这种方式让lambda表达式函数返回相应类型的值</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例如下：</span><br><span class="line">        (<span class="number">2</span>) []()&#123;&#125;();</span><br><span class="line">        </span><br><span class="line">        (<span class="number">3</span>) []()&#123;cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;&#125;();</span><br><span class="line">                [](<span class="keyword">int</span> i)&#123;cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; i &lt;&lt; endl;&#125;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        (<span class="number">4</span>)、(<span class="number">5</span>) <span class="keyword">auto</span> func = [](<span class="keyword">int</span> i) -&gt;<span class="keyword">bool</span> &#123;cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; i &lt;&lt; endl; <span class="keyword">return</span> <span class="literal">false</span>;&#125;;</span><br><span class="line">        <span class="keyword">bool</span> x = <span class="built_in">func</span>(<span class="number">4</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="lambda表达式之参数捕获"><a href="#lambda表达式之参数捕获" class="headerlink" title="lambda表达式之参数捕获"></a>lambda表达式之参数捕获</h3><p>1、什么是参数捕获<br>(1)实验：在lambda表达式外面定义int a，在表达式内部试图访问<br>(2)解决：在[]中增加捕获说明即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">test</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">test</span>(<span class="keyword">int</span> t)&#123;<span class="keyword">this</span>-&gt;sum = t;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt;endl;</span><br><span class="line">        [&amp;]()&#123;sum++;cout&lt;&lt;<span class="string">&quot;lamba4: sum = &quot;</span> &lt;&lt; sum &lt;&lt;endl;&#125;();</span><br><span class="line">        [<span class="keyword">this</span>]()&#123;<span class="keyword">this</span>-&gt;sum++;cout&lt;&lt;<span class="string">&quot;lamba5: this-&gt;sum = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;sum &lt;&lt; endl;&#125;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    string b = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    [a]()&#123;cout &lt;&lt; <span class="string">&quot;lamba1: a = &quot;</span> &lt;&lt; a &lt;&lt; endl;&#125;();</span><br><span class="line">    [&amp;a]()&#123;a++; cout &lt;&lt; <span class="string">&quot;lamba2: a = &quot;</span> &lt;&lt; a &lt;&lt; endl;&#125;();</span><br><span class="line">    <span class="keyword">auto</span> func = [=](<span class="keyword">int</span> i)&#123;cout &lt;&lt; <span class="string">&quot;lamba3: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;&#125;;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">test <span class="title">s</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    s.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)总结：<strong>所谓参数捕获，就是让lambda表达式内部可以捕获并使用外部的变量</strong></p>
<p>2、lambda表达式的捕获列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)[] 空，完全不捕获</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)[=] 等号，以值传参方式捕获（复制了一份传进来，这样表达式内修改了变量，但表达式外值</span><br><span class="line">仍未变，与引用传参的效果不同），捕获范围是表达式所在作用范围（包括所在类的<span class="keyword">this</span>）</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)[&amp;] &amp;号，以引用传参方式捕获，捕获范围是表达式所在作用范围（包括所在类的<span class="keyword">this</span>）</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)[<span class="keyword">this</span>] 只捕获lambda表达式所在类的<span class="keyword">this</span>可访问的那些</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>)[a] 仅以值方式捕获a，其他全部不捕获</span><br><span class="line"></span><br><span class="line">(<span class="number">6</span>)[&amp;a] 仅以引用方式捕获a，其他全部不捕获</span><br><span class="line"></span><br><span class="line">(<span class="number">7</span>)[a, &amp;b] 仅以值方式捕获a，以引用方式捕获b，其余完全不捕获</span><br><span class="line"></span><br><span class="line">(<span class="number">8</span>)[=, &amp;a, &amp;b] 仅以引用方式捕获a和b，其余以值方式捕获</span><br><span class="line"></span><br><span class="line">(<span class="number">9</span>)[&amp;, a, b] 仅以值方式捕获a和b，其余以引用方式捕获</span><br></pre></td></tr></table></figure>

<p>3、lambda表达式总结<br>(1)lambda表达式提供<strong>一种单次使用的函数简写方式</strong><br>(2)<strong>通过捕获列表，在lambda表达式内部也可以访问外部的变量，相当于函数传参</strong></p>
<h3 id="CPP函数适配器"><a href="#CPP函数适配器" class="headerlink" title="CPP函数适配器"></a>CPP函数适配器</h3><p>1、什么是函数适配器<br>(1)<strong>适配器，adapter，用来在不适配的2端间对接的连接器</strong><br>(2)<strong>函数适配器是在不同传参个数的函数间进行适配的技术</strong><br>示例理解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func1</span>(<span class="keyword">int</span> a)</span><br><span class="line"><span class="built_in">func2</span>(<span class="keyword">int</span> a, <span class="keyword">char</span> b)<span class="comment">//可通过手动填充一个参数b进行适配</span></span><br><span class="line"><span class="built_in">func3</span>(<span class="keyword">int</span> a)&#123;<span class="built_in">func2</span>(a, <span class="string">&#x27;A&#x27;</span>);&#125;<span class="comment">//func3则是一个函数适配器，适配了func1与func2</span></span><br></pre></td></tr></table></figure>
<p>(3)几个概念：1元函数、2元函数、1元谓词、2元谓词<br>1元：具有一个参数<br>2元：具有两个参数<br>谓词：返回值是bool类型</p>
<p>2、C++的函数适配器<br>(1)早期C++98时，常用bind1st bind2nd<br>bind1st：预先填充第一个，释放第二个，bind2nd与其刚好相反<br>(2)C++11开始，引入加强版：std::bind</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::<span class="built_in">none_of</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), std::<span class="built_in">bind</span>(std::modulus&lt;<span class="keyword">int</span>&gt;(),                                                 std::placeholders::_1, <span class="number">2</span>)))</span><br><span class="line"><span class="comment">//std::placeholders::_1:表示释放谁，2：表示要填充的值，即将二元谓词的第一个元释放出来，第二个元预先填充，形成一个新的一元谓词</span></span><br><span class="line">&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;None of them are odd\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; class InputIt, class UnaryPredicate &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">all_of</span><span class="params">( InputIt first, InputIt last, UnaryPredicate p )</span></span>;<span class="comment">//UnaryPredicate表示一元谓词</span></span><br><span class="line"></span><br><span class="line">std::modulus::<span class="built_in"><span class="keyword">operator</span></span>()<span class="comment">//二元谓词</span></span><br><span class="line"><span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> T&amp; rhs )</span> <span class="keyword">const</span></span>;</span><br><span class="line">(C++<span class="number">14</span> 前)</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> T&amp; rhs )</span> <span class="keyword">const</span></span>;</span><br><span class="line">(C++<span class="number">14</span> 起)</span><br><span class="line">返回 lhs 除以 rhs 的余数。</span><br><span class="line"></span><br><span class="line">一元谓词和二元谓词并不适配，故需要函数适配器bind</span><br></pre></td></tr></table></figure>

<p>3、bind的学习<br>参考学习：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013654125/article/details/100140328">https://blog.csdn.net/u013654125/article/details/100140328</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestFunc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> c, <span class="keyword">float</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;f = &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> bindFunc1 = <span class="built_in">bind</span>(TestFunc, placeholders::_1, <span class="string">&#x27;A&#x27;</span>, <span class="number">100.1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bindFunc1</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=================================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> bindFunc2 = <span class="built_in">bind</span>(TestFunc, placeholders::_1, placeholders::_2, <span class="number">100.1</span>);</span><br><span class="line">    <span class="built_in">bindFunc2</span>(<span class="number">10</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=================================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> bindFunc3 = <span class="built_in">bind</span>(TestFunc, placeholders::_2, placeholders::_3, placeholders::_1);</span><br><span class="line">    <span class="built_in">bindFunc3</span>(<span class="number">100.1</span>, <span class="number">30</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=================================&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> bindFunc4 = <span class="built_in">bind</span>(TestFunc, <span class="number">10</span>, placeholders::_2, placeholders::_1);</span><br><span class="line">    <span class="built_in">bindFunc4</span>(<span class="number">100.1</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="STL典型泛型算法解读-1"><a href="#STL典型泛型算法解读-1" class="headerlink" title="STL典型泛型算法解读"></a>STL典型泛型算法解读</h3><p>1、for_each、transform、范围 for 循环(C++11)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参考学习：</span><br><span class="line">https:<span class="comment">//zh.cppreference.com/w/cpp/algorithm/for_each</span></span><br><span class="line">https:<span class="comment">//zh.cppreference.com/w/cpp/algorithm/transform</span></span><br><span class="line">https:<span class="comment">//zh.cppreference.com/w/cpp/language/range-for</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; sum += n; &#125;</span><br><span class="line">    <span class="keyword">int</span> sum&#123;<span class="number">0</span>&#125;;<span class="comment">//使用&#123;&#125;赋初值，若struct Sum类型变量被定义，sum初值为0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">for_each示例：</span><br><span class="line"></span><br><span class="line">可能源码：</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class InputIt, class UnaryFunction&gt;</span></span><br><span class="line"><span class="function">UnaryFunction <span class="title">for_each</span><span class="params">(InputIt first, InputIt last, UnaryFunction f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">        <span class="built_in">f</span>(*first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f; <span class="comment">// C++11 起隐式移动</span></span><br><span class="line">&#125;</span><br><span class="line">使用示例：</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">267</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> print = [](<span class="keyword">const</span> <span class="keyword">int</span>&amp; n) &#123; std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n; &#125;;</span><br><span class="line"> </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;before:&quot;</span>;</span><br><span class="line">std::for_each(nums.<span class="built_in">cbegin</span>(), nums.<span class="built_in">cend</span>(), print);<span class="comment">//实现遍历元素并打印</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">transform示例：</span><br><span class="line">可能源码:</span><br><span class="line"></span><br><span class="line">版本一</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class InputIt, class OutputIt, class UnaryOperation&gt;</span></span><br><span class="line"><span class="function">OutputIt <span class="title">transform</span><span class="params">(InputIt first1, InputIt last1, OutputIt d_first, </span></span></span><br><span class="line"><span class="params"><span class="function">                   UnaryOperation unary_op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (first1 != last1) &#123;</span><br><span class="line">        *d_first++ = <span class="built_in">unary_op</span>(*first1++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d_first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用示例：</span><br><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">transform</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s.<span class="built_in">begin</span>(),</span><br><span class="line">[](<span class="keyword">unsigned</span> <span class="keyword">char</span> c) -&gt; <span class="keyword">unsigned</span> <span class="keyword">char</span> &#123; <span class="keyword">return</span> std::<span class="built_in">toupper</span>(c); &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">范围 <span class="keyword">for</span> 循环示例：</span><br><span class="line"></span><br><span class="line">可能源码：</span><br><span class="line">属性(可选) <span class="keyword">for</span> ( 初始化语句(可选)范围变量声明 : 范围表达式 ) 循环语句                </span><br><span class="line"></span><br><span class="line">使用示例：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; i : v) <span class="comment">// 以 const 引用访问</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : v) <span class="comment">// 以值访问，i 的类型是 int</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; i : v) <span class="comment">// 以转发引用访问，i 的类型是 int&amp;</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cv = v;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; i : cv) <span class="comment">// 以转发引用访问，i 的类型是 const int&amp;</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;) <span class="comment">// 初始化器可以是花括号初始化器列表</span></span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : a) <span class="comment">// 初始化器可以是数组</span></span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> ([[maybe_unused]] <span class="keyword">int</span> n : a)  </span><br><span class="line">        std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 不必使用循环变量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n = v.<span class="built_in">size</span>(); <span class="keyword">auto</span> i : v) <span class="comment">// 初始化语句（C++20）</span></span><br><span class="line">        std::cout &lt;&lt; --n + i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">typedef</span> <span class="keyword">decltype</span>(v)::value_type <span class="keyword">elem_t</span>; <span class="keyword">elem_t</span> i : v)</span><br><span class="line">    <span class="comment">// typedef 声明作为初始化语句（C++20）</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">using</span> <span class="keyword">elem_t</span> = <span class="keyword">decltype</span>(v)::value_type; <span class="keyword">elem_t</span> i : v)</span><br><span class="line">    <span class="comment">// 别名声明作为初始化语句，同上（C++23）</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、再看几个泛型算法<br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm">https://zh.cppreference.com/w/cpp/algorithm</a><br>其他算法的学习方法与上边相同，打开上边的网址自主学习，授之以鱼不如授之以渔。</p>
<p>2、泛型算法总结<br>(1)<strong>理解 谓词 和 函数对象，是学习和使用泛型算法的基础</strong><br>(2)泛型算法很多，但是套路是类似的，学会的关键是理解并会用这种套路<br>(3)<strong>不建议试图死记硬背所有泛型算法，建议实战中去熟悉、去用起来并记住</strong><br>(4)能用现成泛型算法写代码就不要自己造轮子<br>(5)一个潜在问题警告：C++包的越来越多（层层封装），不要想当然，未经验证确认的代码都要有怀疑精神</p>
<h2 id="模板特化和类型萃取"><a href="#模板特化和类型萃取" class="headerlink" title="模板特化和类型萃取"></a>模板特化和类型萃取</h2><h3 id="从案例中理解什么是模板特化"><a href="#从案例中理解什么是模板特化" class="headerlink" title="从案例中理解什么是模板特化"></a>从案例中理解什么是模板特化</h3><p>1、通过一个案例理解模板特化<br>(1)案例前奏：写一个swap函数库，可以适用于各种数据类型。结论是模板比函数重载好用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;<span class="comment">//定义一个抽象类型X，在函数被调用时确定具体类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(X&amp; a, X&amp; b)</span><span class="comment">//使用swap作为函数名会与某个库函数名冲突</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X tmp;</span><br><span class="line"></span><br><span class="line">    tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">3.3</span>, d = <span class="number">4.4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myswap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myswap</span>(c, d);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)案例：写一个GreaterThan函数，可以对比各种数据类型的大小。<br>(3)特殊要求：int等比较数值大小，但string类型对比时，不比较字典序，而是以字符串长短来比较</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GreaterThan</span><span class="params">(T a, T b)</span><span class="comment">//模板泛化函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template GreaterThan&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GreaterThan</span><span class="params">(string a, string b)</span><span class="comment">//模板特化函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;special template GreaterThan&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GreaterThan</span><span class="params">(string a, string b)</span><span class="comment">//普通函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ordinary GreaterThan&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; GreaterThan&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; GreaterThan&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; GreaterThan&lt;<span class="keyword">double</span>&gt;(<span class="number">5.4</span>, <span class="number">5.3</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; GreaterThan&lt;<span class="keyword">double</span>&gt;(<span class="number">5.3</span>, <span class="number">5.4</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面所传的两个参数为const型，不可修改，GreaterThan()函数调用优先级为模板泛化函数最高</span></span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; GreaterThan&lt;string&gt;(<span class="string">&quot;linux&quot;</span>, <span class="string">&quot;harmony&quot;</span>) &lt;&lt; endl;<span class="comment">//执行special</span></span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; <span class="built_in">GreaterThan</span>(<span class="string">&quot;linux&quot;</span>, <span class="string">&quot;harmony&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当比较的两个参数为string类型时，上述三个函数优先级为：</span></span><br><span class="line">    <span class="comment">//普通函数 &gt; 模板特化函数 &gt; 模板泛化函数</span></span><br><span class="line">    string a = <span class="string">&quot;linux&quot;</span>, b = <span class="string">&quot;harmony&quot;</span>; </span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; GreaterThan&lt;string&gt;(a, b) &lt;&lt; endl;<span class="comment">//执行special</span></span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; <span class="built_in">GreaterThan</span>(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考学习：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/rickyk/p/3941176.html">C++普通函数与模板函数以及特化函数重载的优先级问题</a></p>
<p>2、模板特化总结<br>(1)<strong>模板特化有点类似于函数重载，而且都是编译链接时确定，而非运行时确定的。</strong><br>(2)特化，specialize，就是<strong>让模板参数T在某个具体类型时可以特殊化指定处理</strong><br>(3)特化的模板声明，前面一般是 template&lt;&gt;</p>
<h3 id="偏特化和全特化"><a href="#偏特化和全特化" class="headerlink" title="偏特化和全特化"></a>偏特化和全特化</h3><p>1、全特化与偏特化概念<br>(1)<strong>全特化，特化原模板的所有模板类型为具体类型</strong><br>(2)<strong>偏特化，又叫局部特化，特化原模板的部分类型，或部分特化原模板的类型</strong><br>(3)全特化比较简单，而偏特化更复杂，是之后讨论的重点。</p>
<p>2、函数模板的全特化<br>(1)代码实践，单个模板参数<br>  上边提供的那个程序中就实现了单个模板参数的全特化。<br>(2)代码实践，多个模板参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T1 a, T2 b)</span> <span class="comment">//模板泛化函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(T1 a, T2 b), a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">int</span> b)</span> <span class="comment">//函数模板的全特化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(double a, int b), a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> b = <span class="number">2.2</span>;</span><br><span class="line">    <span class="built_in">func</span>(a, b);</span><br><span class="line">    <span class="built_in">func</span>(b, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、类模板的全特化<br>(1)代码实践，单个模板参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T attribute;</span><br><span class="line">    <span class="built_in">people</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">people</span>(T attr)&#123;attribute = attr;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T a)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> people&lt;T&gt;::<span class="built_in">print</span>(T a)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template function print: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span><span class="keyword">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> attribute;</span><br><span class="line">    <span class="built_in">people</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">people</span>(<span class="keyword">int</span> attr)&#123;attribute = attr;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span></span>;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> people&lt;<span class="keyword">int</span>&gt;::<span class="built_in">print</span>(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;complete special template function print: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">people&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">people&lt;string&gt; <span class="title">p2</span><span class="params">(<span class="string">&quot;linux&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">10</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(<span class="string">&quot;linux&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)代码实践，多个模板参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 attribute;</span><br><span class="line">    <span class="built_in">people</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">people</span>(T1 attr)&#123;attribute = attr;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T2 a)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="keyword">void</span> people&lt;T1, T2&gt;::<span class="built_in">print</span>(T2 a)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template function print: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span><span class="keyword">int</span>, string&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> attribute;</span><br><span class="line">    <span class="built_in">people</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">people</span>(<span class="keyword">int</span> attr)&#123;attribute = attr;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(string a)</span></span>;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> people&lt;<span class="keyword">int</span>, string&gt;::<span class="built_in">print</span>(string a)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;complete special template function print: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">people&lt;<span class="keyword">int</span>, string&gt; <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">people&lt;string, <span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="string">&quot;linux&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="string">&quot;linux&quot;</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类模板的多种偏特化"><a href="#类模板的多种偏特化" class="headerlink" title="类模板的多种偏特化"></a>类模板的多种偏特化</h3><p>1、类模板的第一种偏特化<br>(1)特化多个模板参数中的一部分参数<br>(2)这种比较简单，代码实践演示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>//模板泛化类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T1 a, T2 b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="keyword">void</span> people&lt;T1, T2&gt;::<span class="built_in">print</span>(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span>string, <span class="keyword">int</span>&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(string a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:people&lt;string, int&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span><span class="keyword">int</span>, string&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a, string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:people&lt;int, string&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    people&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p1;</span><br><span class="line">    people&lt;string, string&gt; p2;</span><br><span class="line">    people&lt;<span class="keyword">int</span>, string&gt; p3;</span><br><span class="line">    people&lt;string, <span class="keyword">int</span>&gt; p4;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(<span class="string">&quot;two&quot;</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">    p3.<span class="built_in">print</span>(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">    p4.<span class="built_in">print</span>(<span class="string">&quot;four&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、类模板的第二种偏特化<br>(1)特化为T的指针类型<br>(2)这种特化理解起来稍微有点绕（可以将T理解为一个万能类型，而T则表示这个类型必须为指针，T包含T，所以T*是T的偏特化），实战演示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>//模板泛化类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T1 a, T2 b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="keyword">void</span> people&lt;T1, T2&gt;::<span class="built_in">print</span>(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span>T *, <span class="keyword">int</span>&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:peoplepeople&lt;T *, int&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span>T *, string&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T *a,  string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:peoplepeoplepeople&lt;T *, string&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    string c = <span class="string">&quot;two&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> d = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    people&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p1;</span><br><span class="line">    people&lt;<span class="keyword">char</span> *, <span class="keyword">int</span>&gt; p2;</span><br><span class="line">    people&lt;<span class="keyword">int</span> *, string&gt; p3;</span><br><span class="line">    people&lt;string *, <span class="keyword">int</span>&gt; p4;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(d, <span class="number">2</span>);</span><br><span class="line">    p3.<span class="built_in">print</span>(&amp;a, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">    p4.<span class="built_in">print</span>(<span class="string">&quot;four&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、类模板的第三种偏特化<br>(1)特化为T的其他类模板，譬如vector<br>(2)这种特化理解起来难度更大，实战演示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>//模板泛化类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T1 a, T2 b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="keyword">void</span> people&lt;T1, T2&gt;::<span class="built_in">print</span>(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span>vector&lt;T&gt;, <span class="keyword">int</span>&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:people&lt;vector&lt;T&gt;, int&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span>array&lt;T, 3&gt;, string&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(array&lt;T, <span class="number">3</span>&gt; a,  string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:people&lt;array&lt;T, 3&gt;, string&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>&lt;</span>T&amp; , string&gt;<span class="comment">//类模板的偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T&amp; a,  string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;partial template class:people&lt;T&amp; , string&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">    array&lt;<span class="keyword">int</span>, 3&gt; c;</span><br><span class="line"></span><br><span class="line">    people&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p1;</span><br><span class="line">    people&lt;<span class="keyword">int</span> &amp;, string&gt; p2;</span><br><span class="line">    people&lt;vector&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; p3;</span><br><span class="line">    people&lt;array&lt;<span class="keyword">int</span>, 3&gt;, string&gt; p4;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">print</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    p2.<span class="built_in">print</span>(a, <span class="string">&quot;int&amp;&quot;</span>);</span><br><span class="line">    p3.<span class="built_in">print</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    p4.<span class="built_in">print</span>(c, <span class="string">&quot;array&lt;int, 3&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、类模板的第四种偏特化<br>(1)特化为带const的版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;template class&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>&lt;</span><span class="keyword">const</span> T &amp;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;People&lt;const T &amp;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    People&lt;string&gt; p1;</span><br><span class="line">    People&lt;<span class="keyword">const</span> <span class="keyword">char</span> &amp;&gt; p2;</span><br><span class="line">    People&lt;<span class="keyword">const</span> <span class="keyword">int</span> &amp;&gt; p3;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">func</span>();</span><br><span class="line">    p2.<span class="built_in">func</span>();</span><br><span class="line">    p3.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数模板为什么不能偏特化"><a href="#函数模板为什么不能偏特化" class="headerlink" title="函数模板为什么不能偏特化"></a>函数模板为什么不能偏特化</h3><p>1、事实<br>(1)<strong>函数模板确实不支持偏特化，只能全特化，这是编译器决定的</strong>（若想求证，可自行写个程序测试一下，比较简单，下面是我的测试程序）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T a)</span><span class="comment">//模板泛化函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template:void func(T a) &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;  endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="comment">//全特化函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;complete template :void func(int a) &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;  endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> func&lt;T*&gt;(T a)<span class="comment">//偏特化函数，但函数没有偏特化，故编译不会通过</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;partial template:void func(T* a) &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;  endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用函数重载来实现T *的偏特化完全相同的效果</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func(T *a), a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="comment">//非模板函数，即普通函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ordinary:void func(int a) &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;  endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3.14</span>);    <span class="comment">//template</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">5</span>);       <span class="comment">//ordinary</span></span><br><span class="line">    func&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>);  <span class="comment">//complete template</span></span><br><span class="line">    <span class="comment">//func&lt;int *&gt;(5);//用于调用偏特化函数，但函数无偏特化</span></span><br><span class="line">    func&lt;<span class="keyword">int</span>&gt;(&amp;a);<span class="comment">//重载函数：func(T *a)</span></span><br><span class="line">    <span class="built_in">func</span>(&amp;a);     <span class="comment">//重载函数：func(T *a)</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="string">&quot;linux&quot;</span>);<span class="comment">//重载函数：func(T *a)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)怎么办？<br>  用模板函数重载即可</p>
<p>(3)总结：为什么函数模板不能偏特化？<br>  因为没必要支持，模板函数重载就能搞定</p>
<p>2、分析深度原因<br>(1)C++语言设计基本原则：<strong>后出现的语法尽量兼容且不破坏原有的语法规则</strong><br>(2)<strong>C++一开始就支持函数重载，所以模板函数自然沿用了支持函数重载</strong><br>(3)<strong>偏特化实现的效果，完全可以用模板函数重载实现，所以没必要让模板函数可以偏特化</strong><br>(4)再思考：类模板为什么可以偏特化？<br>  因为类不能重载 </p>
<h3 id="编译器匹配规则和特化的总结"><a href="#编译器匹配规则和特化的总结" class="headerlink" title="编译器匹配规则和特化的总结"></a>编译器匹配规则和特化的总结</h3><p>1、编译器匹配规则<br>(1)第1步先匹配非模版函数，也就是普通函数，如果匹配到就执行，匹配不到进入下一步<br>(2)第2步再匹配基础泛化版函数，如果匹配不到就报错了，匹配到进入下一步<br>(3)第3步再匹配完全特化版本，如果匹配到就执行，匹配不到就执行上一步匹配到的泛化版本<br>(4)一个小细节：函数模板的特化（当然是全特化）不参与函数重载 </p>
<p>2、特化与递归结合<br>(1)特化与递归结合，可以很巧妙的实现编译期的条件判断</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">int</span> i&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  print&lt;i<span class="number">-1</span>&gt;();</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//特例，终止递归。</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> print&lt;<span class="number">1</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  print&lt;<span class="number">100</span>&gt;();<span class="comment">//在编译期展开相当于100条输出语句</span></span><br><span class="line">  <span class="comment">//即调用void print()并传参100，print&lt;i-1&gt;();开始递归，i初值100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liuxuejiang158blog/article/details/17678573">https://blog.csdn.net/liuxuejiang158blog/article/details/17678573</a></p>
<p>3、特化的最后总结<br>(1)<strong>特化本质上是我们顶替了编译器的工作，我们帮编译器做了类型推导</strong><br>(2)模板特化和模板实例化这2个概念的对比<br>(3)<strong>全特化本质上是一个实例，而偏特化本质上还是一个模板，只是原来模板的一个子集，所以全特化的函数模板，本质上是实例（但不参与普通函数的重载），从而不会与函数模板产生二义性</strong></p>
<h3 id="类型萃取的目的和意义"><a href="#类型萃取的目的和意义" class="headerlink" title="类型萃取的目的和意义"></a>类型萃取的目的和意义</h3><p>1、类型萃取是用途<br>(1)典型应用就是：在模板函数中区分T是 源生类型POD 还是 自定义类型<br>(2)POD,Plain Old Data,简单理解就是C++从C继承而来的基本类型，如int、double等<br>(3)POD类型的本质是没有C++叠加的那些高级特征（构造析构，拷贝构造，移动语义，虚函数等） </p>
<p>2、为什么要区分POD类型和非POD类型<br>(1)典型案例就是copy时，POD类型直接memcpy(C语言的一个库函数)即可，而非POD类型需要用for循环结合“=”(默认提供的运算符重载后的=可以实现对象拷贝)，挨个对象拷贝<br>(2)非POD类型不能memcpy(涉及到了动态内存)，本质是因为需要深拷贝以避免出错<br>(3)代码演练:int数组和string数组的复制对比 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span><span class="comment">//c语言的那个string.h头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//C++的string头文件，与上边的那个不同</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mycopy</span><span class="params">(T* Dst, T* Src, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(Dst, Src, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0    </span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, b[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    string a[<span class="number">3</span>] = &#123;<span class="string">&quot;linux&quot;</span>, <span class="string">&quot;android&quot;</span>, <span class="string">&quot;harmonyos&quot;</span>&#125;;</span><br><span class="line">    string b[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    mycopy&lt;string&gt;(b, a, <span class="built_in"><span class="keyword">sizeof</span></span>(string)*<span class="number">3</span>);<span class="comment">//虽然可以执行，但会报错，这就是浅拷贝</span></span><br><span class="line">    a[<span class="number">1</span>] = <span class="string">&quot;ubuntu&quot;</span>;                       <span class="comment">//报错信息：free(): invalid size ，已放弃 (核心已转储)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//mycopy&lt;int&gt;(b, a, sizeof(int)*3);</span></span><br><span class="line">    <span class="comment">//a[0] = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; b[k] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型萃取实战演练"><a href="#类型萃取实战演练" class="headerlink" title="类型萃取实战演练"></a>类型萃取实战演练</h3><p>1、使用is_pod解决上面的问题<br>(1)std::is_pod介绍</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m1;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m2;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; std::is_pod&lt;A&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::is_pod&lt;B&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::is_pod&lt;C&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>(2)代码实战，使用is_pod来完善mycopy解决上节中的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mycopy</span><span class="params">(T* Dst, T* Src, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_pod&lt;T&gt;::value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(Dst, Src, <span class="built_in"><span class="keyword">sizeof</span></span>(T)*count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Dst[i] = Src[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a[<span class="number">3</span>] = &#123;<span class="string">&quot;linux&quot;</span>, <span class="string">&quot;android&quot;</span>, <span class="string">&quot;harmonyos&quot;</span>&#125;;</span><br><span class="line">    string b[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    mycopy&lt;string&gt;(b, a, <span class="number">3</span>);</span><br><span class="line">    a[<span class="number">1</span>] = <span class="string">&quot;ubuntu&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; b[k] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型萃取是如何实现的"><a href="#类型萃取是如何实现的" class="headerlink" title="类型萃取是如何实现的"></a>类型萃取是如何实现的</h3><p>1、一种可能的实现（方法一）<br>(1)把所有pod类型组成列表，在内部挨个判断，借助两个关键字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeid</span>用来返回一个变量（表达式）（对象）的类型，类似于C语言中的：<span class="built_in">typeof</span>() </span><br><span class="line">是GUN C提供的一种特性，它可以取得变量的类型，或者表达式的类型。</span><br></pre></td></tr></table></figure>
<p>(2)优点：可以实现，且能实现<type_traits>中所有的标准库萃取工具<br>(3)缺点：运行时</p>
<p>2、使用类模板的特化实现（方法二）<br>(1)代码实践演示<br>判断，占用运行时资源，效率低</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛化版本的my_is_pod</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_is_pod</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> my_is_pod&lt;T&gt;::value = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// int类型的特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_is_pod</span>&lt;</span><span class="keyword">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> my_is_pod&lt;<span class="keyword">int</span>&gt;::value = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// double类型的特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_is_pod</span>&lt;</span><span class="keyword">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> my_is_pod&lt;<span class="keyword">double</span>&gt;::value = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// short类型的特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_is_pod</span>&lt;</span><span class="keyword">short</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> my_is_pod&lt;<span class="keyword">short</span>&gt;::value = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string类型使用这样的方法还会报错，我试过，但没有去深入研究</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mycopy</span><span class="params">(T *dest, <span class="keyword">const</span> T *src, <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">// 我们需要一种技术，在这里可以去区分，T到底是pod还是非pod</span></span><br><span class="line">        <span class="keyword">if</span> (my_is_pod&lt;T&gt;::value)</span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;if&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">memcpy</span>(dest, src, cnt*<span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;else&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cnt; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                        dest[i] = src[i];                        <span class="comment">// 非pod类型使用operator=是可以复制的</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; boolalpha &lt;&lt; my_is_pod&lt;double&gt;::value &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">short</span> a[<span class="number">3</span>] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">short</span> b[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        mycopy&lt;<span class="keyword">short</span>&gt;(b, a, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">                cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*        </span></span><br><span class="line"><span class="comment">        string s1[3] = &#123;&quot;linux&quot;, &quot;android&quot;, &quot;harmonyos&quot;&#125;;</span></span><br><span class="line"><span class="comment">        string s2[3];</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        mycopy&lt;string&gt;(s2, s1, 3);                        // 非pod类型不能memcpy，因为会浅拷贝导致错误</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for (int i=0; i&lt;3; i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; &quot;s2[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; s2[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        s1[0] = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;last, s2[0] = &quot; &lt;&lt; s2[0] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">*/</span>        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)总结：特化实现萃取的关键，就是特化版本的优先级高于泛化版本<br>(3)思考：使用类模板特化，是否会增加代码量，影响程序效率？<br>  会增加代码量，不会影响效率，模板特化是在编译时判断的。</p>
<h3 id="类型萃取的另一种可能实现"><a href="#类型萃取的另一种可能实现" class="headerlink" title="类型萃取的另一种可能实现"></a>类型萃取的另一种可能实现</h3><p>1、不使用静态成员变量<br>2、改为使用成员函数<br>3、使用typedef增加一层中间层<br>(1)class/struct内使用typedef定义子类型的方法<br>(2)增加名为value_type的子类型中间层，实现pod判断</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FalseType</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">GetType</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrueType</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">GetType</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛化版本的my_is_pod</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_is_pod</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> FalseType value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_is_pod</span>&lt;</span><span class="keyword">short</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> TrueType value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; my_is_pod&lt;<span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>().<span class="built_in">GetType</span>() &lt;&lt; endl;<span class="comment">//value_type()的这个()表示构造函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器萃取与泛型算法"><a href="#迭代器萃取与泛型算法" class="headerlink" title="迭代器萃取与泛型算法"></a>迭代器萃取与泛型算法</h3><p>1、STL的核心<br>(1)STL，就是C++提供的一套标准实现的template化的library<br>(2)STL有很多内容，但是核心就是2个：<strong>泛型容器、泛型算法</strong><br>(3)为了实现<strong>泛型容器，引入了迭代器，迭代器是指针的泛化抽象</strong><br>(4)泛型算法可以接受多种容器，每种容器内可以存储多种数据载体，这就是泛型算法的2级泛化支持</p>
<p>2、泛型算法实现的难题和解法<br>(1)问题1：泛型算法无法预知自己处理的是什么容器<br>解决思路：<strong>将容器降级为迭代器来对接泛型算法。所以任何容器都必须内置一个迭代器</strong><br>(3)问题2：泛型算法无法预知容器内存储的元素类型，是否POD<br>解决思路：<strong>提供迭代器萃取器，在泛型算法内预先萃取并使用容器元素类型</strong></p>
<h3 id="迭代器萃取器的设计解读"><a href="#迭代器萃取器的设计解读" class="headerlink" title="迭代器萃取器的设计解读"></a>迭代器萃取器的设计解读</h3><p>(1)迭代器萃取器本质是一个类，叫iterator_traits，属于辅助迭代器的第三方类<br>(2)解读参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/virtual_func/article/details/48398451">https://blog.csdn.net/virtual_func/article/details/48398451</a></p>
<h3 id="迭代器萃取器的特化"><a href="#迭代器萃取器的特化" class="headerlink" title="迭代器萃取器的特化"></a>迭代器萃取器的特化</h3><p>1、萃取器的特化讲解<br>(1)参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/terence1212/article/details/52287762">https://blog.csdn.net/terence1212/article/details/52287762</a><br>(2)总结：本质是偏特化结合类型萃取技术</p>
<p>2、本章节文章总结<br>(1)主要讲了2项技术，一个 是特化，一个是萃取<br>(2)特化的核心价值是，<strong>让模板类/函数按一定优先级规则去匹配</strong><br>(3)萃取的核心价值是，让我们在<strong>写泛型算法时可以预先得知未来传参容器及容器内元素的型别特征</strong><br>(4)<strong>如果只是使用STL，实际上不需要关注特化和萃取</strong><br>(5)<strong>真正理解模板技术、特化、萃取等技术的使用和实现，你才会感受到C++的魅力，知道C++为什么效率高</strong><br>(6)<strong>从实用角度讲，不需要真的深度去研究这些。但是如果完全不懂甚至不知道这些技术的存在，那休想用好C++</strong></p>
<h2 id="STL其它容器讲解"><a href="#STL其它容器讲解" class="headerlink" title="STL其它容器讲解"></a>STL其它容器讲解</h2><h3 id="STL的三种容器适配器"><a href="#STL的三种容器适配器" class="headerlink" title="STL的三种容器适配器"></a>STL的三种容器适配器</h3><p>1、什么是容器适配器<br>(1)回顾：C++三种适配器：<strong>函数适配器、容器适配器、迭代器适配器</strong><br>(2)<strong>适配器，adapter，本质是添加一个中间层来转换以适配双方</strong><br>(3)<strong>容器适配器，是用已有容器来二次封装以构建新容器</strong><br>(4)<strong>STL提供三种容器适配器，分别是：stack、queue、priority_queue</strong><br>(5)stack:栈，先进后出，关心压栈和弹栈操作<br>(6)queue:队列，FIFO，关心入队和出队操作<br>(7)priority_queue:优先级队列，内部自排队式进，按优先级出，关心入队和出队操作 </p>
<p>2、为什么会有容器适配器<br>(1)<strong>顺序式容器是基本容器，偏重于“存储”特性，核心是元素如何在内存中管理</strong><br>(2)<strong>栈和队列是数据结构型容器，偏重于“数据操作”特性，核心是元素如何按需要进去出来</strong><br>(3)从层次讲：<strong>顺序式容器是底层实现，而栈和队列是上层应用</strong><br>(4)<strong>栈和队列底层完全可以由vector、list、array等顺序式容器封装形成，没必要完全从零构建</strong> </p>
<p>3、总结<br>(1)<strong>容器适配器很多时候用起来和容器完全一样，所以也可以叫容器</strong><br>(2)容器适配器内部实现和容器不同<br>(3)<strong>容器适配器直接内部没有迭代器，但是间接包含有</strong><br>(4)<strong>容器适配器不能访问内部间接迭代器，而且也没有必要访问</strong><br>(5)容器适配器怎么实现的可以不必关心，除非你自己需要去定义新的容器适配器 </p>
<h3 id="容器适配器之stack详解"><a href="#容器适配器之stack详解" class="headerlink" title="容器适配器之stack详解"></a>容器适配器之stack详解</h3><p>参考学习：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/stack">https://zh.cppreference.com/w/cpp/container/stack</a><br>  栈(这个容器)是无法进行遍历的，其内没有迭代器。只可以通过弹栈的方式来查看栈内的元素，当元素被依次弹出时，虽然看到了其中的元素，但最终栈将会变为一个空栈。<br>1、stack的构造<br>参考手册：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/stack/stack">https://zh.cppreference.com/w/cpp/container/stack/stack</a></p>
<p>2、stack的操作函数<br>(1)进栈push<br>(2)出栈pop</p>
<p>3、stack元素查询<br>(1)栈顶元素读取top<br>(2)栈内元素个数获取size<br>(3)栈元素是否空empty</p>
<p>4、栈和栈操作<br>(1)栈元素交换：2个swap<br>(2)栈元素对比：一众运算符重载 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    a.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    a.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    a.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    a.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.size() = &quot;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.top() = &quot;</span> &lt;&lt; a.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; <span class="string">&quot;a.empty() = &quot;</span> &lt;&lt; a.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a.top() = &quot;</span> &lt;&lt; a.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="容器适配器之queue和priority-queue详解"><a href="#容器适配器之queue和priority-queue详解" class="headerlink" title="容器适配器之queue和priority_queue详解"></a>容器适配器之queue和priority_queue详解</h3><p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/queue">https://zh.cppreference.com/w/cpp/container/queue</a><br>1、queue<br>(1)FIFO，先进先出<br>(2)访问元素用front访问队首，用back访问队尾<br>(3)push时只能push到back的后面，pop时只能从front处pop</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::queue&lt;<span class="keyword">int</span>&gt; c1;</span><br><span class="line">    c1.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c1.size = &quot;</span> &lt;&lt; c1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">queue&lt;<span class="keyword">int</span>&gt; <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c2.size = &quot;</span> &lt;&lt; c2.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; deq&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">queue&lt;<span class="keyword">int</span>&gt; <span class="title">c3</span><span class="params">(deq)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.size = &quot;</span> &lt;&lt; c3.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.front = &quot;</span> &lt;&lt; c3.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.back = &quot;</span> &lt;&lt; c3.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">    c3.<span class="built_in">push</span>(<span class="number">6</span>);</span><br><span class="line">    c3.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">    c3.<span class="built_in">emplace</span>(<span class="number">8</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.front = &quot;</span> &lt;&lt; c3.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.back = &quot;</span> &lt;&lt; c3.<span class="built_in">back</span>() &lt;&lt; endl;    </span><br><span class="line">    c3.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.front = &quot;</span> &lt;&lt; c3.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3.back = &quot;</span> &lt;&lt; c3.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        queue&lt;string&gt; q1;</span><br><span class="line">        </span><br><span class="line">        q1.<span class="built_in">push</span>(<span class="built_in">string</span>(<span class="string">&quot;android&quot;</span>));</span><br><span class="line">        q1.<span class="built_in">push</span>(<span class="built_in">string</span>(<span class="string">&quot;linux&quot;</span>));</span><br><span class="line">        q1.<span class="built_in">push</span>(<span class="built_in">string</span>(<span class="string">&quot;harmonyos&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;q1.size = &quot;</span> &lt;&lt; q1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        string s1 = q1.<span class="built_in">front</span>();</span><br><span class="line">        string s2 = q1.<span class="built_in">back</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;s1 = &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;, s2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;q1.size = &quot;</span> &lt;&lt; q1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、priority_queue<br>(1)按照规则进时排队，从top出<br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/priority_queue">https://zh.cppreference.com/w/cpp/container/priority_queue</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_queue</span><span class="params">(T&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; q.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;)</span><br><span class="line">        q.<span class="built_in">push</span>(n);</span><br><span class="line">    <span class="built_in">print_queue</span>(q);</span><br><span class="line"></span><br><span class="line">    std::priority_queue&lt;<span class="keyword">int</span>, std::vector&lt;<span class="keyword">int</span>&gt;, std::greater&lt;<span class="keyword">int</span>&gt;&gt; q2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;)</span><br><span class="line">        q2.<span class="built_in">push</span>(n);</span><br><span class="line">    <span class="built_in">print_queue</span>(q2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">int</span> left, <span class="keyword">int</span> right)&#123;<span class="built_in"><span class="keyword">return</span></span> (left ^ <span class="number">1</span>) &lt; (right ^ <span class="number">1</span>);&#125;;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">q3</span>(cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;)</span><br><span class="line">        q3.<span class="built_in">push</span>(n);</span><br><span class="line">    <span class="built_in">print_queue</span>(q3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有序关联容器set"><a href="#有序关联容器set" class="headerlink" title="有序关联容器set"></a>有序关联容器set</h3><p>1、什么是有序关联容器<br>(1)顺序容器，<strong>容器中的元素是按它们在容器中的位置来顺序保存和访问的</strong><br>(2)顺序容器有<strong>array、vector、deque、list、forward_list、string</strong>等<br>(3)<strong>关联容器中的元素是按关键字来保存和访问的，关联的意思就是关键字（key）与存储值（value）的关联</strong><br>(4)主要的关联容器类型是<strong>map</strong>和<strong>set</strong><br>(5)<strong>关联容器支持高效的关键字查找和访问</strong><br>(6)有序关联容器：容器内元素按顺序排列，一般用树（譬如红黑树）来实现<br>(7)无序关联容器：容器内元素无顺序排列，一般用哈希表来实现，本质上是一种映射</p>
<p>2、set的基本使用<br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/set">https://zh.cppreference.com/w/cpp/container/set</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7192.html">http://c.biancheng.net/view/7192.html</a><br>(1)set的基本理解：<strong>就是一个用来装Key类型对象的筐子，数学上叫集合</strong><br>(2)set的构造函数<br>(3)<strong>插入数据可以用insert，插入时内部自动排序</strong><br>(4)查询set中元素个数用：empty、size，max_size是理论上的最大元素数<br>(5)清除全部元素用clear<br>(6)针对清除某个Key用erase，若erase的元素不存在则不报错<br>(7)<strong>使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;string&gt; s1;</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="string">&quot;cat&quot;</span>);<span class="comment">//这里有个转换的过程，&quot;key&quot;是c中的字符串，这里内部将其转换为了string类型</span></span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="string">&quot;monkey&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1.size = &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; boolalpha &lt;&lt; <span class="string">&quot;, empty = &quot;</span> &lt;&lt; s1.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    s1.<span class="built_in">erase</span>(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1.size = &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; boolalpha &lt;&lt; <span class="string">&quot;, empty = &quot;</span> &lt;&lt; s1.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">    s1.<span class="built_in">erase</span>(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    s1.<span class="built_in">erase</span>(<span class="string">&quot;monkey&quot;</span>);    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1.size = &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; boolalpha &lt;&lt; <span class="string">&quot;, empty = &quot;</span> &lt;&lt; s1.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set的遍历和原地构造"><a href="#set的遍历和原地构造" class="headerlink" title="set的遍历和原地构造"></a>set的遍历和原地构造</h3><p>1、set的三种遍历方法（set具有迭代器）<br>(1)使用ranged for<br>(2)使用迭代器写for循环<br>(3)使用std::for_each</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;string&gt; s1;</span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="string">&quot;house&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1.size() = &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 第一种遍历方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : s1)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种遍历方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = s1.<span class="built_in">cbegin</span>(); iter != s1.<span class="built_in">cend</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种遍历方式</span></span><br><span class="line">    <span class="keyword">auto</span> print = [](<span class="keyword">auto</span> s)&#123;cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;&#125;;</span><br><span class="line">    for_each(s1.<span class="built_in">cbegin</span>(), s1.<span class="built_in">cend</span>(), print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1.<span class="built_in">size</span>() = <span class="number">3</span></span><br><span class="line">cat dog house </span><br><span class="line">cat dog house </span><br><span class="line">cat dog house </span><br></pre></td></tr></table></figure>

<p>2、set的原地构造<br>在容器的指定位置直接构造元素，而不是先单独生成，再将其复制（或移动）到容器中。即构建一个临时对象直接使用，而不是将值复制过去再去构建一个对象<br>(1)set插入新元素一共有3个方法：insert、emplace、emplace_hint<br>(2)**一般来说，emplace比insert效率更高，详解参考(必读)**：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6834.html">http://c.biancheng.net/view/6834.html</a> </p>
<h3 id="移动构造和emplace-hint"><a href="#移动构造和emplace-hint" class="headerlink" title="移动构造和emplace_hint"></a>移动构造和emplace_hint</h3><p>1、移动构造函数<br>参考学习:<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7847.html">C++11移动构造函数详解</a><br>(1)移动构造函数特征：传参是一个右值引用的对象（对比copy构造函数）<br>(2)**右值引用的特征就是&amp;&amp;**，lvalue和rvalue相关的内容在之后的文章中会讲解<br><strong>(3)右值引用对应移动语义，对应移动构造函数；而左值引用对应复制语义，对应复制构造函数<br>(4)移动语义就是直接把右值的临时对象给左值，而不是复制右值给左值重新构造一份<br>(5)移动构造函数可以避免不必要的深拷贝，这在很多时候可以提升效率，当拷贝构造函数和移动构造函数同时存在时，insert() 会优先调用移动构造函数。</strong></p>
<p>2、emplace_hint<br>(1)emplace_hint使用得到会比emplace效率更高，主要原因是插入位置会影响内部自排队效率<br>因为set容器中的元素是经过排序的，你插入新的元素可能需要重新排序，而使用emplace_hint可以尽可能减少这个问题的影响。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nof_operations = <span class="number">100500</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_emplace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nof_operations; ++i) &#123;</span><br><span class="line">    set.<span class="built_in">emplace</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> set.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_emplace_hint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">  <span class="keyword">auto</span> it = set.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nof_operations; ++i) &#123;</span><br><span class="line">    set.<span class="built_in">emplace_hint</span>(it, i);</span><br><span class="line">    it = set.<span class="built_in">end</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> set.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_emplace_hint_wrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">  <span class="keyword">auto</span> it = set.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = nof_operations; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    set.<span class="built_in">emplace_hint</span>(it, i);</span><br><span class="line">    it = set.<span class="built_in">end</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> set.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_emplace_hint_corrected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">  <span class="keyword">auto</span> it = set.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = nof_operations; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    set.<span class="built_in">emplace_hint</span>(it, i);</span><br><span class="line">    it = set.<span class="built_in">begin</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> set.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_emplace_hint_closest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">  <span class="keyword">auto</span> it = set.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nof_operations; ++i) &#123;</span><br><span class="line">    it = set.<span class="built_in">emplace_hint</span>(it, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> set.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timeit</span><span class="params">(std::function&lt;<span class="keyword">int</span>()&gt; set_test, std::string what = <span class="string">&quot;&quot;</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">int</span> setsize = <span class="built_in">set_test</span>();</span><br><span class="line">  <span class="keyword">auto</span> stop = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">  std::chrono::duration&lt;<span class="keyword">double</span>, std::milli&gt; time = stop - start;</span><br><span class="line">  <span class="keyword">if</span> (what.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; setsize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">2</span>)</span><br><span class="line">              &lt;&lt; time.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;  ms for &quot;</span> &lt;&lt; what &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">timeit</span>(set_emplace); <span class="comment">// 栈加热</span></span><br><span class="line">   <span class="built_in">timeit</span>(set_emplace, <span class="string">&quot;plain emplace&quot;</span>);</span><br><span class="line">   <span class="built_in">timeit</span>(set_emplace_hint, <span class="string">&quot;emplace with correct hint&quot;</span>);</span><br><span class="line">   <span class="built_in">timeit</span>(set_emplace_hint_wrong, <span class="string">&quot;emplace with wrong hint&quot;</span>);</span><br><span class="line">   <span class="built_in">timeit</span>(set_emplace_hint_corrected, <span class="string">&quot;corrected emplace&quot;</span>);</span><br><span class="line">   <span class="built_in">timeit</span>(set_emplace_hint_closest, <span class="string">&quot;emplace using returned iterator&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可能的输出：</span><br><span class="line"><span class="number">18.96</span>  ms <span class="keyword">for</span> plain emplace</span><br><span class="line"><span class="number">7.95</span>  ms <span class="keyword">for</span> emplace with correct hint</span><br><span class="line"><span class="number">19.39</span>  ms <span class="keyword">for</span> emplace with wrong hint</span><br><span class="line"><span class="number">8.39</span>  ms <span class="keyword">for</span> corrected emplace</span><br><span class="line"><span class="number">7.90</span>  ms <span class="keyword">for</span> emplace <span class="keyword">using</span> returned iterator</span><br></pre></td></tr></table></figure>

<h3 id="set的其他方法"><a href="#set的其他方法" class="headerlink" title="set的其他方法"></a>set的其他方法</h3><p>参考学习：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/set">https://zh.cppreference.com/w/cpp/container/set</a><br>1、extract和merge</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::set&lt;<span class="keyword">int</span>&gt; cont&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> print = [](<span class="keyword">const</span> <span class="keyword">int</span>&amp; n) &#123; std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n; &#125;;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Start:&quot;</span>;</span><br><span class="line">    std::for_each(cont.<span class="built_in">begin</span>(), cont.<span class="built_in">end</span>(), print);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 释出结点柄并更改键</span></span><br><span class="line">    <span class="keyword">auto</span> nh = cont.<span class="built_in">extract</span>(<span class="number">1</span>);</span><br><span class="line">    nh.<span class="built_in">value</span>() = <span class="number">4</span>; </span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After extract and before insert:&quot;</span>;</span><br><span class="line">    std::for_each(cont.<span class="built_in">begin</span>(), cont.<span class="built_in">end</span>(), print);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 往回插入结点柄</span></span><br><span class="line">    cont.<span class="built_in">insert</span>(<span class="built_in">move</span>(nh));</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;End:&quot;</span>;</span><br><span class="line">    std::for_each(cont.<span class="built_in">begin</span>(), cont.<span class="built_in">end</span>(), print);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Start: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">After extract <span class="keyword">and</span> before insert: <span class="number">2</span> <span class="number">3</span></span><br><span class="line">End: <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 打印出容器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Os</span>, <span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line">Os&amp; <span class="keyword">operator</span>&lt;&lt;(Os&amp; os, <span class="keyword">const</span> std::set&lt;K&gt;&amp; v) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&#x27;[&#x27;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;] &#123;&quot;</span>;</span><br><span class="line">    <span class="keyword">bool</span> o&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : v)</span><br><span class="line">        os &lt;&lt; (o ? <span class="string">&quot;, &quot;</span> : (o = <span class="number">1</span>, <span class="string">&quot; &quot;</span>)) &lt;&lt; e;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">&quot; &#125;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::set&lt;<span class="keyword">char</span>&gt;</span><br><span class="line">        p&#123; <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;A&#x27;</span> &#125;, </span><br><span class="line">        q&#123; <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;C&#x27;</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p: &quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;q: &quot;</span> &lt;&lt; q;</span><br><span class="line"> </span><br><span class="line">    p.<span class="built_in">merge</span>(q);</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p.merge(q);\n&quot;</span> &lt;&lt; <span class="string">&quot;p: &quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;q: &quot;</span> &lt;&lt; q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">p: [<span class="number">3</span>] &#123; A, B, C &#125;</span><br><span class="line">q: [<span class="number">3</span>] &#123; C, D, E &#125;</span><br><span class="line">p.<span class="built_in">merge</span>(q);</span><br><span class="line">p: [<span class="number">5</span>] &#123; A, B, C, D, E &#125;</span><br><span class="line">q: [<span class="number">1</span>] &#123; C &#125;</span><br></pre></td></tr></table></figure>

<p>2、查找和观察器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(s1.<span class="built_in">key_comp</span>()).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(less&lt;<span class="keyword">int</span>&gt;).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有序关联容器map"><a href="#有序关联容器map" class="headerlink" title="有序关联容器map"></a>有序关联容器map</h3><p>1、map介绍<br>(1)<strong>map和set类似，但是map是(key, value)对，而set只有key（可以理解为key就是value）</strong><br>(2)map是映射的意思，此处是key到value的一对一映射。不要理解成地图（根据地图查位置）,一般用key去查value<br>(3)map的用法和特征与set非常类似，学会set了再学map就容易多了 </p>
<p>2、pair<br>(1)<strong>pair即对，也就是(key, value)对，本质是有2个元素的结构体</strong><br>(2)std::pair是STL的标准pair封装<br>(3)<strong>pair中2个元素类型可以不同，也就是说key和value的类型可以不同，也可以相同</strong><br>(4)<strong>pair中2个元素名字是固定的，key叫first，而value叫second</strong><br>(5)<strong>map中存的元素都是一个一个的pair，访问map的key和value要先从map找到pair，再去first和second</strong><br>参考学习：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/utility/pair">https://zh.cppreference.com/w/cpp/utility/pair</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7173.html">http://c.biancheng.net/view/7173.html</a></p>
<p>3、map的构造函数详解<br>(1)直接参考cppreference中构造函数页面的sample即可，链接如下：<br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/map/map">https://zh.cppreference.com/w/cpp/container/map/map</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Map&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_map</span><span class="params">(Map&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : m)</span><br><span class="line">        std::cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; p.second &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&#125;\n&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span><span class="keyword">double</span> x,y;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PointCmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Point&amp; lhs, <span class="keyword">const</span> Point&amp; rhs)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.x &lt; rhs.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//定义一个函数对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、默认构造函数</span></span><br><span class="line">    std::map&lt;std::string, <span class="keyword">int</span>&gt; map1;</span><br><span class="line">    map1[<span class="string">&quot;something&quot;</span>] = <span class="number">69</span>;<span class="comment">//向位图中添加元素</span></span><br><span class="line">    map1[<span class="string">&quot;anything&quot;</span>] = <span class="number">199</span>;</span><br><span class="line">    map1[<span class="string">&quot;everything&quot;</span>] = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;map1 = &quot;</span>;<span class="built_in">print_map</span>(map1); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、范围构造函数</span></span><br><span class="line">    <span class="function">std::map&lt;std::string, <span class="keyword">int</span>&gt; <span class="title">iter</span><span class="params">(map1.find(<span class="string">&quot;anything&quot;</span>),map1.end())</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\niter = &quot;</span>;<span class="built_in">print_map</span>(iter);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;map1 = &quot;</span>;<span class="built_in">print_map</span>(map1); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、复制（拷贝构造函数）</span></span><br><span class="line">    <span class="function">std::map&lt;std::string, <span class="keyword">int</span>&gt; <span class="title">copied</span><span class="params">(map1)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\ncopied = &quot;</span>;<span class="built_in">print_map</span>(copied);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;map1 = &quot;</span>;<span class="built_in">print_map</span>(map1); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、移动构造函数</span></span><br><span class="line">    <span class="function">std::map&lt;std::string, <span class="keyword">int</span>&gt; <span class="title">moved</span><span class="params">(std::move(map1))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nmoved = &quot;</span>;<span class="built_in">print_map</span>(moved);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;map1 = &quot;</span>;<span class="built_in">print_map</span>(map1); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、initializer_list 构造函数</span></span><br><span class="line">    std::map&lt;std::string, <span class="keyword">int</span>&gt; init&#123;</span><br><span class="line">        &#123;<span class="string">&quot;this&quot;</span>, <span class="number">100</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;can&quot;</span>, <span class="number">100</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;be&quot;</span>, <span class="number">100</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;const&quot;</span>, <span class="number">100</span>&#125;,        </span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\ninit = &quot;</span>;<span class="built_in">print_map</span>(init);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定制关键类选项 1 ：</span></span><br><span class="line">  <span class="comment">// 使用比较 struct</span></span><br><span class="line">  std::map&lt;Point, <span class="keyword">double</span>, PointCmp&gt; mag = &#123;</span><br><span class="line">      &#123; &#123;<span class="number">5</span>, <span class="number">-12</span>&#125;, <span class="number">13</span> &#125;,</span><br><span class="line">      &#123; &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,   <span class="number">5</span> &#125;,</span><br><span class="line">      &#123; &#123;<span class="number">-8</span>, <span class="number">-15</span>&#125;, <span class="number">17</span> &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> p : mag)</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;The magnitude of (&quot;</span> &lt;&lt; p.first.x</span><br><span class="line">                &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.first.y &lt;&lt; <span class="string">&quot;) is &quot;</span></span><br><span class="line">                &lt;&lt; p.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 定制关键类选项 2 ：</span></span><br><span class="line">    <span class="comment">// 使用比较 lambda</span></span><br><span class="line">    <span class="comment">// 此 lambda 按照其模比较点，注意其中模取自局部变量 mag</span></span><br><span class="line">    <span class="keyword">auto</span> cmpLambda = [&amp;mag](<span class="keyword">const</span> Point &amp;lhs, <span class="keyword">const</span> Point &amp;rhs) &#123; <span class="keyword">return</span> mag[lhs] &lt; mag[rhs]; &#125;;</span><br><span class="line">    <span class="comment">// 你亦可使用不依赖局部变量的 lambda ，像这样：</span></span><br><span class="line">    <span class="comment">// auto cmpLambda = [](const Point &amp;lhs, const Point &amp;rhs) &#123; return lhs.y &lt; rhs.y; &#125;;</span></span><br><span class="line">    <span class="function">std::map&lt;Point, <span class="keyword">double</span>, <span class="title">decltype</span><span class="params">(cmpLambda)</span>&gt;   <span class="title">magy</span><span class="params">(cmpLambda)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 各种插入元素的方式：</span></span><br><span class="line">    magy.<span class="built_in">insert</span>(std::pair&lt;Point, <span class="keyword">double</span>&gt;(&#123;<span class="number">5</span>, <span class="number">-12</span>&#125;, <span class="number">13</span>));</span><br><span class="line">    magy.<span class="built_in">insert</span>(&#123; &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, <span class="number">5</span>&#125;);</span><br><span class="line">    magy.<span class="built_in">insert</span>(&#123;Point&#123;<span class="number">-8.0</span>, <span class="number">-15.0</span>&#125;, <span class="number">17</span>&#125;);</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : magy)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The magnitude of (&quot;</span> &lt;&lt; p.first.x</span><br><span class="line">                &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.first.y &lt;&lt; <span class="string">&quot;) is &quot;</span></span><br><span class="line">                &lt;&lt; p.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、其他方法<br>(1)与set非常类似，详见：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/map">https://zh.cppreference.com/w/cpp/container/map</a><br>(2)<strong>extract是修改map的key值的唯一方法,map和set中的key是不可以重复的，但map的value可以重复，而由于set的key和value是一个东西，所以set的value也不可以重复。</strong><br>(3)map中的排序是根据key进行的，所以一般都不修改key，修改后需要再次排序 </p>
<h3 id="multi-set和multi-map"><a href="#multi-set和multi-map" class="headerlink" title="multi_set和multi_map"></a>multi_set和multi_map</h3><p>1、multi_版本的差异<br>(1)<strong>set和map中每个容器内所有元素的key都是unique(独一无二)的，不能重复</strong><br>(2)<strong>如果需要容器中同一个key有多个元素(也可理解为有多个相同的key)，则需要使用multi_版本的set和map</strong><br>(3)除此区别外，multi_版本和普通版本没有任何差异，所有方法也完全一样<br>(4)工作中用哪个，取决于实际需求。</p>
<p>2、multi_set实战演示<br>学习参考：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/multiset">https://zh.cppreference.com/w/cpp/container/multiset</a></p>
<p>3、multi_map实战演示<br>学习参考：<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/multimap">https://zh.cppreference.com/w/cpp/container/multimap</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        multimap&lt;<span class="keyword">int</span>, string&gt; m1;</span><br><span class="line">        m1.<span class="built_in">insert</span>(&#123;<span class="number">0</span>, <span class="string">&quot;linux&quot;</span>&#125;);</span><br><span class="line">        m1.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, <span class="string">&quot;android&quot;</span>&#125;);</span><br><span class="line">        m1.<span class="built_in">insert</span>(&#123;<span class="number">2</span>, <span class="string">&quot;windows&quot;</span>&#125;);</span><br><span class="line">        m1.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, <span class="string">&quot;macos&quot;</span>&#125;);</span><br><span class="line">        m1.<span class="built_in">insert</span>(&#123;<span class="number">2</span>, <span class="string">&quot;harmonyos&quot;</span>&#125;);</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;size = &quot;</span> &lt;&lt; m1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> val : m1)</span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;&#123;&quot;</span> &lt;&lt; val.first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;&#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        multiset&lt;string&gt; s1;</span></span><br><span class="line"><span class="comment">        s1.insert(&quot;horse&quot;);                // 按照key去排序</span></span><br><span class="line"><span class="comment">        s1.insert(&quot;cat&quot;);</span></span><br><span class="line"><span class="comment">        s1.insert(&quot;cat&quot;);</span></span><br><span class="line"><span class="comment">        s1.insert(&quot;cat&quot;);</span></span><br><span class="line"><span class="comment">        s1.insert(&quot;dog&quot;);</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;size = &quot; &lt;&lt; s1.size() &lt;&lt; boolalpha &lt;&lt; &quot;, empty = &quot; &lt;&lt; s1.empty() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        for (auto val : s1)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h3><p>1、无序关联容器和有序关联容器的相同点<br>(1)也属于关联容器，<strong>有set和map两种，set只有key，map有(key, value)对</strong><br>(2)<strong>也有带不带multi_的版本</strong>，差异和上节讲的一样<br>(3)<strong>操作方法很多都是重合的，名字和作用也都一样</strong></p>
<p>2、无序关联容器和有序关联容器的差异点<br>(1)<strong>有序内部用红黑树实现，无序内部用哈希函数实现</strong><br>(2)<strong>有序插入元素时会内部自动排序，无序插入时不排序，按照哈希规则直接映射存放</strong></p>
<p>3、无序关联容器初步使用<br>(1)unordered_set和unordered_map<br>参考学习：<br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/unordered_set">https://zh.cppreference.com/w/cpp/container/unordered_set</a><br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/unordered_map">https://zh.cppreference.com/w/cpp/container/unordered_map</a></p>
<h3 id="哈希函数和桶"><a href="#哈希函数和桶" class="headerlink" title="哈希函数和桶"></a>哈希函数和桶</h3><p>1、什么是哈希函数(一类函数)<br>(1)哈希表是一种典型数据结构，又被称为是散列表，英文hashmap<br>(2)STL中的哈希表hashmap就是unordered_map<br>(3)哈希函数是可以用来实现哈希表的函数，是一类而不是一个<br>(4)哈希表的本质是k-v结构，也就是给定key可以找到一个位置来对应value</p>
<p>2、哈希冲突及其解决<br>参考学习：<a target="_blank" rel="noopener" href="https://blog.csdn.net/WX_East/article/details/56005664?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control">unorder_map的底层实现方法</a></p>
<h3 id="unordered-map中桶相关的方法"><a href="#unordered-map中桶相关的方法" class="headerlink" title="unordered_map中桶相关的方法"></a>unordered_map中桶相关的方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, string&gt; m1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                m1.<span class="built_in">insert</span>(&#123;i, <span class="string">&quot;abc&quot;</span>&#125;);</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;&#123;&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="string">&quot;abc&quot;</span> &lt;&lt; <span class="string">&quot;&#125;,     &quot;</span>;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;element size = &quot;</span> &lt;&lt; m1.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;, bucket size = &quot;</span> &lt;&lt; m1.<span class="built_in">bucket_count</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C-C/" rel="tag"><i class="fa fa-tag"></i> C/C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/11/17/2024-11-17-CPP-Basics-C-and-ObjectOrientation/" rel="prev" title="C++从入门到进阶之二-C++和面向对象">
                  <i class="fa fa-angle-left"></i> C++从入门到进阶之二-C++和面向对象
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/11/18/2024-11-19-CPP-Basics-C-Programming-Optimization/" rel="next" title="C++从入门到进阶之四-C++编程优化">
                  C++从入门到进阶之四-C++编程优化 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2021 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">空白</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">288k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">12:01</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"shenweikun/helloworld","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
